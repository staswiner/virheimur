#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\fps.cpp"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\fps.h"
#pragma once
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\time.h"
#pragma once
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\chrono"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

#pragma once






 
















































































#line 91 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

  


















































































#line 252 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"
 #line 253 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

#line 255 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"

#line 257 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"
#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xkeycheck.h"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"








#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





















    
#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"






    
    

#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        
            
        

#line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    #line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"













#pragma once







































































































































#line 151 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



#line 155 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"





























#line 185 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


#line 188 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"

#line 190 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"





#line 196 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



#line 200 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






#line 207 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"











#line 219 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"








#line 228 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
#line 229 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"































































































































































































































































































































































































































































































#pragma region Input Buffer SAL 1 compatibility macros



























































































































































































































































































































































































































































































































































































































































































































































































#pragma endregion Input Buffer SAL 1 compatibility macros

















































































#line 1555 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






























#line 1586 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
























#line 1611 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"












#line 1624 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






































#line 1663 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"















































































































#line 1775 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






































































































#line 1878 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"








































































































































































#line 2047 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"





































































































#line 2149 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



















































































































































































































#line 2361 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
extern "C" {




#line 2367 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"



































































































































































































































#line 2595 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    

#line 2634 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"









































































































































































































































#line 2868 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"









#line 2878 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


    
    
#line 2883 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






#line 2890 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
#line 2891 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






#line 2898 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"
#line 2899 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"











#line 2911 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"

































#line 2945 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"






















}
#line 2969 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"


















#pragma once


extern "C" {
#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"
















































































































































































































































#line 265 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"



#line 269 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"


















































































#line 352 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"


}
#line 356 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"

#line 358 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\concurrencysal.h"
#line 2971 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sal.h"


#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"










#pragma once



#pragma pack(push, 8)


extern "C" {
#line 20 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"



#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    
    


        typedef unsigned int uintptr_t;
    #line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    
    


        typedef char* va_list;
    #line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"
#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    


#line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"





#line 54 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"



#line 58 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"
    
    
#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"











#line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"

    

    
    
    




































#line 116 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


} 
#line 120 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"


    extern "C++"
    {
        template <typename _Ty>
        struct __vcrt_va_list_is_reference
        {
            enum : bool { __the_value = false };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        struct __vcrt_va_list_is_reference<_Ty&&>
        {
            enum : bool { __the_value = true };
        };

        template <typename _Ty>
        void __vcrt_va_start_verify_argument_type() throw()
        {
            static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
        }
    } 

    





#line 156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vadefs.h"

#pragma pack(pop)
#line 47 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"






    



    





















#line 80 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

__pragma(pack(push, 8)) extern "C" {




    
#line 88 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


















    

#line 109 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

#line 113 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        
    

#line 117 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 118 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    





#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
        
    #line 129 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 130 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"







#line 138 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
#line 140 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"





#line 146 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
    
#line 149 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"




    
#line 155 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"








    


#line 167 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



#line 171 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
#line 173 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"




    
#line 179 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
        
        
    

#line 187 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 188 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"










    typedef unsigned int     size_t;
    typedef int              ptrdiff_t;
    typedef int              intptr_t;
#line 202 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    typedef bool  __vcrt_bool;






#line 212 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



    
#line 217 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
#line 221 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
#line 225 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"








    
        
    

#line 238 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 239 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



#line 243 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
    
#line 245 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper( _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];

        
    }


#line 257 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"






#line 264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    


        




    #line 275 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 276 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"



#line 280 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"


    
        
    


#line 288 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 289 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"









    void __cdecl __security_init_cookie(void);

    
        void __fastcall __security_check_cookie(  uintptr_t _StackCookie);
        __declspec(noreturn) void __cdecl __report_gsfailure(void);
    


#line 307 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 308 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

extern uintptr_t __security_cookie;


    
    
    
#line 316 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"

} __pragma(pack(pop))

#line 320 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"
#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 11 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

__pragma(pack(push, 8)) extern "C" {









    

#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
        
    

#line 29 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"




    
#line 36 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    

#line 41 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
        
    

#line 45 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 46 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 50 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 52 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


#line 58 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"





#line 64 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 66 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



    


#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"













    


        
    #line 91 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 92 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 96 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 98 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 102 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 104 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    
#line 110 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"









extern "C++"
{
    template<bool _Enable, typename _Ty>
    struct _CrtEnableIf;

    template<typename _Ty>
    struct _CrtEnableIf<true, _Ty>
    {
        typedef _Ty _Type;
    };
}
#line 131 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    typedef bool  __crt_bool;


#line 137 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"










    
#line 149 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"











#line 161 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
#line 165 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"









    











        
    #line 188 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 189 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
#line 193 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
        
    

#line 200 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 201 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
















    __declspec(dllimport) void __cdecl _invalid_parameter(
          wchar_t const*,
          wchar_t const*,
          wchar_t const*,
                unsigned int,
                uintptr_t
        );
#line 225 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

__declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
__declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
__declspec(dllimport) void __cdecl _invoke_watson(
      wchar_t const*,
      wchar_t const*,
      wchar_t const*,
            unsigned int,
            uintptr_t);


    
        

    













#line 256 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 257 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"










#line 268 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        


    #line 277 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 278 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"









    






        
    #line 296 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 297 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        
    #line 304 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 305 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 309 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"













#line 323 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"




















    
#line 345 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 349 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    

#line 354 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 355 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        


            
        #line 365 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    #line 366 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 367 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 371 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"





#line 377 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        



    #line 387 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 388 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
        
    



#line 397 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

    
        
        
        
    



#line 407 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

    
        
              
        

#line 414 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
    



#line 419 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

    
        
    



#line 427 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

    
        
    



#line 435 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 436 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    
#line 440 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"








typedef int                           errno_t;
typedef unsigned short                wint_t;
typedef unsigned short                wctype_t;
typedef long                          __time32_t;
typedef __int64                       __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
      int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data*    locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t; 

typedef struct _Mbstatet
{ 
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;



#line 480 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



#line 484 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    


        typedef __time64_t time_t;
    #line 491 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 492 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



    
#line 497 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"


    typedef size_t rsize_t;
#line 501 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"










    

        










        










        










        










        










        










        










        










        










        















        















        
















    














#line 677 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 678 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"












































































    





































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1753 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"

        
        
        
        

        


        


        


        


        


        


        


        


        



        



        


        


        


        


        


        


        


        


        


        


        



        



        



        


        



        




        

        




        

        




        

        




        

        




        

        




        

        




        

        




        

    #line 1897 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"
#line 1898 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt.h"



} __pragma(pack(pop))

#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"









    

#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"

#line 25 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        
    #line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 28 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"


    

#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        
            
        

#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
    #line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"


    

#line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        
            
        

#line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
    #line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 52 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"


    

#line 57 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"

#line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
        
            
        

#line 64 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
    #line 65 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 66 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\crtdefs.h"
#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#pragma pack(push,8)





 
  


   
  #line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  
  
 


#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"














 
  
   

#line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
    
   #line 52 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
  





#line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 66 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 68 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 69 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 75 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 77 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 84 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 86 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 87 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 93 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 95 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  

#line 102 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 104 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 




























#line 137 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 139 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		

	







		
		
			
		

#line 156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 157 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 158 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		




 
  
 #line 167 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"










































	
	






		
			
		

#line 222 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 223 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
	




		
			
		

#line 235 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 236 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
	
		
	



#line 245 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 247 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"





	
		#pragma detect_mismatch("_MSC_VER", "1900")
	#line 255 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
		#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "2")
	#line 259 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	
		

#line 264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 266 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 268 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
			#pragma detect_mismatch("RuntimeLibrary", "MDd_DynamicDebug")
		#line 270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	#line 271 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 272 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"








	

#line 283 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
		
	#line 285 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 286 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"




#line 291 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"




#line 296 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 298 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 299 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"













#line 313 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
#line 317 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
 

 









 









 









 

 









 









 




 





 













#line 399 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"











#line 411 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"













#pragma once








#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"











    
    



#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"


    






#line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"



    
#line 56 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"

#pragma comment(lib, "msvcprt" "d" "")






#line 65 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"

#line 67 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"

#line 69 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\use_ansi.h"
#line 413 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"



#line 417 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"



#line 421 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 















 
  

#line 443 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 445 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 446 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  

#line 451 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 453 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 454 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  

#line 459 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   
  #line 461 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 462 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"


 
  





#line 472 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

   


#line 477 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
    
   #line 479 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

  #line 481 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 482 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  
 #line 486 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 
  

#line 491 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
   


     
   #line 496 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
  #line 497 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 498 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

 


























  
   
  #line 529 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
 #line 530 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		

 
  
  
  




  
  
  

  







   
   
   
  #line 557 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

  
  
  
  

 












#line 577 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

		





		







typedef long long _Longlong;
typedef unsigned long long _ULonglong;

		






		
		






 
namespace std {
enum _Uninitialized
	{	
	_Noinit
	};

		

#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit
	{	
public:
 

  
















#line 644 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	__thiscall _Lockit();	
	explicit __thiscall _Lockit(int);	
	__thiscall ~_Lockit() noexcept;	
  #line 648 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

	static  void __cdecl _Lockit_ctor(int);
	static  void __cdecl _Lockit_dtor(int);

private:
	static  void __cdecl _Lockit_ctor(_Lockit *);
	static  void __cdecl _Lockit_ctor(_Lockit *, int);
	static  void __cdecl _Lockit_dtor(_Lockit *);

public:
	 _Lockit(const _Lockit&) = delete;
	_Lockit&  operator=(const _Lockit&) = delete;

private:
	int _Locktype;

  











#line 677 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	};

 



































































  



  


  



  


  
 #line 763 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

class __declspec(dllimport) _Init_locks
	{	
public:
 
  










#line 780 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	__thiscall _Init_locks();
	__thiscall ~_Init_locks() noexcept;
  #line 783 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"

private:
	static  void __cdecl _Init_locks_ctor(_Init_locks *);
	static  void __cdecl _Init_locks_dtor(_Init_locks *);

 







#line 797 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
	};

#pragma warning(pop)
}
 #line 802 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"





		

__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void));

typedef unsigned long _Uint32t;




 
 #pragma pack(pop)
#line 819 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"
#line 820 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\yvals.h"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 

  

 
 
extern "C" {
 #line 18 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"
 #line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

		





		






void __cdecl _Feraise(int);

typedef union
	{	
	unsigned short _Word[8];
	float _Float;
	double _Double;
	long double _Long_double;
	} _Dconst;

		
__declspec(dllimport) double __cdecl _Cosh(double, double);
__declspec(dllimport) short __cdecl _Dtest(double *);
__declspec(dllimport) double __cdecl _Sinh(double, double);

__declspec(dllimport) short __cdecl _Exp(double *, double, short);
extern __declspec(dllimport)  _Dconst _Denorm, _Hugeval, _Inf,
	_Nan, _Snan;

		
__declspec(dllimport) float __cdecl _FCosh(float, float);
__declspec(dllimport) short __cdecl _FDtest(float *);
__declspec(dllimport) float __cdecl _FSinh(float, float);

__declspec(dllimport) short __cdecl _FExp(float *, float, short);
extern __declspec(dllimport)  _Dconst _FDenorm, _FInf, _FNan, _FSnan;

		
__declspec(dllimport) long double __cdecl _LCosh(long double, long double);
__declspec(dllimport) short __cdecl _LDtest(long double *);
__declspec(dllimport) long double __cdecl _LSinh(long double, long double);

__declspec(dllimport) short __cdecl _LExp(long double *, long double, short);
extern __declspec(dllimport)  _Dconst _LDenorm, _LInf, _LNan, _LSnan;

 
 
}
 #line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"
 #line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 79 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"
#line 80 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ymath.h"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cfloat"

#pragma once




#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"








#pragma once




__pragma(pack(push, 8)) extern "C" {




    


        


            
        #line 27 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"
    #line 28 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"
#line 29 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"



















    
        
            
        

#line 54 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"
    

#line 57 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"
#line 58 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"






















































































































































    





#line 215 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"











__declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable: 4141)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_controlfp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) unsigned int __cdecl _controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );

#pragma warning(pop)


__declspec(dllimport) void __cdecl _set_controlfp(
      unsigned int _NewValue,
      unsigned int _Mask
    );


__declspec(dllimport) errno_t __cdecl _controlfp_s(
      unsigned int* _CurrentState,
           unsigned int  _NewValue,
           unsigned int  _Mask
    );


__declspec(dllimport) unsigned int __cdecl _statusfp(void);


__declspec(dllimport) void __cdecl _fpreset(void);



    
    __declspec(dllimport) void __cdecl _statusfp2(
          unsigned int* _X86Status,
          unsigned int* _SSE2Status
        );

#line 267 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"





__declspec(dllimport) unsigned int __cdecl _control87(
      unsigned int _NewValue,
      unsigned int _Mask
    );


    
    __declspec(dllimport) int __cdecl __control87_2(
               unsigned int  _NewValue,
               unsigned int  _Mask,
          unsigned int* _X86ControlWord,
          unsigned int* _Sse2ControlWord
        );
#line 286 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"


 
__declspec(dllimport) int* __cdecl __fpecode(void);



 
__declspec(dllimport) int __cdecl __fpe_flt_rounds(void);












  __declspec(dllimport) double __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double __cdecl _chgsign(  double _X);
  __declspec(dllimport) double __cdecl _scalb(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl _logb(  double _X);
  __declspec(dllimport) double __cdecl _nextafter(  double _X,   double _Y);
  __declspec(dllimport) int    __cdecl _finite(  double _X);
  __declspec(dllimport) int    __cdecl _isnan(  double _X);
  __declspec(dllimport) int    __cdecl _fpclass(  double _X);














    
    
    

    
    __declspec(dllimport) void __cdecl fpreset(void);

    
    

    
    

    
    
    

    
    
    
    
    
    
    

    
    
    

    
    
    
    
    

    
    
    
    

    

    
    
    
    
    
    

    
    
    
    

    
    
    
    
    
    

    
    
    
    

    

#line 398 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\float.h"



} __pragma(pack(pop))
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cfloat"
#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cfloat"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"







#pragma once


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"

__pragma(pack(push, 8)) extern "C" {









    
    



#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"









































#line 71 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"


    


        
    #line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"
#line 79 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"


    
        
    #line 84 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"
#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits.h"



} __pragma(pack(pop))
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"
#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\climits"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

#pragma once









 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"












__pragma(pack(push, 8)) extern "C" {



#pragma warning(push)
#pragma warning(disable:4738) 
#pragma warning(disable:4820) 
#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"



    
    
    struct _exception
    {
        int    type;   
        char*  name;   
        double arg1;   
        double arg2;   
        double retval; 
    };

    
    
    
        

        struct _complex
        {
            double x, y; 
        };

        


#line 49 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"
    #line 50 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"
#line 51 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

typedef float float_t;
typedef double double_t;













    
        extern double const _HUGE;
    

#line 72 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"
#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"


    
#line 77 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"


















































































void __cdecl _fperrraise(  int _Except);

  __declspec(dllimport) short __cdecl _dclass(  double _X);
  __declspec(dllimport) short __cdecl _ldclass(  long double _X);
  __declspec(dllimport) short __cdecl _fdclass(  float _X);

  __declspec(dllimport) int __cdecl _dsign(  double _X);
  __declspec(dllimport) int __cdecl _ldsign(  long double _X);
  __declspec(dllimport) int __cdecl _fdsign(  float _X);

  __declspec(dllimport) int __cdecl _dpcomp(  double _X,   double _Y);
  __declspec(dllimport) int __cdecl _ldpcomp(  long double _X,   long double _Y);
  __declspec(dllimport) int __cdecl _fdpcomp(  float _X,   float _Y);

  __declspec(dllimport) short __cdecl _dtest(  double* _Px);
  __declspec(dllimport) short __cdecl _ldtest(  long double* _Px);
  __declspec(dllimport) short __cdecl _fdtest(  float* _Px);

__declspec(dllimport) short __cdecl _d_int(  double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _ld_int(  long double* _Px,   short _Xexp);
__declspec(dllimport) short __cdecl _fd_int(  float* _Px,   short _Xexp);

__declspec(dllimport) short __cdecl _dscale(  double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _ldscale(  long double* _Px,   long _Lexp);
__declspec(dllimport) short __cdecl _fdscale(  float* _Px,   long _Lexp);

__declspec(dllimport) short __cdecl _dunscale(  short* _Pex,   double* _Px);
__declspec(dllimport) short __cdecl _ldunscale(  short* _Pex,   long double* _Px);
__declspec(dllimport) short __cdecl _fdunscale(  short* _Pex,   float* _Px);

  __declspec(dllimport) short __cdecl _dexp(  double* _Px,   double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _ldexp(  long double* _Px,   long double _Y,   long _Eoff);
  __declspec(dllimport) short __cdecl _fdexp(  float* _Px,   float _Y,   long _Eoff);

  __declspec(dllimport) short __cdecl _dnorm(  unsigned short* _Ps);
  __declspec(dllimport) short __cdecl _fdnorm(  unsigned short* _Ps);

  __declspec(dllimport) double __cdecl _dpoly(  double _X,   double const* _Tab,   int _N);
  __declspec(dllimport) long double __cdecl _ldpoly(  long double _X,   long double const* _Tab,   int _N);
  __declspec(dllimport) float __cdecl _fdpoly(  float _X,   float const* _Tab,   int _N);

  __declspec(dllimport) double __cdecl _dlog(  double _X,   int _Baseflag);
  __declspec(dllimport) long double __cdecl _ldlog(  long double _X,   int _Baseflag);
  __declspec(dllimport) float __cdecl _fdlog(  float _X,   int _Baseflag);

  __declspec(dllimport) double __cdecl _dsin(  double _X,   unsigned int _Qoff);
  __declspec(dllimport) long double __cdecl _ldsin(  long double _X,   unsigned int _Qoff);
  __declspec(dllimport) float __cdecl _fdsin(  float _X,   unsigned int _Qoff);


typedef union
{   
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{   
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{   
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{   
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C,  _Inf_C,  _Nan_C,  _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C,  _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double      _Zero_C,  _Xbig_C;
extern const float       _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;




























extern "C++"
{
      inline int fpclassify(  float _X) throw()
    {
        return _fdtest(&_X);
    }

      inline int fpclassify(  double _X) throw()
    {
        return _dtest(&_X);
    }

      inline int fpclassify(  long double _X) throw()
    {
        return _ldtest(&_X);
    }

      inline bool signbit(  float _X) throw()
    {
        return _fdsign(_X) != 0;
    }

      inline bool signbit(  double _X) throw()
    {
        return _dsign(_X) != 0;
    }

      inline bool signbit(  long double _X) throw()
    {
        return _ldsign(_X) != 0;
    }

      inline int _fpcomp(  float _X,   float _Y) throw()
    {
        return _fdpcomp(_X, _Y);
    }

      inline int _fpcomp(  double _X,   double _Y) throw()
    {
        return _dpcomp(_X, _Y);
    }

      inline int _fpcomp(  long double _X,   long double _Y) throw()
    {
        return _ldpcomp(_X, _Y);
    }

    template <class _Trc, class _Tre> struct _Combined_type
    {   
        typedef float _Type;
    };

    template <> struct _Combined_type<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Combined_type<float, long double>
    {   
        typedef long double _Type;
    };

    template <class _Ty, class _T2> struct _Real_widened
    {   
        typedef long double _Type;
    };

    template <> struct _Real_widened<float, float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_widened<float, double>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, float>
    {   
        typedef double _Type;
    };

    template <> struct _Real_widened<double, double>
    {   
        typedef double _Type;
    };

    template <class _Ty> struct _Real_type
    {   
        typedef double _Type;   
    };

    template <> struct _Real_type<float>
    {   
        typedef float _Type;
    };

    template <> struct _Real_type<long double>
    {   
        typedef long double _Type;
    };

    template <class _T1, class _T2>
      inline int _fpcomp(  _T1 _X,   _T2 _Y) throw()
    {   
        typedef typename _Combined_type<float,
            typename _Real_widened<
            typename _Real_type<_T1>::_Type,
            typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
        return _fpcomp((_Tw)_X, (_Tw)_Y);
    }

    template <class _Ty>
      inline bool isfinite(  _Ty _X) throw()
    {
        return fpclassify(_X) <= 0;
    }

    template <class _Ty>
      inline bool isinf(  _Ty _X) throw()
    {
        return fpclassify(_X) == 1;
    }

    template <class _Ty>
      inline bool isnan(  _Ty _X) throw()
    {
        return fpclassify(_X) == 2;
    }

    template <class _Ty>
      inline bool isnormal(  _Ty _X) throw()
    {
        return fpclassify(_X) == (-1);
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 4) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isgreaterequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isless(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & 1) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessequal(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool islessgreater(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
    }

    template <class _Ty1, class _Ty2>
      inline bool isunordered(  _Ty1 _X,   _Ty2 _Y) throw()
    {
        return _fpcomp(_X, _Y) == 0;
    }
}  
#line 449 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"





  int       __cdecl abs(  int _X);
  long      __cdecl labs(  long _X);
  long long __cdecl llabs(  long long _X);

  double __cdecl acos(  double _X);
  double __cdecl asin(  double _X);
  double __cdecl atan(  double _X);
  double __cdecl atan2(  double _Y,   double _X);

  double __cdecl cos(  double _X);
  double __cdecl cosh(  double _X);
  double __cdecl exp(  double _X);
   double __cdecl fabs(  double _X);
  double __cdecl fmod(  double _X,   double _Y);
  double __cdecl log(  double _X);
  double __cdecl log10(  double _X);
  double __cdecl pow(  double _X,   double _Y);
  double __cdecl sin(  double _X);
  double __cdecl sinh(  double _X);
   double __cdecl sqrt(  double _X);
  double __cdecl tan(  double _X);
  double __cdecl tanh(  double _X);

  __declspec(dllimport) double    __cdecl acosh(  double _X);
  __declspec(dllimport) double    __cdecl asinh(  double _X);
  __declspec(dllimport) double    __cdecl atanh(  double _X);
  __declspec(dllimport)  double    __cdecl atof(  char const* _String);
  __declspec(dllimport)  double    __cdecl _atof_l(  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) double    __cdecl _cabs(  struct _complex _Complex_value);
  __declspec(dllimport) double    __cdecl cbrt(  double _X);
  __declspec(dllimport) double    __cdecl ceil(  double _X);
  __declspec(dllimport) double    __cdecl _chgsign(  double _X);
  __declspec(dllimport) double    __cdecl copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double    __cdecl _copysign(  double _Number,   double _Sign);
  __declspec(dllimport) double    __cdecl erf(  double _X);
  __declspec(dllimport) double    __cdecl erfc(  double _X);
  __declspec(dllimport) double    __cdecl exp2(  double _X);
  __declspec(dllimport) double    __cdecl expm1(  double _X);
  __declspec(dllimport) double    __cdecl fdim(  double _X,   double _Y);
  __declspec(dllimport) double    __cdecl floor(  double _X);
  __declspec(dllimport) double    __cdecl fma(  double _X,   double _Y,   double _Z);
  __declspec(dllimport) double    __cdecl fmax(  double _X,   double _Y);
  __declspec(dllimport) double    __cdecl fmin(  double _X,   double _Y);
  __declspec(dllimport) double    __cdecl frexp(  double _X,   int* _Y);
  __declspec(dllimport) double    __cdecl hypot(  double _X,   double _Y);
  __declspec(dllimport) double    __cdecl _hypot(  double _X,   double _Y);
  __declspec(dllimport) int       __cdecl ilogb(  double _X);
  __declspec(dllimport) double    __cdecl ldexp(  double _X,   int _Y);
  __declspec(dllimport) double    __cdecl lgamma(  double _X);
  __declspec(dllimport) long long __cdecl llrint(  double _X);
  __declspec(dllimport) long long __cdecl llround(  double _X);
  __declspec(dllimport) double    __cdecl log1p(  double _X);
  __declspec(dllimport) double    __cdecl log2(  double _X);
  __declspec(dllimport) double    __cdecl logb(  double _X);
  __declspec(dllimport) long      __cdecl lrint(  double _X);
  __declspec(dllimport) long      __cdecl lround(  double _X);

int __cdecl _matherr(  struct _exception* _Except);

  __declspec(dllimport) double __cdecl modf(  double _X,   double* _Y);
  __declspec(dllimport) double __cdecl nan(  char const*);
  __declspec(dllimport) double __cdecl nearbyint(  double _X);
  __declspec(dllimport) double __cdecl nextafter(  double _X,   double _Y);
  __declspec(dllimport) double __cdecl nexttoward(  double _X,   long double _Y);
  __declspec(dllimport) double __cdecl remainder(  double _X,   double _Y);
  __declspec(dllimport) double __cdecl remquo(  double _X,   double _Y,   int* _Z);
  __declspec(dllimport) double __cdecl rint(  double _X);
  __declspec(dllimport) double __cdecl round(  double _X);
  __declspec(dllimport) double __cdecl scalbln(  double _X,   long _Y);
  __declspec(dllimport) double __cdecl scalbn(  double _X,   int _Y);
  __declspec(dllimport) double __cdecl tgamma(  double _X);
  __declspec(dllimport) double __cdecl trunc(  double _X);
  __declspec(dllimport) double __cdecl _j0(  double _X );
  __declspec(dllimport) double __cdecl _j1(  double _X );
  __declspec(dllimport) double __cdecl _jn(int _X,   double _Y);
  __declspec(dllimport) double __cdecl _y0(  double _X);
  __declspec(dllimport) double __cdecl _y1(  double _X);
  __declspec(dllimport) double __cdecl _yn(  int _X,   double _Y);

  __declspec(dllimport) float     __cdecl acoshf(  float _X);
  __declspec(dllimport) float     __cdecl asinhf(  float _X);
  __declspec(dllimport) float     __cdecl atanhf(  float _X);
  __declspec(dllimport) float     __cdecl cbrtf(  float _X);
  __declspec(dllimport) float     __cdecl _chgsignf(  float _X);
  __declspec(dllimport) float     __cdecl copysignf(  float _Number,   float _Sign);
  __declspec(dllimport) float     __cdecl _copysignf(  float _Number,   float _Sign);
  __declspec(dllimport) float     __cdecl erff(  float _X);
  __declspec(dllimport) float     __cdecl erfcf(  float _X);
  __declspec(dllimport) float     __cdecl expm1f(  float _X);
  __declspec(dllimport) float     __cdecl exp2f(  float _X);
  __declspec(dllimport) float     __cdecl fdimf(  float _X,   float _Y);
  __declspec(dllimport) float     __cdecl fmaf(  float _X,   float _Y,   float _Z);
  __declspec(dllimport) float     __cdecl fmaxf(  float _X,   float _Y);
  __declspec(dllimport) float     __cdecl fminf(  float _X,   float _Y);
  __declspec(dllimport) float     __cdecl _hypotf(  float _X,   float _Y);
  __declspec(dllimport) int       __cdecl ilogbf(  float _X);
  __declspec(dllimport) float     __cdecl lgammaf(  float _X);
  __declspec(dllimport) long long __cdecl llrintf(  float _X);
  __declspec(dllimport) long long __cdecl llroundf(  float _X);
  __declspec(dllimport) float     __cdecl log1pf(  float _X);
  __declspec(dllimport) float     __cdecl log2f(  float _X);
  __declspec(dllimport) float     __cdecl logbf(  float _X);
  __declspec(dllimport) long      __cdecl lrintf(  float _X);
  __declspec(dllimport) long      __cdecl lroundf(  float _X);
  __declspec(dllimport) float     __cdecl nanf(  char const*);
  __declspec(dllimport) float     __cdecl nearbyintf(  float _X);
  __declspec(dllimport) float     __cdecl nextafterf(  float _X,   float _Y);
  __declspec(dllimport) float     __cdecl nexttowardf(  float _X,   long double _Y);
  __declspec(dllimport) float     __cdecl remainderf(  float _X,   float _Y);
  __declspec(dllimport) float     __cdecl remquof(  float _X,   float _Y,   int* _Z);
  __declspec(dllimport) float     __cdecl rintf(  float _X);
  __declspec(dllimport) float     __cdecl roundf(  float _X);
  __declspec(dllimport) float     __cdecl scalblnf(  float _X,   long _Y);
  __declspec(dllimport) float     __cdecl scalbnf(  float _X,   int _Y);
  __declspec(dllimport) float     __cdecl tgammaf(  float _X);
  __declspec(dllimport) float     __cdecl truncf(  float _X);



      __declspec(dllimport) int  __cdecl _set_SSE2_enable(  int _Flag);

















#line 592 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"














#line 607 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

      __inline float __cdecl acosf(  float _X)
    {
        return (float)acos(_X);
    }

      __inline float __cdecl asinf(  float _X)
    {
        return (float)asin(_X);
    }

      __inline float __cdecl atan2f(  float _Y,   float _X)
    {
        return (float)atan2(_Y, _X);
    }

      __inline float __cdecl atanf(  float _X)
    {
        return (float)atan(_X);
    }

      __inline float __cdecl ceilf(  float _X)
    {
        return (float)ceil(_X);
    }

      __inline float __cdecl cosf(  float _X)
    {
        return (float)cos(_X);
    }

      __inline float __cdecl coshf(  float _X)
    {
        return (float)cosh(_X);
    }

      __inline float __cdecl expf(  float _X)
    {
        return (float)exp(_X);
    }

#line 649 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"





#line 655 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

      __inline float __cdecl fabsf(  float _X)
    {
        return (float)fabs(_X);
    }

#line 662 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"






#line 669 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

      __inline float __cdecl floorf(  float _X)
    {
        return (float)floor(_X);
    }

      __inline float __cdecl fmodf(  float _X,   float _Y)
    {
        return (float)fmod(_X, _Y);
    }

#line 681 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

  __inline float __cdecl frexpf(  float _X,   int *_Y)
{
    return (float)frexp(_X, _Y);
}

  __inline float __cdecl hypotf(  float _X,   float _Y)
{
    return _hypotf(_X, _Y);
}

  __inline float __cdecl ldexpf(  float _X,   int _Y)
{
    return (float)ldexp(_X, _Y);
}













#line 710 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

      __inline float __cdecl log10f(  float _X)
    {
        return (float)log10(_X);
    }

      __inline float __cdecl logf(  float _X)
    {
        return (float)log(_X);
    }

      __inline float __cdecl modff(  float _X,   float* _Y)
    {
        double _F, _I;
        _F = modf(_X, &_I);
        *_Y = (float)_I;
        return (float)_F;
    }

      __inline float __cdecl powf(  float _X,   float _Y)
    {
        return (float)pow(_X, _Y);
    }

      __inline float __cdecl sinf(  float _X)
    {
        return (float)sin(_X);
    }

      __inline float __cdecl sinhf(  float _X)
    {
        return (float)sinh(_X);
    }

      __inline float __cdecl sqrtf(  float _X)
    {
        return (float)sqrt(_X);
    }

      __inline float __cdecl tanf(  float _X)
    {
        return (float)tan(_X);
    }

      __inline float __cdecl tanhf(  float _X)
    {
        return (float)tanh(_X);
    }

#line 760 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

  __declspec(dllimport) long double __cdecl acoshl(  long double _X);

  __inline long double __cdecl acosl(  long double _X)
{
    return acos((double)_X);
}

  __declspec(dllimport) long double __cdecl asinhl(  long double _X);

  __inline long double __cdecl asinl(  long double _X)
{
    return asin((double)_X);
}

  __inline long double __cdecl atan2l(  long double _Y,   long double _X)
{
    return atan2((double)_Y, (double)_X);
}

  __declspec(dllimport) long double __cdecl atanhl(  long double _X);

  __inline long double __cdecl atanl(  long double _X)
{
    return atan((double)_X);
}

  __declspec(dllimport) long double __cdecl cbrtl(  long double _X);

  __inline long double __cdecl ceill(  long double _X)
{
    return ceil((double)_X);
}

  __inline long double __cdecl _chgsignl(  long double _X)
{
    return _chgsign((double)_X);
}

  __declspec(dllimport) long double __cdecl copysignl(  long double _Number,   long double _Sign);

  __inline long double __cdecl _copysignl(  long double _Number,   long double _Sign)
{
    return _copysign((double)_Number, (double)_Sign);
}

  __inline long double __cdecl coshl(  long double _X)
{
    return cosh((double)_X);
}

  __inline long double __cdecl cosl(  long double _X)
{
    return cos((double)_X);
}

  __declspec(dllimport) long double __cdecl erfl(  long double _X);
  __declspec(dllimport) long double __cdecl erfcl(  long double _X);

  __inline long double __cdecl expl(  long double _X)
{
    return exp((double)_X);
}

  __declspec(dllimport) long double __cdecl exp2l(  long double _X);
  __declspec(dllimport) long double __cdecl expm1l(  long double _X);

  __inline long double __cdecl fabsl(  long double _X)
{
    return fabs((double)_X);
}

  __declspec(dllimport) long double __cdecl fdiml(  long double _X,   long double _Y);

  __inline long double __cdecl floorl(  long double _X)
{
    return floor((double)_X);
}

  __declspec(dllimport) long double __cdecl fmal(  long double _X,   long double _Y,   long double _Z);
  __declspec(dllimport) long double __cdecl fmaxl(  long double _X,   long double _Y);
  __declspec(dllimport) long double __cdecl fminl(  long double _X,   long double _Y);

  __inline long double __cdecl fmodl(  long double _X,   long double _Y)
{
    return fmod((double)_X, (double)_Y);
}

  __inline long double __cdecl frexpl(  long double _X,   int *_Y)
{
    return frexp((double)_X, _Y);
}

  __declspec(dllimport) int __cdecl ilogbl(  long double _X);

  __inline long double __cdecl _hypotl(  long double _X,   long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

  __inline long double __cdecl hypotl(  long double _X,   long double _Y)
{
    return _hypot((double)_X, (double)_Y);
}

  __inline long double __cdecl ldexpl(  long double _X,   int _Y)
{
    return ldexp((double)_X, _Y);
}

  __declspec(dllimport) long double __cdecl lgammal(  long double _X);
  __declspec(dllimport) long long __cdecl llrintl(  long double _X);
  __declspec(dllimport) long long __cdecl llroundl(  long double _X);

  __inline long double __cdecl logl(  long double _X)
{
    return log((double)_X);
}

  __inline long double __cdecl log10l(  long double _X)
{
    return log10((double)_X);
}

  __declspec(dllimport) long double __cdecl log1pl(  long double _X);
  __declspec(dllimport) long double __cdecl log2l(  long double _X);
  __declspec(dllimport) long double __cdecl logbl(  long double _X);
  __declspec(dllimport) long __cdecl lrintl(  long double _X);
  __declspec(dllimport) long __cdecl lroundl(  long double _X);

  __inline long double __cdecl modfl(  long double _X,   long double* _Y)
{
    double _F, _I;
    _F = modf((double)_X, &_I);
    *_Y = _I;
    return _F;
}

  __declspec(dllimport) long double __cdecl nanl(  char const*);
  __declspec(dllimport) long double __cdecl nearbyintl(  long double _X);
  __declspec(dllimport) long double __cdecl nextafterl(  long double _X,   long double _Y);
  __declspec(dllimport) long double __cdecl nexttowardl(  long double _X,   long double _Y);

  __inline long double __cdecl powl(  long double _X,   long double _Y)
{
    return pow((double)_X, (double)_Y);
}

  __declspec(dllimport) long double __cdecl remainderl(  long double _X,   long double _Y);
  __declspec(dllimport) long double __cdecl remquol(  long double _X,   long double _Y,   int* _Z);
  __declspec(dllimport) long double __cdecl rintl(  long double _X);
  __declspec(dllimport) long double __cdecl roundl(  long double _X);
  __declspec(dllimport) long double __cdecl scalblnl(  long double _X,   long _Y);
  __declspec(dllimport) long double __cdecl scalbnl(  long double _X,   int _Y);

  __inline long double __cdecl sinhl(  long double _X)
{
    return sinh((double)_X);
}

  __inline long double __cdecl sinl(  long double _X)
{
    return sin((double)_X);
}

  __inline long double __cdecl sqrtl(  long double _X)
{
    return sqrt((double)_X);
}

  __inline long double __cdecl tanhl(  long double _X)
{
    return tanh((double)_X);
}

  __inline long double __cdecl tanl(  long double _X)
{
    return tan((double)_X);
}

  __declspec(dllimport) long double __cdecl tgammal(  long double _X);
  __declspec(dllimport) long double __cdecl truncl(  long double _X);





#line 948 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"



    
    
    
    
    
    
    

    

    
        
            extern double HUGE;
        

#line 967 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j0" ". See online help for details."))   __declspec(dllimport) double __cdecl j0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_j1" ". See online help for details."))   __declspec(dllimport) double __cdecl j1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_jn" ". See online help for details."))   __declspec(dllimport) double __cdecl jn(  int _X,   double _Y);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y0" ". See online help for details."))   __declspec(dllimport) double __cdecl y0(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_y1" ". See online help for details."))   __declspec(dllimport) double __cdecl y1(  double _X);
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_yn" ". See online help for details."))   __declspec(dllimport) double __cdecl yn(  int _X,   double _Y);
    #line 975 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"
#line 976 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"



#pragma warning(pop)
#line 981 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"


} __pragma(pack(pop))

#line 986 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"























#line 1010 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

#line 13 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

 

  inline double abs(  double _Xx) noexcept
	{
	return (:: fabs(_Xx));
	}

  inline double pow(  double _Xx,   int _Yx) noexcept
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (:: pow(_Xx, static_cast<double>(_Yx)));
	}

  inline float abs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline float acos(  float _Xx) noexcept
	{
	return (:: acosf(_Xx));
	}

  inline float acosh(  float _Xx) noexcept
	{
	return (:: acoshf(_Xx));
	}

  inline float asin(  float _Xx) noexcept
	{
	return (:: asinf(_Xx));
	}

  inline float asinh(  float _Xx) noexcept
	{
	return (:: asinhf(_Xx));
	}

  inline float atan(  float _Xx) noexcept
	{
	return (:: atanf(_Xx));
	}

  inline float atanh(  float _Xx) noexcept
	{
	return (:: atanhf(_Xx));
	}

  inline float atan2(  float _Yx,   float _Xx) noexcept
	{
	return (:: atan2f(_Yx, _Xx));
	}

  inline float cbrt(  float _Xx) noexcept
	{
	return (:: cbrtf(_Xx));
	}

  inline float ceil(  float _Xx) noexcept
	{
	return (:: ceilf(_Xx));
	}

  inline float copysign(  float _Number,
	  float _Sign) noexcept
	{
	return (:: copysignf(_Number, _Sign));
	}

  inline float cos(  float _Xx) noexcept
	{
	return (:: cosf(_Xx));
	}

  inline float cosh(  float _Xx) noexcept
	{
	return (:: coshf(_Xx));
	}

  inline float erf(  float _Xx) noexcept
	{
	return (:: erff(_Xx));
	}

  inline float erfc(  float _Xx) noexcept
	{
	return (:: erfcf(_Xx));
	}

  inline float exp(  float _Xx) noexcept
	{
	return (:: expf(_Xx));
	}

  inline float exp2(  float _Xx) noexcept
	{
	return (:: exp2f(_Xx));
	}

  inline float expm1(  float _Xx) noexcept
	{
	return (:: expm1f(_Xx));
	}

  inline float fabs(  float _Xx) noexcept
	{
	return (:: fabsf(_Xx));
	}

  inline float fdim(  float _Xx,   float _Yx) noexcept
	{
	return (:: fdimf(_Xx, _Yx));
	}

  inline float floor(  float _Xx) noexcept
	{
	return (:: floorf(_Xx));
	}

  inline float fma(  float _Xx,   float _Yx,
	  float _Zx) noexcept
	{
	return (:: fmaf(_Xx, _Yx, _Zx));
	}

  inline float fmax(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmaxf(_Xx, _Yx));
	}

  inline float fmin(  float _Xx,   float _Yx) noexcept
	{
	return (:: fminf(_Xx, _Yx));
	}

  inline float fmod(  float _Xx,   float _Yx) noexcept
	{
	return (:: fmodf(_Xx, _Yx));
	}

  inline float frexp(  float _Xx,   int* _Yx) noexcept
	{
	return (:: frexpf(_Xx, _Yx));
	}

  inline float hypot(  float _Xx,   float _Yx) noexcept
	{
	return (:: hypotf(_Xx, _Yx));
	}

  inline int ilogb(  float _Xx) noexcept
	{
	return (:: ilogbf(_Xx));
	}

  inline float ldexp(  float _Xx,   int _Yx) noexcept
	{
	return (:: ldexpf(_Xx, _Yx));
	}

  inline float lgamma(  float _Xx) noexcept
	{
	return (:: lgammaf(_Xx));
	}

  inline long long llrint(  float _Xx) noexcept
	{
	return (:: llrintf(_Xx));
	}

  inline long long llround(  float _Xx) noexcept
	{
	return (:: llroundf(_Xx));
	}

  inline float log(  float _Xx) noexcept
	{
	return (:: logf(_Xx));
	}

  inline float log10(  float _Xx) noexcept
	{
	return (:: log10f(_Xx));
	}

  inline float log1p(  float _Xx) noexcept
	{
	return (:: log1pf(_Xx));
	}

  inline float log2(  float _Xx) noexcept
	{
	return (:: log2f(_Xx));
	}

  inline float logb(  float _Xx) noexcept
	{
	return (:: logbf(_Xx));
	}

  inline long lrint(  float _Xx) noexcept
	{
	return (:: lrintf(_Xx));
	}

  inline long lround(  float _Xx) noexcept
	{
	return (:: lroundf(_Xx));
	}

  inline float modf(  float _Xx,   float* _Yx) noexcept
	{
	return (:: modff(_Xx, _Yx));
	}

  inline float nearbyint(  float _Xx) noexcept
	{
	return (:: nearbyintf(_Xx));
	}

  inline float nextafter(  float _Xx,   float _Yx) noexcept
	{
	return (:: nextafterf(_Xx, _Yx));
	}

  inline float nexttoward(  float _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,
	  float _Yx) noexcept
	{
	return (:: powf(_Xx, _Yx));
	}

  inline float pow(  float _Xx,   int _Yx) noexcept
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (:: powf(_Xx, static_cast<float>(_Yx)));
	}

  inline float remainder(  float _Xx,   float _Yx) noexcept
	{
	return (:: remainderf(_Xx, _Yx));
	}

  inline float remquo(  float _Xx,   float _Yx,
	  int *_Zx) noexcept
	{
	return (:: remquof(_Xx, _Yx, _Zx));
	}

  inline float rint(  float _Xx) noexcept
	{
	return (:: rintf(_Xx));
	}

  inline float round(  float _Xx) noexcept
	{
	return (:: roundf(_Xx));
	}

  inline float scalbln(  float _Xx,   long _Yx) noexcept
	{
	return (:: scalblnf(_Xx, _Yx));
	}

  inline float scalbn(  float _Xx,   int _Yx) noexcept
	{
	return (:: scalbnf(_Xx, _Yx));
	}

  inline float sin(  float _Xx) noexcept
	{
	return (:: sinf(_Xx));
	}

  inline float sinh(  float _Xx) noexcept
	{
	return (:: sinhf(_Xx));
	}

  inline float sqrt(  float _Xx) noexcept
	{
	return (:: sqrtf(_Xx));
	}

  inline float tan(  float _Xx) noexcept
	{
	return (:: tanf(_Xx));
	}

  inline float tanh(  float _Xx) noexcept
	{
	return (:: tanhf(_Xx));
	}

  inline float tgamma(  float _Xx) noexcept
	{
	return (:: tgammaf(_Xx));
	}

  inline float trunc(  float _Xx) noexcept
	{
	return (:: truncf(_Xx));
	}

  inline long double abs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

  inline long double acos(  long double _Xx) noexcept
	{
	return (:: acosl(_Xx));
	}

  inline long double acosh(  long double _Xx) noexcept
	{
	return (:: acoshl(_Xx));
	}

  inline long double asin(  long double _Xx) noexcept
	{
	return (:: asinl(_Xx));
	}

  inline long double asinh(  long double _Xx) noexcept
	{
	return (:: asinhl(_Xx));
	}

  inline long double atan(  long double _Xx) noexcept
	{
	return (:: atanl(_Xx));
	}

  inline long double atanh(  long double _Xx) noexcept
	{
	return (:: atanhl(_Xx));
	}

  inline long double atan2(  long double _Yx,
	  long double _Xx) noexcept
	{
	return (:: atan2l(_Yx, _Xx));
	}

  inline long double cbrt(  long double _Xx) noexcept
	{
	return (:: cbrtl(_Xx));
	}

  inline long double ceil(  long double _Xx) noexcept
	{
	return (:: ceill(_Xx));
	}

  inline long double copysign(  long double _Number,
	  long double _Sign) noexcept
	{
	return (:: copysignl(_Number, _Sign));
	}

  inline long double cos(  long double _Xx) noexcept
	{
	return (:: cosl(_Xx));
	}

  inline long double cosh(  long double _Xx) noexcept
	{
	return (:: coshl(_Xx));
	}

  inline long double erf(  long double _Xx) noexcept
	{
	return (:: erfl(_Xx));
	}

  inline long double erfc(  long double _Xx) noexcept
	{
	return (:: erfcl(_Xx));
	}

  inline long double exp(  long double _Xx) noexcept
	{
	return (:: expl(_Xx));
	}

  inline long double exp2(  long double _Xx) noexcept
	{
	return (:: exp2l(_Xx));
	}

  inline long double expm1(  long double _Xx) noexcept
	{
	return (:: expm1l(_Xx));
	}

  inline long double fabs(  long double _Xx) noexcept
	{
	return (:: fabsl(_Xx));
	}

  inline long double fdim(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fdiml(_Xx, _Yx));
	}

  inline long double floor(  long double _Xx) noexcept
	{
	return (:: floorl(_Xx));
	}

  inline long double fma(  long double _Xx,
	  long double _Yx,   long double _Zx) noexcept
	{
	return (:: fmal(_Xx, _Yx, _Zx));
	}

  inline long double fmax(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmaxl(_Xx, _Yx));
	}

  inline long double fmin(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fminl(_Xx, _Yx));
	}

  inline long double fmod(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: fmodl(_Xx, _Yx));
	}

  inline long double frexp(  long double _Xx,
	  int* _Yx) noexcept
	{
	return (:: frexpl(_Xx, _Yx));
	}

  inline long double hypot(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: hypotl(_Xx, _Yx));
	}

  inline int ilogb(  long double _Xx) noexcept
	{
	return (:: ilogbl(_Xx));
	}

  inline long double ldexp(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: ldexpl(_Xx, _Yx));
	}

  inline long double lgamma(  long double _Xx) noexcept
	{
	return (:: lgammal(_Xx));
	}

  inline long long llrint(  long double _Xx) noexcept
	{
	return (:: llrintl(_Xx));
	}

  inline long long llround(  long double _Xx) noexcept
	{
	return (:: llroundl(_Xx));
	}

  inline long double log(  long double _Xx) noexcept
	{
	return (:: logl(_Xx));
	}

  inline long double log10(  long double _Xx) noexcept
	{
	return (:: log10l(_Xx));
	}

  inline long double log1p(  long double _Xx) noexcept
	{
	return (:: log1pl(_Xx));
	}

  inline long double log2(  long double _Xx) noexcept
	{
	return (:: log2l(_Xx));
	}

  inline long double logb(  long double _Xx) noexcept
	{
	return (:: logbl(_Xx));
	}

  inline long lrint(  long double _Xx) noexcept
	{
	return (:: lrintl(_Xx));
	}

  inline long lround(  long double _Xx) noexcept
	{
	return (:: lroundl(_Xx));
	}

  inline long double modf(  long double _Xx,
	  long double* _Yx) noexcept
	{
	return (:: modfl(_Xx, _Yx));
	}

  inline long double nearbyint(  long double _Xx) noexcept
	{
	return (:: nearbyintl(_Xx));
	}

  inline long double nextafter(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nextafterl(_Xx, _Yx));
	}

  inline long double nexttoward(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: nexttowardl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: powl(_Xx, _Yx));
	}

  inline long double pow(  long double _Xx,
	  int _Yx) noexcept
	{
	if (_Yx == 2)
		return (_Xx * _Xx);

	return (:: powl(_Xx, static_cast<long double>(_Yx)));
	}

  inline long double remainder(  long double _Xx,
	  long double _Yx) noexcept
	{
	return (:: remainderl(_Xx, _Yx));
	}

  inline long double remquo(  long double _Xx,
	  long double _Yx,   int *_Zx) noexcept
	{
	return (:: remquol(_Xx, _Yx, _Zx));
	}

  inline long double rint(  long double _Xx) noexcept
	{
	return (:: rintl(_Xx));
	}

  inline long double round(  long double _Xx) noexcept
	{
	return (:: roundl(_Xx));
	}

  inline long double scalbln(  long double _Xx,
	  long _Yx) noexcept
	{
	return (:: scalblnl(_Xx, _Yx));
	}

  inline long double scalbn(  long double _Xx,
	  int _Yx) noexcept
	{
	return (:: scalbnl(_Xx, _Yx));
	}

  inline long double sin(  long double _Xx) noexcept
	{
	return (:: sinl(_Xx));
	}

  inline long double sinh(  long double _Xx) noexcept
	{
	return (:: sinhl(_Xx));
	}

  inline long double sqrt(  long double _Xx) noexcept
	{
	return (:: sqrtl(_Xx));
	}

  inline long double tan(  long double _Xx) noexcept
	{
	return (:: tanl(_Xx));
	}

  inline long double tanh(  long double _Xx) noexcept
	{
	return (:: tanhl(_Xx));
	}

  inline long double tgamma(  long double _Xx) noexcept
	{
	return (:: tgammal(_Xx));
	}

  inline long double trunc(  long double _Xx) noexcept
	{
	return (:: truncl(_Xx));
	}

 #line 641 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"






 #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"


 
#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"







#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_malloc.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {





































#line 52 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_malloc.h"

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _calloc_base(
      size_t _Count,
      size_t _Size
    );

     
__declspec(dllimport)  __declspec(allocator) __declspec(restrict)
void* __cdecl calloc(
      __declspec(guard(overflow)) size_t _Count,
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport) int __cdecl _callnewh(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)
void* __cdecl _expand(
                void*  _Block,
      __declspec(guard(overflow)) size_t _Size
    );

__declspec(dllimport)
void __cdecl _free_base(
        void* _Block
    );

__declspec(dllimport)
void __cdecl free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _malloc_base(
      size_t _Size
    );

     
__declspec(dllimport) __declspec(allocator)  __declspec(restrict)
void* __cdecl malloc(
      __declspec(guard(overflow)) size_t _Size
    );

 
__declspec(dllimport)
size_t __cdecl _msize(
      void* _Block
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _realloc_base(
         void*  _Block,
                                 size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size
    );

__declspec(dllimport)
void __cdecl _aligned_free(
        void* _Block
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment
    );

     
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_malloc(
      __declspec(guard(overflow)) size_t _Size,
                         size_t _Alignment,
                         size_t _Offset
    );

 
__declspec(dllimport)
size_t __cdecl _aligned_msize(
      void*  _Block,
               size_t _Alignment,
               size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_offset_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment,
                                size_t _Offset
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_realloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );

       
__declspec(dllimport) __declspec(allocator) __declspec(restrict)
void* __cdecl _aligned_recalloc(
        void*  _Block,
      __declspec(guard(overflow))        size_t _Count,
      __declspec(guard(overflow))        size_t _Size,
                                size_t _Alignment
    );


















#line 211 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_malloc.h"



} __pragma(pack(pop))
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"










#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stddef.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {




    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;
#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stddef.h"




__declspec(dllimport) int* __cdecl _errno(void);


__declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
__declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);



    
        
    

#line 42 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stddef.h"


#line 45 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stddef.h"

__declspec(dllimport) extern unsigned long  __cdecl __threadid(void);

__declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);



} __pragma(pack(pop))
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"

__pragma(pack(push, 8)) extern "C" {





     
    __declspec(dllimport) void* __cdecl bsearch_s(
                                                        void const* _Key,
          void const* _Base,
                                                        rsize_t     _NumOfElements,
                                                        rsize_t     _SizeOfElements,
          int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                        void*       _Context
        );

    __declspec(dllimport) void __cdecl qsort_s(
          void*   _Base,
                                                             rsize_t _NumOfElements,
                                                             rsize_t _SizeOfElements,
          int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                             void*   _Context
        );

#line 41 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"



 
__declspec(dllimport) void* __cdecl bsearch(
                                                    void const* _Key,
      void const* _Base,
                                                    size_t      _NumOfElements,
                                                    size_t      _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

__declspec(dllimport) void __cdecl qsort(
      void*  _Base,
                                                         size_t _NumOfElements,
                                                         size_t _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

 
__declspec(dllimport) void* __cdecl _lfind_s(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       size_t        _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void*, void const*, void const*), 
                                                       void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lfind(
                                                       void const*   _Key,
      void const*   _Base,
                                                    unsigned int* _NumOfElements,
                                                       unsigned int  _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

 
__declspec(dllimport) void* __cdecl _lsearch_s(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             size_t        _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void*, void const*, void const*),
                                                             void*         _Context
    );

 
__declspec(dllimport) void* __cdecl _lsearch(
                                                             void const*   _Key,
      void*         _Base,
                                                          unsigned int* _NumOfElements,
                                                             unsigned int  _SizeOfElements,
      int (__cdecl* _PtFuncCompare)(void const*, void const*)
    );

















































































#line 179 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"





      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lfind" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lfind(
                                                           void const*   _Key,
          void const*   _Base,
                                                        unsigned int* _NumOfElements,
                                                           unsigned int  _SizeOfElements,
          int (__cdecl* _PtFuncCompare)(void const*, void const*)
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_lsearch" ". See online help for details."))
    __declspec(dllimport) void* __cdecl lsearch(
                                                                void const*   _Key,
          void*         _Base,
                                                             unsigned int* _NumOfElements,
                                                                unsigned int  _SizeOfElements,
          int (__cdecl* _PtFuncCompare)(void const*, void const*)
        );

#line 203 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_search.h"



} __pragma(pack(pop))
#line 14 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {
































 

__declspec(dllimport) errno_t __cdecl _itow_s(
                              int      _Value,
      wchar_t* _Buffer,
                              size_t   _BufferCount,
                              int      _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _itow_s(  int _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _itow_s(_Value, _Buffer, _Size, _Radix); } }
#line 61 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _itow( int _Value,   wchar_t *_Buffer,  int _Radix);
#line 68 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ltow_s(
                              long     _Value,
      wchar_t* _Buffer,
                              size_t   _BufferCount,
                              int      _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltow_s(  long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ltow_s(_Value, _Buffer, _Size, _Radix); } }
#line 84 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ltow( long _Value,   wchar_t *_Buffer,  int _Radix);
#line 91 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"


__declspec(dllimport) errno_t __cdecl _ultow_s(
                              unsigned long _Value,
      wchar_t*      _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultow_s(  unsigned long _Value, wchar_t (&_Buffer)[_Size],   int _Radix) throw() { return _ultow_s(_Value, _Buffer, _Size, _Radix); } }
#line 106 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _ultow( unsigned long _Value,   wchar_t *_Buffer,  int _Radix);
#line 113 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

 
__declspec(dllimport) double __cdecl wcstod(
                        wchar_t const* _String,
        wchar_t**      _EndPtr
    );

 
__declspec(dllimport) double __cdecl _wcstod_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                      _locale_t      _Locale
    );

 
__declspec(dllimport) long __cdecl wcstol(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
__declspec(dllimport) long __cdecl _wcstol_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
__declspec(dllimport) long long __cdecl wcstoll(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
__declspec(dllimport) long long __cdecl _wcstoll_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
__declspec(dllimport) unsigned long __cdecl wcstoul(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
__declspec(dllimport) unsigned long __cdecl _wcstoul_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
__declspec(dllimport) unsigned long long __cdecl wcstoull(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
__declspec(dllimport) unsigned long long __cdecl _wcstoull_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
__declspec(dllimport) long double __cdecl wcstold(
                        wchar_t const* _String,
        wchar_t**      _EndPtr
    );

 
__declspec(dllimport) long double __cdecl _wcstold_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                      _locale_t      _Locale
    );

 
__declspec(dllimport) float __cdecl wcstof(
                        wchar_t const* _String,
        wchar_t**      _EndPtr
    );

 
__declspec(dllimport) float __cdecl _wcstof_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                      _locale_t      _Locale
    );

 
__declspec(dllimport) double __cdecl _wtof(
      wchar_t const* _String
    );

 
__declspec(dllimport) double __cdecl _wtof_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wtoi(
      wchar_t const* _String
    );

 
__declspec(dllimport) int __cdecl _wtoi_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );

 
__declspec(dllimport) long __cdecl _wtol(
      wchar_t const* _String
    );

 
__declspec(dllimport) long __cdecl _wtol_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );

 
__declspec(dllimport) long long __cdecl _wtoll(
      wchar_t const* _String
    );

 
__declspec(dllimport) long long __cdecl _wtoll_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );


__declspec(dllimport) errno_t __cdecl _i64tow_s(
                              __int64  _Value,
      wchar_t* _Buffer,
                              size_t   _BufferCount,
                              int      _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _i64tow(
                        __int64  _Value,
        wchar_t* _Buffer,
                        int      _Radix
    );


__declspec(dllimport) errno_t __cdecl _ui64tow_s(
                              unsigned __int64 _Value,
      wchar_t*         _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64tow_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _ui64tow(
                        unsigned __int64 _Value,
        wchar_t*         _Buffer,
                        int              _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _wtoi64(
      wchar_t const* _String
    );

 
__declspec(dllimport) __int64 __cdecl _wtoi64_l(
        wchar_t const* _String,
      _locale_t      _Locale
    );

 
__declspec(dllimport) __int64 __cdecl _wcstoi64(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _wcstoi64_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(
                        wchar_t const* _String,
        wchar_t**      _EndPtr,
                          int            _Radix,
                      _locale_t      _Locale
    );




 
 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath(
      wchar_t*       _Buffer,
                                wchar_t const* _Path,
                                  size_t         _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _wmakepath_s(
      wchar_t*       _Buffer,
                              size_t         _BufferCount,
                        wchar_t const* _Drive,
                        wchar_t const* _Dir,
                        wchar_t const* _Filename,
                        wchar_t const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _Drive,   wchar_t const* _Dir,   wchar_t const* _Filename,   wchar_t const* _Ext) throw() { return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 359 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmakepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(  wchar_t *_Buffer,  wchar_t const* _Drive,  wchar_t const* _Dir,  wchar_t const* _Filename,  wchar_t const* _Ext);
#line 368 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

__declspec(dllimport) void __cdecl _wperror(
      wchar_t const* _ErrMsg
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsplitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _wsplitpath(
                        wchar_t const* _FullPath,
        wchar_t*       _Drive,
        wchar_t*       _Dir,
        wchar_t*       _Filename,
        wchar_t*       _Ext
    );

__declspec(dllimport) errno_t __cdecl _wsplitpath_s(
                                  wchar_t const* _FullPath,
         wchar_t*       _Drive,
                                    size_t         _DriveCount,
           wchar_t*       _Dir,
                                    size_t         _DirCount,
      wchar_t*       _Filename,
                                    size_t         _FilenameCount,
           wchar_t*       _Ext,
                                    size_t         _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _wsplitpath_s(   wchar_t const* _Path,   wchar_t (&_Drive)[_DriveSize],   wchar_t (&_Dir)[_DirSize],   wchar_t (&_Name)[_NameSize],   wchar_t (&_Ext)[_ExtSize] ) throw() { return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }
#line 398 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"





    
    

    
    __declspec(dllimport) errno_t __cdecl _wdupenv_s(
            wchar_t**      _Buffer,
                                                                            size_t*        _BufferCount,
                                                                               wchar_t const* _VarName
        );

    

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wdupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl _wgetenv(
          wchar_t const* _VarName
        );

     
    
    __declspec(dllimport) errno_t __cdecl _wgetenv_s(
                                     size_t*        _RequiredCount,
          wchar_t*       _Buffer,
                                      size_t         _BufferCount,
                                    wchar_t const* _VarName
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wgetenv_s(  size_t* _RequiredCount, wchar_t (&_Buffer)[_Size],   wchar_t const* _VarName) throw() { return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 436 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

     
    __declspec(dllimport) int __cdecl _wputenv(
          wchar_t const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _wputenv_s(
          wchar_t const* _Name,
          wchar_t const* _Value
        );
    
    __declspec(dllimport) errno_t __cdecl _wsearchenv_s(
                                wchar_t const* _Filename,
                                wchar_t const* _VarName,
          wchar_t*       _Buffer,
                                  size_t         _BufferCount
        );
    
    extern "C++" { template <size_t _Size> inline errno_t __cdecl _wsearchenv_s(  wchar_t const* _Filename,   wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw() { return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size); } }
#line 461 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"
    
    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsearchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv( wchar_t const* _Filename,  wchar_t const* _VarName,   wchar_t *_ResultPath);
#line 468 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"

    __declspec(dllimport) int __cdecl _wsystem(
          wchar_t const* _Command
        );

#line 474 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdlib.h"



} __pragma(pack(pop))
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"


__pragma(pack(push, 8)) extern "C" {




    
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"









__declspec(dllimport) void __cdecl _swab(
        char* _Buf1,
        char* _Buf2,
                                                                  int   _SizeInBytes
    );












__declspec(dllimport) __declspec(noreturn) void __cdecl exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl _exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(  int _Code);
__declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);





__declspec(dllimport) unsigned int __cdecl _set_abort_behavior(
      unsigned int _Flags,
      unsigned int _Mask
    );




    typedef int (__cdecl* _onexit_t)(void);



#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"






    
    
#line 82 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

























































    int       __cdecl atexit(void (__cdecl*)(void));
    _onexit_t __cdecl _onexit(  _onexit_t _Func);
#line 142 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

int __cdecl at_quick_exit(void (__cdecl*)(void));









    
    typedef void (__cdecl* _purecall_handler)(void);

    
    typedef void (__cdecl* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*, 
        unsigned int,
        uintptr_t
        );

    
    __declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(
          _purecall_handler _Handler
        );

    __declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(void);

    
    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(
          _invalid_parameter_handler _Handler
        );

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);
#line 185 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"












#line 198 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"









 __declspec(dllimport) int __cdecl _set_error_mode(  int _Mode);



__declspec(dllimport) int* __cdecl _errno(void);


__declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
__declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);

__declspec(dllimport) unsigned long* __cdecl __doserrno(void);


__declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
__declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) char** __cdecl __sys_errlist(void);


__declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) int * __cdecl __sys_nerr(void);


__declspec(dllimport) void __cdecl perror(  char const* _ErrMsg);




__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_pgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char**    __cdecl __p__pgmptr (void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_wpgmptr" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_fmode" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) int*      __cdecl __p__fmode  (void);






    
    
    
#line 248 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 
__declspec(dllimport) errno_t __cdecl _get_pgmptr (  char**    _Value);

 
__declspec(dllimport) errno_t __cdecl _get_wpgmptr(  wchar_t** _Value);

__declspec(dllimport) errno_t __cdecl _set_fmode  (               int       _Mode );

__declspec(dllimport) errno_t __cdecl _get_fmode  (              int*      _PMode);








typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

  int       __cdecl abs   (  int       _Number);
  long      __cdecl labs  (  long      _Number);
  long long __cdecl llabs (  long long _Number);
  __int64   __cdecl _abs64(  __int64   _Number);

  unsigned short   __cdecl _byteswap_ushort(  unsigned short   _Number);
  unsigned long    __cdecl _byteswap_ulong (  unsigned long    _Number);
  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64 _Number);

  __declspec(dllimport) div_t   __cdecl div  (  int       _Numerator,   int       _Denominator);
  __declspec(dllimport) ldiv_t  __cdecl ldiv (  long      _Numerator,   long      _Denominator);
  __declspec(dllimport) lldiv_t __cdecl lldiv(  long long _Numerator,   long long _Denominator);



#pragma warning (push)
#pragma warning (disable:6540) 

unsigned int __cdecl _rotl(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotl(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotl64(
      unsigned __int64 _Value,
      int              _Shift
    );

unsigned int __cdecl _rotr(
      unsigned int _Value,
      int          _Shift
    );

 
unsigned long __cdecl _lrotr(
      unsigned long _Value,
      int           _Shift
    );

unsigned __int64 __cdecl _rotr64(
      unsigned __int64 _Value,
      int              _Shift
    );

#pragma warning (pop)






__declspec(dllimport) void __cdecl srand(  unsigned int _Seed);

  __declspec(dllimport) int __cdecl rand(void);



#line 348 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"




extern "C++"
{
    inline long abs(long const _X) throw()
    {
        return labs(_X);
    }

    inline long long abs(long long const _X) throw()
    {
        return llabs(_X);
    }

    inline ldiv_t div(long const _A1, long const _A2) throw()
    {
        return ldiv(_A1, _A2);
    }

    inline lldiv_t div(long long const _A1, long long const _A2) throw()
    {
        return lldiv(_A1, _A2);
    }
}
#line 375 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"










    #pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
    #pragma pack(pop)

    











#line 405 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;





typedef struct
{
    long double x;
} _LONGDOUBLE;



#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)








                     __declspec(dllimport) double    __cdecl atof   (  char const* _String);
   __declspec(dllimport) int       __cdecl atoi   (  char const* _String);
                     __declspec(dllimport) long      __cdecl atol   (  char const* _String);
                     __declspec(dllimport) long long __cdecl atoll  (  char const* _String);
                     __declspec(dllimport) __int64   __cdecl _atoi64(  char const* _String);

  __declspec(dllimport) double    __cdecl _atof_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) int       __cdecl _atoi_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long      __cdecl _atol_l  (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) long long __cdecl _atoll_l (  char const* _String,   _locale_t _Locale);
  __declspec(dllimport) __int64   __cdecl _atoi64_l(  char const* _String,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl _atoflt (  _CRT_FLOAT*  _Result,   char const* _String);
  __declspec(dllimport) int __cdecl _atodbl (  _CRT_DOUBLE* _Result,   char*       _String);
  __declspec(dllimport) int __cdecl _atoldbl(  _LDOUBLE*    _Result,   char*       _String);

 
__declspec(dllimport) int __cdecl _atoflt_l(
         _CRT_FLOAT* _Result,
        char const* _String,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _atodbl_l(
         _CRT_DOUBLE* _Result,
        char*        _String,
      _locale_t    _Locale
    );


 
__declspec(dllimport) int __cdecl _atoldbl_l(
         _LDOUBLE* _Result,
        char*     _String,
      _locale_t _Locale
    );

 
__declspec(dllimport) float __cdecl strtof(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) float __cdecl _strtof_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) double __cdecl strtod(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) double __cdecl _strtod_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long double __cdecl strtold(
                        char const* _String,
        char**      _EndPtr
    );

 
__declspec(dllimport) long double __cdecl _strtold_l(
                        char const* _String,
        char**      _EndPtr,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long __cdecl strtol(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long __cdecl _strtol_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) long long __cdecl strtoll(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) long long __cdecl _strtoll_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long __cdecl strtoul(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long __cdecl _strtoul_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned long long __cdecl strtoull(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned long long __cdecl _strtoull_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) __int64 __cdecl _strtoi64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix
    );

 
__declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(
                        char const* _String,
        char**      _EndPtr,
                          int         _Radix,
                      _locale_t   _Locale
    );








 

__declspec(dllimport) errno_t __cdecl _itoa_s(
                              int    _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _itoa_s(  int _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _itoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 631 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa( int _Value,   char *_Buffer,  int _Radix);
#line 638 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ltoa_s(
                              long   _Value,
      char*  _Buffer,
                              size_t _BufferCount,
                              int    _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ltoa_s(  long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ltoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 654 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa( long _Value,   char *_Buffer,  int _Radix);
#line 661 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _ultoa_s(
                              unsigned long _Value,
      char*         _Buffer,
                              size_t        _BufferCount,
                              int           _Radix
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ultoa_s(  unsigned long _Value, char (&_Buffer)[_Size],   int _Radix) throw() { return _ultoa_s(_Value, _Buffer, _Size, _Radix); } }
#line 677 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa( unsigned long _Value,   char *_Buffer,  int _Radix);
#line 684 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 

__declspec(dllimport) errno_t __cdecl _i64toa_s(
                              __int64 _Value,
      char*   _Buffer,
                              size_t  _BufferCount,
                              int     _Radix
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_i64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _i64toa(
                        __int64 _Value,
        char*   _Buffer,
                        int     _Radix
    );

 

__declspec(dllimport) errno_t __cdecl _ui64toa_s(
                              unsigned __int64 _Value,
      char*            _Buffer,
                              size_t           _BufferCount,
                              int              _Radix
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_ui64toa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ui64toa(
                        unsigned __int64 _Value,
        char*            _Buffer,
                        int              _Radix
    );













 

__declspec(dllimport) errno_t __cdecl _ecvt_s(
      char* _Buffer,
       size_t                       _BufferCount,
       double                       _Value,
       int                          _DigitCount,
      int*                         _PtDec,
      int*                         _PtSign
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount,   int* _PtDec,   int* _PtSign) throw() { return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign); } }
#line 749 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ecvt(
       double _Value,
       int    _DigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 

__declspec(dllimport) errno_t __cdecl _fcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _FractionalDigitCount,
                             int*   _PtDec,
                             int*   _PtSign
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size],   double _Value,   int _FractionalDigitCount,   int* _PtDec,   int* _PtSign) throw() { return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign); } }
#line 778 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _fcvt(
       double _Value,
       int    _FractionalDigitCount,
      int*   _PtDec,
      int*   _PtSign
    );

 
__declspec(dllimport) errno_t __cdecl _gcvt_s(
      char*  _Buffer,
                              size_t _BufferCount,
                              double _Value,
                              int    _DigitCount
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size],   double _Value,   int _DigitCount) throw() { return _gcvt_s(_Buffer, _Size, _Value, _DigitCount); } }
#line 803 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_gcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _gcvt(
                        double _Value,
                        int    _DigitCount,
        char*  _Buffer
    );











    

#line 824 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
        
    #line 826 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    


        
    #line 832 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

     
    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t);
#line 839 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"



 
__declspec(dllimport) int __cdecl mblen(
        char const* _Ch,
                                             size_t      _MaxCount
    );

  
__declspec(dllimport) int __cdecl _mblen_l(
        char const* _Ch,
                                             size_t      _MaxCount,
                                         _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen(
      char const* _String
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrlen_l(
        char const* _String, 
      _locale_t   _Locale
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen(
      char const* _String,
        size_t      _MaxCount
    );

 
 
__declspec(dllimport) size_t __cdecl _mbstrnlen_l(
        char const* _String,
          size_t      _MaxCount,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl mbtowc(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes
    );

 
__declspec(dllimport) int __cdecl _mbtowc_l(
                      wchar_t*    _DstCh,
      char const* _SrcCh,
                                      size_t      _SrcSizeInBytes,
                                  _locale_t   _Locale
    );


__declspec(dllimport) errno_t __cdecl mbstowcs_s(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl mbstowcs_s(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount) throw() { return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 914 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbstowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl mbstowcs( wchar_t *_Dest,  char const* _Source,  size_t _MaxCount);
#line 921 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(
                                                      size_t*     _PtNumOfCharConverted,
      wchar_t*    _DstBuf,
                                                           size_t      _SizeInWords,
                                     char const* _SrcBuf,
                                                           size_t      _MaxCount,
                                                       _locale_t   _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _mbstowcs_s_l(  size_t* _PtNumOfCharConverted,   wchar_t (&_Dest)[_Size],   char const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 940 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_mbstowcs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _mbstowcs_l(  wchar_t *_Dest,   char const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 949 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"




__declspec(deprecated("This function or variable may be unsafe. Consider using " "wctomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl wctomb(
      char*   _MbCh,
                                wchar_t _WCh
    );

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctomb_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wctomb_l(
        char*     _MbCh,
                          wchar_t   _WCh,
                      _locale_t _Locale
    );



    
    __declspec(dllimport) errno_t __cdecl wctomb_s(
                                                         int*    _SizeConverted,
          char*   _MbCh,
                                                              rsize_t _SizeInBytes,
                                                              wchar_t _WCh
        );

#line 977 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wctomb_s_l(
                             int*     _SizeConverted,
      char*     _MbCh,
                                  size_t    _SizeInBytes,
                                  wchar_t   _WCh, 
                              _locale_t _Locale);


__declspec(dllimport) errno_t __cdecl wcstombs_s(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcstombs_s(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount) throw() { return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount); } }
#line 1002 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcstombs( char *_Dest,  wchar_t const* _Source,  size_t _MaxCount);
#line 1009 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"


__declspec(dllimport) errno_t __cdecl _wcstombs_s_l(
                                                               size_t*        _PtNumOfCharConverted,
      char*          _Dst,
                                                                    size_t         _DstSizeInBytes,
                                                                  wchar_t const* _Src,
                                                                    size_t         _MaxCountInBytes,
                                                                _locale_t      _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcstombs_s_l(  size_t* _PtNumOfCharConverted,   char (&_Dest)[_Size],   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale) throw() { return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale); } }
#line 1028 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcstombs_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl _wcstombs_l(  char *_Dest,   wchar_t const* _Source,   size_t _MaxCount,   _locale_t _Locale);
#line 1037 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"




















 
 
__declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(
      char*       _Buffer,
                                char const* _Path,
                                  size_t      _BufferCount
    );




__declspec(dllimport) errno_t __cdecl _makepath_s(
      char*       _Buffer,
                              size_t      _BufferCount,
                        char const* _Drive,
                        char const* _Dir,
                        char const* _Filename,
                        char const* _Ext
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _makepath_s(char (&_Buffer)[_Size],   char const* _Drive,   char const* _Dir,   char const* _Filename,   char const* _Ext) throw() { return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext); } }
#line 1085 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_makepath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _makepath(  char *_Buffer,  char const* _Drive,  char const* _Dir,  char const* _Filename,  char const* _Ext);
#line 1094 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_splitpath_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl _splitpath(
                        char const* _FullPath,
        char*       _Drive,
        char*       _Dir,
        char*       _Filename,
        char*       _Ext
    );


__declspec(dllimport) errno_t __cdecl _splitpath_s(
                                  char const* _FullPath,
         char*       _Drive,
                                    size_t      _DriveCount,
           char*       _Dir,
                                    size_t      _DirCount,
      char*       _Filename,
                                    size_t      _FilenameCount,
           char*       _Ext,
                                    size_t      _ExtCount
    );

extern "C++" { template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize> inline errno_t __cdecl _splitpath_s(   char const* _Dest,   char (&_Drive)[_DriveSize],   char (&_Dir)[_DirSize],   char (&_Name)[_NameSize],   char (&_Ext)[_ExtSize] ) throw() { return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize); } }










    

    
     
    __declspec(dllimport) errno_t __cdecl getenv_s(
                                     size_t*     _RequiredCount,
          char*       _Buffer,
                                      rsize_t     _BufferCount,
                                    char const* _VarName
        );
    
    #line 1140 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"




    __declspec(dllimport) int*       __cdecl __p___argc (void);
    __declspec(dllimport) char***    __cdecl __p___argv (void);
    __declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);

    




        
        
        
    #line 1157 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
    
    __declspec(dllimport) char***    __cdecl __p__environ (void);
    __declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);

    
        
    #line 1164 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"
    
    





        
        
    #line 1174 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"



    
    



      __declspec(deprecated("This function or variable may be unsafe. Consider using " "_dupenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) 
    __declspec(dllimport) char* __cdecl getenv(
          char const* _VarName
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl getenv_s(  size_t* _RequiredCount, char (&_Buffer)[_Size],   char const* _VarName) throw() { return getenv_s(_RequiredCount, _Buffer, _Size, _VarName); } }
#line 1193 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    


#line 1198 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    
    __declspec(dllimport) errno_t __cdecl _dupenv_s(
            char**      _Buffer,
                                                                            size_t*     _BufferCount,
                                                                               char const* _VarName
        );

    

#line 1209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    __declspec(dllimport) int __cdecl system(
          char const* _Command
        );

    
    
    #pragma warning (push)
    #pragma warning (disable:6540)

     
    __declspec(dllimport) int __cdecl _putenv(
          char const* _EnvString
        );

    
    __declspec(dllimport) errno_t __cdecl _putenv_s(
          char const* _Name,
          char const* _Value
        );

    #pragma warning (pop)

    __declspec(dllimport) errno_t __cdecl _searchenv_s(
                                char const* _Filename,
                                char const* _VarName,
          char*       _Buffer,
                                  size_t      _BufferCount
        );

    extern "C++" { template <size_t _Size> inline errno_t __cdecl _searchenv_s(  char const* _Filename,   char const* _VarName, char (&_Buffer)[_Size]) throw() { return _searchenv_s(_Filename, _VarName, _Buffer, _Size); } }
#line 1245 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_searchenv_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv( char const* _Filename,  char const* _VarName,   char *_Buffer);
#line 1252 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetErrorMode" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _seterrormode(
          int _Mode
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Beep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _beep(
          unsigned _Frequency,
          unsigned _Duration
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "Sleep" " " "instead. See online help for details."))
    __declspec(dllimport) void __cdecl _sleep(
          unsigned long _Duration
        );

#line 1271 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"










    




    
    

    #pragma warning(push)
    #pragma warning(disable: 4141) 

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ecvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ecvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ecvt(
           double _Value,
           int    _DigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl fcvt(
           double _Value,
           int    _FractionalDigitCount,
          int*   _PtDec,
          int*   _PtSign
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_gcvt" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fcvt_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl gcvt(
                            double _Value,
                            int    _DigitCount,
            char*  _DstBuf
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_itoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_itoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl itoa(
                            int   _Value,
            char* _Buffer,
                            int   _Radix
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ltoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ltoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ltoa(
                            long  _Value,
            char* _Buffer,
                            int   _Radix
        );


    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_swab" ". See online help for details."))
    __declspec(dllimport) void __cdecl swab(
          char* _Buf1,
          char* _Buf2,
                                     int   _SizeInBytes
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_ultoa" ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ultoa_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __declspec(dllimport) char* __cdecl ultoa(
                            unsigned long _Value,
            char*         _Buffer,
                            int           _Radix
        );

    

        

          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putenv" ". See online help for details."))
        __declspec(dllimport) int __cdecl putenv(
              char const* _EnvString
            );

    #line 1354 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"

    #pragma warning(pop)

    _onexit_t __cdecl onexit(  _onexit_t _Func);

#line 1360 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdlib.h"



} __pragma(pack(pop))

#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

 
namespace std {
using :: size_t; using :: div_t; using :: ldiv_t;
using :: abort; using :: abs; using :: atexit;
using :: atof; using :: atoi; using :: atol;
using :: bsearch; using :: calloc; using :: div;
using :: exit; using :: free;
using :: labs; using :: ldiv; using :: malloc;
using :: mblen; using :: mbstowcs; using :: mbtowc;
using :: qsort; using :: rand; using :: realloc;
using :: srand; using :: strtod; using :: strtol;
using :: strtoul;
using :: wcstombs; using :: wctomb;

using :: lldiv_t;

 
using :: getenv;
using :: system;
 #line 36 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

using :: atoll; using :: llabs; using :: lldiv;
using :: strtof; using :: strtold;
using :: strtoll; using :: strtoull;

using :: _Exit; using :: at_quick_exit; using :: quick_exit;
}
 #line 44 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"

#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdlib"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
struct _Nil
	{	
	};

	
template<class _Ty,
	_Ty _Val>
	struct integral_constant
	{	
	static constexpr _Ty value = _Val;

	typedef _Ty value_type;
	typedef integral_constant<_Ty, _Val> type;

	constexpr operator value_type() const noexcept
		{	
		return (value);
		}

	constexpr value_type operator()() const noexcept
		{	
		return (value);
		}
	};

typedef integral_constant<bool, true> true_type;
typedef integral_constant<bool, false> false_type;

	
template<bool _Val>
	using bool_constant = integral_constant<bool, _Val>;

	
template<bool _Val>
	struct _Cat_base
		: integral_constant<bool, _Val>
	{	
	};

	
template<bool _Test,
	class _Ty = void>
	struct enable_if
	{	
	};

template<class _Ty>
	struct enable_if<true, _Ty>
	{	
	typedef _Ty type;
	};

	
template<bool _Test,
	class _Ty1,
	class _Ty2>
	struct conditional
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct conditional<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

	
template<class _Ty1,
	class _Ty2>
	struct is_same
		: false_type
	{	
	};

template<class _Ty1>
	struct is_same<_Ty1, _Ty1>
		: true_type
	{	
	};

 
template<class _Ty,
	class _Uty>
	constexpr bool is_same_v = is_same<_Ty, _Uty>::value;
 #line 102 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct remove_const
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_const<const _Ty>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_volatile
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_volatile<volatile _Ty>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_cv
	{	
	typedef typename remove_const<typename remove_volatile<_Ty>::type>::type
		type;
	};

	
template<class _Ty>
	struct _Is_integral
		: false_type
	{	
	};

template<>
	struct _Is_integral<bool>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned char>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed char>
		: true_type
	{	
	};

 
template<>
	struct _Is_integral<wchar_t>
		: true_type
	{	
	};
 #line 175 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

template<>
	struct _Is_integral<unsigned short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed short>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed int>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<signed long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char16_t>
		: true_type
	{	
	};

template<>
	struct _Is_integral<char32_t>
		: true_type
	{	
	};

template<>
	struct _Is_integral<long long>
		: true_type
	{	
	};

template<>
	struct _Is_integral<unsigned long long>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_integral
		: _Is_integral<typename remove_cv<_Ty>::type>
	{	
	};

 
template<class _Ty>
	constexpr bool is_integral_v = is_integral<_Ty>::value;
 #line 247 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct _Is_floating_point
		: false_type
	{	
	};

template<>
	struct _Is_floating_point<float>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<double>
		: true_type
	{	
	};

template<>
	struct _Is_floating_point<long double>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_floating_point
		: _Is_floating_point<typename remove_cv<_Ty>::type>
	{	
	};

 
template<class _Ty>
	constexpr bool is_floating_point_v = is_floating_point<_Ty>::value;
 #line 284 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct is_arithmetic
		: _Cat_base<is_integral<_Ty>::value
			|| is_floating_point<_Ty>::value>
	{	
	};

 
template<class _Ty>
	constexpr bool is_arithmetic_v = is_arithmetic<_Ty>::value;
 #line 297 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"

	
template<class _Ty>
	struct remove_reference
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_reference<_Ty&&>
	{	
	typedef _Ty type;
	};

	
struct _Wrap_int
	{	
	_Wrap_int(int)
		{	
		}
	};

template<class _Ty>
	struct _Identity
	{	
	typedef _Ty type;
	};














}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 349 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"
#line 350 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtr1common"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
template<class _Ty>
	struct _Promote_to_float
	{	
	typedef typename conditional<is_integral<_Ty>::value,
		double, _Ty>::type type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Common_float_type
	{	
	typedef typename _Promote_to_float<_Ty1>::type _Ty1f;
	typedef typename _Promote_to_float<_Ty2>::type _Ty2f;
	typedef typename conditional<is_same<_Ty1f, long double>::value
		|| is_same<_Ty2f, long double>::value, long double,
		typename conditional<is_same<_Ty1f, double>::value
			|| is_same<_Ty2f, double>::value, double,
			float>::type>::type type;
	};
}








































template<class _Ty1,
	class _Ty2> inline
	typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value
		&& ::std:: is_arithmetic<_Ty2>::value,
		typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type
	pow(const _Ty1 _Left, const _Ty2 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (:: pow(type(_Left), type(_Right)));
	}


extern "C"    double __cdecl acos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acos(_Ty _Left) { return (:: acos((double)_Left)); }
extern "C"    double __cdecl asin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asin(_Ty _Left) { return (:: asin((double)_Left)); }
extern "C"    double __cdecl atan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atan(_Ty _Left) { return (:: atan((double)_Left)); }
extern "C"    double __cdecl atan2(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type atan2(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: atan2((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl ceil(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ceil(_Ty _Left) { return (:: ceil((double)_Left)); }
extern "C"    double __cdecl cos(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cos(_Ty _Left) { return (:: cos((double)_Left)); }
extern "C"    double __cdecl cosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cosh(_Ty _Left) { return (:: cosh((double)_Left)); }
extern "C"    double __cdecl exp(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp(_Ty _Left) { return (:: exp((double)_Left)); }

extern "C"    double __cdecl fabs(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type fabs(_Ty _Left) { return (:: fabs((double)_Left)); }

extern "C"   __declspec(dllimport) double __cdecl floor(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type floor(_Ty _Left) { return (:: floor((double)_Left)); }
extern "C"    double __cdecl fmod(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmod(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmod((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl frexp(  double,   int *); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type frexp(_Ty _Left,   int * _Arg2) { return (:: frexp((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl ldexp(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type ldexp(_Ty _Left,   int _Arg2) { return (:: ldexp((double)_Left, _Arg2)); }
extern "C"    double __cdecl log(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log(_Ty _Left) { return (:: log((double)_Left)); }
extern "C"    double __cdecl log10(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log10(_Ty _Left) { return (:: log10((double)_Left)); }


extern "C"    double __cdecl sin(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sin(_Ty _Left) { return (:: sin((double)_Left)); }
extern "C"    double __cdecl sinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sinh(_Ty _Left) { return (:: sinh((double)_Left)); }
extern "C"    double __cdecl sqrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type sqrt(_Ty _Left) { return (:: sqrt((double)_Left)); }
extern "C"    double __cdecl tan(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tan(_Ty _Left) { return (:: tan((double)_Left)); }
extern "C"    double __cdecl tanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tanh(_Ty _Left) { return (:: tanh((double)_Left)); }

		









		

inline float _Fma(float _Left, float _Middle, float _Right)
	{	
	return (:: fmaf(_Left, _Middle, _Right));
	}

inline double _Fma(double _Left, double _Middle, double _Right)
	{	
	return (:: fma(_Left, _Middle, _Right));
	}

inline long double _Fma(long double _Left, long double _Middle,
	long double _Right)
	{	
	return (:: fmal(_Left, _Middle, _Right));
	}

template<class _Ty1,
	class _Ty2,
	class _Ty3> inline
	typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type
	fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1,
		typename ::std:: _Common_float_type<_Ty2, _Ty3>::type>::type type;
	return (_Fma((type)_Left, (type)_Middle, (type)_Right));
	}

		

inline float _Remquo(float _Left, float _Right, int *_Pquo)
	{	
	return (:: remquof(_Left, _Right, _Pquo));
	}

inline double _Remquo(double _Left, double _Right, int *_Pquo)
	{	
	return (:: remquo(_Left, _Right, _Pquo));
	}

inline long double _Remquo(long double _Left, long double _Right, int *_Pquo)
	{	
	return (:: remquol(_Left, _Right, _Pquo));
	}

template<class _Ty1,
	class _Ty2> inline
	typename ::std:: _Common_float_type<_Ty1, _Ty2>::type
	remquo(_Ty1 _Left, _Ty2 _Right, int *_Pquo)
	{	
	typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type;
	return (_Remquo((type)_Left, (type)_Right, _Pquo));
	}

extern "C"   __declspec(dllimport) double __cdecl acosh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type acosh(_Ty _Left) { return (:: acosh((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl asinh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type asinh(_Ty _Left) { return (:: asinh((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl atanh(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type atanh(_Ty _Left) { return (:: atanh((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl cbrt(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type cbrt(_Ty _Left) { return (:: cbrt((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl copysign(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type copysign(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: copysign((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl erf(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erf(_Ty _Left) { return (:: erf((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl erfc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type erfc(_Ty _Left) { return (:: erfc((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl expm1(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type expm1(_Ty _Left) { return (:: expm1((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl exp2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type exp2(_Ty _Left) { return (:: exp2((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl fdim(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fdim(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fdim((type)_Left, (type)_Right)); }

extern "C"   __declspec(dllimport) double __cdecl fmax(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmax(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmax((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl fmin(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type fmin(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: fmin((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl hypot(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type hypot(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: hypot((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) int __cdecl ilogb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, int>::type ilogb(_Ty _Left) { return (:: ilogb((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl lgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type lgamma(_Ty _Left) { return (:: lgamma((double)_Left)); }
extern "C"   __declspec(dllimport) long long __cdecl llrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llrint(_Ty _Left) { return (:: llrint((double)_Left)); }
extern "C"   __declspec(dllimport) long long __cdecl llround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long long>::type llround(_Ty _Left) { return (:: llround((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl log1p(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log1p(_Ty _Left) { return (:: log1p((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl log2(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type log2(_Ty _Left) { return (:: log2((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl logb(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type logb(_Ty _Left) { return (:: logb((double)_Left)); }
extern "C"   __declspec(dllimport) long __cdecl lrint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lrint(_Ty _Left) { return (:: lrint((double)_Left)); }
extern "C"   __declspec(dllimport) long __cdecl lround(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, long>::type lround(_Ty _Left) { return (:: lround((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl nearbyint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nearbyint(_Ty _Left) { return (:: nearbyint((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl nextafter(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type nextafter(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: nextafter((type)_Left, (type)_Right)); }
extern "C"   __declspec(dllimport) double __cdecl nexttoward(  double,   long double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type nexttoward(_Ty _Left,   long double _Arg2) { return (:: nexttoward((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl remainder(   double,   double); template<class _Ty1, class _Ty2> inline typename ::std:: enable_if< ::std:: is_arithmetic<_Ty1>::value && ::std:: is_arithmetic<_Ty2>::value, typename ::std:: _Common_float_type<_Ty1, _Ty2>::type>::type remainder(_Ty1 _Left, _Ty2 _Right) { typedef typename ::std:: _Common_float_type<_Ty1, _Ty2>::type type; return (:: remainder((type)_Left, (type)_Right)); }

extern "C"   __declspec(dllimport) double __cdecl rint(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type rint(_Ty _Left) { return (:: rint((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl round(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type round(_Ty _Left) { return (:: round((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl scalbln(  double,   long); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbln(_Ty _Left,   long _Arg2) { return (:: scalbln((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl scalbn(  double,   int); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type scalbn(_Ty _Left,   int _Arg2) { return (:: scalbn((double)_Left, _Arg2)); }
extern "C"   __declspec(dllimport) double __cdecl tgamma(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type tgamma(_Ty _Left) { return (:: tgamma((double)_Left)); }
extern "C"   __declspec(dllimport) double __cdecl trunc(  double); template<class _Ty> inline typename ::std:: enable_if< ::std:: is_integral<_Ty>::value, double>::type trunc(_Ty _Left) { return (:: trunc((double)_Left)); }

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 218 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"
#line 219 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"
 #line 220 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtgmath.h"





#line 648 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"
#line 649 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

 
namespace std {
using :: abs; using :: acos; using :: asin;
using :: atan; using :: atan2; using :: ceil;
using :: cos; using :: cosh; using :: exp;
using :: fabs; using :: floor; using :: fmod;
using :: frexp; using :: ldexp; using :: log;
using :: log10; using :: modf; using :: pow;
using :: sin; using :: sinh; using :: sqrt;
using :: tan; using :: tanh;

using :: acosf; using :: asinf;
using :: atanf; using :: atan2f; using :: ceilf;
using :: cosf; using :: coshf; using :: expf;
using :: fabsf; using :: floorf; using :: fmodf;
using :: frexpf; using :: ldexpf; using :: logf;
using :: log10f; using :: modff; using :: powf;
using :: sinf; using :: sinhf; using :: sqrtf;
using :: tanf; using :: tanhf;

using :: acosl; using :: asinl;
using :: atanl; using :: atan2l; using :: ceill;
using :: cosl; using :: coshl; using :: expl;
using :: fabsl; using :: floorl; using :: fmodl;
using :: frexpl; using :: ldexpl; using :: logl;
using :: log10l; using :: modfl; using :: powl;
using :: sinl; using :: sinhl; using :: sqrtl;
using :: tanl; using :: tanhl;

using :: float_t; using :: double_t;

using :: acosh; using :: asinh; using :: atanh;
using :: cbrt; using :: erf; using :: erfc;
using :: expm1; using :: exp2;
using :: hypot; using :: ilogb; using :: lgamma;
using :: log1p; using :: log2; using :: logb;
using :: llrint; using :: lrint; using :: nearbyint;
using :: rint; using :: llround; using :: lround;
using :: fdim; using :: fma; using :: fmax; using :: fmin;
using :: round; using :: trunc;
using :: remainder; using :: remquo;
using :: copysign; using :: nan; using :: nextafter;
using :: scalbn; using :: scalbln;
using :: nexttoward; using :: tgamma;

using :: acoshf; using :: asinhf; using :: atanhf;
using :: cbrtf; using :: erff; using :: erfcf;
using :: expm1f; using :: exp2f;
using :: hypotf; using :: ilogbf; using :: lgammaf;
using :: log1pf; using :: log2f; using :: logbf;
using :: llrintf; using :: lrintf; using :: nearbyintf;
using :: rintf; using :: llroundf; using :: lroundf;
using :: fdimf; using :: fmaf; using :: fmaxf; using :: fminf;
using :: roundf; using :: truncf;
using :: remainderf; using :: remquof;
using :: copysignf; using :: nanf;
using :: nextafterf; using :: scalbnf; using :: scalblnf;
using :: nexttowardf; using :: tgammaf;

using :: acoshl; using :: asinhl; using :: atanhl;
using :: cbrtl; using :: erfl; using :: erfcl;
using :: expm1l; using :: exp2l;
using :: hypotl; using :: ilogbl; using :: lgammal;
using :: log1pl; using :: log2l; using :: logbl;
using :: llrintl; using :: lrintl; using :: nearbyintl;
using :: rintl; using :: llroundl; using :: lroundl;
using :: fdiml; using :: fmal; using :: fmaxl; using :: fminl;
using :: roundl; using :: truncl;
using :: remainderl; using :: remquol;
using :: copysignl; using :: nanl;
using :: nextafterl; using :: scalbnl; using :: scalblnl;
using :: nexttowardl; using :: tgammal;

using :: fpclassify; using :: signbit;
using :: isfinite; using :: isinf;
using :: isnan; using :: isnormal;
using :: isgreater; using :: isgreaterequal;
using :: isless; using :: islessequal;
using :: islessgreater; using :: isunordered;
}
 #line 731 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"

#line 733 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cmath"





#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"









#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\errno.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {



__declspec(dllimport) extern int* __cdecl _errno(void);


__declspec(dllimport) errno_t __cdecl _set_errno(  int _Value);
__declspec(dllimport) errno_t __cdecl _get_errno(  int* _Value);



__declspec(dllimport) unsigned long* __cdecl __doserrno(void);


__declspec(dllimport) errno_t __cdecl _set_doserrno(  unsigned long _Value);
__declspec(dllimport) errno_t __cdecl _get_doserrno(  unsigned long * _Value);










































    
    
    
    
    
#line 78 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\errno.h"






    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
#line 126 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\errno.h"



} __pragma(pack(pop))
#line 12 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"



__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) void const* __cdecl memchr(
      void const* _Buf,
                                 int         _Val,
                                 size_t      _MaxCount
    );

 
int __cdecl memcmp(
      void const* _Buf1,
      void const* _Buf2,
                         size_t      _Size
    );


 

#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"
void* __cdecl memcpy(
      void* _Dst,
            void const* _Src,
                               size_t      _Size
    );


__declspec(dllimport) void* __cdecl memmove(
      void*       _Dst,
            void const* _Src,
                                   size_t      _Size
    );

 

#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"
void* __cdecl memset(
      void*  _Dst,
                               int    _Val,
                               size_t _Size
    );

 
__declspec(dllimport) char const* __cdecl strchr(
      char const* _Str,
        int         _Val
    );

 
__declspec(dllimport) char const* __cdecl strrchr(
      char const* _Str,
        int         _Ch
    );

   
__declspec(dllimport) char const* __cdecl strstr(
      char const* _Str,
      char const* _SubStr
    );

 

__declspec(dllimport) wchar_t const* __cdecl wcschr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

 
__declspec(dllimport) wchar_t const* __cdecl wcsrchr(
      wchar_t const* _Str,
        wchar_t        _Ch
    );

   

__declspec(dllimport) wchar_t const* __cdecl wcsstr(
      wchar_t const* _Str,
      wchar_t const* _SubStr
    );



} __pragma(pack(pop))

#line 109 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_string.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"

__pragma(pack(push, 8)) extern "C" {


    
#line 19 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"














     
    
    static __inline errno_t __cdecl memcpy_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

            
            return 22;
        }

        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    
    static __inline errno_t __cdecl memmove_s(
          void*       const _Destination,
                                                              rsize_t     const _DestinationSize,
                                 void const* const _Source,
                                                              rsize_t     const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != 0); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }

#line 85 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memcpy_s.h"



} __pragma(pack(pop))
#line 15 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"








#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {





#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"
    
#line 23 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"


    




#line 31 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"























#line 55 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"




#line 60 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"


    


        #pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")
    #line 67 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"
#line 68 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"



   
__declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_printf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}



   
__declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}



















} __pragma(pack(pop))

#line 108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_stdio_config.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

__pragma(pack(push, 8)) extern "C" {









    
     
    __declspec(dllimport) errno_t __cdecl _cgetws_s(
          wchar_t* _Buffer,
                                               size_t   _BufferCount,
                                              size_t*  _SizeRead
        );

    extern "C++" { template <size_t _Size> inline   errno_t __cdecl _cgetws_s(  wchar_t (&_Buffer)[_Size],   size_t* _SizeRead) throw() { return _cgetws_s(_Buffer, _Size, _SizeRead); } }
#line 38 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __declspec(dllimport) int __cdecl _cputws(
          wchar_t const* _Buffer
        );

          __declspec(dllimport) wint_t __cdecl _getwch  (void);
          __declspec(dllimport) wint_t __cdecl _getwche (void);
     __declspec(dllimport) wint_t __cdecl _putwch  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch(  wint_t  _Character);

          __declspec(dllimport) wint_t __cdecl _getwch_nolock  (void);
          __declspec(dllimport) wint_t __cdecl _getwche_nolock (void);
     __declspec(dllimport) wint_t __cdecl _putwch_nolock  (  wchar_t _Character);
     __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(  wint_t  _Character);



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(
                                             unsigned __int64 _Options,
            wchar_t const*   _Format,
                                         _locale_t        _Locale,
                                                va_list          _ArgList
        );

    
    __inline int __cdecl _vcwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 94 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 98 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 107 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }
#line 111 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 121 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 125 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 134 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }
#line 138 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
        )


#line 148 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }
#line 152 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwprintf_p(
            const wchar_t* const _Format,
                                      va_list              _ArgList
        )


#line 161 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }
#line 165 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 174 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 183 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf(
            wchar_t const* const _Format,
        ...)


#line 191 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 200 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 218 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_s(
            wchar_t const* const _Format,
        ...)


#line 226 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 235 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p_l(
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
        ...)


#line 244 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 253 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwprintf_p(
            wchar_t const* const _Format,
        ...)


#line 261 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"



    
    
    
    
    
    
    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(
                                            unsigned __int64 _Options,
            wchar_t const*   _Format,
                                        _locale_t        _Locale,
                                               va_list          _ArgList
        );

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 295 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()),
            _Format, _Locale, _ArgList);
    }
#line 301 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vcwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _vcwscanf(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 310 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        #pragma warning(push)
        #pragma warning(disable: 4996) 
        return _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)
    }
#line 317 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
                                               va_list              _ArgList
        )


#line 327 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return __conio_common_vcwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Format, _Locale, _ArgList);
    }
#line 333 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _vcwscanf_s(
            wchar_t const* const _Format,
                                               va_list              _ArgList
        )


#line 342 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }
#line 346 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 355 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 369 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

     __declspec(deprecated("This function or variable may be unsafe. Consider using " "_cwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    __inline int __cdecl _cwscanf(
            wchar_t const* const _Format,
        ...)


#line 377 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 391 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s_l(
            wchar_t const* const _Format,
                                        _locale_t      const _Locale,
        ...)


#line 400 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 409 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

    
    __inline int __cdecl _cwscanf_s(
            wchar_t const* const _Format,
        ...)


#line 417 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 426 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"

#line 428 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wconio.h"



} __pragma(pack(pop))
#line 16 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {











    

#line 28 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"
        
    #line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"

    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t*       __cdecl __pwctype_func(void);

    



        
        
    #line 41 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"
#line 42 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"





















  __declspec(dllimport) int __cdecl iswalnum  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswalpha  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswascii  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswblank  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswcntrl  (  wint_t _C);


  __declspec(dllimport) int __cdecl iswdigit  (  wint_t _C);

  __declspec(dllimport) int __cdecl iswgraph  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswlower  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswprint  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswpunct  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswspace  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswupper  (  wint_t _C);
  __declspec(dllimport) int __cdecl iswxdigit (  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsymf(  wint_t _C);
  __declspec(dllimport) int __cdecl __iswcsym (  wint_t _C);

  __declspec(dllimport) int __cdecl _iswalnum_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswalpha_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswblank_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcntrl_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswdigit_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswgraph_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswlower_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswprint_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswpunct_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswspace_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswupper_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswxdigit_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsymf_l (  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl _iswcsym_l  (  wint_t _C,   _locale_t _Locale);


  __declspec(dllimport) wint_t __cdecl towupper(  wint_t _C);
  __declspec(dllimport) wint_t __cdecl towlower(  wint_t _C);
  __declspec(dllimport) int    __cdecl iswctype(  wint_t _C,   wctype_t _Type);

  __declspec(dllimport) wint_t __cdecl _towupper_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) wint_t __cdecl _towlower_l(  wint_t _C,   _locale_t _Locale);
  __declspec(dllimport) int    __cdecl _iswctype_l(  wint_t _C,   wctype_t _Type,   _locale_t _Locale);



      __declspec(dllimport) int __cdecl isleadbyte(  int _C);
      __declspec(dllimport) int __cdecl _isleadbyte_l(  int _C,   _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "iswctype" " " "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(  wint_t _C,   wctype_t _Type);
#line 113 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"


















































































#line 196 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wctype.h"



} __pragma(pack(pop))
#line 17 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wdirect.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {






 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );

 
   
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(
                                  int      _Drive,
      wchar_t* _DstBuf,
                                  int      _SizeInWords
    );






 
__declspec(dllimport) int __cdecl _wchdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wmkdir(
      wchar_t const* _Path
    );

 
__declspec(dllimport) int __cdecl _wrmdir(
      wchar_t const* _Path
    );



} __pragma(pack(pop))
#line 18 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"








#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_share.h"








#pragma once












    
    
    
    
#line 27 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_share.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

__pragma(pack(push, 8)) extern "C" {



#pragma warning(push)
#pragma warning(disable:4820) 
#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"











    
    
#line 35 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

typedef unsigned long _fsize_t;

struct _wfinddata32_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata32i64_t
{
    unsigned   attrib;
    __time32_t time_create;    
    __time32_t time_access;    
    __time32_t time_write;
    __int64    size;
    wchar_t    name[260];
};

struct _wfinddata64i32_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    _fsize_t   size;
    wchar_t    name[260];
};

struct _wfinddata64_t
{
    unsigned   attrib;
    __time64_t time_create;    
    __time64_t time_access;    
    __time64_t time_write;
    __int64    size;
    wchar_t    name[260];
};














    
    
    
    
#line 96 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

 
__declspec(dllimport) int __cdecl _waccess(
      wchar_t const* _FileName,
        int            _AccessMode
    );


__declspec(dllimport) errno_t __cdecl _waccess_s(
      wchar_t const* _FileName,
        int            _AccessMode
    );

 
__declspec(dllimport) int __cdecl _wchmod(
      wchar_t const* _FileName,
        int            _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int __cdecl _wcreat(
      wchar_t const* _FileName,
        int            _PermissionMode
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32(
      wchar_t const*         _FileName,
       struct _wfinddata32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32(
       intptr_t               _FindHandle,
      struct _wfinddata32_t* _FindData
    );

__declspec(dllimport) int __cdecl _wunlink(
      wchar_t const* _FileName
    );

 
__declspec(dllimport) int __cdecl _wrename(
      wchar_t const* _OldFileName,
      wchar_t const* _NewFileName
    );

__declspec(dllimport) errno_t __cdecl _wmktemp_s(
      wchar_t* _TemplateName,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw() { return _wmktemp_s(_TemplateName, _Size); } }
#line 154 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wmktemp_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp( wchar_t *_TemplateName);
#line 160 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(
      wchar_t const*            _FileName,
       struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(
      wchar_t const*            _FileName,
       struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) intptr_t __cdecl _wfindfirst64(
      wchar_t const*         _FileName,
       struct _wfinddata64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext32i64(
       intptr_t                  _FindHandle,
      struct _wfinddata32i64_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64i32(
       intptr_t                  _FindHandle,
      struct _wfinddata64i32_t* _FindData
    );

 
 
__declspec(dllimport) int __cdecl _wfindnext64(
       intptr_t               _FindHandle,
      struct _wfinddata64_t* _FindData
    );


__declspec(dllimport) errno_t __cdecl _wsopen_s(
       int*           _FileHandle,
      wchar_t const* _FileName,
        int            _OpenFlag,
        int            _ShareFlag,
        int            _PermissionFlag
    );

__declspec(dllimport) errno_t __cdecl _wsopen_dispatch(
      wchar_t const* _FileName,
        int            _OFlag,
        int            _ShFlag,
        int            _PMode,
       int*           _PFileHandle,
        int            _BSecure
    );





    
    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++"   __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wsopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    inline int __cdecl _wsopen(
          wchar_t const* _FileName,
            int            _OFlag,
            int            _ShFlag,
            int            _PMode = 0
        )
    {
        int _FileHandle;
        
        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

















#line 270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"



#pragma warning(pop)
#line 275 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wio.h"


} __pragma(pack(pop))
#line 19 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wprocess.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {


    


    __declspec(dllimport) intptr_t __cdecl _wexecl(
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

    __declspec(dllimport) intptr_t __cdecl _wexecle(
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

    __declspec(dllimport) intptr_t __cdecl _wexeclp(
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

    __declspec(dllimport) intptr_t __cdecl _wexeclpe(
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

    __declspec(dllimport) intptr_t __cdecl _wexecv(
          wchar_t const*        _FileName,
          wchar_t const* const* _ArgList
        );

    __declspec(dllimport) intptr_t __cdecl _wexecve(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList,
          wchar_t const* const* _Env
        );

    __declspec(dllimport) intptr_t __cdecl _wexecvp(
          wchar_t const*        _FileName,
          wchar_t const* const* _ArgList
        );

    __declspec(dllimport) intptr_t __cdecl _wexecvpe(
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList,
          wchar_t const* const* _Env
        );

    __declspec(dllimport) intptr_t __cdecl _wspawnl(
            int            _Mode,
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

    __declspec(dllimport) intptr_t __cdecl _wspawnle(
            int            _Mode,
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

    __declspec(dllimport) intptr_t __cdecl _wspawnlp(
            int            _Mode,
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

    __declspec(dllimport) intptr_t __cdecl _wspawnlpe(
            int            _Mode,
          wchar_t const* _FileName,
          wchar_t const* _ArgList,
        ...);

    __declspec(dllimport) intptr_t __cdecl _wspawnv(
            int                   _Mode,
          wchar_t const*        _FileName,
          wchar_t const* const* _ArgList
        );

    __declspec(dllimport) intptr_t __cdecl _wspawnve(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList,
          wchar_t const* const* _Env
        );

    __declspec(dllimport) intptr_t __cdecl _wspawnvp(
            int                   _Mode,
          wchar_t const*        _FileName,
          wchar_t const* const* _ArgList
        );

    __declspec(dllimport) intptr_t __cdecl _wspawnvpe(
                int                   _Mode,
              wchar_t const*        _FileName,
              wchar_t const* const* _ArgList,
          wchar_t const* const* _Env
        );

    __declspec(dllimport) int __cdecl _wsystem(
          wchar_t const* _Command
        );

#line 116 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wprocess.h"



} __pragma(pack(pop))
#line 20 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"









#pragma once




__pragma(pack(push, 8)) extern "C" {








    
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;
#line 30 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned);















__declspec(dllimport) wint_t __cdecl fgetwc(
      FILE* _Stream
    );


__declspec(dllimport) wint_t __cdecl _fgetwchar(void);


__declspec(dllimport) wint_t __cdecl fputwc(
         wchar_t _Character,
      FILE*   _Stream);


__declspec(dllimport) wint_t __cdecl _fputwchar(
      wchar_t _Character
    );

 
__declspec(dllimport) wint_t __cdecl getwc(
      FILE* _Stream
    );

 
__declspec(dllimport) wint_t __cdecl getwchar(void);



 
__declspec(dllimport) wchar_t* __cdecl fgetws(
      wchar_t* _Buffer,
                              int      _BufferCount,
                           FILE*    _Stream
    );


__declspec(dllimport) int __cdecl fputws(
       wchar_t const* _Buffer,
      FILE*          _Stream
    );


 
__declspec(dllimport) wchar_t* __cdecl _getws_s(
      wchar_t* _Buffer,
                              size_t   _BufferCount
    );

extern "C++" { template <size_t _Size> inline   wchar_t* __cdecl _getws_s(  wchar_t (&_Buffer)[_Size]) throw() { return _getws_s(_Buffer, _Size); } }
#line 99 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__declspec(dllimport) wint_t __cdecl putwc(
         wchar_t _Character,
      FILE*   _Stream
    );


__declspec(dllimport) wint_t __cdecl putwchar(
      wchar_t _Character
    );


__declspec(dllimport) int __cdecl _putws(
      wchar_t const* _Buffer
    );


__declspec(dllimport) wint_t __cdecl ungetwc(
         wint_t _Character,
      FILE*  _Stream
    );

 
__declspec(dllimport) FILE * __cdecl _wfdopen(
        int            _FileHandle,
      wchar_t const* _Mode
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) FILE* __cdecl _wfopen(
      wchar_t const* _FileName,
      wchar_t const* _Mode
    );


__declspec(dllimport) errno_t __cdecl _wfopen_s(
      FILE**         _Stream,
                         wchar_t const* _FileName,
                         wchar_t const* _Mode
    );

 
__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wfreopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) FILE* __cdecl _wfreopen(
       wchar_t const* _FileName,
       wchar_t const* _Mode,
      FILE*          _OldStream
    );


__declspec(dllimport) errno_t __cdecl _wfreopen_s(
      FILE**         _Stream,
                         wchar_t const* _FileName,
                         wchar_t const* _Mode,
                        FILE*          _OldStream
    );

 
__declspec(dllimport) FILE* __cdecl _wfsopen(
      wchar_t const* _FileName,
      wchar_t const* _Mode,
        int            _ShFlag
    );

__declspec(dllimport) void __cdecl _wperror(
      wchar_t const* _ErrorMessage
    );



     
    __declspec(dllimport) FILE* __cdecl _wpopen(
          wchar_t const* _Command,
          wchar_t const* _Mode
        );

#line 177 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__declspec(dllimport) int __cdecl _wremove(
      wchar_t const* _FileName
    );




 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(
      wchar_t const* _Directory,
      wchar_t const* _FilePrefix
    );



 

__declspec(dllimport) errno_t __cdecl _wtmpnam_s(
      wchar_t* _Buffer,
                              size_t   _BufferCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wtmpnam_s(_Buffer, _Size); } }
#line 204 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wtmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wtmpnam(  wchar_t *_Buffer);
#line 210 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"









__declspec(dllimport) wint_t __cdecl _fgetwc_nolock(
      FILE* _Stream
    );


__declspec(dllimport) wint_t __cdecl _fputwc_nolock(
         wchar_t _Character, 
      FILE*   _Stream
    );


__declspec(dllimport) wint_t __cdecl _getwc_nolock(
      FILE* _Stream
    );


__declspec(dllimport) wint_t __cdecl _putwc_nolock(
         wchar_t _Character,
      FILE*   _Stream
    );


__declspec(dllimport) wint_t __cdecl _ungetwc_nolock(
         wint_t _Character,
      FILE*  _Stream
    );





#line 251 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
















__declspec(dllimport) int __cdecl __stdio_common_vfwprintf(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );


__declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );


__declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );


__inline int __cdecl _vfwprintf_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 303 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 307 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl vfwprintf(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 317 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
}
#line 321 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vfwprintf_s_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 332 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 336 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl vfwprintf_s(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 348 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
#line 352 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 354 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vfwprintf_p_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 365 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 369 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vfwprintf_p(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 379 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
}
#line 383 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwprintf_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 393 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 397 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl vwprintf(
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 406 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}
#line 410 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwprintf_s_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 420 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 424 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl vwprintf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 435 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
#line 439 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 441 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwprintf_p_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 451 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 455 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwprintf_p(
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 464 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}
#line 468 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwprintf_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 478 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 487 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl fwprintf(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
    ...)


#line 496 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 505 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwprintf_s_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 515 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 524 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl fwprintf_s(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)


#line 535 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 544 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 546 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwprintf_p_l(
                                      FILE*          const _Stream,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 556 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 565 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwprintf_p(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
    ...)


#line 574 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 583 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wprintf_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 592 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 601 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl wprintf(
        wchar_t const* const _Format,
    ...)


#line 609 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 618 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wprintf_s_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 627 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 636 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl wprintf_s(
            wchar_t const* const _Format,
        ...)


#line 646 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 655 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 657 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wprintf_p_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 666 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 675 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wprintf_p(
        wchar_t const* const _Format,
    ...)


#line 683 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 692 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"








__declspec(dllimport) int __cdecl __stdio_common_vfwscanf(
                                        unsigned __int64 _Options,
                                     FILE*            _Stream,
        wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                           va_list          _ArgList
    );


__inline int __cdecl _vfwscanf_l(
      FILE*                                const _Stream,
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 718 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwscanf(
        (*__local_stdio_scanf_options ()),
        _Stream, _Format, _Locale, _ArgList);
}
#line 724 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl vfwscanf(
      FILE*                                const _Stream,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 734 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
}
#line 738 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vfwscanf_s_l(
                            FILE*          const _Stream,
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 749 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vfwscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Stream, _Format, _Locale, _ArgList);
}
#line 755 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl vfwscanf_s(
                                FILE*          const _Stream,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 767 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
#line 771 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 773 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__inline int __cdecl _vwscanf_l(
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 782 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}
#line 786 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl vwscanf(
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 795 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
}
#line 799 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _vwscanf_s_l(
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 809 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}
#line 813 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl vwscanf_s(
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 824 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
#line 828 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 830 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _fwscanf_l(
                                     FILE*          const _Stream,
        wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)


#line 840 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 849 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl fwscanf(
                           FILE*          const _Stream,
        wchar_t const* const _Format,
    ...)


#line 858 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 867 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _fwscanf_s_l(
                                       FILE*          const _Stream,
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 877 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 886 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl fwscanf_s(
                                 FILE*          const _Stream,
            wchar_t const* const _Format,
        ...)


#line 897 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 906 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 908 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _wscanf_l(
        wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)


#line 917 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 926 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl wscanf(
        wchar_t const* const _Format,
    ...)


#line 934 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 943 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"


__inline int __cdecl _wscanf_s_l(
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 952 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 961 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    
    __inline int __cdecl wscanf_s(
            wchar_t const* const _Format,
        ...)


#line 971 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 980 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 982 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"









    





#line 998 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__declspec(dllimport) int __cdecl __stdio_common_vswprintf(
                                         unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                         size_t           _BufferCount,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 

__declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(
                                         unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                         size_t           _BufferCount,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 

__declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(
                                         unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                         size_t           _BufferCount,
                                         size_t           _MaxCount,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 

__declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(
                                         unsigned __int64 _Options,
                 wchar_t*         _Buffer,
                                         size_t           _BufferCount,
        wchar_t const*   _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnwprintf_l(
           wchar_t*       const _Buffer,
                                             size_t         const _BufferCount,
            wchar_t const* const _Format,
                                         _locale_t      const _Locale,
                                                va_list              _ArgList
    )


#line 1056 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1064 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)
#pragma warning(disable: 4793)

 

__inline int __cdecl _vsnwprintf_s_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
                                         size_t         const _MaxCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1081 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vsnwprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1089 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vsnwprintf_s(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
                               size_t         const _MaxCount,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1102 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
}
#line 1106 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _snwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vsnwprintf(    wchar_t *_Buffer,   size_t _BufferCount,     wchar_t const* _Format, va_list _Args);
#line 1115 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(pop)

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnwprintf(
        wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                   wchar_t const* _Format,
                                             va_list        _ArgList
    )


#line 1129 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)
}
#line 1136 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { template <size_t _Size> inline   int __cdecl _vsnwprintf_s(  wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, va_list _ArgList) throw() { return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1145 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_c_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1158 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1166 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_c(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1178 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1182 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_l(
                         wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1195 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)
}
#line 1202 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl __vswprintf_l(
                         wchar_t*       const _Buffer,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1214 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 1218 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf(
               wchar_t*       const _Buffer,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1229 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
}
#line 1233 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl vswprintf(
                         wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                            va_list              _ArgList
    )


#line 1245 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1249 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_s_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1262 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



     
    __inline int __cdecl vswprintf_s(
           wchar_t*       const _Buffer,
                                   size_t         const _BufferCount,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 1283 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
#line 1287 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 1289 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { template <size_t _Size> inline   int __cdecl vswprintf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _ArgList) throw() { return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1297 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_p_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1310 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf_p(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1318 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswprintf_p(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1330 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1334 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _vscwprintf_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1345 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1353 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _vscwprintf(
        wchar_t const* const _Format,
                                  va_list              _ArgList
    )


#line 1363 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vscwprintf_l(_Format, 0, _ArgList);
}
#line 1367 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _vscwprintf_p_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
                                            va_list              _ArgList
    )


#line 1378 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int const _Result = __stdio_common_vswprintf_p(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1386 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _vscwprintf_p(
        wchar_t const* const _Format, 
                                  va_list              _ArgList
    )


#line 1396 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vscwprintf_p_l(_Format, 0, _ArgList);
}
#line 1400 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl __swprintf_l(
                         wchar_t*       const _Buffer,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1411 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1420 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_l(
                         wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1432 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1441 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf(
               wchar_t*       const _Buffer,
        wchar_t const* const _Format,
    ...)


#line 1451 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1460 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl swprintf(
               wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
    ...)


#line 1471 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1480 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(push)


#pragma warning(disable:4793 4996)

__declspec(deprecated("This function or variable may be unsafe. Consider using " "__swprintf_l_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __swprintf_l(    wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl __vswprintf_l(    wchar_t *_Buffer,     wchar_t const* _Format,   _locale_t _Locale, va_list _Args);
#line 1494 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _swprintf(    wchar_t *_Buffer,     wchar_t const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __inline   int __cdecl _vswprintf(    wchar_t *_Buffer,     wchar_t const* _Format, va_list _Args);
#line 1501 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#pragma warning(pop)

 

__inline int __cdecl _swprintf_s_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1515 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1524 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



     
    __inline int __cdecl swprintf_s(
           wchar_t*       const _Buffer,
                                   size_t         const _BufferCount,
            wchar_t const* const _Format,
        ...)


#line 1536 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 1545 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 1547 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl swprintf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vswprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1554 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_p_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1566 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1575 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_p(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
    ...)


#line 1586 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1595 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_c_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1607 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1616 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swprintf_c(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
        wchar_t const* const _Format,
    ...)


#line 1627 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1636 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snwprintf_l(
        wchar_t*       const _Buffer,
                                          size_t         const _BufferCount,
         wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 1648 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1662 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwprintf(
        wchar_t*       _Buffer,
                                          size_t         _BufferCount,
                   wchar_t const* _Format,
    ...)


#line 1673 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1687 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwprintf_s_l(
                 wchar_t*       const _Buffer,
                                         size_t         const _BufferCount,
                                         size_t         const _MaxCount,
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1700 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1709 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwprintf_s(
       wchar_t*       const _Buffer,
                               size_t         const _BufferCount,
                               size_t         const _MaxCount,
        wchar_t const* const _Format,
    ...)


#line 1721 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1730 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snwprintf_s(  wchar_t (&_Buffer)[_Size],   size_t _BufferCount,     wchar_t const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1738 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
__inline int __cdecl _scwprintf_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1747 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1756 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _scwprintf(
        wchar_t const* const _Format,
    ...)


#line 1765 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1774 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _scwprintf_p_l(
        wchar_t const* const _Format,
                                     _locale_t      const _Locale,
    ...)


#line 1784 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1793 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 
__inline int __cdecl _scwprintf_p(
        wchar_t const* const _Format,
    ...)


#line 1802 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1811 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



    #pragma warning(push)
    #pragma warning(disable: 4141 4412 4793 4996 6054)

    

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "swprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int swprintf(
                       wchar_t*       const _Buffer,
                wchar_t const* const _Format,
            ...) throw()
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            #pragma warning(suppress: 28719)
            _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);       
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "vswprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int __cdecl vswprintf(
                       wchar_t*       const _Buffer,
                wchar_t const* const _Format,
                                          va_list              _ArgList
            ) throw()
        {
            #pragma warning(suppress: 28719)
            return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int _swprintf_l(
                                 wchar_t*       const _Buffer,
                wchar_t const* const _Format,
                                             _locale_t      const _Locale,
            ...) throw()
        {
            int _Result;
            va_list _ArgList;
            ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
            _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
            ((void)(_ArgList = (va_list)0));
            return _Result;
        }

        extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vswprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        inline int __cdecl _vswprintf_l(
                                 wchar_t*       const _Buffer,
                wchar_t const* const _Format,
                                             _locale_t      const _Locale,
                                                    va_list              _ArgList
            ) throw()
        {
            return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        }

    #line 1872 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

    #pragma warning(pop)
#line 1875 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"






#line 1882 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"







 
__declspec(dllimport) int __cdecl __stdio_common_vswscanf(
                                        unsigned __int64 _Options,
              wchar_t const*   _Buffer,
                                        size_t           _BufferCount,
        wchar_t const*   _Format,
                                    _locale_t        _Locale,
                                           va_list          _ArgList
    );

 

__inline int __cdecl _vswscanf_l(
                             wchar_t const* const _Buffer,
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 1910 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 1916 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl vswscanf(
                             wchar_t const* _Buffer,
        wchar_t const* _Format,
                                  va_list        _ArgList
    )


#line 1927 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
}
#line 1931 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vswscanf_s_l(
                             wchar_t const* const _Buffer,
        wchar_t const* const _Format,
                           _locale_t      const _Locale,
                                  va_list              _ArgList
    )


#line 1943 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 1949 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



     
    
    __inline int __cdecl vswscanf_s(
                                 wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                      va_list              _ArgList
        )


#line 1962 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
#line 1966 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 1968 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

extern "C++" { template <size_t _Size> inline   int __cdecl vswscanf_s(  wchar_t (&_Buffer)[_Size],     wchar_t const* _Format, va_list _Args) throw() { return vswscanf_s(_Buffer, _Size, _Format, _Args); } }
#line 1976 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnwscanf_l(
              wchar_t const* const _Buffer,
                                        size_t         const _BufferCount,
        wchar_t const* const _Format,
                                    _locale_t      const _Locale,
                                           va_list              _ArgList
    )


#line 1989 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
#line 1995 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _vsnwscanf_s_l(
                wchar_t const* const _Buffer,
                                          size_t         const _BufferCount,
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
                                             va_list              _ArgList
    )


#line 2008 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    return __stdio_common_vswscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);
}
#line 2014 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_swscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _swscanf_l(
                                      wchar_t const* const _Buffer,
        wchar_t const* const _Format,
                                    _locale_t            _Locale,
    ...)


#line 2025 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2034 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "swscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl swscanf(
                            wchar_t const* const _Buffer,
        wchar_t const* const _Format,
    ...)


#line 2044 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2053 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _swscanf_s_l(
                                        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 2064 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2073 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"



     
    
    __inline int __cdecl swscanf_s(
                                  wchar_t const* const _Buffer,
            wchar_t const* const _Format,
        ...)


#line 2085 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);  
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 2094 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

#line 2096 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snwscanf_l(
              wchar_t const* const _Buffer,
                                        size_t         const _BufferCount,
        wchar_t const* const _Format,
                                    _locale_t      const _Locale,
    ...)


#line 2108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2122 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snwscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snwscanf(
        wchar_t const* const _Buffer,
                                  size_t         const _BufferCount,
            wchar_t const* const _Format,
    ...)


#line 2133 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2147 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwscanf_s_l(
                wchar_t const* const _Buffer,
                                          size_t         const _BufferCount,
        wchar_t const* const _Format,
                                      _locale_t      const _Locale,
    ...)


#line 2159 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2168 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"

 

__inline int __cdecl _snwscanf_s(
         wchar_t const* const _Buffer,
                                   size_t         const _BufferCount,
           wchar_t const* const _Format,
    ...)


#line 2179 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2188 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstdio.h"







} __pragma(pack(pop))

#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"








#pragma once






__pragma(pack(push, 8)) extern "C" {










    
    __declspec(dllimport) errno_t __cdecl wcscat_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl wcscpy_s(
          wchar_t* _Destination,
          rsize_t _SizeInWords,
          wchar_t const* _Source
        );
    
    
    __declspec(dllimport) errno_t __cdecl wcsncat_s(
          wchar_t*       _Destination,
                                     rsize_t        _SizeInWords,
               wchar_t const* _Source,
                                     rsize_t        _MaxCount
        );
    
    
    __declspec(dllimport) errno_t __cdecl wcsncpy_s(
          wchar_t*       _Destination,
                                  rsize_t        _SizeInWords,
            wchar_t const* _Source,
                                  rsize_t        _MaxCount
        );
    
     
    __declspec(dllimport) wchar_t* __cdecl wcstok_s(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
            wchar_t**      _Context
        );

#line 65 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"











#line 77 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(
      wchar_t const* _String
    );



#line 86 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"



extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscat_s(_Destination, _Size, _Source); } }
#line 94 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"



    __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscat( wchar_t *_Destination,  wchar_t const* _Source);
#line 102 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

#line 104 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcscmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source) throw() { return wcscpy_s(_Destination, _Size, _Source); } }
#line 116 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcscpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcscpy( wchar_t *_Destination,  wchar_t const* _Source);
#line 122 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) size_t __cdecl wcscspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcslen(
      wchar_t const* _String
    );

 

#line 139 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

#line 143 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
__declspec(dllimport) size_t __cdecl wcsnlen(
      wchar_t const* _Source,
                            size_t         _MaxCount
    );



     
    
#line 155 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
    
#line 159 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
    static __inline size_t __cdecl wcsnlen_s(
          wchar_t const* _Source,
                                size_t         _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

#line 168 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncat_s(  wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncat_s(_Destination, _Size, _Source, _Count); } }
#line 175 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncat(  wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 183 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) int __cdecl wcsncmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size],   wchar_t const* _Source,   size_t _Count) throw() { return wcsncpy_s(_Destination, _Size, _Source, _Count); } }
#line 197 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsncpy(    wchar_t *_Destination,   wchar_t const* _Source,   size_t _Count);
#line 205 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
__declspec(dllimport) wchar_t const* __cdecl wcspbrk(
      wchar_t const* _String,
      wchar_t const* _Control
    );

 
__declspec(dllimport) size_t __cdecl wcsspn(
      wchar_t const* _String,
      wchar_t const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl wcstok(
                          wchar_t*       _String,
                                 wchar_t const* _Delimiter,
        wchar_t**      _Context
    );



    

#line 230 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
        



    #line 235 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(push)
    #pragma warning(disable: 4141 4996) 

      __declspec(deprecated("This function or variable may be unsafe. Consider using " "wcstok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
    static __inline wchar_t* __cdecl _wcstok(
          wchar_t*       const _String,
                 wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }

    

#line 251 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

    
        extern "C++"   __declspec(deprecated("wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK.")) 
        inline wchar_t* __cdecl wcstok(
              wchar_t*       _String,
                     wchar_t const* _Delimiter
            ) throw()
        {
            return wcstok(_String, _Delimiter, 0);
        }
    #line 262 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

    #pragma warning(pop)

#line 266 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"



 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wcserror(
      int _ErrorNumber
    );


__declspec(dllimport) errno_t __cdecl _wcserror_s(
      wchar_t* _Buffer,
                                  size_t   _SizeInWords,
                                  int      _ErrorNumber
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size],   int _Error) throw() { return _wcserror_s(_Buffer, _Size, _Error); } }
#line 287 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "__wcserror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl __wcserror(
      wchar_t const* _String
    );

 __declspec(dllimport) errno_t __cdecl __wcserror_s(
      wchar_t*       _Buffer,
                                  size_t         _SizeInWords,
                                wchar_t const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size],   wchar_t const* _ErrorMessage) throw() { return __wcserror_s(_Buffer, _Size, _ErrorMessage); } }
#line 306 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

  __declspec(dllimport) int __cdecl _wcsicmp(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

  __declspec(dllimport) int __cdecl _wcsicmp_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

  __declspec(dllimport) int __cdecl _wcsnicmp(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

  __declspec(dllimport) int __cdecl _wcsnicmp_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 __declspec(dllimport) errno_t __cdecl _wcsnset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value,
                                 size_t   _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsnset_s(  wchar_t (&_Destination)[_Size],   wchar_t _Value,   size_t _MaxCount) throw() { return _wcsnset_s(_Destination, _Size, _Value, _MaxCount); } }
#line 344 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsnset(  wchar_t *_String,   wchar_t _Value,   size_t _MaxCount);
#line 352 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(dllimport) wchar_t* __cdecl _wcsrev(
      wchar_t* _String
    );

 __declspec(dllimport) errno_t __cdecl _wcsset_s(
      wchar_t* _Destination,
                                 size_t   _SizeInWords,
                                 wchar_t  _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsset_s(  wchar_t (&_String)[_Size],   wchar_t _Value) throw() { return _wcsset_s(_String, _Size, _Value); } }
#line 368 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsset(  wchar_t *_String,   wchar_t _Value);
#line 375 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 __declspec(dllimport) errno_t __cdecl _wcslwr_s(
      wchar_t* _String,
                                 size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s(  wchar_t (&_String)[_Size]) throw() { return _wcslwr_s(_String, _Size); } }
#line 385 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr( wchar_t *_String);
#line 390 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcslwr_s_l(
      wchar_t*  _String,
                                 size_t    _SizeInWords,
                             _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcslwr_s_l(_String, _Size, _Locale); } }
#line 403 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcslwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr_l(  wchar_t *_String,   _locale_t _Locale);
#line 410 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s(
      wchar_t* _String,
                          size_t   _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s(  wchar_t (&_String)[_Size]) throw() { return _wcsupr_s(_String, _Size); } }
#line 421 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr( wchar_t *_String);
#line 426 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"


__declspec(dllimport) errno_t __cdecl _wcsupr_s_l(
      wchar_t*  _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(  wchar_t (&_String)[_Size],   _locale_t _Locale) throw() { return _wcsupr_s_l(_String, _Size, _Locale); } }
#line 439 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wcsupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr_l(  wchar_t *_String,   _locale_t _Locale);
#line 446 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

 

__declspec(dllimport) size_t __cdecl wcsxfrm(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _wcsxfrm_l(
        wchar_t*       _Destination,
                                         wchar_t const* _Source,
                size_t         _MaxCount,
                                       _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl wcscoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcscoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsicoll(
      wchar_t const* _String1,
      wchar_t const* _String2
    );

 
__declspec(dllimport) int __cdecl _wcsicoll_l(
        wchar_t const* _String1,
        wchar_t const* _String2,
      _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsncoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsncoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount
    );

 
__declspec(dllimport) int __cdecl _wcsnicoll_l(
      wchar_t const* _String1,
      wchar_t const* _String2,
                            size_t         _MaxCount,
                        _locale_t      _Locale
    );









extern "C++" {

     
    
    inline wchar_t* __cdecl wcschr(  wchar_t* _String, wchar_t _C)
    {
        return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
    }

     
    inline wchar_t* __cdecl wcspbrk(  wchar_t* _String,   wchar_t const* _Control)
    {
        return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
    }

     
    inline wchar_t* __cdecl wcsrchr(  wchar_t* _String,   wchar_t _C)
    {
        return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
    }

       
    
    inline wchar_t* __cdecl wcsstr(  wchar_t* _String,   wchar_t const*_SubStr)
    {
        return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
    }

}
#line 558 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"









    


#line 571 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsdup" ". See online help for details."))
    __declspec(dllimport) wchar_t* __cdecl wcsdup(
          wchar_t const* _String
        );

    

#line 580 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"

    
    

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicmp(
          wchar_t const* _String1,
          wchar_t const* _String2
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsnicmp(
          wchar_t const* _String1,
          wchar_t const* _String2,
                                size_t         _MaxCount
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsnset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsnset(
          wchar_t* _String,
                                  wchar_t  _Value,
                                  size_t   _MaxCount
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsrev" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsrev(
          wchar_t* _String
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsset" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsset(
          wchar_t* _String,
               wchar_t  _Value
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcslwr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcslwr(
          wchar_t* _String
        );
    
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsupr" ". See online help for details."))
     
    __declspec(dllimport) wchar_t* __cdecl wcsupr(
          wchar_t* _String
        );
    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_wcsicoll" ". See online help for details."))
    __declspec(dllimport) int __cdecl wcsicoll(
          wchar_t const* _String1,
          wchar_t const* _String2
        );

#line 637 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"



} __pragma(pack(pop))

#line 643 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wstring.h"
#line 23 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"








#pragma once



__pragma(pack(push, 8)) extern "C" {








struct tm
{
    int tm_sec;   
    int tm_min;   
    int tm_hour;  
    int tm_mday;  
    int tm_mon;   
    int tm_year;  
    int tm_wday;  
    int tm_yday;  
    int tm_isdst; 
};







  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wasctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
 
 
__declspec(dllimport) wchar_t* __cdecl _wasctime(
      struct tm const* _Tm
    );

 

__declspec(dllimport) errno_t __cdecl _wasctime_s(
        wchar_t*         _Buffer,
                                          size_t           _SizeInWords,
                                                       struct tm const* _Tm
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl _wasctime_s(  wchar_t (&_Buffer)[_Size],   struct tm const* _Time) throw() { return _wasctime_s(_Buffer, _Size, _Time); } }
#line 62 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

 

__declspec(dllimport) size_t __cdecl wcsftime(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _wcsftime_l(
       wchar_t*         _Buffer,
                               size_t           _SizeInWords,
                             wchar_t const*   _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime32_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime32_s(  wchar_t (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _wctime32_s(_Buffer, _Size, _Time); } }
#line 100 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_wctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) wchar_t* __cdecl _wctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _wctime64_s(
        wchar_t*          _Buffer,
                                      size_t            _SizeInWords,
                                                       __time64_t const* _Time);

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wctime64_s(  wchar_t (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _wctime64_s(_Buffer, _Size, _Time); } }
#line 119 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrdate_s(
        wchar_t* _Buffer,
                                      size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrdate_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrdate_s(_Buffer, _Size); } }
#line 130 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrdate( wchar_t *_Buffer);
#line 135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"


__declspec(dllimport) errno_t __cdecl _wstrtime_s(
        wchar_t* _Buffer,
                                      size_t   _SizeInWords
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _wstrtime_s(  wchar_t (&_Buffer)[_Size]) throw() { return _wstrtime_s(_Buffer, _Size); } }
#line 146 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_wstrtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  wchar_t* __cdecl _wstrtime( wchar_t *_Buffer);
#line 151 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"









    #pragma warning(push)
    #pragma warning(disable: 4996)

    




















         
        static __inline wchar_t * __cdecl _wctime(
              time_t const* const _Time)
        {
            return _wctime64(_Time);
        }

        
        static __inline errno_t __cdecl _wctime_s(
                  wchar_t*      const _Buffer,
                                                             size_t        const _SizeInWords,
                                                             time_t const* const _Time
            )
        {
            return _wctime64_s(_Buffer, _SizeInWords, _Time);
        }

    #line 202 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"

    #pragma warning(pop)
#line 205 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_wtime.h"



} __pragma(pack(pop))
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"







#pragma once




    

    typedef unsigned short _ino_t; 

    
        typedef _ino_t ino_t;
    #line 20 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"
#line 21 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"




    

    typedef unsigned int _dev_t; 

    
        typedef _dev_t dev_t;
    #line 32 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"
#line 33 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"




    

    typedef long _off_t; 

    
        typedef _off_t off_t;
    #line 44 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"
#line 45 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\types.h"
#line 12 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"

__pragma(pack(push, 8)) extern "C" {



#pragma warning(push)
#pragma warning(disable:4820) 
#line 20 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"







struct _stat32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat32i64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time32_t     st_atime;
    __time32_t     st_mtime;
    __time32_t     st_ctime;
};

struct _stat64i32
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    _off_t         st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};

struct _stat64
{
    _dev_t         st_dev;
    _ino_t         st_ino;
    unsigned short st_mode;
    short          st_nlink;
    short          st_uid;
    short          st_gid;
    _dev_t         st_rdev;
    __int64        st_size;
    __time64_t     st_atime;
    __time64_t     st_mtime;
    __time64_t     st_ctime;
};




    struct stat
    {
        _dev_t         st_dev;
        _ino_t         st_ino;
        unsigned short st_mode;
        short          st_nlink;
        short          st_uid;
        short          st_gid;
        _dev_t         st_rdev;
        _off_t         st_size;
        time_t         st_atime;
        time_t         st_mtime;
        time_t         st_ctime;
    };
#line 105 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"


















    
    
    
    
    
    
    
#line 131 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"
















    
    
    
    
    
    
#line 154 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"



__declspec(dllimport) int __cdecl _fstat32(
       int             _FileHandle,
      struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat32i64(
       int                _FileHandle,
      struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64i32(
       int                _FileHandle,
      struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _fstat64(
       int             _FileHandle,
      struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _stat32(
      char const*     _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _stat32i64(
      char const*        _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _stat64i32(
      char const*        _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _stat64(
      char const*     _FileName,
       struct _stat64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32(
      wchar_t const*  _FileName,
       struct _stat32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat32i64(
      wchar_t const*     _FileName,
       struct _stat32i64* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64i32(
      wchar_t const*     _FileName,
       struct _stat64i32* _Stat
    );

__declspec(dllimport) int __cdecl _wstat64(
      wchar_t const*  _FileName,
       struct _stat64* _Stat
    );




    















        static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
        }
        static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
        {
            typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
            return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
        }

    #line 248 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"
#line 249 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"



#pragma warning(pop)
#line 254 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\sys\\stat.h"


} __pragma(pack(pop))
#line 25 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"



__pragma(pack(push, 8)) extern "C" {








typedef wchar_t _Wint_t;




__declspec(dllimport) wchar_t* __cdecl _wsetlocale(
            int            _Category,
      wchar_t const* _Locale
    );


__declspec(dllimport) _locale_t __cdecl _wcreate_locale(
        int            _Category,
      wchar_t const* _Locale
    );



__declspec(dllimport) wint_t __cdecl btowc(
      int _Ch
    );

__declspec(dllimport) size_t __cdecl mbrlen(
        char const* _Ch,
                                                size_t      _SizeInBytes,
                                             mbstate_t*  _State
    );

__declspec(dllimport) size_t __cdecl mbrtowc(
                              wchar_t*    _DstCh,
        char const* _SrcCh,
                                                size_t      _SizeInBytes,
                                             mbstate_t*  _State
    );

 
__declspec(dllimport) errno_t __cdecl mbsrtowcs_s(
                              size_t*      _Retval,
              wchar_t*     _Dst,
                                   size_t       _Size,
                      char const** _PSrc,
                                   size_t       _N,
                                mbstate_t*   _State
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl mbsrtowcs_s(  size_t* _Retval,   wchar_t (&_Dest)[_Size],     char const** _PSource,   size_t _Count,   mbstate_t* _State) throw() { return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State); } }
#line 91 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "mbsrtowcs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  __declspec(dllimport) size_t __cdecl mbsrtowcs( wchar_t *_Dest,  char const** _PSrc,  size_t _Count,  mbstate_t* _State);
#line 99 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

 
__declspec(dllimport) errno_t __cdecl wcrtomb_s(
                             size_t*    _Retval,
      char*      _Dst,
                                  size_t     _SizeInBytes,
                                  wchar_t    _Ch,
                           mbstate_t* _State
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcrtomb_s(  size_t* _Retval,   char (&_Dest)[_Size],   wchar_t _Source,   mbstate_t* _State) throw() { return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State); } }
#line 117 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcrtomb_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcrtomb(  char *_Dest,  wchar_t _Source,  mbstate_t* _State);
#line 124 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

 
__declspec(dllimport) errno_t __cdecl wcsrtombs_s(
                                              size_t*         _Retval,
      char*           _Dst,
                                                   size_t          _SizeInBytes,
                                wchar_t const** _Src,
                                                   size_t          _Size,
                                            mbstate_t*      _State
    );

extern "C++" { template <size_t _Size> inline   errno_t __cdecl wcsrtombs_s(  size_t* _Retval,   char (&_Dest)[_Size],     wchar_t const** _PSrc,   size_t _Count,   mbstate_t* _State) throw() { return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State); } }
#line 144 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "wcsrtombs_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) size_t __cdecl wcsrtombs(  char *_Dest,  wchar_t const** _PSource,  size_t _Count,  mbstate_t* _State);
#line 152 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

__declspec(dllimport) int __cdecl wctob(
      wint_t _WCh
    );





    

         
        errno_t __cdecl wmemcpy_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

         
        errno_t __cdecl wmemmove_s(
              wchar_t*       _S1,
                                      rsize_t        _N1,
                        wchar_t const* _S2,
                                      rsize_t        _N
            );

    #line 180 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

    __inline int __cdecl fwide(
          FILE* _F,
              int   _M
        )
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(
          mbstate_t const* _P
        )
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(
          wchar_t const* _S,
                    wchar_t        _C,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S, --_N)
            if (*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(
          wchar_t const* _S1,
          wchar_t const* _S2,
                    size_t         _N
        )
    {
        for (; 0 < _N; ++_S1, ++_S2, --_N)
            if (*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

     
    
    __inline 
    wchar_t* __cdecl wmemcpy(
          wchar_t*       _S1,
                wchar_t const* _S2,
                          size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

    __inline 
    wchar_t* __cdecl wmemmove(
          wchar_t*       _S1,
                wchar_t const* _S2,
                              size_t         _N
        )
    {
        #pragma warning(push)
        #pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N*sizeof(wchar_t));
        #pragma warning(pop)
    }

     
    
    __inline wchar_t* __cdecl wmemset(
          wchar_t* _S,
                          wchar_t  _C,
                          size_t   _N
        )
    {
        wchar_t *_Su = _S;
        for (; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    

        extern "C++" inline wchar_t* __cdecl wmemchr(
              wchar_t* _S,
                        wchar_t  _C,
                        size_t   _N
            )
        {
            wchar_t const* const _SC = _S;
            return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
        }

    #line 280 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"

#line 282 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\wchar.h"



} __pragma(pack(pop))
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"

typedef mbstate_t _Mbstatet;

 
namespace std {
using :: _Mbstatet;

using :: mbstate_t; using :: size_t; using :: tm; using :: wint_t;

using :: btowc; using :: fgetwc; using :: fgetws; using :: fputwc;
using :: fputws; using :: fwide; using :: fwprintf;
using :: fwscanf; using :: getwc; using :: getwchar;
using :: mbrlen; using :: mbrtowc; using :: mbsrtowcs;
using :: mbsinit; using :: putwc; using :: putwchar;
using :: swprintf; using :: swscanf; using :: ungetwc;
using :: vfwprintf; using :: vswprintf; using :: vwprintf;
using :: wcrtomb; using :: wprintf; using :: wscanf;
using :: wcsrtombs; using :: wcstol; using :: wcscat;
using :: wcschr; using :: wcscmp; using :: wcscoll;
using :: wcscpy; using :: wcscspn; using :: wcslen;
using :: wcsncat; using :: wcsncmp; using :: wcsncpy;
using :: wcspbrk; using :: wcsrchr; using :: wcsspn;
using :: wcstod; using :: wcstoul; using :: wcsstr;
using :: wcstok; using :: wcsxfrm; using :: wctob;
using :: wmemchr; using :: wmemcmp; using :: wmemcpy;
using :: wmemmove; using :: wmemset; using :: wcsftime;

using :: vfwscanf; using :: vswscanf; using :: vwscanf;
using :: wcstof; using :: wcstold;
using :: wcstoll; using :: wcstoull;
}
 #line 47 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"

#line 49 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cwchar"





#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"

#pragma once










 
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"

 
namespace std {
using :: ptrdiff_t; using :: size_t;
}
 #line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"

 
namespace std {
typedef double max_align_t;	
}

using ::std:: max_align_t;	
 #line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"
#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstddef"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\initializer_list"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
template<class _Elem>
	class initializer_list
	{	
public:
	typedef _Elem value_type;
	typedef const _Elem& reference;
	typedef const _Elem& const_reference;
	typedef size_t size_type;

	typedef const _Elem* iterator;
	typedef const _Elem* const_iterator;

	constexpr initializer_list() noexcept
		: _First(0), _Last(0)
		{	
		}

	constexpr initializer_list(const _Elem *_First_arg,
		const _Elem *_Last_arg) noexcept
		: _First(_First_arg), _Last(_Last_arg)
		{	
		}

	constexpr const _Elem *begin() const noexcept
		{	
		return (_First);
		}

	constexpr const _Elem *end() const noexcept
		{	
		return (_Last);
		}

	constexpr size_t size() const noexcept
		{	
		return ((size_t)(_Last - _First));
		}

private:
	const _Elem *_First;
	const _Elem *_Last;
	};

		
template<class _Elem> inline
	constexpr const _Elem *begin(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.begin());
	}

		
template<class _Elem> inline
	constexpr const _Elem *end(initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.end());
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 76 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\initializer_list"
#line 77 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\initializer_list"





#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 
  
  
  
 #line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

namespace std {
		
 
 
 #line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 
 
 
 
 

 
 

  

  











#line 55 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"
   
   
  #line 58 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 



















#line 80 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

		


		
 

 



































 
 

		

template<bool,
	class _Ty1,
	class _Ty2>
	struct _If
	{	
	typedef _Ty2 type;
	};

template<class _Ty1,
	class _Ty2>
	struct _If<true, _Ty1, _Ty2>
	{	
	typedef _Ty1 type;
	};

template<class _Ty>
	struct _Always_false
	{	
	static constexpr bool value = false;
	};

		

 
		
template<class _Arg,
	class _Result>
	struct unary_function
	{	
	typedef _Arg argument_type;
	typedef _Result result_type;
	};

		
template<class _Arg1,
	class _Arg2,
	class _Result>
	struct binary_function
	{	
	typedef _Arg1 first_argument_type;
	typedef _Arg2 second_argument_type;
	typedef _Result result_type;
	};
 #line 172 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

		
template<class _Ty = void>
	struct plus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left + _Right);
		}
	};

		
template<class _Ty = void>
	struct minus
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left - _Right);
		}
	};

		
template<class _Ty = void>
	struct multiplies
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef _Ty result_type;

	constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left * _Right);
		}
	};

		
template<class _Ty = void>
	struct equal_to
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left == _Right);
		}
	};

		
template<class _Ty = void>
	struct less
	{	
	typedef _Ty first_argument_type;
	typedef _Ty second_argument_type;
	typedef bool result_type;

	constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
		{	
		return (_Left < _Right);
		}
	};

		
template<>
	struct plus<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			+ static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct minus<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			- static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct multiplies<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			* static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct equal_to<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			== static_cast<_Ty2&&>(_Right));
		}
	};

		
template<>
	struct less<void>
	{	
	typedef int is_transparent;

	template<class _Ty1,
		class _Ty2>
		constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
		-> decltype(static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right))
		{	
		return (static_cast<_Ty1&&>(_Left)
			< static_cast<_Ty2&&>(_Right));
		}
	};


}



namespace std {
	
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count)
	{	
 




#line 343 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"
	static_assert(sizeof(size_t) == 4, "This code is for 32-bit size_t.");
	const size_t _FNV_offset_basis = 2166136261U;
	const size_t _FNV_prime = 16777619U;
 #line 347 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

	size_t _Val = _FNV_offset_basis;
	for (size_t _Next = 0; _Next < _Count; ++_Next)
		{	
		_Val ^= (size_t)_First[_Next];
		_Val *= _FNV_prime;
		}
	return (_Val);
	}

	
template<class _Kty>
	struct _Bitwise_hash
	{	
	typedef _Kty argument_type;
	typedef size_t result_type;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)&_Keyval, sizeof (_Kty)));
		}
	};

	
template<class _Kty>
	struct hash
		: public _Bitwise_hash<_Kty>
	{	
	static constexpr bool _Value = __is_enum(_Kty);
	static_assert(_Value,
		"The C++ Standard doesn't provide a hash for this type.");
	};
template<>
	struct hash<bool>
		: public _Bitwise_hash<bool>
	{	
	};

template<>
	struct hash<char>
		: public _Bitwise_hash<char>
	{	
	};

template<>
	struct hash<signed char>
		: public _Bitwise_hash<signed char>
	{	
	};

template<>
	struct hash<unsigned char>
		: public _Bitwise_hash<unsigned char>
	{	
	};

template<>
	struct hash<char16_t>
		: public _Bitwise_hash<char16_t>
	{	
	};

template<>
	struct hash<char32_t>
		: public _Bitwise_hash<char32_t>
	{	
	};

 
template<>
	struct hash<wchar_t>
		: public _Bitwise_hash<wchar_t>
	{	
	};
 #line 422 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

template<>
	struct hash<short>
		: public _Bitwise_hash<short>
	{	
	};

template<>
	struct hash<unsigned short>
		: public _Bitwise_hash<unsigned short>
	{	
	};

template<>
	struct hash<int>
		: public _Bitwise_hash<int>
	{	
	};

template<>
	struct hash<unsigned int>
		: public _Bitwise_hash<unsigned int>
	{	
	};

template<>
	struct hash<long>
		: public _Bitwise_hash<long>
	{	
	};

template<>
	struct hash<unsigned long>
		: public _Bitwise_hash<unsigned long>
	{	
	};

template<>
	struct hash<long long>
		: public _Bitwise_hash<long long>
	{	
	};

template<>
	struct hash<unsigned long long>
		: public _Bitwise_hash<unsigned long long>
	{	
	};

template<>
	struct hash<float>
		: public _Bitwise_hash<float>
	{	
	typedef float _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<double>
		: public _Bitwise_hash<double>
	{	
	typedef double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<>
	struct hash<long double>
		: public _Bitwise_hash<long double>
	{	
	typedef long double _Kty;
	typedef _Bitwise_hash<_Kty> _Mybase;

	size_t operator()(const _Kty& _Keyval) const
		{	
		return (_Mybase::operator()(
			_Keyval == 0 ? 0 : _Keyval));	
		}
	};

template<class _Ty>
	struct hash<_Ty *>
		: public _Bitwise_hash<_Ty *>
	{	
	};
}
#line 520 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


namespace std {
namespace tr1 {	
using ::std:: hash;
}	
}
#line 528 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"




 





 #line 539 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 



 

#line 547 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 





 


#line 558 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

 



 

#line 567 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


































































namespace std {
	
template<class... _Types>
	struct _Arg_types
	{	
	};

template<class _Ty1>
	struct _Arg_types<_Ty1>
	{	
	typedef _Ty1 argument_type;
	};

template<class _Ty1,
	class _Ty2>
	struct _Arg_types<_Ty1, _Ty2>
	{	
	typedef _Ty1 first_argument_type;
	typedef _Ty2 second_argument_type;
	};

	
template<class _Ty>
	struct _Is_function
	{	
	typedef false_type _Bool_type;
	static constexpr bool _Weird = false;
	};












template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) > : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile &> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __cdecl (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };  template<class _Ret, class... _Types> struct _Is_function<_Ret __fastcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __stdcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret __vectorcall (_Types...) const volatile &&> : _Arg_types<_Types...> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };












template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = false; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; }; template<class _Ret, class... _Types> struct _Is_function<_Ret (_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; static constexpr bool _Weird = true; };


template<class _Ty>
	struct is_function
		: _Is_function<_Ty>::_Bool_type
	{	
	};

 
template<class _Ty>
	constexpr bool is_function_v = is_function<_Ty>::value;
 #line 699 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"

		





















template<class _Ty> inline
	constexpr _Ty *addressof(_Ty& _Val) noexcept
	{	
	return (__builtin_addressof(_Val));
	}
#line 728 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"


		
template<class _Ptrty> inline
	auto _Unfancy(_Ptrty _Ptr)
	{	
	return (::std:: addressof(*_Ptr));
	}

template<class _Ty> inline
	_Ty * _Unfancy(_Ty * _Ptr)
	{	
	return (_Ptr);
	}

}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 748 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"
#line 749 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstddef"





#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {















 

 
 
 
 

 
 
 
 

 
 
 
 

		
typedef enum
	{	
	denorm_indeterminate = -1,
	denorm_absent = 0,
	denorm_present = 1}
		float_denorm_style;

		
typedef enum
	{	
	round_indeterminate = -1,
	round_toward_zero = 0,
	round_to_nearest = 1,
	round_toward_infinity = 2,
	round_toward_neg_infinity = 3}
		float_round_style;

		
struct _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_absent);
	static constexpr bool has_denorm_loss = (bool)(false);
	static constexpr bool has_infinity = (bool)(false);
	static constexpr bool has_quiet_NaN = (bool)(false);
	static constexpr bool has_signaling_NaN = (bool)(false);
	static constexpr bool is_bounded = (bool)(false);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(false);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr bool is_specialized = (bool)(false);
	static constexpr bool tinyness_before = (bool)(false);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_toward_zero);
	static constexpr int digits = (int)(0);
	static constexpr int digits10 = (int)(0);

	static constexpr int max_digits10 = (int)(0);

	static constexpr int max_exponent = (int)(0);
	static constexpr int max_exponent10 = (int)(0);
	static constexpr int min_exponent = (int)(0);
	static constexpr int min_exponent10 = (int)(0);
	static constexpr int radix = (int)(0);
	};

		
template<class _Ty>
	class numeric_limits
		: public _Num_base
	{	
public:
	static constexpr _Ty (min)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (_Ty());
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (_Ty());
		}
	};

template<class _Ty>
	class numeric_limits<const _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

template<class _Ty>
	class numeric_limits<const volatile _Ty>
		: public numeric_limits<_Ty>
	{	
	};

		
struct _Num_int_base
	: public _Num_base
	{	
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(true);
	static constexpr bool is_integer = (bool)(true);
	static constexpr bool is_modulo = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr int radix = (int)(2);
	};

		
struct _Num_float_base
	: public _Num_base
	{	
	static constexpr float_denorm_style has_denorm = (float_denorm_style)(denorm_present);
	static constexpr bool has_denorm_loss = (bool)(true);
	static constexpr bool has_infinity = (bool)(true);
	static constexpr bool has_quiet_NaN = (bool)(true);
	static constexpr bool has_signaling_NaN = (bool)(true);
	static constexpr bool is_bounded = (bool)(true);
	static constexpr bool is_exact = (bool)(false);
	static constexpr bool is_iec559 = (bool)(true);
	static constexpr bool is_integer = (bool)(false);
	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(true);
	static constexpr bool is_specialized = (bool)(true);
	static constexpr bool tinyness_before = (bool)(true);
	static constexpr bool traps = (bool)(false);
	static constexpr float_round_style round_style = (float_round_style)(round_to_nearest);
	static constexpr int radix = (int)(2);
	};

		
template<> class numeric_limits<char>
	: public _Num_int_base
	{	
public:
	typedef char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)((-128) != 0);
	static constexpr int digits = (int)(8 - ((-128) != 0 ? 1 : 0));
	static constexpr int digits10 = (int)((8 - ((-128) != 0 ? 1 : 0)) * 301L / 1000);
#line 259 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<wchar_t>
	: public _Num_int_base
	{	
public:
	typedef wchar_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((_Ty)0x0000);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return ((_Ty)0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(0x0000 != 0);
	static constexpr int digits = (int)(8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0));
#line 316 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	static constexpr int digits10 = (int)((8 * sizeof (wchar_t) - (0x0000 != 0 ? 1 : 0)) * 301L / 1000);
#line 318 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<bool>
	: public _Num_int_base
	{	
public:
	typedef bool _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (false);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (true);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_modulo = (bool)(false);
	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(1);
	static constexpr int digits10 = (int)(0);
	};

		
template<> class numeric_limits<signed char>
	: public _Num_int_base
	{	
public:
	typedef signed char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-128));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (127);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 - 1);
	static constexpr int digits10 = (int)((8 - 1) * 301L / 1000);
	};

		
template<> class numeric_limits<unsigned char>
	: public _Num_int_base
	{	
public:
	typedef unsigned char _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8);
	static constexpr int digits10 = (int)(8 * 301L / 1000);
	};

		
template<> class numeric_limits<short>
	: public _Num_int_base
	{	
public:
	typedef short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-32768));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (32767);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (short) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (short) - 1) * 301L / 1000);
#line 548 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

 
		
template<> class numeric_limits<unsigned short>
	: public _Num_int_base
	{	
public:
	typedef unsigned short _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned short));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned short) * 301L / 1000);
#line 607 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};
 #line 609 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

		
template<> class numeric_limits<char16_t>
	: public _Num_int_base
	{	
public:
	typedef char16_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char16_t));
	static constexpr int digits10 = (int)(8 * sizeof (char16_t) * 301L / 1000);
#line 666 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<int>
	: public _Num_int_base
	{	
public:
	typedef int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647 - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (int) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (int) - 1) * 301L / 1000);
#line 724 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned int>
	: public _Num_int_base
	{	
public:
	typedef unsigned int _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned int));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned int) * 301L / 1000);
#line 782 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<long>
	: public _Num_int_base
	{	
public:
	typedef long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return ((-2147483647L - 1));
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (2147483647L);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (long) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (long) - 1) * 301L / 1000);
#line 840 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffUL);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned long));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned long) * 301L / 1000);
#line 898 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<char32_t>
	: public _Num_int_base
	{	
public:
	typedef char32_t _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (char32_t));
	static constexpr int digits10 = (int)(8 * sizeof (char32_t) * 301L / 1000);
#line 956 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<long long>
	: public _Num_int_base
	{	
public:
	typedef long long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (-0x7fffffffffffffff - 1);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0x7fffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(true);
	static constexpr int digits = (int)(8 * sizeof (long long) - 1);
	static constexpr int digits10 = (int)((8 * sizeof (long long) - 1) * 301L / 1000);
#line 1014 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<unsigned long long>
	: public _Num_int_base
	{	
public:
	typedef unsigned long long _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (0);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (0xffffffffffffffff);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return ((min)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (0);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (0);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (0);
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (0);
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (0);
		}

	static constexpr bool is_signed = (bool)(false);
	static constexpr int digits = (int)(8 * sizeof (unsigned long long));
	static constexpr int digits10 = (int)(8 * sizeof (unsigned long long) * 301L / 1000);
#line 1072 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
	};

		
template<> class numeric_limits<float>
	: public _Num_float_base
	{	
public:
	typedef float _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (1.175494351e-38F);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (3.402823466e+38F);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (1.192092896e-07F);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5F);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (1.401298464e-45F);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (__builtin_huge_valf());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (__builtin_nanf("0"));
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (__builtin_nansf("1"));
		}

	static constexpr int digits = (int)(24);
	static constexpr int digits10 = (int)(6);

	static constexpr int max_digits10 = (int)(2 + 24 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)128);
	static constexpr int max_exponent10 = (int)((int)38);
	static constexpr int min_exponent = (int)((int)(-125));
	static constexpr int min_exponent10 = (int)((int)(-37));
	};

		
template<> class numeric_limits<double>
	: public _Num_float_base
	{	
public:
	typedef double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623158e+308);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-016);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (__builtin_huge_val());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (__builtin_nan("0"));
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (__builtin_nans("1"));
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

		
template<> class numeric_limits<long double>
	: public _Num_float_base
	{	
public:
	typedef long double _Ty;

	static constexpr _Ty (min)() noexcept
		{	
		return (2.2250738585072014e-308);
		}

	static constexpr _Ty (max)() noexcept
		{	
		return (1.7976931348623158e+308);
		}

	static constexpr _Ty lowest() noexcept
		{	
		return (-(max)());
		}

	static constexpr _Ty epsilon() noexcept
		{	
		return (2.2204460492503131e-016);
		}

	static constexpr _Ty round_error() noexcept
		{	
		return (0.5L);
		}

	static constexpr _Ty denorm_min() noexcept
		{	
		return (4.9406564584124654e-324);
		}

	static constexpr _Ty infinity() noexcept
		{	
		return (__builtin_huge_val());
		}

	static constexpr _Ty quiet_NaN() noexcept
		{	
		return (__builtin_nan("0"));
		}

	static constexpr _Ty signaling_NaN() noexcept
		{	
		return (__builtin_nans("1"));
		}

	static constexpr int digits = (int)(53);
	static constexpr int digits10 = (int)(15);

	static constexpr int max_digits10 = (int)(2 + 53 * 301L / 1000);

	static constexpr int max_exponent = (int)((int)1024);
	static constexpr int max_exponent10 = (int)((int)308);
	static constexpr int min_exponent = (int)((int)(-1021));
	static constexpr int min_exponent10 = (int)((int)(-307));
	};

  









































































































































































































#line 1466 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"

 
 
 
 

 
 
 
 

 
 
 
 
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1486 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"
#line 1487 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\limits"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\chrono"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ratio"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"







#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"



typedef signed char        int8_t;
typedef short              int16_t;
typedef int                int32_t;
typedef long long          int64_t;
typedef unsigned char      uint8_t;
typedef unsigned short     uint16_t;
typedef unsigned int       uint32_t;
typedef unsigned long long uint64_t;

typedef signed char        int_least8_t;
typedef short              int_least16_t;
typedef int                int_least32_t;
typedef long long          int_least64_t;
typedef unsigned char      uint_least8_t;
typedef unsigned short     uint_least16_t;
typedef unsigned int       uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char        int_fast8_t;
typedef int                int_fast16_t;
typedef int                int_fast32_t;
typedef long long          int_fast64_t;
typedef unsigned char      uint_fast8_t;
typedef unsigned int       uint_fast16_t;
typedef unsigned int       uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long          intmax_t;
typedef unsigned long long uintmax_t;














































    
    
    
#line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"




































#line 133 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdint.h"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ratio"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4180 4296)

namespace std {
template<class _Ty>
	struct _Is_memfunptr
	{	
	typedef false_type _Bool_type;
	};













template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  > : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const > : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile > : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile > : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  &> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...)  &&> : _Arg_types< _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const &&> : _Arg_types<const _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) volatile &&> : _Arg_types<volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };  template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__fastcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__stdcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__thiscall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (__vectorcall _Arg0::*)(_Types...) const volatile &&> : _Arg_types<const volatile _Arg0 *, _Types...> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };













template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) > { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; }; template<class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile &&> { typedef true_type _Bool_type; typedef _Ret result_type; typedef _Arg0 _Class_type; };


	
template<class _Ty>
	struct is_void
		: false_type
	{	
	};








template<> struct is_void< void> : true_type { }; template<> struct is_void<const void> : true_type { }; template<> struct is_void<volatile void> : true_type { }; template<> struct is_void<const volatile void> : true_type { };


	
	
template<class _Ty>
	struct add_const
	{	
	typedef const _Ty type;
	};

	
template<class _Ty>
	struct add_volatile
	{	
	typedef volatile _Ty type;
	};

	
template<class _Ty>
	struct add_cv
	{	
	typedef const volatile _Ty type;
	};

	
template<class _Ty,
	bool = _Is_function<_Ty>::_Weird || is_void<_Ty>::value>
	struct _Add_reference
	{	
	typedef _Ty _Lvalue;
	typedef _Ty _Rvalue;
	};

template<class _Ty>
	struct _Add_reference<_Ty, false>
	{	
	typedef _Ty& _Lvalue;
	typedef _Ty&& _Rvalue;
	};

	
template<class _Ty>
	struct add_lvalue_reference
	{	
	typedef typename _Add_reference<_Ty>::_Lvalue type;
	};

	
template<class _Ty>
	struct add_rvalue_reference
	{	
	typedef typename _Add_reference<_Ty>::_Rvalue type;
	};

	
template<class _Ty>
	typename add_rvalue_reference<_Ty>::type
		declval() noexcept;

	
template<class _Ty>
	struct remove_extent
	{	
	typedef _Ty type;
	};

template<class _Ty, size_t _Ix>
	struct remove_extent<_Ty[_Ix]>
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct remove_extent<_Ty[]>
	{	
	typedef _Ty type;
	};

	
template<class _Ty>
	struct remove_all_extents
	{	
	typedef _Ty type;
	};

template<class _Ty, size_t _Ix>
	struct remove_all_extents<_Ty[_Ix]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

template<class _Ty>
	struct remove_all_extents<_Ty[]>
	{	
	typedef typename remove_all_extents<_Ty>::type type;
	};

	
template<class _Ty>
	struct remove_pointer
	{	
	typedef _Ty type;
	};








template<class _Ty> struct remove_pointer<_Ty *> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *volatile> { typedef _Ty type; }; template<class _Ty> struct remove_pointer<_Ty *const volatile> { typedef _Ty type; };


	
template<class _Ty,
	bool = _Is_function<_Ty>::_Weird>
	struct _Add_pointer
	{	
	typedef _Ty type;
	};

template<class _Ty>
	struct _Add_pointer<_Ty, false>
	{	
	typedef typename remove_reference<_Ty>::type *type;
	};

template<class _Ty>
	struct add_pointer
	{	
	typedef typename _Add_pointer<_Ty>::type type;
	};

	
	
template<class _Ty>
	struct is_array
		: false_type
	{	
	};

template<class _Ty, size_t _Nx>
	struct is_array<_Ty[_Nx]>
		: true_type
	{	
	};

template<class _Ty>
	struct is_array<_Ty[]>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_lvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_lvalue_reference<_Ty&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_rvalue_reference
		: false_type
	{	
	};

template<class _Ty>
	struct is_rvalue_reference<_Ty&&>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_reference
		: _Cat_base<is_lvalue_reference<_Ty>::value
		|| is_rvalue_reference<_Ty>::value>
	{	
	};


	
template<class _Ty,
	bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value>
	struct _Is_member_object_pointer
		: false_type
	{	
	};

template<class _Ty1,
	class _Ty2>
	struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
		: true_type
	{	
	typedef _Ty2 _Class_type;
	};

template<class _Ty>
	struct is_member_object_pointer
		: _Is_member_object_pointer<typename remove_cv<_Ty>::type>::type
	{	
	};

	
template<class _Ty>
	struct is_member_function_pointer
		: _Is_memfunptr<typename remove_cv<_Ty>::type>::_Bool_type
	{	
	};

	
template<class _Ty>
	struct _Is_pointer
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_pointer<_Ty *>
		: _Cat_base<!is_member_object_pointer<_Ty *>::value
		&& !is_member_function_pointer<_Ty *>::value>
	{	
	};

template<class _Ty>
	struct is_pointer
		: _Is_pointer<typename remove_cv<_Ty>::type>
	{	
	};

	

template<class _Ty>
	struct is_null_pointer
		: _Cat_base<is_same<typename remove_cv<_Ty>::type, nullptr_t>::value>
	{	
	};

	
template<class _Ty>
	struct is_union
		: _Cat_base<__is_union(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_class
		: _Cat_base<__is_class(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_fundamental
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_void<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_object
		: _Cat_base<!is_function<_Ty>::value
		&& !is_reference<_Ty>::value
		&& !is_void<_Ty>::value>
	{	
	};

	

template<class _From,
	class _To>
	struct is_convertible
		: _Cat_base<__is_convertible_to(_From, _To)>
	{	
	};

	
template<class _Ty>
	struct is_enum
		: _Cat_base<__is_enum(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_compound
		: _Cat_base<!is_fundamental<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_member_pointer
		: _Cat_base<is_member_object_pointer<_Ty>::value
		|| is_member_function_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_scalar
		: _Cat_base<is_arithmetic<_Ty>::value
		|| is_enum<_Ty>::value
		|| is_pointer<_Ty>::value
		|| is_member_pointer<_Ty>::value
		|| is_null_pointer<_Ty>::value>
	{	
	};

	
template<class _Ty>
	struct is_const
		: false_type
	{	
	};

template<class _Ty>
	struct is_const<const _Ty>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_volatile
		: false_type
	{	
	};

template<class _Ty>
	struct is_volatile<volatile _Ty>
		: true_type
	{	
	};

	
template<class _Ty>
	struct is_pod
		: _Cat_base<__is_pod(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_empty
		: _Cat_base<__is_empty(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_polymorphic
		: _Cat_base<__is_polymorphic(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_abstract
		: _Cat_base<__is_abstract(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_final
		: _Cat_base<__is_final(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_standard_layout
		: _Cat_base<__is_standard_layout(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_literal_type
		: _Cat_base<__is_literal_type(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivial
		: _Cat_base<__is_trivial(_Ty)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copyable
		: _Cat_base<__is_trivially_copyable(_Ty)>
	{	
	};

	
template<class _Ty>
	struct has_virtual_destructor
		: _Cat_base<__has_virtual_destructor(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_constructible
		: _Cat_base<__is_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_copy_constructible
		: is_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_default_constructible
		: is_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_move_constructible
		: is_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_assignable
		: integral_constant<bool, __is_assignable(_To, _From)>
	{	
	};

	
template<class _Ty>
	struct is_copy_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_move_assignable
		: is_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_destructible
		: _Cat_base<__is_destructible(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_trivially_constructible
		: _Cat_base<__is_trivially_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_constructible
		: is_trivially_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_default_constructible
		: is_trivially_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_constructible
		: is_trivially_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_trivially_assignable
		: _Cat_base<__is_trivially_assignable(_To, _From)>
	{	
	};

	
template<class _Ty>
	struct is_trivially_copy_assignable
		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_move_assignable
		: is_trivially_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_trivially_destructible
		: _Cat_base<__has_trivial_destructor(_Ty)>
	{	
	};

		
	

template<class _Ty,
	class... _Args>
	struct is_nothrow_constructible
		: _Cat_base<__is_nothrow_constructible(_Ty, _Args...)>
	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_default_constructible
		: is_nothrow_constructible<_Ty>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_constructible
		: is_nothrow_constructible<
			_Ty,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _To,
	class _From>
	struct is_nothrow_assignable
		: _Cat_base<__is_nothrow_assignable(_To, _From)>
	{	
	};

	
template<class _Ty>
	struct is_nothrow_copy_assignable
		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<
				typename add_const<_Ty>::type
			>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_move_assignable
		: is_nothrow_assignable<
			typename add_lvalue_reference<_Ty>::type,
			typename add_rvalue_reference<_Ty>::type
		>::type
	{	
	};

	
template<class _Ty>
	struct is_nothrow_destructible
		: _Cat_base<__is_nothrow_destructible(_Ty)>
	{	
	};

	
template<class _Ty,
	bool = is_integral<_Ty>::value>
	struct _Sign_base
	{	
	typedef typename remove_cv<_Ty>::type _Uty;
	typedef _Cat_base<_Uty(-1) < _Uty(0)> _Signed;
	typedef _Cat_base<_Uty(0) < _Uty(-1)> _Unsigned;
	};

template<class _Ty>
	struct _Sign_base<_Ty, false>
	{	
		
	typedef is_floating_point<_Ty> _Signed;
	typedef false_type _Unsigned;
	};

template<class _Ty>
	struct is_signed
		: _Sign_base<_Ty>::_Signed
	{	
	};

	
template<class _Ty>
	struct is_unsigned
		: _Sign_base<_Ty>::_Unsigned
	{	
	};

	
template<class _Ty>
	struct _Change_sign
	{	
	static_assert(
		((is_integral<_Ty>::value || is_enum<_Ty>::value)
			&& !is_same<_Ty, bool>::value),
		"make_signed<T>/make_unsigned<T> require that T shall be a (possibly "
		"cv-qualified) integral type or enumeration but not a bool type.");

	typedef
		typename _If<is_same<_Ty, signed char>::value
			|| is_same<_Ty, unsigned char     >::value, signed char,
		typename _If<is_same<_Ty, short       >::value
			|| is_same<_Ty, unsigned short    >::value, short,
		typename _If<is_same<_Ty, int         >::value
			|| is_same<_Ty, unsigned int      >::value, int,
		typename _If<is_same<_Ty, long        >::value
			|| is_same<_Ty, unsigned long     >::value, long,
		typename _If<is_same<_Ty, long long   >::value
			|| is_same<_Ty, unsigned long long>::value, long long,
		typename _If<sizeof (_Ty) == sizeof (signed char), signed char,
		typename _If<sizeof (_Ty) == sizeof (short      ), short,
		typename _If<sizeof (_Ty) == sizeof (int        ), int,
		typename _If<sizeof (_Ty) == sizeof (long       ), long,
			long long
		>::type>::type>::type>::type>::type>::type>::type>::type>::type
			_Signed;

	typedef
		typename _If<is_same<_Signed, signed char>::value, unsigned char,
		typename _If<is_same<_Signed, short      >::value, unsigned short,
		typename _If<is_same<_Signed, int        >::value, unsigned int,
		typename _If<is_same<_Signed, long       >::value, unsigned long,
			unsigned long long
		>::type>::type>::type>::type
			_Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const _Ty>
	{	
	typedef const typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<volatile _Ty>
	{	
	typedef volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

template<class _Ty>
	struct _Change_sign<const volatile _Ty>
	{	
	typedef const volatile typename _Change_sign<_Ty>::_Signed _Signed;
	typedef const volatile typename _Change_sign<_Ty>::_Unsigned _Unsigned;
	};

	
template<class _Ty>
	struct make_signed
	{	
	typedef typename _Change_sign<_Ty>::_Signed type;
	};

	
template<class _Ty>
	struct make_unsigned
	{	
	typedef typename _Change_sign<_Ty>::_Unsigned type;
	};

	

template<class _Ty>
	struct alignment_of
		: integral_constant<size_t, alignof(_Ty)>
	{	
	};

	




template<class _Ty,
	size_t _Len>
	union _Align_type
	{	
	_Ty _Val;
	char _Pad[_Len];
	};

template<size_t _Len,
	size_t _Align,
	class _Ty,
	bool _Ok>
	struct _Aligned;

template<size_t _Len,
	size_t _Align,
	class _Ty>
	struct _Aligned<_Len, _Align, _Ty, true>
	{	
	typedef _Align_type<_Ty, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, double, false>
	{	
	typedef _Align_type<max_align_t, _Len> type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, int, false>
	{	
	typedef typename _Aligned<_Len, _Align, double, _Align <= alignment_of<double>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, short, false>
	{	
	typedef typename _Aligned<_Len, _Align, int, _Align <= alignment_of<int>::value>::type type;
	};

template<size_t _Len,
	size_t _Align>
	struct _Aligned<_Len, _Align, char, false>
	{	
	typedef typename _Aligned<_Len, _Align, short, _Align <= alignment_of<short>::value>::type type;
	};

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	struct aligned_storage
	{	
	typedef typename _Aligned<_Len, _Align, char, _Align <= alignment_of<char>::value>::type type;
	};




	
template<size_t... _Vals>
	struct _Maximum;

template<>
	struct _Maximum<>
	{	
	static constexpr size_t value = 0;
	};

template<size_t _Val>
	struct _Maximum<_Val>
	{	
	static constexpr size_t value = _Val;
	};

template<size_t _First,
	size_t _Second,
	size_t... _Rest>
	struct _Maximum<_First, _Second, _Rest...>
		: _Maximum<(_First < _Second ? _Second : _First), _Rest...>
	{	
	};

template<size_t _Len,
	class... _Types>
	struct aligned_union
	{	
	static constexpr size_t _Max_len = _Maximum<
		_Len, sizeof(_Types)...>::value;	
	static constexpr size_t alignment_value = _Maximum<
		alignment_of<_Types>::value...>::value;
	typedef typename aligned_storage<_Max_len, alignment_value>::type type;
	};

	
template<class _Ty>
	struct underlying_type
	{	
	typedef __underlying_type(_Ty) type;
	};

	
template<class _Ty>
	struct rank
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, size_t _Ix>
	struct rank<_Ty[_Ix]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

template<class _Ty>
	struct rank<_Ty[]>
		: integral_constant<size_t, rank<_Ty>::value + 1>
	{	
	};

	
template<class _Ty, unsigned int _Nx>
	struct _Extent
		: integral_constant<size_t, 0>
	{	
	};

template<class _Ty, size_t _Ix>
	struct _Extent<_Ty[_Ix], 0>
		: integral_constant<size_t, _Ix>
	{	
	};

template<class _Ty, unsigned int _Nx, size_t _Ix>
	struct _Extent<_Ty[_Ix], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx>
	struct _Extent<_Ty[], _Nx>
		: _Extent<_Ty, _Nx - 1>
	{	
	};

template<class _Ty, unsigned int _Nx = 0>
	struct extent
		: _Extent<_Ty, _Nx>
	{	
	};

	
template<class _Base,
	class _Der>
	struct is_base_of
		: _Cat_base<__is_base_of(_Base, _Der)>
	{	
	};

	
template<class _Ty>
	struct decay
	{	
	typedef typename remove_reference<_Ty>::type _Ty1;

	typedef typename _If<is_array<_Ty1>::value,
		typename remove_extent<_Ty1>::type *,
		typename _If<is_function<_Ty1>::value,
			typename add_pointer<_Ty1>::type,
			typename remove_cv<_Ty1>::type>::type>::type type;
	};

	
template<class...>
	struct _Conjunction;

template<bool,
	class _Lhs,
	class... _Traits>
	struct _Choose_conjunction
	{	
	typedef _Lhs type;
	};

template<class _Lhs,
	class... _Traits>
	struct _Choose_conjunction<true, _Lhs, _Traits...>
	{	
	typedef typename _Conjunction<_Traits...>::type type;
	};

template<>
	struct _Conjunction<>
	{	
	typedef true_type type;
	};

template<class _Trait>
	struct _Conjunction<_Trait>
	{	
	typedef _Trait type;
	};

template<class _Lhs,
	class... _Traits>
	struct _Conjunction<_Lhs, _Traits...>
	{	
	typedef typename _Choose_conjunction<_Lhs::value, _Lhs, _Traits...>::type type;
	};

template<class... _Traits>
	struct conjunction
		: _Conjunction<_Traits...>::type
	{	
		
		
	};

	
template<class...>
	struct _Disjunction;

template<bool,
	class _Lhs,
	class... _Traits>
	struct _Choose_disjunction
	{	
	typedef _Lhs type;
	};

template<class _Lhs,
	class... _Traits>
	struct _Choose_disjunction<false, _Lhs, _Traits...>
	{	
	typedef typename _Disjunction<_Traits...>::type type;
	};

template<>
	struct _Disjunction<>
	{	
	typedef false_type type;
	};

template<class _Trait>
	struct _Disjunction<_Trait>
	{	
	typedef _Trait type;
	};

template<class _Lhs,
	class... _Traits>
	struct _Disjunction<_Lhs, _Traits...>
	{	
	typedef typename _Choose_disjunction<_Lhs::value, _Lhs, _Traits...>::type type;
	};

template<class... _Traits>
	struct disjunction
		: _Disjunction<_Traits...>::type
	{	
		
		
	};

	
template<class _Trait>
	struct negation
		: bool_constant<!_Trait::value>
	{	
	};


namespace tr1 {	
using ::std:: add_const;
using ::std:: add_cv;
using ::std:: add_pointer;
using ::std:: add_volatile;
using ::std:: aligned_storage;
using ::std:: alignment_of;
using ::std:: conditional;
using ::std:: decay;
using ::std:: enable_if;
using ::std:: extent;
using ::std:: false_type;
using ::std:: has_virtual_destructor;
using ::std:: integral_constant;
using ::std:: is_abstract;
using ::std:: is_arithmetic;
using ::std:: is_array;
using ::std:: is_base_of;
using ::std:: is_class;
using ::std:: is_compound;
using ::std:: is_const;
using ::std:: is_convertible;
using ::std:: is_empty;
using ::std:: is_enum;
using ::std:: is_floating_point;
using ::std:: is_function;
using ::std:: is_fundamental;
using ::std:: is_integral;
using ::std:: is_member_function_pointer;
using ::std:: is_member_object_pointer;
using ::std:: is_member_pointer;
using ::std:: is_object;
using ::std:: is_pod;
using ::std:: is_pointer;
using ::std:: is_polymorphic;
using ::std:: is_reference;
using ::std:: is_same;
using ::std:: is_scalar;
using ::std:: is_signed;
using ::std:: is_union;
using ::std:: is_unsigned;
using ::std:: is_void;
using ::std:: is_volatile;
using ::std:: make_signed;
using ::std:: make_unsigned;
using ::std:: rank;
using ::std:: remove_all_extents;
using ::std:: remove_const;
using ::std:: remove_cv;
using ::std:: remove_extent;
using ::std:: remove_pointer;
using ::std:: remove_reference;
using ::std:: remove_volatile;
using ::std:: true_type;
	}	
#line 1156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

		
template<class... _Ty>
	struct common_type;

template<class _Ty>
	struct common_type<_Ty>
	{	
	typedef typename decay<_Ty>::type type;
	};

template<class _Ty0,
	class _Ty1>
	struct common_type<_Ty0, _Ty1>
	{	
	typedef typename decay<
		decltype(_Always_false<_Ty0>::value
			? ::std:: declval<_Ty0>()
			: ::std:: declval<_Ty1>())
	>::type type;
	};

template<class _Ty0,
	class _Ty1,
	class... _Ty>
	struct common_type<_Ty0, _Ty1, _Ty...>
	{	
	typedef typename common_type<
		typename common_type<_Ty0, _Ty1>::type, _Ty...
	>::type type;
	};

	
template<class _Ty,
	_Ty... _Vals>
	struct integer_sequence
	{	
	static_assert(is_integral<_Ty>::value,
		"integer_sequence<T, I...> requires T to be an integral type.");

	typedef integer_sequence<_Ty, _Vals...> type;
	typedef _Ty value_type;

	static constexpr size_t size() noexcept
		{	
		return (sizeof...(_Vals));
		}
	};

	
 




































template<class _Ty,
	_Ty _Size>
	using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;
 #line 1247 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

template<size_t... _Vals>
	using index_sequence = integer_sequence<size_t, _Vals...>;

template<size_t _Size>
	using make_index_sequence = make_integer_sequence<size_t, _Size>;

template<class... _Types>
	using index_sequence_for = make_index_sequence<sizeof...(_Types)>;


	
template<class _Ty>
	struct identity
	{	
	typedef _Ty type;

	const _Ty& operator()(const _Ty& _Left) const
		{	
		return (_Left);
		}
	};
#line 1270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

	
template<class _Ty> inline
	constexpr _Ty&& forward(
		typename remove_reference<_Ty>::type& _Arg) noexcept
	{	
	return (static_cast<_Ty&&>(_Arg));
	}

template<class _Ty> inline
	constexpr _Ty&& forward(
		typename remove_reference<_Ty>::type&& _Arg) noexcept
	{	
	static_assert(!is_lvalue_reference<_Ty>::value, "bad forward call");
	return (static_cast<_Ty&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename remove_reference<_Ty>::type&&
		move(_Ty&& _Arg) noexcept
	{	
	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));
	}

		
template<class _Ty> inline
	constexpr typename _If<!is_nothrow_move_constructible<_Ty>::value
		&& is_copy_constructible<_Ty>::value,
			const _Ty&, _Ty&&>::type
	move_if_noexcept(_Ty& _Arg) noexcept
	{	
	return (::std:: move(_Arg));
	}

	
template<class...>
	struct _Param_tester
	{	
	typedef void type;
	};

	
template<class... _Types>	
	using void_t = typename _Param_tester<_Types...>::type;

	
struct _Invoker_pmf_object
	{	
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
		-> decltype((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...))
		{	
		return ((::std:: forward<_Ty1>(_Arg1).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...));
		}
	};

struct _Invoker_pmf_pointer
	{	
	template<class _Decayed,
		class _Ty1,
		class... _Types2>
		static auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2)
		-> decltype(((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...))
		{	
		return (((*::std:: forward<_Ty1>(_Arg1)).*_Pmf)(
			::std:: forward<_Types2>(_Args2)...));
		}
	};

struct _Invoker_pmd_object
	{	
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
		-> decltype(::std:: forward<_Ty1>(_Arg1).*_Pmd)
		{	
		return (::std:: forward<_Ty1>(_Arg1).*_Pmd);
		}
	};

struct _Invoker_pmd_pointer
	{	
	template<class _Decayed,
		class _Ty1>
		static auto _Call(_Decayed _Pmd, _Ty1&& _Arg1)
		-> decltype((*::std:: forward<_Ty1>(_Arg1)).*_Pmd)
		{	
		return ((*::std:: forward<_Ty1>(_Arg1)).*_Pmd);
		}
	};

struct _Invoker_functor
	{	
	template<class _Callable,
		class... _Types>
		static auto _Call(_Callable&& _Obj, _Types&&... _Args)
		-> decltype(::std:: forward<_Callable>(_Obj)(
			::std:: forward<_Types>(_Args)...))
		{	
		return (::std:: forward<_Callable>(_Obj)(
			::std:: forward<_Types>(_Args)...));
		}
	};

template<class _Callable,
	class _Ty1,
	class _Decayed = typename decay<_Callable>::type,
	bool _Is_pmf = is_member_function_pointer<_Decayed>::value,
	bool _Is_pmd = is_member_object_pointer<_Decayed>::value>
	struct _Invoker1;

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, true, false>
		: _If<is_base_of<
			typename _Is_memfunptr<_Decayed>::_Class_type,
			typename decay<_Ty1>::type>::value,
		_Invoker_pmf_object,
		_Invoker_pmf_pointer>::type
	{	
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, true>
		: _If<is_base_of<
			typename _Is_member_object_pointer<_Decayed>::_Class_type,
			typename decay<_Ty1>::type>::value,
		_Invoker_pmd_object,
		_Invoker_pmd_pointer>::type
	{	
	};

template<class _Callable,
	class _Ty1,
	class _Decayed>
	struct _Invoker1<_Callable, _Ty1, _Decayed, false, false>
		: _Invoker_functor
	{	
	};

template<class _Callable,
	class... _Types>
	struct _Invoker;

template<class _Callable>
	struct _Invoker<_Callable>
		: _Invoker_functor
	{	
	};

template<class _Callable,
	class _Ty1,
	class... _Types2>
	struct _Invoker<_Callable, _Ty1, _Types2...>
		: _Invoker1<_Callable, _Ty1>
	{	
	};

template<class _Callable,
	class... _Types> inline
	auto invoke(_Callable&& _Obj, _Types&&... _Args)
	-> decltype(_Invoker<_Callable, _Types...>::_Call(
		::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...))
	{	
	return (_Invoker<_Callable, _Types...>::_Call(
		::std:: forward<_Callable>(_Obj), ::std:: forward<_Types>(_Args)...));
	}

template<class _Rx,
	bool = is_void<_Rx>::value>
	struct _Forced
	{	
	};

struct _Unforced
	{	
	};

template<class _Cv_void,
	class... _Valtys> inline
	void _Invoke_ret(_Forced<_Cv_void, true>, _Valtys&&... _Vals)
	{	
	::std:: invoke(::std:: forward<_Valtys>(_Vals)...);
	}

template<class _Rx,
	class... _Valtys> inline
	_Rx _Invoke_ret(_Forced<_Rx, false>, _Valtys&&... _Vals)
	{	
	return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
	}

template<class... _Valtys> inline
	auto _Invoke_ret(_Forced<_Unforced, false>, _Valtys&&... _Vals)
	-> decltype(::std:: invoke(::std:: forward<_Valtys>(_Vals)...))
	{	
	return (::std:: invoke(::std:: forward<_Valtys>(_Vals)...));
	}

	
struct _Unique_tag_result_of
	{	
	};

template<class _Void,
	class... _Types>
	struct _Result_of
	{	
	};

template<class... _Types>
	struct _Result_of<
		void_t<
			_Unique_tag_result_of,	
			decltype(::std:: invoke(::std:: declval<_Types>()...))>,
		_Types...>
	{	
	typedef decltype(::std:: invoke(::std:: declval<_Types>()...)) type;
	};

template<class _Fty>
	struct result_of
	{	
	static_assert(_Always_false<_Fty>::value,
		"result_of<CallableType> is invalid; use "
		"result_of<CallableType(zero or more argument types)> instead.");
	};









template<class _Fty, class... _Args> struct result_of<_Fty __cdecl (_Args...)> : _Result_of<void, _Fty, _Args...> { };  template<class _Fty, class... _Args> struct result_of<_Fty __fastcall (_Args...)> : _Result_of<void, _Fty, _Args...> { }; template<class _Fty, class... _Args> struct result_of<_Fty __stdcall (_Args...)> : _Result_of<void, _Fty, _Args...> { }; template<class _Fty, class... _Args> struct result_of<_Fty __vectorcall (_Args...)> : _Result_of<void, _Fty, _Args...> { };


	
template<class _Ty,
	class = void>
	struct _Weak_result_type
	{	
	};

template<class _Ty>
	struct _Weak_result_type<_Ty, void_t<
		typename _Ty::result_type> >
	{	
	typedef typename _Ty::result_type result_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_argument_type
		: _Weak_result_type<_Ty>
	{	
	};

template<class _Ty>
	struct _Weak_argument_type<_Ty, void_t<
		typename _Ty::argument_type> >
		: _Weak_result_type<_Ty>
	{	
	typedef typename _Ty::argument_type argument_type;
	};

template<class _Ty,
	class = void>
	struct _Weak_binary_args
		: _Weak_argument_type<_Ty>
	{	
	};

template<class _Ty>
	struct _Weak_binary_args<_Ty, void_t<
		typename _Ty::first_argument_type,
		typename _Ty::second_argument_type> >
		: _Weak_argument_type<_Ty>
	{	
	typedef typename _Ty::first_argument_type first_argument_type;
	typedef typename _Ty::second_argument_type second_argument_type;
	};

template<class _Ty>
	struct _Weak_types
	{	
	typedef _Is_function<typename remove_pointer<_Ty>::type> _Is_f_or_pf;
	typedef _Is_memfunptr<typename remove_cv<_Ty>::type> _Is_pmf;
	typedef typename _If<_Is_f_or_pf::_Bool_type::value, _Is_f_or_pf,
		typename _If<_Is_pmf::_Bool_type::value, _Is_pmf,
		_Weak_binary_args<_Ty> >::type>::type type;
	};

	
template<class _Ty>
	class reference_wrapper
		: public _Weak_types<_Ty>::type
	{	
public:
	static_assert(is_object<_Ty>::value || is_function<_Ty>::value,
		"reference_wrapper<T> requires T to be an object type "
		"or a function type.");

	typedef _Ty type;

	reference_wrapper(_Ty& _Val) noexcept
		: _Ptr(::std:: addressof(_Val))
		{	
		}

	operator _Ty&() const noexcept
		{	
		return (*_Ptr);
		}

	_Ty& get() const noexcept
		{	
		return (*_Ptr);
		}

	template<class... _Types>
		auto operator()(_Types&&... _Args) const
		-> decltype(::std:: invoke(get(), ::std:: forward<_Types>(_Args)...))
		{	
		return (::std:: invoke(get(), ::std:: forward<_Types>(_Args)...));
		}

	reference_wrapper(_Ty&&) = delete;

private:
	_Ty *_Ptr;
	};

	
template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(_Ty& _Val) noexcept
	{	
	return (reference_wrapper<_Ty>(_Val));
	}

template<class _Ty>
	void ref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<_Ty>
		ref(reference_wrapper<_Ty> _Val) noexcept
	{	
	return (::std:: ref(_Val.get()));
	}

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(const _Ty& _Val) noexcept
	{	
	return (reference_wrapper<const _Ty>(_Val));
	}

template<class _Ty>
	void cref(const _Ty&&) = delete;

template<class _Ty> inline
	reference_wrapper<const _Ty>
		cref(reference_wrapper<_Ty> _Val) noexcept
	{	
	return (::std:: cref(_Val.get()));
	}

	
template<class _Ty>
	struct _Unrefwrap_helper
	{	
	typedef _Ty type;
	static constexpr bool _Is_refwrap = false;
	};

template<class _Ty>
	struct _Unrefwrap_helper<reference_wrapper<_Ty> >
	{	
	typedef _Ty& type;
	static constexpr bool _Is_refwrap = true;
	};

template<class _Ty>
	struct _Unrefwrap
	{	
	typedef typename decay<_Ty>::type _Ty1;
	typedef typename _Unrefwrap_helper<_Ty1>::type type;
	static constexpr bool _Is_refwrap = _Unrefwrap_helper<_Ty1>::_Is_refwrap;
	};


namespace tr1 {	
using ::std:: cref;
using ::std:: ref;
using ::std:: reference_wrapper;
using ::std:: result_of;
	}	
#line 1680 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

		
template<class _Ty>
	struct _Is_swappable;

		
template<class _Ty>
	struct _Is_nothrow_swappable;

		




#line 1695 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
template<class _Ty,
	class = void> inline
#line 1698 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
	void swap(_Ty&, _Ty&)
		noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value);
#line 1701 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

template<class _Ty,
	size_t _Size,
	class = typename enable_if<_Is_swappable<_Ty>::value>::type> inline
	void swap(_Ty (&)[_Size], _Ty (&)[_Size])
		noexcept(_Is_nothrow_swappable<_Ty>::value);

		
template<class _Ty1,
	class _Ty2,
	class = void>
	struct _Swappable_with_helper
		: false_type
	{	
	};

struct _Swappable_with_helper_unique_type {}; 
template<class _Ty1,
	class _Ty2>
	struct _Swappable_with_helper<_Ty1, _Ty2, void_t<
		_Swappable_with_helper_unique_type,
		decltype(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))>>
		: true_type
	{	
	};

		
template<class _Ty1,
	class _Ty2>
	struct _Is_swappable_with
		: conjunction<
			_Swappable_with_helper<_Ty1, _Ty2>,
			_Swappable_with_helper<_Ty2, _Ty1>>::type
	{	
		
	};

		
template<class _Ty>
	struct _Is_swappable
		: _Is_swappable_with<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<_Ty>::type>::type
	{	
	};

		
template<class _Ty1,
	class _Ty2>
	struct _Swap_cannot_throw
	{	
		
		

	static constexpr bool value = 
		noexcept(swap(::std:: declval<_Ty1>(), ::std:: declval<_Ty2>()))
		&& noexcept(swap(::std:: declval<_Ty2>(), ::std:: declval<_Ty1>()));


#line 1761 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
	using type = bool_constant<value>;
	};

		
template<class _Ty1,
	class _Ty2>
	struct _Is_nothrow_swappable_with
		: conjunction<
			_Is_swappable_with<_Ty1, _Ty2>,
			_Swap_cannot_throw<_Ty1, _Ty2>>::type
	{	
		
	};

		
template<class _Ty>
	struct _Is_nothrow_swappable
		: _Is_nothrow_swappable_with<
			typename add_lvalue_reference<_Ty>::type,
			typename add_lvalue_reference<_Ty>::type>::type
	{	
	};

































#line 1817 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

		
template<class _Ty>
	using remove_const_t = typename remove_const<_Ty>::type;

template<class _Ty>
	using remove_volatile_t = typename remove_volatile<_Ty>::type;

template<class _Ty>
	using remove_cv_t = typename remove_cv<_Ty>::type;

template<class _Ty>
	using add_const_t = typename add_const<_Ty>::type;

template<class _Ty>
	using add_volatile_t = typename add_volatile<_Ty>::type;

template<class _Ty>
	using add_cv_t = typename add_cv<_Ty>::type;

template<class _Ty>
	using remove_reference_t = typename remove_reference<_Ty>::type;

template<class _Ty>
	using add_lvalue_reference_t = typename add_lvalue_reference<_Ty>::type;

template<class _Ty>
	using add_rvalue_reference_t = typename add_rvalue_reference<_Ty>::type;

template<class _Ty>
	using make_signed_t = typename make_signed<_Ty>::type;

template<class _Ty>
	using make_unsigned_t = typename make_unsigned<_Ty>::type;

template<class _Ty>
	using remove_extent_t = typename remove_extent<_Ty>::type;

template<class _Ty>
	using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

template<class _Ty>
	using remove_pointer_t = typename remove_pointer<_Ty>::type;

template<class _Ty>
	using add_pointer_t = typename add_pointer<_Ty>::type;

template<size_t _Len,
	size_t _Align = alignment_of<max_align_t>::value>
	using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

template<size_t _Len,
	class... _Types>
	using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

template<class _Ty>
	using decay_t = typename decay<_Ty>::type;

template<bool _Test,
	class _Ty = void>
	using enable_if_t = typename enable_if<_Test, _Ty>::type;

template<bool _Test,
	class _Ty1,
	class _Ty2>
	using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

template<class... _Ty>
	using common_type_t = typename common_type<_Ty...>::type;

template<class _Ty>
	using underlying_type_t = typename underlying_type<_Ty>::type;

template<class _Ty>
	using result_of_t = typename result_of<_Ty>::type;

	
 
template<class _Ty>
	constexpr bool is_void_v = is_void<_Ty>::value;
template<class _Ty>
	constexpr bool is_null_pointer_v = is_null_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_array_v = is_array<_Ty>::value;
template<class _Ty>
	constexpr bool is_pointer_v = is_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_lvalue_reference_v = is_lvalue_reference<_Ty>::value;
template<class _Ty>
	constexpr bool is_rvalue_reference_v = is_rvalue_reference<_Ty>::value;
template<class _Ty>
	constexpr bool is_member_object_pointer_v = is_member_object_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_member_function_pointer_v = is_member_function_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_enum_v = is_enum<_Ty>::value;
template<class _Ty>
	constexpr bool is_union_v = is_union<_Ty>::value;
template<class _Ty>
	constexpr bool is_class_v = is_class<_Ty>::value;
template<class _Ty>
	constexpr bool is_reference_v = is_reference<_Ty>::value;
template<class _Ty>
	constexpr bool is_fundamental_v = is_fundamental<_Ty>::value;
template<class _Ty>
	constexpr bool is_object_v = is_object<_Ty>::value;
template<class _Ty>
	constexpr bool is_scalar_v = is_scalar<_Ty>::value;
template<class _Ty>
	constexpr bool is_compound_v = is_compound<_Ty>::value;
template<class _Ty>
	constexpr bool is_member_pointer_v = is_member_pointer<_Ty>::value;
template<class _Ty>
	constexpr bool is_const_v = is_const<_Ty>::value;
template<class _Ty>
	constexpr bool is_volatile_v = is_volatile<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivial_v = is_trivial<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_copyable_v = is_trivially_copyable<_Ty>::value;
template<class _Ty>
	constexpr bool is_standard_layout_v = is_standard_layout<_Ty>::value;
template<class _Ty>
	constexpr bool is_pod_v = is_pod<_Ty>::value;
template<class _Ty>
	constexpr bool is_literal_type_v = is_literal_type<_Ty>::value;
template<class _Ty>
	constexpr bool is_empty_v = is_empty<_Ty>::value;
template<class _Ty>
	constexpr bool is_polymorphic_v = is_polymorphic<_Ty>::value;
template<class _Ty>
	constexpr bool is_abstract_v = is_abstract<_Ty>::value;
template<class _Ty>
	constexpr bool is_final_v = is_final<_Ty>::value;
template<class _Ty>
	constexpr bool is_signed_v = is_signed<_Ty>::value;
template<class _Ty>
	constexpr bool is_unsigned_v = is_unsigned<_Ty>::value;
template<class _Ty,
	class... _Args>
	constexpr bool is_constructible_v = is_constructible<_Ty, _Args...>::value;
template<class _Ty>
	constexpr bool is_default_constructible_v = is_default_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_copy_constructible_v = is_copy_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_move_constructible_v = is_move_constructible<_Ty>::value;
template<class _Ty,
	class _Uty>
	constexpr bool is_assignable_v = is_assignable<_Ty, _Uty>::value;
template<class _Ty>
	constexpr bool is_copy_assignable_v = is_copy_assignable<_Ty>::value;
template<class _Ty>
	constexpr bool is_move_assignable_v = is_move_assignable<_Ty>::value;






#line 1978 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
template<class _Ty>
	constexpr bool is_destructible_v = is_destructible<_Ty>::value;
template<class _Ty,
	class... _Args>
	constexpr bool is_trivially_constructible_v = is_trivially_constructible<_Ty, _Args...>::value;
template<class _Ty>
	constexpr bool is_trivially_default_constructible_v = is_trivially_default_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_copy_constructible_v = is_trivially_copy_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_move_constructible_v = is_trivially_move_constructible<_Ty>::value;
template<class _Ty,
	class _Uty>
	constexpr bool is_trivially_assignable_v = is_trivially_assignable<_Ty, _Uty>::value;
template<class _Ty>
	constexpr bool is_trivially_copy_assignable_v = is_trivially_copy_assignable<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_move_assignable_v = is_trivially_move_assignable<_Ty>::value;
template<class _Ty>
	constexpr bool is_trivially_destructible_v = is_trivially_destructible<_Ty>::value;
template<class _Ty,
	class... _Args>
	constexpr bool is_nothrow_constructible_v = is_nothrow_constructible<_Ty, _Args...>::value;
template<class _Ty>
	constexpr bool is_nothrow_default_constructible_v = is_nothrow_default_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_nothrow_copy_constructible_v = is_nothrow_copy_constructible<_Ty>::value;
template<class _Ty>
	constexpr bool is_nothrow_move_constructible_v = is_nothrow_move_constructible<_Ty>::value;
template<class _Ty,
	class _Uty>
	constexpr bool is_nothrow_assignable_v = is_nothrow_assignable<_Ty, _Uty>::value;
template<class _Ty>
	constexpr bool is_nothrow_copy_assignable_v = is_nothrow_copy_assignable<_Ty>::value;
template<class _Ty>
	constexpr bool is_nothrow_move_assignable_v = is_nothrow_move_assignable<_Ty>::value;






#line 2021 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
template<class _Ty>
	constexpr bool is_nothrow_destructible_v = is_nothrow_destructible<_Ty>::value;
template<class _Ty>
	constexpr bool has_virtual_destructor_v = has_virtual_destructor<_Ty>::value;
template<class _Ty>
	constexpr size_t alignment_of_v = alignment_of<_Ty>::value;
template<class _Ty>
	constexpr size_t rank_v = rank<_Ty>::value;
template<class _Ty,
	unsigned int _Ix = 0>
	constexpr size_t extent_v = extent<_Ty, _Ix>::value;
template<class _Base,
	class _Derived>
	constexpr bool is_base_of_v = is_base_of<_Base, _Derived>::value;
template<class _From,
	class _To>
	constexpr bool is_convertible_v = is_convertible<_From, _To>::value;
template<class... _Traits>
	constexpr bool conjunction_v = conjunction<_Traits...>::value;
template<class... _Traits>
	constexpr bool disjunction_v = disjunction<_Traits...>::value;
template<class _Trait>
	constexpr bool negation_v = negation<_Trait>::value;
 #line 2045 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"

}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2052 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"
#line 2053 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\type_traits"






#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ratio"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
template<intmax_t _Val>
	struct _Abs
	{	
	static constexpr intmax_t value = _Val < 0 ? -_Val : _Val;
	};

	
template<intmax_t _Ax,
	intmax_t _Bx,
	bool _Sfinae = false,
	bool _Good = (_Abs<_Ax>::value
		<= 9223372036854775807i64 / (_Bx == 0 ? 1 : _Abs<_Bx>::value))>
	struct _Safe_mult
		: integral_constant<intmax_t, _Ax * _Bx>
	{	
	};

template<intmax_t _Ax,
	intmax_t _Bx,
	bool _Sfinae>
	struct _Safe_mult<_Ax, _Bx, _Sfinae, false>
	{	
	static_assert(_Sfinae,
		"integer arithmetic overflow");
	};

	
template<intmax_t _Val>
	struct _Sign_of
	{	
	static constexpr intmax_t value = _Val < 0 ? -1 : 1;
	};

	
template<intmax_t _Ax,
	intmax_t _Bx,
	bool _Good,
	bool _Also_good>
	struct _Safe_addX
	{	
	static constexpr intmax_t value = _Ax + _Bx;
	};

template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Safe_addX<_Ax, _Bx, false, false>
	{	
	static_assert(_Always_false<_Safe_addX>::value,
		"integer arithmetic overflow");
	};

template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Safe_add
	{	
	static constexpr intmax_t value = _Safe_addX<_Ax, _Bx,
		_Sign_of<_Ax>::value != _Sign_of<_Bx>::value,
		(_Abs<_Ax>::value <= 9223372036854775807i64 - _Abs<_Bx>::value)>::value;
	};

	
template<intmax_t _Ax,
	intmax_t _Bx>
	struct _GcdX
	{	
	static constexpr intmax_t value = _GcdX<_Bx, _Ax % _Bx>::value;
	};

template<intmax_t _Ax>
	struct _GcdX<_Ax, 0>
	{	
	static constexpr intmax_t value = _Ax;
	};

template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Gcd
	{	
	static constexpr intmax_t value =
		_GcdX<_Abs<_Ax>::value, _Abs<_Bx>::value>::value;
	};

template<>
	struct _Gcd<0, 0>
	{	
	static constexpr intmax_t value = 1;	
	};

	
template<intmax_t _Nx,
	intmax_t _Dx = 1>
	struct ratio
	{	
	static_assert(_Dx != 0,
		"zero denominator");
	static_assert(-9223372036854775807i64 <= _Nx,
		"numerator too negative");
	static_assert(-9223372036854775807i64 <= _Dx,
		"denominator too negative");

	static constexpr intmax_t num = _Sign_of<_Nx>::value
		* _Sign_of<_Dx>::value * _Abs<_Nx>::value / _Gcd<_Nx, _Dx>::value;

	static constexpr intmax_t den = _Abs<_Dx>::value / _Gcd<_Nx, _Dx>
		::value;

	typedef ratio<num, den> type;
	};

	
template<class _Ty1,
	class _Ty2>
	struct _Are_ratios
		: false_type
	{	
	};

template<intmax_t _N1,
	intmax_t _D1,
	intmax_t _N2,
	intmax_t _D2>
	struct _Are_ratios<ratio<_N1, _D1>, ratio<_N2, _D2> >
		: true_type
	{	
	};

	
template<class _R1,
	class _R2>
	struct _Ratio_add
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_add<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _N1 = _R1::num;
	static constexpr intmax_t _D1 = _R1::den;
	static constexpr intmax_t _N2 = _R2::num;
	static constexpr intmax_t _D2 = _R2::den;

	static constexpr intmax_t _Gx = _Gcd<_D1, _D2>::value;

	
	typedef typename ratio<
		_Safe_add<
			_Safe_mult<_N1, _D2 / _Gx>::value,
			_Safe_mult<_N2, _D1 / _Gx>::value
			>::value,
		_Safe_mult<_D1, _D2 / _Gx>::value
		>::type type;
	};

template<class _R1,
	class _R2>
	using ratio_add = typename _Ratio_add<_R1, _R2>::type;

	
template<class _R1,
	class _R2>
	struct _Ratio_subtract
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_subtract<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _N2 = _R2::num;
	static constexpr intmax_t _D2 = _R2::den;

	typedef ratio_add<_R1, ratio<-_N2, _D2> > type;
	};

template<class _R1,
	class _R2>
	using ratio_subtract = typename _Ratio_subtract<_R1, _R2>::type;

	
template<class _R1,
	class _R2>
	struct _Ratio_multiply
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_multiply<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _N1 = _R1::num;
	static constexpr intmax_t _D1 = _R1::den;
	static constexpr intmax_t _N2 = _R2::num;
	static constexpr intmax_t _D2 = _R2::den;

	static constexpr intmax_t _Gx = _Gcd<_N1, _D2>::value;
	static constexpr intmax_t _Gy = _Gcd<_N2, _D1>::value;

	typedef _Safe_mult<_N1 / _Gx, _N2 / _Gy, true> _Num;
	typedef _Safe_mult<_D1 / _Gy, _D2 / _Gx, true> _Den;
	};

template<class _R1,
	class _R2,
	bool _Sfinae = true,
	class = void>
	struct _Ratio_multiply_sfinae
	{	
	static_assert(_Sfinae,
		"integer arithmetic overflow");
	};

template<class _R1,
	class _R2,
	bool _Sfinae>
	struct _Ratio_multiply_sfinae<_R1, _R2, _Sfinae, void_t<
		typename _Ratio_multiply<_R1, _R2>::_Num::type,
		typename _Ratio_multiply<_R1, _R2>::_Den::type> >
	{	
	typedef ratio<
		_Ratio_multiply<_R1, _R2>::_Num::value,
		_Ratio_multiply<_R1, _R2>::_Den::value> type;
	};

template<class _R1,
	class _R2>
	using ratio_multiply = typename _Ratio_multiply_sfinae<_R1, _R2, false>
		::type;

	
template<class _R1,
	class _R2>
	struct _Ratio_divide
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_divide<R1, R2> requires R1 and R2 to be ratio<>s.");

	static constexpr intmax_t _N2 = _R2::num;
	static constexpr intmax_t _D2 = _R2::den;

	typedef ratio<_D2, _N2> _R2_inverse;
	};

template<class _R1,
	class _R2,
	bool _Sfinae = true>
	using _Ratio_divide_sfinae = typename _Ratio_multiply_sfinae<
		_R1, typename _Ratio_divide<_R1, _R2>::_R2_inverse, _Sfinae>::type;

template<class _R1,
	class _R2>
	using ratio_divide = _Ratio_divide_sfinae<_R1, _R2, false>;

	
template<class _R1,
	class _R2>
	struct ratio_equal
		: _Cat_base<_R1::num == _R2::num && _R1::den == _R2::den>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct ratio_not_equal
		: integral_constant<bool, !ratio_equal<_R1, _R2>::value>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_not_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct _Ratio_less
	{	
	static constexpr intmax_t _N1 = _R1::num;
	static constexpr intmax_t _D1 = _R1::den;
	static constexpr intmax_t _N2 = _R2::num;
	static constexpr intmax_t _D2 = _R2::den;

	static constexpr intmax_t _Gn = _Gcd<_N1, _N2>::value;
	static constexpr intmax_t _Gd = _Gcd<_D1, _D2>::value;

	static constexpr intmax_t _Left = _Safe_mult<_N1 / _Gn, _D2 / _Gd>::value;
	static constexpr intmax_t _Right = _Safe_mult<_N2 / _Gn, _D1 / _Gd>::value;

	typedef integral_constant<bool, (_Left < _Right)> type;
	};

template<class _R1,
	class _R2>
	struct ratio_less
		: _Ratio_less<_R1, _R2>::type
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_less<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct ratio_less_equal
		: integral_constant<bool, !ratio_less<_R2, _R1>::value>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_less_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct ratio_greater
		: integral_constant<bool, ratio_less<_R2, _R1>::value>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_greater<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
template<class _R1,
	class _R2>
	struct ratio_greater_equal
		: integral_constant<bool, !ratio_less<_R1, _R2>::value>
	{	
	static_assert(_Are_ratios<_R1, _R2>::value,
		"ratio_greater_equal<R1, R2> requires R1 and R2 to be ratio<>s.");
	};

	
 
template<class _R1,
	class _R2>
	constexpr bool ratio_equal_v = ratio_equal<_R1, _R2>::value;
template<class _R1,
	class _R2>
	constexpr bool ratio_not_equal_v = ratio_not_equal<_R1, _R2>::value;
template<class _R1,
	class _R2>
	constexpr bool ratio_less_v = ratio_less<_R1, _R2>::value;
template<class _R1,
	class _R2>
	constexpr bool ratio_less_equal_v = ratio_less_equal<_R1, _R2>::value;
template<class _R1,
	class _R2>
	constexpr bool ratio_greater_v = ratio_greater<_R1, _R2>::value;
template<class _R1,
	class _R2>
	constexpr bool ratio_greater_equal_v = ratio_greater_equal<_R1, _R2>::value;
 #line 359 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ratio"

	

typedef ratio<1, 1000000000000000000LL> atto;
typedef ratio<1, 1000000000000000LL> femto;
typedef ratio<1, 1000000000000LL> pico;

typedef ratio<1, 1000000000> nano;
typedef ratio<1, 1000000> micro;
typedef ratio<1, 1000> milli;
typedef ratio<1, 100> centi;
typedef ratio<1, 10> deci;
typedef ratio<10, 1> deca;
typedef ratio<100, 1> hecto;
typedef ratio<1000, 1> kilo;
typedef ratio<1000000, 1> mega;
typedef ratio<1000000000, 1> giga;

typedef ratio<1000000000000LL, 1> tera;
typedef ratio<1000000000000000LL, 1> peta;
typedef ratio<1000000000000000000LL, 1> exa;
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 385 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ratio"
#line 386 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ratio"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\chrono"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {































    
#line 48 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"















    
    
#line 66 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


typedef __int64 fpos_t;




__declspec(dllimport) errno_t __cdecl _get_stream_buffer_pointers(
           FILE*   _Stream,
      char*** _Base,
      char*** _Pointer,
      int**   _Count
    );









    
    __declspec(dllimport) errno_t __cdecl clearerr_s(
          FILE* _Stream
        );

    
    __declspec(dllimport) errno_t __cdecl fopen_s(
          FILE**      _Stream,
                             char const* _FileName,
                             char const* _Mode
        );
    
    
     
    __declspec(dllimport) size_t __cdecl fread_s(
            void*  _Buffer,
                       size_t _BufferSize,
                                                                        size_t _ElementSize,
                                                                        size_t _ElementCount,
                                                                     FILE*  _Stream
        );
    
    
    __declspec(dllimport) errno_t __cdecl freopen_s(
          FILE**      _Stream,
                             char const* _FileName,
                             char const* _Mode,
                            FILE*       _OldStream
        );

     
    __declspec(dllimport) char* __cdecl gets_s(
          char*   _Buffer,
                           rsize_t _Size
        );

    
    __declspec(dllimport) errno_t __cdecl tmpfile_s(
            FILE** _Stream
        );

     
    
    __declspec(dllimport) errno_t __cdecl tmpnam_s(
          char*   _Buffer,
                           rsize_t _Size
        );

#line 137 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

__declspec(dllimport) void __cdecl clearerr(
      FILE* _Stream
    );

 

__declspec(dllimport) int __cdecl fclose(
      FILE* _Stream
    );


__declspec(dllimport) int __cdecl _fcloseall(void);

 
__declspec(dllimport) FILE* __cdecl _fdopen(
        int         _FileHandle,
      char const* _Mode
    );

 
__declspec(dllimport) int __cdecl feof(
      FILE* _Stream
    );

 
__declspec(dllimport) int __cdecl ferror(
      FILE* _Stream
    );


__declspec(dllimport) int __cdecl fflush(
      FILE* _Stream
    );

 

__declspec(dllimport) int __cdecl fgetc(
      FILE* _Stream
    );


__declspec(dllimport) int __cdecl _fgetchar(void);

 

__declspec(dllimport) int __cdecl fgetpos(
      FILE*   _Stream,
        fpos_t* _Position
    );

 

__declspec(dllimport) char* __cdecl fgets(
      char* _Buffer,
                           int   _MaxCount,
                        FILE* _Stream
    );

 
__declspec(dllimport) int __cdecl _fileno(
      FILE* _Stream
    );


__declspec(dllimport) int __cdecl _flushall(void);

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) FILE* __cdecl fopen(
      char const* _FileName,
      char const* _Mode
    );


 

__declspec(dllimport) int __cdecl fputc(
         int   _Character,
      FILE* _Stream
    );


__declspec(dllimport) int __cdecl _fputchar(
      int _Character
    );

 

__declspec(dllimport) int __cdecl fputs(
       char const* _Buffer,
      FILE*       _Stream
    );


__declspec(dllimport) size_t __cdecl fread(
      void*  _Buffer,
                                                  size_t _ElementSize,
                                                  size_t _ElementCount,
                                               FILE*  _Stream
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "freopen_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) FILE* __cdecl freopen(
       char const* _FileName,
       char const* _Mode,
      FILE*       _Stream
    );

 
__declspec(dllimport) FILE* __cdecl _fsopen(
      char const* _FileName,
      char const* _Mode,
        int         _ShFlag
    );

 

__declspec(dllimport) int __cdecl fsetpos(
      FILE*         _Stream,
         fpos_t const* _Position
    );

 

__declspec(dllimport) int __cdecl fseek(
      FILE* _Stream,
         long  _Offset,
         int   _Origin
    );

 

__declspec(dllimport) int __cdecl _fseeki64(
      FILE*   _Stream,
         __int64 _Offset,
         int     _Origin
    );

 
 
__declspec(dllimport) long __cdecl ftell(
      FILE* _Stream
    );

 
 
__declspec(dllimport) __int64 __cdecl _ftelli64(
      FILE* _Stream
    );


__declspec(dllimport) size_t __cdecl fwrite(
      void const* _Buffer,
                                                size_t      _ElementSize,
                                                size_t      _ElementCount,
                                             FILE*       _Stream
    );

 
 
__declspec(dllimport) int __cdecl getc(
      FILE* _Stream
    );

 
__declspec(dllimport) int __cdecl getchar(void);

 
__declspec(dllimport) int __cdecl _getmaxstdio(void);

extern "C++" { template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw() { return gets_s(_Buffer, _Size); } }
#line 311 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__declspec(dllimport) int __cdecl _getw(
      FILE* _Stream
    );

__declspec(dllimport) void __cdecl perror(
      char const* _ErrorMessage
    );



     
    
    __declspec(dllimport) int __cdecl _pclose(
          FILE* _Stream
        );

     
    __declspec(dllimport) FILE* __cdecl _popen(
          char const* _Command,
          char const* _Mode
        );

#line 336 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__declspec(dllimport) int __cdecl putc(
         int   _Character,
      FILE* _Stream
    );


__declspec(dllimport) int __cdecl putchar(
      int _Character
    );


__declspec(dllimport) int __cdecl puts(
      char const* _Buffer
    );

 

__declspec(dllimport) int __cdecl _putw(
         int   _Word, 
      FILE* _Stream
    );



__declspec(dllimport) int __cdecl remove(
      char const* _FileName
    );

 
__declspec(dllimport) int __cdecl rename(
      char const* _OldFileName,
      char const* _NewFileName
    );

__declspec(dllimport) int __cdecl _unlink(
      char const* _FileName
    );



    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_unlink" ". See online help for details."))
    __declspec(dllimport) int __cdecl unlink(
          char const* _FileName
        );

#line 385 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



__declspec(dllimport) void __cdecl rewind(
      FILE* _Stream
    );


__declspec(dllimport) int __cdecl _rmtmp(void);

__declspec(deprecated("This function or variable may be unsafe. Consider using " "setvbuf" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) void __cdecl setbuf(
                                                  FILE* _Stream,
        char* _Buffer
    );


__declspec(dllimport) int __cdecl _setmaxstdio(
      int _Maximum
    );

 

__declspec(dllimport) int __cdecl setvbuf(
                           FILE*  _Stream,
        char*  _Buffer,
                              int    _Mode,
                              size_t _Size
    );




#line 419 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(
      char const* _DirectoryName,
      char const* _FilePrefix
    );



#line 429 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpfile_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) FILE* __cdecl tmpfile(void);

extern "C++" { template <size_t _Size> inline errno_t __cdecl tmpnam_s(  char (&_Buffer)[_Size]) throw() { return tmpnam_s(_Buffer, _Size); } }
#line 437 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "tmpnam_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl tmpnam(  char *_Buffer);
#line 443 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__declspec(dllimport) int __cdecl ungetc(
         int   _Character,
      FILE* _Stream
    );








__declspec(dllimport) void __cdecl _lock_file(
      FILE* _Stream
    );

__declspec(dllimport) void __cdecl _unlock_file(
      FILE* _Stream
    );

 

__declspec(dllimport) int __cdecl _fclose_nolock(
      FILE* _Stream
    );

 

__declspec(dllimport) int __cdecl _fflush_nolock(
      FILE* _Stream
    );

 

__declspec(dllimport) int __cdecl _fgetc_nolock(
      FILE* _Stream
    );

 

__declspec(dllimport) int __cdecl _fputc_nolock(
         int   _Character,
      FILE* _Stream
    );


__declspec(dllimport) size_t __cdecl _fread_nolock(
      void*  _Buffer,
                                                  size_t _ElementSize,
                                                  size_t _ElementCount,
                                               FILE*  _Stream
    );


 
__declspec(dllimport) size_t __cdecl _fread_nolock_s(
      void*  _Buffer,
               size_t _BufferSize,
                                                                  size_t _ElementSize,
                                                                  size_t _ElementCount,
                                                               FILE*  _Stream
    );


__declspec(dllimport) int __cdecl _fseek_nolock(
      FILE* _Stream,
         long  _Offset,
         int   _Origin
    );


__declspec(dllimport) int __cdecl _fseeki64_nolock(
      FILE*   _Stream,
         __int64 _Offset,
         int     _Origin
    );

 
__declspec(dllimport) long __cdecl _ftell_nolock(
      FILE* _Stream
    );

 
__declspec(dllimport) __int64 __cdecl _ftelli64_nolock(
      FILE* _Stream
    );


__declspec(dllimport) size_t __cdecl _fwrite_nolock(
      void const* _Buffer,
                                                size_t      _ElementSize,
                                                size_t      _ElementCount,
                                             FILE*       _Stream
    );


__declspec(dllimport) int __cdecl _getc_nolock(
      FILE* _Stream
    );


__declspec(dllimport) int __cdecl _putc_nolock(
         int   _Character,
      FILE* _Stream
    );


__declspec(dllimport) int __cdecl _ungetc_nolock(
         int   _Character,
      FILE* _Stream
    );






















#line 580 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



__declspec(dllimport) int* __cdecl __p__commode(void);




    
#line 590 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"






#line 597 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"






__declspec(dllimport) int __cdecl __stdio_common_vfprintf(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

__declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
__declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(
                                         unsigned __int64 _Options,
                                      FILE*            _Stream,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );


__inline int __cdecl _vfprintf_l(
       FILE*       const _Stream,
        char const* const _Format,
      _locale_t   const _Locale,
             va_list           _ArgList
    )


#line 638 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 642 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vfprintf(
                            FILE*       const _Stream,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 652 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_l(_Stream, _Format, 0, _ArgList);
}
#line 656 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vfprintf_s_l(
       FILE*       const _Stream,
        char const* const _Format,
      _locale_t   const _Locale,
             va_list           _ArgList
    )


#line 667 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 671 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl vfprintf_s(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 683 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
    }
#line 687 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 689 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vfprintf_p_l(
       FILE*       const _Stream,
        char const* const _Format,
      _locale_t   const _Locale,
             va_list           _ArgList
    )


#line 700 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
}
#line 704 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vfprintf_p(
                            FILE*       const _Stream,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 714 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
}
#line 718 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vprintf_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 728 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 732 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vprintf(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 741 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}
#line 745 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vprintf_s_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 755 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 759 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl vprintf_s(
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 770 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }
#line 774 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 776 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vprintf_p_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 786 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
}
#line 790 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vprintf_p(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 799 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
}
#line 803 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _fprintf_l(
                                      FILE*       const _Stream,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 813 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 822 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl fprintf(
                            FILE*       const _Stream,
        char const* const _Format,
    ...)


#line 831 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 840 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

__declspec(dllimport) int __cdecl _set_printf_count_output(
      int _Value
    );

__declspec(dllimport) int __cdecl _get_printf_count_output(void);


__inline int __cdecl _fprintf_s_l(
                                      FILE*       const _Stream,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 856 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 865 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl fprintf_s(
                                FILE*       const _Stream,
            char const* const _Format,
        ...)


#line 876 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 885 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 887 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _fprintf_p_l(
                                      FILE*       const _Stream,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 897 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 906 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _fprintf_p(
                            FILE*       const _Stream,
        char const* const _Format,
    ...)


#line 915 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 924 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _printf_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 933 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 942 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl printf(
        char const* const _Format,
    ...)


#line 950 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 959 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _printf_s_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 968 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 977 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl printf_s(
            char const* const _Format,
        ...)


#line 987 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 996 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 998 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _printf_p_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1007 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1016 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _printf_p(
        char const* const _Format,
    ...)


#line 1024 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1033 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"







__declspec(dllimport) int __cdecl __stdio_common_vfscanf(
                                        unsigned __int64 _Options,
                                     FILE*            _Stream,
        char const*      _Format,
                                    _locale_t        _Locale,
                                           va_list          _Arglist
    );


__inline int __cdecl _vfscanf_l(
                            FILE*       const _Stream,
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 1058 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfscanf(
        (*__local_stdio_scanf_options ()),
        _Stream, _Format, _Locale, _ArgList);
}
#line 1064 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vfscanf(
                            FILE*       const _Stream,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1074 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfscanf_l(_Stream, _Format, 0, _ArgList);
}
#line 1078 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vfscanf_s_l(
                            FILE*       const _Stream,
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 1089 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vfscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Stream, _Format, _Locale, _ArgList);
}
#line 1095 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"




    
    __inline int __cdecl vfscanf_s(
                                FILE*       const _Stream,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 1108 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
    }
#line 1112 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1114 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vscanf_l(
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 1124 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}
#line 1128 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vscanf(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1137 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
}
#line 1141 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vscanf_s_l(
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 1151 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
}
#line 1155 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl vscanf_s(
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 1166 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }
#line 1170 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1172 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_fscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _fscanf_l(
                                     FILE*       const _Stream,
        char const* const _Format,
                                    _locale_t   const _Locale,
    ...)


#line 1182 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1191 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "fscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl fscanf(
                           FILE*       const _Stream,
        char const* const _Format,
    ...)


#line 1200 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1209 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _fscanf_s_l(
                                       FILE*       const _Stream,
        char const* const _Format,
                                      _locale_t   const _Locale,
    ...)


#line 1219 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1228 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl fscanf_s(
                                 FILE*       const _Stream,
            char const* const _Format,
        ...)


#line 1239 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 1248 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1250 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_scanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _scanf_l(
        char const* const _Format,
                                    _locale_t   const _Locale,
    ...)


#line 1259 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1268 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "scanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl scanf(
        char const* const _Format,
    ...)


#line 1276 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1285 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _scanf_s_l(
        char const* const _Format,
                                      _locale_t   const _Locale,
    ...)


#line 1294 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1303 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl scanf_s(
            char const* const _Format,
        ...)


#line 1313 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 1322 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1324 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"








 
__declspec(dllimport) int __cdecl __stdio_common_vsprintf(
                                         unsigned __int64 _Options,
                 char*            _Buffer,
                                         size_t           _BufferCount,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
__declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(
                                         unsigned __int64 _Options,
                 char*            _Buffer,
                                         size_t           _BufferCount,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
__declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(
                                         unsigned __int64 _Options,
                 char*            _Buffer,
                                         size_t           _BufferCount,
                                         size_t           _MaxCount,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
__declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(
                                         unsigned __int64 _Options,
                 char*            _Buffer,
                                         size_t           _BufferCount,
        char const*      _Format,
                                     _locale_t        _Locale,
                                            va_list          _ArgList
    );

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsnprintf_l(
                   char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1385 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1393 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsnprintf(
        char*       const _Buffer,
                                          size_t      const _BufferCount,
                   char const* const _Format,
                                             va_list           _ArgList
    )


#line 1405 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    #pragma warning(pop)
}
#line 1412 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"










#line 1423 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl vsnprintf(
         char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1435 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        _Buffer, _BufferCount, _Format, 0, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1443 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _vsprintf_l(
        char*       const _Buffer,
                      char const* const _Format,
                    _locale_t   const _Locale,
                           va_list           _ArgList
    )


#line 1455 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    #pragma warning(pop)
}
#line 1462 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl vsprintf(
               char*       const _Buffer,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1473 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    #pragma warning(push)
    #pragma warning(disable: 4996) 
    return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    #pragma warning(pop)
}
#line 1480 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsprintf_s_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1493 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1501 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



     
    
    __inline int __cdecl vsprintf_s(
           char*       const _Buffer,
                                   size_t      const _BufferCount,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 1515 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }
#line 1519 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    
    extern "C++" { template <size_t _Size> inline   int __cdecl vsprintf_s(  char (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 1527 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1529 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsprintf_p_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1542 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf_p(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1550 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsprintf_p(
       char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1562 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1566 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsnprintf_s_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
                                         size_t      const _MaxCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list          _ArgList
    )


#line 1580 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsnprintf_s(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1588 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsnprintf_s(
       char*       const _Buffer,
                               size_t      const _BufferCount,
                               size_t      const _MaxCount,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1601 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
}
#line 1605 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

extern "C++" { template <size_t _Size> inline   int __cdecl _vsnprintf_s(  char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1614 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



     
    
    __inline int __cdecl vsnprintf_s(
           char*       const _Buffer,
                                   size_t      const _BufferCount,
                                   size_t      const _MaxCount,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 1629 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }
#line 1633 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    
    extern "C++" { template <size_t _Size> inline   int __cdecl vsnprintf_s(  char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, va_list _ArgList) throw() { return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } }
#line 1642 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1644 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vscprintf_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1654 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1662 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _vscprintf(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1671 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vscprintf_l(_Format, 0, _ArgList);
}
#line 1675 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vscprintf_p_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1685 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf_p(
        (*__local_stdio_printf_options()) | (1ULL << 1),
        0, 0, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1693 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _vscprintf_p(
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1702 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vscprintf_p_l(_Format, 0, _ArgList);
}
#line 1706 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vsnprintf_c_l(
                   char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
                                            va_list           _ArgList
    )


#line 1718 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int const _Result = __stdio_common_vsprintf(
        (*__local_stdio_printf_options()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    return _Result < 0 ? -1 : _Result;
}
#line 1726 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _vsnprintf_c(
         char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 1738 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
}
#line 1742 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _sprintf_l(
                         char*       const _Buffer,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1752 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1766 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl sprintf(
               char*       const _Buffer,
        char const* const _Format,
    ...)


#line 1776 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1790 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable: 4996)
__declspec(deprecated("This function or variable may be unsafe. Consider using " "sprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl sprintf(  char *_Buffer,  char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "vsprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))   int __cdecl vsprintf(  char *_Buffer,  char const* _Format, va_list _Args);
#line 1799 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
#pragma warning(pop)

 

__inline int __cdecl _sprintf_s_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1812 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1821 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



     
    
    __inline int __cdecl sprintf_s(
           char*       const _Buffer,
                                   size_t      const _BufferCount,
            char const* const _Format,
        ...)


#line 1834 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 1843 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 1845 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline int __cdecl sprintf_s(  char (&_Buffer)[_Size],     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return vsprintf_s(_Buffer, _Size, _Format, _ArgList); } __pragma(warning(pop)); }
#line 1851 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _sprintf_p_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1863 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1872 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _sprintf_p(
       char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
    ...)


#line 1883 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1892 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snprintf_l(
                   char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1904 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    #pragma warning(push)
    #pragma warning(disable: 4996) 
    _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    #pragma warning(pop)

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1918 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"










#line 1929 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
 
__inline int __cdecl snprintf(
       char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
    ...)


#line 1940 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
#pragma warning(suppress:28719)    
    _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1950 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _snprintf(
        char*       const _Buffer,
                                          size_t      const _BufferCount,
                   char const* const _Format,
    ...)


#line 1960 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
#pragma warning(suppress:28719)    
    _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 1970 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_snprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _snprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, ...); __declspec(deprecated("This function or variable may be unsafe. Consider using " "_vsnprintf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))    int __cdecl _vsnprintf(    char *_Buffer,   size_t _BufferCount,     char const* _Format, va_list _Args);
#line 1979 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _snprintf_c_l(
                   char*       const _Buffer,
                                         size_t      const _BufferCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 1991 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2000 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _snprintf_c(
         char*       const _Buffer,
                               size_t      const _BufferCount,
        char const* const _Format,
    ...)


#line 2011 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2020 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _snprintf_s_l(
                 char*       const _Buffer,
                                         size_t      const _BufferCount,
                                         size_t      const _MaxCount,
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 2033 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2042 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 

__inline int __cdecl _snprintf_s(
       char*       const _Buffer,
                               size_t      const _BufferCount,
                               size_t      const _MaxCount,
        char const* const _Format,
    ...)


#line 2054 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2063 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

extern "C++" { __pragma(warning(push)); __pragma(warning(disable: 4793)); template <size_t _Size> inline   int __cdecl _snprintf_s(  char (&_Buffer)[_Size],   size_t _BufferCount,     char const* _Format, ...) throw() { va_list _ArgList; ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1)))))); return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList); } __pragma(warning(pop)); }
#line 2071 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _scprintf_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 2080 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2089 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _scprintf(
        char const* const _Format,
    ...)


#line 2097 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_l(_Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2106 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _scprintf_p_l(
        char const* const _Format,
                                     _locale_t   const _Locale,
    ...)


#line 2115 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2124 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 
__inline int __cdecl _scprintf_p(
        char const* const _Format,
    ...)


#line 2132 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vscprintf_p(_Format, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2141 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"






__declspec(dllimport) int __cdecl __stdio_common_vsscanf(
                                        unsigned __int64 _Options,
              char const*      _Buffer,
                                        size_t           _BufferCount,
        char const*      _Format,
                                    _locale_t        _Locale,
                                           va_list          _ArgList
    );


__inline int __cdecl _vsscanf_l(
                             char const* const _Buffer,
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 2166 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 2172 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl vsscanf(
                             char const* const _Buffer,
        char const* const _Format,
                                  va_list           _ArgList
    )


#line 2182 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
}
#line 2186 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _vsscanf_s_l(
                             char const* const _Buffer,
        char const* const _Format,
                           _locale_t   const _Locale,
                                  va_list           _ArgList
    )


#line 2197 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    return __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
}
#line 2203 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    #pragma warning(push)
    #pragma warning(disable:6530)

    
    __inline int __cdecl vsscanf_s(
                                 char const* const _Buffer,
            char const* const _Format,
                                      va_list           _ArgList
        )


#line 2218 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }
#line 2222 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

    extern "C++" { template <size_t _Size> inline int __cdecl vsscanf_s(  char const (&_Buffer)[_Size],     char const* _Format, va_list _ArgList) throw() { return vsscanf_s(_Buffer, _Size, _Format, _ArgList); } }
#line 2229 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
   
    #pragma warning(pop)

#line 2233 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_sscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _sscanf_l(
                                      char const* const _Buffer,
        char const* const _Format,
                                    _locale_t   const _Locale,
    ...)


#line 2243 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2252 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "sscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl sscanf(
                            char const* const _Buffer,
        char const* const _Format,
    ...)


#line 2261 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2270 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _sscanf_s_l(
                                        char const* const _Buffer,
        char const* const _Format,
                                      _locale_t   const _Locale,
    ...)


#line 2280 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));
    _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2289 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



    
    __inline int __cdecl sscanf_s(
                                  char const* const _Buffer,
            char const* const _Format,
        ...)


#line 2300 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

        #pragma warning(push)
        #pragma warning(disable: 4996) 
        _Result = vsscanf_s(_Buffer, _Format, _ArgList);
        #pragma warning(pop)

        ((void)(_ArgList = (va_list)0));
        return _Result;
    }
#line 2314 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#line 2316 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#pragma warning(push)
#pragma warning(disable:6530)

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snscanf_l(
        char const* const _Buffer,
                                        size_t      const _BufferCount,
        char const* const _Format,
                                    _locale_t   const _Locale,
    ...)


#line 2330 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2343 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

 __declspec(deprecated("This function or variable may be unsafe. Consider using " "_snscanf_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__inline int __cdecl _snscanf(
        char const* const _Buffer,
                                        size_t      const _BufferCount,
                  char const* const _Format,
    ...)


#line 2353 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()),
        _Buffer, _BufferCount, _Format, 0, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2366 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



__inline int __cdecl _snscanf_s_l(
          char const* const _Buffer,
                                          size_t      const _BufferCount,
        char const* const _Format,
                                      _locale_t   const _Locale,
    ...)


#line 2378 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Locale)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))) + ((sizeof(_Locale) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, _Locale, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2391 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"


__inline int __cdecl _snscanf_s(
        char const* const _Buffer,
                                        size_t      const _BufferCount,
                char const* const _Format,
    ...)


#line 2401 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"
{
    int _Result;
    va_list _ArgList;
    ((void)(__vcrt_va_start_verify_argument_type<decltype(_Format)>(), ((void)(_ArgList = (va_list)(&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))) + ((sizeof(_Format) + sizeof(int) - 1) & ~(sizeof(int) - 1))))));

    _Result = __stdio_common_vsscanf(
        (*__local_stdio_scanf_options ()) | (1ULL << 0),
        _Buffer, _BufferCount, _Format, 0, _ArgList);

    ((void)(_ArgList = (va_list)0));
    return _Result;
}
#line 2414 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

#pragma warning(pop)



#line 2420 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"










    

    


#line 2436 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tempnam" ". See online help for details."))
    __declspec(dllimport) char* __cdecl tempnam(
          char const* _Directory,
          char const* _FilePrefix
        );

    

#line 2446 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"

     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fcloseall" ". See online help for details.")) __declspec(dllimport) int   __cdecl fcloseall(void);
          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fdopen" ". See online help for details."))    __declspec(dllimport) FILE* __cdecl fdopen(  int _FileHandle,   char const* _Format);
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fgetchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fgetchar(void);
          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fileno" ". See online help for details."))    __declspec(dllimport) int   __cdecl fileno(  FILE* _Stream);
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_flushall" ". See online help for details."))  __declspec(dllimport) int   __cdecl flushall(void);
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_fputchar" ". See online help for details."))  __declspec(dllimport) int   __cdecl fputchar(  int _Ch);
          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_getw" ". See online help for details."))      __declspec(dllimport) int   __cdecl getw(  FILE* _Stream);
     __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_putw" ". See online help for details."))      __declspec(dllimport) int   __cdecl putw(  int _Ch,   FILE* _Stream);
          __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_rmtmp" ". See online help for details."))     __declspec(dllimport) int   __cdecl rmtmp(void);

#line 2458 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\stdio.h"



} __pragma(pack(pop))

#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"


 
 
 
 
 
 
 

 
 
 
 

  

typedef FILE FILE;

 
namespace std {
using :: FILE; using :: _Mbstatet;

using :: size_t; using :: fpos_t; using :: FILE;
using :: clearerr; using :: fclose; using :: feof;
using :: ferror; using :: fflush; using :: fgetc;
using :: fgetpos; using :: fgets; using :: fopen;
using :: fprintf; using :: fputc; using :: fputs;
using :: fread; using :: freopen; using :: fscanf;
using :: fseek; using :: fsetpos; using :: ftell;
using :: fwrite; using :: getc; using :: getchar;
using :: perror;
using :: putc; using :: putchar;
using :: printf; using :: puts; using :: remove;
using :: rename; using :: rewind; using :: scanf;
using :: setbuf; using :: setvbuf; using :: sprintf;
using :: sscanf; using :: tmpfile; using :: tmpnam;
using :: ungetc; using :: vfprintf; using :: vprintf;
using :: vsprintf;

using :: snprintf; using :: vsnprintf;
using :: vfscanf; using :: vscanf; using :: vsscanf;
}
 #line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"

#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdio"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"

#pragma once










 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"







#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"










#pragma once







__pragma(pack(push, 8)) extern "C" {



 
__declspec(dllimport) int __cdecl _memicmp(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size
    );

 
__declspec(dllimport) int __cdecl _memicmp_l(
      void const* _Buf1,
      void const* _Buf2,
                             size_t      _Size,
                         _locale_t   _Locale
    );





    












#line 56 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"

    












#line 71 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"

#line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"




    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memccpy" ". See online help for details."))
    __declspec(dllimport) void* __cdecl memccpy(
          void*       _Dst,
            void const* _Src,
                                   int         _Val,
                                   size_t      _Size
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_memicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl memicmp(
          void const* _Buf1,
          void const* _Buf2,
                                 size_t      _Size
        );
#line 92 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"




    extern "C++"  
    inline void* __cdecl memchr(
          void*  _Pv,
                              int    _C,
                              size_t _N
        )
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }
#line 107 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"



} __pragma(pack(pop))

#line 113 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_memory.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"





__pragma(pack(push, 8)) extern "C" {







     
    __declspec(dllimport) errno_t __cdecl strcpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
                                char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strcat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
                                   char const* _Source
        );

    
    __declspec(dllimport) errno_t __cdecl strerror_s(
          char*  _Buffer,
                                  size_t _SizeInBytes,
                                  int    _ErrorNumber);

    
    __declspec(dllimport) errno_t __cdecl strncat_s(
          char*       _Destination,
                                     rsize_t     _SizeInBytes,
               char const* _Source,
                                     rsize_t     _MaxCount
        );

    
    __declspec(dllimport) errno_t __cdecl strncpy_s(
          char*       _Destination,
                                  rsize_t     _SizeInBytes,
            char const* _Source,
                                  rsize_t     _MaxCount
        );

     
    __declspec(dllimport) char*  __cdecl strtok_s(
                          char*       _String,
                                 char const* _Delimiter,
            char**      _Context
        );

#line 70 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(dllimport) void* __cdecl _memccpy(
      void*       _Dst,
                                   void const* _Src,
                                   int         _Val,
                                   size_t      _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcat_s(char (&_Destination)[_Size],   char const* _Source) throw() { return strcat_s(_Destination, _Size, _Source); } }
#line 83 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"



    __declspec(deprecated("This function or variable may be unsafe. Consider using " "strcat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcat( char *_Destination,  char const* _Source);
#line 91 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

#line 93 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
int __cdecl strcmp(
      char const* _Str1,
      char const* _Str2
    );

 
__declspec(dllimport) int __cdecl _strcmpi(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl strcoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _strcoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

char* __cdecl strcpy(
      char*       _Dest,
                                            char const* _Source
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strcpy_s(  char (&_Destination)[_Size],   char const* _Source) throw() { return strcpy_s(_Destination, _Size, _Source); } }
#line 129 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strcpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl strcpy( char *_Destination,  char const* _Source);
#line 135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
__declspec(dllimport) size_t __cdecl strcspn(
      char const* _Str,
      char const* _Control
    );




#line 146 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
__declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(
      char const* _Source
    );



#line 155 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char*  __cdecl _strerror(
      char const* _ErrorMessage
    );


__declspec(dllimport) errno_t __cdecl _strerror_s(
      char*       _Buffer,
                              size_t      _SizeInBytes,
                        char const* _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size],   char const* _ErrorMessage) throw() { return _strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 175 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strerror_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strerror(
      int _ErrorMessage
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size],   int _ErrorMessage) throw() { return strerror_s(_Buffer, _Size, _ErrorMessage); } }
#line 187 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl _stricmp(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll(
      char const* _String1,
      char const* _String2
    );

 
__declspec(dllimport) int __cdecl _stricoll_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _stricmp_l(
        char const* _String1,
        char const* _String2,
      _locale_t   _Locale
    );

 
size_t __cdecl strlen(
      char const* _Str
    );


__declspec(dllimport) errno_t __cdecl _strlwr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s(  char (&_String)[_Size]) throw() { return _strlwr_s(_String, _Size); } }
#line 229 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr( char *_String);
#line 234 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strlwr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strlwr_s_l(_String, _Size, _Locale); } }
#line 247 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strlwr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l(  char *_String,   _locale_t _Locale);
#line 254 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(dllimport) char* __cdecl strncat(
      char*       _Dest,
        char const* _Source,
                           size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncat_s(  char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncat_s(_Destination, _Size, _Source, _Count); } }
#line 267 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncat_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncat(  char *_Destination,   char const* _Source,   size_t _Count);
#line 275 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
__declspec(dllimport) int __cdecl strncmp(
      char const* _Str1,
      char const* _Str2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicmp_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strnicoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strnicoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

 
__declspec(dllimport) int __cdecl _strncoll(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount
    );

 
__declspec(dllimport) int __cdecl _strncoll_l(
      char const* _String1,
      char const* _String2,
                            size_t      _MaxCount,
                        _locale_t   _Locale
    );

__declspec(dllimport) size_t __cdecl __strncnt(
      char const* _String,
                         size_t      _Count
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size],   char const* _Source,   size_t _Count) throw() { return strncpy_s(_Destination, _Size, _Source, _Count); } }
#line 339 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "strncpy_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy(    char *_Destination,   char const* _Source,   size_t _Count);
#line 347 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 

#line 353 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

#line 357 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"
__declspec(dllimport) size_t __cdecl strnlen(
      char const* _String,
                            size_t      _MaxCount
    );



     
    
#line 369 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"
    
#line 373 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"
    static __inline size_t __cdecl strnlen_s(
          char const* _String,
                                size_t      _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

#line 382 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(dllimport) char* __cdecl _strnset(
      char*  _Dest,
                           int    _Val,
                           size_t _Count
    );


__declspec(dllimport) errno_t __cdecl _strnset_s(
      char*  _String,
                                 size_t _SizeInBytes,
                                 int    _Value,
                                 size_t _MaxCount
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strnset_s(  char (&_Destination)[_Size],   int _Value,   size_t _Count) throw() { return _strnset_s(_Destination, _Size, _Value, _Count); } }
#line 403 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strnset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset(  char *_Destination,   int _Value,   size_t _Count);
#line 411 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 
__declspec(dllimport) char const* __cdecl strpbrk(
      char const* _Str,
      char const* _Control
    );

__declspec(dllimport) char* __cdecl _strrev(
      char* _Str
    );


__declspec(dllimport) errno_t __cdecl _strset_s(
      char*  _Destination,
                                     size_t _DestinationSize,
                                     int    _Value
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strset_s(  char (&_Destination)[_Size],   int _Value) throw() { return _strset_s(_Destination, _Size, _Value); } }
#line 434 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strset_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))  char* __cdecl _strset( char *_Destination,  int _Value);
#line 440 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

char* __cdecl _strset(
      char* _Dest,
           int   _Value
    );

 
__declspec(dllimport) size_t __cdecl strspn(
      char const* _Str,
      char const* _Control
    );

  __declspec(deprecated("This function or variable may be unsafe. Consider using " "strtok_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl strtok(
      char*       _String,
             char const* _Delimiter
    );


__declspec(dllimport) errno_t __cdecl _strupr_s(
      char*  _String,
                          size_t _Size
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s(  char (&_String)[_Size]) throw() { return _strupr_s(_String, _Size); } }
#line 468 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr( char *_String);
#line 473 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"


__declspec(dllimport) errno_t __cdecl _strupr_s_l(
      char*     _String,
                          size_t    _Size,
                      _locale_t _Locale
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strupr_s_l(  char (&_String)[_Size],   _locale_t _Locale) throw() { return _strupr_s_l(_String, _Size, _Locale); } }
#line 486 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strupr_s_l" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l(  char *_String,   _locale_t _Locale);
#line 493 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

 

__declspec(dllimport) size_t __cdecl strxfrm(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount
    );

 

__declspec(dllimport) size_t __cdecl _strxfrm_l(
        char*       _Destination,
                                         char const* _Source,
                 size_t      _MaxCount,
                                       _locale_t   _Locale
    );




extern "C++"
{
     
    inline char* __cdecl strchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
    }

     
    inline char* __cdecl strpbrk(  char* const _String,   char const* const _Control)
    {
        return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
    }

     
    inline char* __cdecl strrchr(  char* const _String,   int const _Ch)
    {
        return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
    }

       
    inline char* __cdecl strstr(  char* const _String,   char const* const _SubString)
    {
        return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
    }
}
#line 541 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"





    


#line 550 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strdup" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strdup(
          char const* _String
        );

    

#line 559 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"

    
      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strcmpi" ". See online help for details."))
    __declspec(dllimport) int __cdecl strcmpi(
          char const* _String1,
          char const* _String2
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_stricmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl stricmp(
          char const* _String1,
          char const* _String2
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strlwr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strlwr(
          char* _String
        );

      __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnicmp" ". See online help for details."))
    __declspec(dllimport) int __cdecl strnicmp(
          char const* _String1,
          char const* _String2,
                                size_t      _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strnset" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strnset(
          char*  _String,
                                  int    _Value,
                                  size_t _MaxCount
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strrev" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strrev(
          char* _String
        );

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strset" ". See online help for details."))
    char* __cdecl strset(
          char* _String,
               int   _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_strupr" ". See online help for details."))
    __declspec(dllimport) char* __cdecl strupr(
          char* _String
        );

#line 608 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"



} __pragma(pack(pop))

#line 614 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\string.h"
#line 14 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"

 
namespace std {
using :: size_t; using :: memchr; using :: memcmp;
using :: memcpy; using :: memmove; using :: memset;
using :: strcat; using :: strchr; using :: strcmp;
using :: strcoll; using :: strcpy; using :: strcspn;
using :: strerror; using :: strlen; using :: strncat;
using :: strncmp; using :: strncpy; using :: strpbrk;
using :: strrchr; using :: strspn; using :: strstr;
using :: strtok; using :: strxfrm;
}
 #line 28 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"

#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstring"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"







#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"


extern "C++" {

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable: 4985) 






    namespace std
    {
        struct nothrow_t { };

        extern nothrow_t const nothrow;
    }
#line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"

   
__declspec(allocator) void* __cdecl operator new(
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new(
    size_t                _Size,
    std::nothrow_t const&
    ) throw();

   
__declspec(allocator) void* __cdecl operator new[](
    size_t _Size
    );

     
__declspec(allocator) void* __cdecl operator new[](
    size_t                _Size,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void* _Block
    ) throw();

void __cdecl operator delete(
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete[](
    void* _Block
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    std::nothrow_t const&
    ) throw();

void __cdecl operator delete(
    void*  _Block,
    size_t _Size
    ) throw();

void __cdecl operator delete[](
    void* _Block,
    size_t _Size
    ) throw();


    
       
    inline void* __cdecl operator new(size_t _Size,   void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) throw()
    {
        return;
    }
#line 97 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"


    
       
    inline void* __cdecl operator new[](size_t _Size,   void* _Where) throw()
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) throw()
    {
    }
#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"



#pragma warning(pop)
#pragma pack(pop)

} 
#line 119 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new.h"
#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"


extern "C++" {

#pragma pack(push, 8)






         
    __declspec(allocator) void* __cdecl operator new(
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

         
    __declspec(allocator) void* __cdecl operator new[](
            size_t      _Size,
            int         _BlockUse,
          char const* _FileName,
            int         _LineNumber
        );

    void __cdecl operator delete(
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

    void __cdecl operator delete[](
        void*       _Block,
        int         _BlockUse,
        char const* _FileName,
        int         _LineNumber
        ) throw();

#line 53 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"



#pragma pack(pop)

} 
#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_new_debug.h"
#line 13 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

__pragma(pack(push, 8)) extern "C" {



typedef void* _HFILE; 

























typedef int (__cdecl* _CRT_REPORT_HOOK )(int, char*,    int*);
typedef int (__cdecl* _CRT_REPORT_HOOKW)(int, wchar_t*, int*);





typedef int (__cdecl* _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);























































typedef void (__cdecl* _CRT_DUMP_CLIENT)(void*, size_t);





struct _CrtMemBlockHeader;

typedef struct _CrtMemState
{
    struct _CrtMemBlockHeader* pBlockHeader;
    size_t lCounts[5];
    size_t lSizes[5];
    size_t lHighWaterCount;
    size_t lTotalCount;
} _CrtMemState;


























    

        __declspec(dllimport) int*  __cdecl __p__crtDbgFlag(void);
        __declspec(dllimport) long* __cdecl __p__crtBreakAlloc(void);

        
        

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtGetAllocHook(void);

        __declspec(dllimport) _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
              _CRT_ALLOC_HOOK _PfnNewHook
            );

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtGetDumpClient(void);

        __declspec(dllimport) _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
              _CRT_DUMP_CLIENT _PFnNewDump
            );

    #line 170 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

    __declspec(dllimport) int __cdecl _CrtCheckMemory(void);

    typedef void (__cdecl* _CrtDoForAllClientObjectsCallback)(void*, void*);

    __declspec(dllimport) void __cdecl _CrtDoForAllClientObjects(
          _CrtDoForAllClientObjectsCallback _Callback,
          void*                             _Context
        );

    __declspec(dllimport) int __cdecl _CrtDumpMemoryLeaks(void);

    __declspec(dllimport) int __cdecl _CrtIsMemoryBlock(
           void const*  _Block,
               unsigned int _Size,
          long*        _RequestNumber,
          char**       _FileName,
          int*         _LineNumber
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidHeapPointer(
          void const* _Pointer
        );

     
    __declspec(dllimport) int __cdecl _CrtIsValidPointer(
          void const*  _Pointer,
              unsigned int _Size,
              int          _ReadWrite
        );

    __declspec(dllimport) void __cdecl _CrtMemCheckpoint(
          _CrtMemState* _State
        );

    __declspec(dllimport) int __cdecl _CrtMemDifference(
          _CrtMemState*       _State,
           _CrtMemState const* _OldState,
           _CrtMemState const* _NewState
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpAllObjectsSince(
          _CrtMemState const* _State
        );

    __declspec(dllimport) void __cdecl _CrtMemDumpStatistics(
          _CrtMemState const* _State
        );

     
    __declspec(dllimport) int __cdecl _CrtReportBlockType(
          void const* _Block
        );

    __declspec(dllimport) long __cdecl _CrtSetBreakAlloc(
          long _NewValue
        );

    __declspec(dllimport) int __cdecl _CrtSetDbgFlag(
          int _NewFlag
        );

#line 234 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"
















































    












































    __declspec(dllimport) void __cdecl _aligned_free_dbg(
            void* _Block
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _aligned_msize_dbg(
          void*  _Block,
                   size_t _Alignment,
                   size_t _Offset
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_malloc_dbg(
                size_t      _Size,
                size_t      _Alignment,
                size_t      _Offset,
          char const* _FileName,
                int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_offset_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                                    size_t      _Offset,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _aligned_recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    size_t      _Alignment,
                              char const* _FileName,
                                    int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _calloc_dbg(
                size_t      _Count,
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _expand_dbg(
          void*       _Block,
                   size_t      _Size,
                   int         _BlockUse,
             char const* _FileName,
                   int         _LineNumber
        );

    __declspec(dllimport) void __cdecl _free_dbg(
            void* _Block,
                                    int   _BlockUse
        );

         
    __declspec(dllimport) __declspec(allocator) void* __cdecl _malloc_dbg(
                size_t      _Size,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

    __declspec(dllimport) size_t __cdecl _msize_dbg(
          void* _Block,
                   int   _BlockUse
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _realloc_dbg(
            void*       _Block,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

           
    __declspec(dllimport) __declspec(allocator) void* __cdecl _recalloc_dbg(
            void*       _Block,
                                    size_t      _Count,
                                    size_t      _Size,
                                    int         _BlockUse,
                              char const* _FileName,
                                    int         _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _dupenv_s_dbg(
            char** _PBuffer,
                               size_t*     _PBufferSizeInBytes,
                                  char const* _VarName,
                                    int          _BlockType,
                              char const* _FileName,
                                    int          _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath_dbg(
          char*       _FullPath,
                                    char const* _Path,
                                      size_t      _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getcwd_dbg(
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );


     
       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _getdcwd_dbg(
                                      int         _Drive,
          char*       _DstBuf,
                                      int         _SizeInBytes,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _strdup_dbg(
          char const* _String,
                int         _BlockUse,
          char const* _FileName,
                int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam_dbg(
          char const* _DirName,
          char const* _FilePrefix,
                int         _BlockType,
          char const* _FileName,
                int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup_dbg(
          wchar_t const* _String,
                int            _BlockUse,
          char const*    _FileName,
                int            _LineNumber
        );

     
    
    __declspec(dllimport) errno_t __cdecl _wdupenv_s_dbg(
            wchar_t** _PBuffer,
                                 size_t*         _PBufferSizeInWords,
                                    wchar_t const* _VarName,
                                      int             _BlockType,
                                char const*    _FileName,
                                      int             _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wfullpath_dbg(
          wchar_t*       _FullPath,
                                    wchar_t const* _Path,
                                      size_t         _SizeInWords,
                                      int            _BlockType,
                                char const*    _FileName,
                                      int            _LineNumber
        );
    
     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd_dbg(
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

     
       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd_dbg(
                                      int         _Drive,
          wchar_t*    _DstBuf,
                                      int         _SizeInWords,
                                      int         _BlockType,
                                char const* _FileName,
                                      int         _LineNumber
        );

       
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam_dbg(
          wchar_t const* _DirName,
          wchar_t const* _FilePrefix,
                int            _BlockType,
          char const*    _FileName,
                int            _LineNumber
        );

    
    

    







#line 583 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

#line 585 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"





















    __declspec(dllimport) int __cdecl _CrtDbgReport(
                int         _ReportType,
          char const* _FileName,
                int         _Linenumber,
          char const* _ModuleName,
          char const* _Format,
        ...);

    __declspec(dllimport) int __cdecl _CrtDbgReportW(
                int            _ReportType,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
        ...);


    __declspec(dllimport) int __cdecl _VCrtDbgReportA(
                int         _ReportType,
            void*       _ReturnAddress,
          char const* _FileName,
                int         _LineNumber,
          char const* _ModuleName,
          char const* _Format,
                   va_list     _ArgList
        );

    __declspec(dllimport) int __cdecl _VCrtDbgReportW(
                int            _ReportType,
            void*          _ReturnAddress,
          wchar_t const* _FileName,
                int            _LineNumber,
          wchar_t const* _ModuleName,
          wchar_t const* _Format,
                   va_list        _ArgList
        );

    __declspec(dllimport) size_t __cdecl _CrtSetDebugFillThreshold(
          size_t _NewDebugFillThreshold
        );

    __declspec(dllimport) size_t __cdecl _CrtGetDebugFillThreshold(void);

    __declspec(dllimport) _HFILE __cdecl _CrtSetReportFile(
              int    _ReportType,
          _HFILE _ReportFile
        );

    __declspec(dllimport) int __cdecl _CrtSetReportMode(
          int _ReportType,
          int _ReportMode
        );

    

        extern long _crtAssertBusy;

        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtGetReportHook(void);

        
        
        
        __declspec(dllimport) _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHook2(
                  int              _Mode,
              _CRT_REPORT_HOOK _PFnNewHook
            );

        __declspec(dllimport) int __cdecl _CrtSetReportHookW2(
                  int               _Mode,
              _CRT_REPORT_HOOKW _PFnNewHook
            );

    #line 683 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

#line 685 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"







































    

    
    
    
        





    #line 736 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

    
        
    #line 740 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

    
        
    #line 744 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"

    



    



    
    

    
    

    
    

    
    

#line 766 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"













    
#line 781 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\crtdbg.h"



























} __pragma(pack(pop))

#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

typedef _Longlong streamoff;
typedef _Longlong streamsize;

  
  

  



extern __declspec(dllimport)  const streamoff _BADOFF;
  #line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

		
template<class _Statetype>
	class fpos
	{	
	typedef fpos<_Statetype> _Myt;

public:
	 fpos(streamoff _Off = 0)
		: _Myoff(_Off), _Fpos(0), _Mystate()
		{	
		}

	 fpos(_Statetype _State, fpos_t _Fileposition)
		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)
		{	
		}

	_Statetype  state() const
		{	
		return (_Mystate);
		}

	void  state(_Statetype _State)
		{	
		_Mystate = _State;
		}

	fpos_t  seekpos() const
		{	
		return (_Fpos);
		}

	 operator streamoff() const
		{	
		return ((streamoff)(_Myoff + ((long long)(_Fpos))));
		}

	streamoff  operator-(const _Myt& _Right) const
		{	
		return ((streamoff)*this - (streamoff)_Right);
		}

	_Myt&  operator+=(streamoff _Off)
		{	
		_Myoff += _Off;
		return (*this);
		}

	_Myt&  operator-=(streamoff _Off)
		{	
		_Myoff -= _Off;
		return (*this);
		}

	_Myt  operator+(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myt  operator-(streamoff _Off) const
		{	
		_Myt _Tmp = *this;
		return (_Tmp -= _Off);
		}

	bool  operator==(const _Myt& _Right) const
		{	
		return ((streamoff)*this == (streamoff)_Right);
		}

	bool  operator==(streamoff _Right) const
		{	
		return ((streamoff)*this == _Right);
		}

	bool  operator!=(const _Myt& _Right) const
		{	
		return (!(*this == _Right));
		}

private:
	streamoff _Myoff;	
	fpos_t _Fpos;	
	_Statetype _Mystate;	
	};

 

 
 

typedef fpos<_Mbstatet> streampos;

typedef streampos wstreampos;

		
template<class _Elem,
	class _Int_type>
	struct _Char_traits
	{	
	typedef _Elem char_type;
	typedef _Int_type int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(
		  const _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		for (; 0 < _Count; --_Count, ++_First1, ++_First2)
			if (!eq(*_First1, *_First2))
				return (lt(*_First1, *_First2) ? -1 : +1);
		return (0);
		}

	static size_t __cdecl length(  const _Elem *_First)
		{	
		size_t _Count;
		for (_Count = 0; !eq(*_First, _Elem()); ++_First)
			++_Count;
		return (_Count);
		}

	static _Elem *__cdecl copy(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		for (; 0 < _Count; --_Count, ++_Next, ++_First2)
			assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Dest_size,
		  const _Elem *_First2, size_t _Count)
		{	
		{ if (!(_Count <= _Dest_size)) { (void)( (!!(("_Count <= _Dest_size" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd", 173, 0, L"%ls", L"\"_Count <= _Dest_size\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"_Count <= _Dest_size", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd", 173, 0); return (0); } };
		return (copy(_First1, _First2, _Count));
		}

	static const _Elem *__cdecl find(
		  const _Elem *_First,
		size_t _Count, const _Elem& _Ch)
		{	
		for (; 0 < _Count; --_Count, ++_First)
			if (eq(*_First, _Ch))
				return (_First);
		return (0);
		}

	static _Elem *__cdecl move(
		  _Elem *_First1,
		  const _Elem *_First2, size_t _Count)
		{	
		_Elem *_Next = _First1;
		if (_First2 < _Next && _Next < _First2 + _Count)
			for (_Next += _Count, _First2 += _Count; 0 < _Count; --_Count)
				assign(*--_Next, *--_First2);
		else
			for (; 0 < _Count; --_Count, ++_Next, ++_First2)
				assign(*_Next, *_First2);
		return (_First1);
		}

	static _Elem *__cdecl assign(
		  _Elem *_First,
		size_t _Count, _Elem _Ch)
		{	
		_Elem *_Next = _First;
		for (; 0 < _Count; --_Count, ++_Next)
			assign(*_Next, _Ch);
		return (_First);
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return ((_Elem)_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return ((int_type)_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? (int_type)_Meta : (int_type)!eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return ((int_type)(-1));
		}
	};

		
template<class _Elem>
	struct char_traits
		: public _Char_traits<_Elem, long>
	{	
	};

		
template<>
	struct char_traits<char16_t>
	: public _Char_traits<char16_t, unsigned short>
	{	
	};

typedef streampos u16streampos;

		
template<>
	struct char_traits<char32_t>
	: public _Char_traits<char32_t, unsigned int>
	{	
	};

typedef streampos u32streampos;

		
template<>
	struct char_traits<wchar_t>
	{	
	typedef wchar_t _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s((_First1), (_Size_in_words), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return (_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return (_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return (((wint_t)(0xFFFF)));
		}
	};

 
		
template<>
	struct char_traits<unsigned short>
	{	
	typedef unsigned short _Elem;
	typedef _Elem char_type;	
	typedef wint_t int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: wmemcmp((const wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: wcslen((const wchar_t *)_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemcpy((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_words,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::wmemcpy_s(((wchar_t *)_First1), (_Size_in_words), ((const wchar_t *)_First2), (_Count));
#line 431 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: wmemchr((const wchar_t *)_First,
				_Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: wmemmove((wchar_t *)_First1,
				(const wchar_t *)_First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: wmemset((wchar_t *)_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left < _Right);
		}

	static constexpr _Elem __cdecl to_char_type(const int_type& _Meta)
		noexcept
		{	
		return (_Meta);
		}

	static constexpr int_type __cdecl to_int_type(const _Elem& _Ch)
		noexcept
		{	
		return (_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(const int_type& _Meta)
		noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return (((wint_t)(0xFFFF)));
		}
	};
 #line 503 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

		
template<> struct char_traits<char>
	{	
	typedef char _Elem;
	typedef _Elem char_type;
	typedef int int_type;
	typedef streampos pos_type;
	typedef streamoff off_type;
	typedef _Mbstatet state_type;

	static int __cdecl compare(const _Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? 0
			: :: memcmp(_First1, _First2, _Count));
		}

	static size_t __cdecl length(const _Elem *_First)
		{	
		return (*_First == 0 ? 0
			: :: strlen(_First));
		}

	static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memcpy(_First1, _First2, _Count));
		}

	static _Elem *__cdecl _Copy_s(
		  _Elem *_First1, size_t _Size_in_bytes,
		  const _Elem *_First2, size_t _Count)
		{	
		if (0 < _Count)
			::memcpy_s((_First1), (_Size_in_bytes), (_First2), (_Count));
		return (_First1);
		}

	static const _Elem *__cdecl find(const _Elem *_First, size_t _Count,
		const _Elem& _Ch)
		{	
		return (_Count == 0 ? (const _Elem *)0
			: (const _Elem *):: memchr(_First, _Ch, _Count));
		}

	static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2,
		size_t _Count)
		{	
		return (_Count == 0 ? _First1
			: (_Elem *):: memmove(_First1, _First2, _Count));
		}

	static _Elem *__cdecl assign(_Elem *_First, size_t _Count,
		_Elem _Ch)
		{	
		return ((_Elem *):: memset(_First, _Ch, _Count));
		}

	static void __cdecl assign(_Elem& _Left, const _Elem& _Right) noexcept
		{	
		_Left = _Right;
		}

	static constexpr bool __cdecl eq(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr bool __cdecl lt(const _Elem& _Left,
		const _Elem& _Right) noexcept
		{	
		return ((unsigned char)_Left < (unsigned char)_Right);
		}

	static constexpr _Elem __cdecl to_char_type(
		const int_type& _Meta) noexcept
		{	
		return ((_Elem)_Meta);
		}

	static constexpr int_type __cdecl to_int_type(
		const _Elem& _Ch) noexcept
		{	
		return ((unsigned char)_Ch);
		}

	static constexpr bool __cdecl eq_int_type(const int_type& _Left,
		const int_type& _Right) noexcept
		{	
		return (_Left == _Right);
		}

	static constexpr int_type __cdecl not_eof(
		const int_type& _Meta) noexcept
		{	
		return (_Meta != eof() ? _Meta : !eof());
		}

	static constexpr int_type __cdecl eof() noexcept
		{	
		return ((-1));
		}
	};

		
template<class _Ty>
	class allocator;
class ios_base;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ios;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class istreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class ostreambuf_iterator;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_streambuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_istream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ostream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_iostream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringbuf;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_istringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_ostringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Alloc = allocator<_Elem> >
	class basic_stringstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_filebuf;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ifstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_ofstream;
template<class _Elem,
	class _Traits = char_traits<_Elem> >
	class basic_fstream;

 
template<class _Elem,
	class _InIt >
	class num_get;
template<class _Elem,
	class _OutIt >
	class num_put;
template<class _Elem>
	class collate;
 #line 674 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"

		
typedef basic_ios<char, char_traits<char> > ios;
typedef basic_streambuf<char, char_traits<char> > streambuf;
typedef basic_istream<char, char_traits<char> > istream;
typedef basic_ostream<char, char_traits<char> > ostream;
typedef basic_iostream<char, char_traits<char> > iostream;
typedef basic_stringbuf<char, char_traits<char>,
	allocator<char> > stringbuf;
typedef basic_istringstream<char, char_traits<char>,
	allocator<char> > istringstream;
typedef basic_ostringstream<char, char_traits<char>,
	allocator<char> > ostringstream;
typedef basic_stringstream<char, char_traits<char>,
	allocator<char> > stringstream;
typedef basic_filebuf<char, char_traits<char> > filebuf;
typedef basic_ifstream<char, char_traits<char> > ifstream;
typedef basic_ofstream<char, char_traits<char> > ofstream;
typedef basic_fstream<char, char_traits<char> > fstream;

		
typedef basic_ios<wchar_t, char_traits<wchar_t> > wios;
typedef basic_streambuf<wchar_t, char_traits<wchar_t> >
	wstreambuf;
typedef basic_istream<wchar_t, char_traits<wchar_t> > wistream;
typedef basic_ostream<wchar_t, char_traits<wchar_t> > wostream;
typedef basic_iostream<wchar_t, char_traits<wchar_t> > wiostream;
typedef basic_stringbuf<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringbuf;
typedef basic_istringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wistringstream;
typedef basic_ostringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wostringstream;
typedef basic_stringstream<wchar_t, char_traits<wchar_t>,
	allocator<wchar_t> > wstringstream;
typedef basic_filebuf<wchar_t, char_traits<wchar_t> > wfilebuf;
typedef basic_ifstream<wchar_t, char_traits<wchar_t> > wifstream;
typedef basic_ofstream<wchar_t, char_traits<wchar_t> > wofstream;
typedef basic_fstream<wchar_t, char_traits<wchar_t> > wfstream;

 





















 
typedef num_get<char, istreambuf_iterator<char, char_traits<char> > >
	numget;
typedef num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumget;
typedef num_put<char, ostreambuf_iterator<char, char_traits<char> > >
	numput;
typedef num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >
	wnumput;
typedef collate<char> ncollate;
typedef collate<wchar_t> wcollate;
 #line 748 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 754 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"
#line 755 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iosfwd"





#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4180 4512)

namespace std {
		
template<class _FwdIt1,
	class _FwdIt2> inline
	void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
	{	
	swap(*_Left, *_Right);
	}

		
template<class _Ty,
	size_t _Size,
	class> inline
	void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size])
		noexcept(_Is_nothrow_swappable<_Ty>::value)
	{	
	if (&_Left != &_Right)
		{	
		_Ty *_First1 = _Left;
		_Ty *_Last1 = _First1 + _Size;
		_Ty *_First2 = _Right;
		for (; _First1 != _Last1; ++_First1, ++_First2)
			::std:: iter_swap(_First1, _First2);
		}
	}

template<class _Ty,
	class> inline
	void swap(_Ty& _Left, _Ty& _Right)
		noexcept(is_nothrow_move_constructible<_Ty>::value && is_nothrow_move_assignable<_Ty>::value)
#line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
	{	
	_Ty _Tmp = ::std:: move(_Left);
	_Left = ::std:: move(_Right);
	_Right = ::std:: move(_Tmp);
	}

		
template<class _Ty> inline
	void _Swap_adl(_Ty& _Left, _Ty& _Right)
		noexcept(_Is_nothrow_swappable<_Ty>::value)
	{	
	swap(_Left, _Right);
	}

		
struct piecewise_construct_t
	{	
	};

constexpr piecewise_construct_t piecewise_construct{};

		
template<class...>
	class tuple;

template<class _Ty1,
	class _Ty2>
	struct pair
	{	
	typedef pair<_Ty1, _Ty2> _Myt;
	typedef _Ty1 first_type;
	typedef _Ty2 second_type;

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		class = enable_if_t<is_default_constructible<_Uty1>::value
						&& is_default_constructible<_Uty2>::value> >
		constexpr pair()
		: first(), second()
		{	
		}

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		class = enable_if_t<is_copy_constructible<_Uty1>::value
						&& is_copy_constructible<_Uty2>::value>,
		enable_if_t<is_convertible<const _Uty1&, _Uty1>::value
				&& is_convertible<const _Uty2&, _Uty2>::value, int> = 0>
		constexpr pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	
		}

	template<class _Uty1 = _Ty1,
		class _Uty2 = _Ty2,
		class = enable_if_t<is_copy_constructible<_Uty1>::value
						&& is_copy_constructible<_Uty2>::value>,
		enable_if_t<!is_convertible<const _Uty1&, _Uty1>::value
				|| !is_convertible<const _Uty2&, _Uty2>::value, int> = 0>
		constexpr explicit pair(const _Ty1& _Val1, const _Ty2& _Val2)
		: first(_Val1), second(_Val2)
		{	
		}

	pair(const pair&) = default;
	pair(pair&&) = default;

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, const _Other1&>::value
						&& is_constructible<_Ty2, const _Other2&>::value>,
		enable_if_t<is_convertible<const _Other1&, _Ty1>::value
				&& is_convertible<const _Other2&, _Ty2>::value, int> = 0>
		constexpr pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	
		}

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, const _Other1&>::value
						&& is_constructible<_Ty2, const _Other2&>::value>,
		enable_if_t<!is_convertible<const _Other1&, _Ty1>::value
				|| !is_convertible<const _Other2&, _Ty2>::value, int> = 0>
		constexpr explicit pair(const pair<_Other1, _Other2>& _Right)
		: first(_Right.first), second(_Right.second)
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(const pair<_Other1, _Other2>& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			integer_sequence<size_t, _Indexes1...>,
			integer_sequence<size_t, _Indexes2...>);

	template<class... _Types1,
		class... _Types2> inline
		pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2);

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, _Other1>::value
						&& is_constructible<_Ty2, _Other2>::value>,
		enable_if_t<is_convertible<_Other1, _Ty1>::value
				&& is_convertible<_Other2, _Ty2>::value, int> = 0>
		constexpr pair(_Other1&& _Val1, _Other2&& _Val2)
			noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))
#line 170 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{	
		}

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, _Other1>::value
						&& is_constructible<_Ty2, _Other2>::value>,
		enable_if_t<!is_convertible<_Other1, _Ty1>::value
				|| !is_convertible<_Other2, _Ty2>::value, int> = 0>
		constexpr explicit pair(_Other1&& _Val1, _Other2&& _Val2)
			noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))
#line 184 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Val1)),
				second(::std:: forward<_Other2>(_Val2))
		{	
		}

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, _Other1>::value
						&& is_constructible<_Ty2, _Other2>::value>,
		enable_if_t<is_convertible<_Other1, _Ty1>::value
				&& is_convertible<_Other2, _Ty2>::value, int> = 0>
		constexpr pair(pair<_Other1, _Other2>&& _Right)
			noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))
#line 198 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{	
		}

	template<class _Other1,
		class _Other2,
		class = enable_if_t<is_constructible<_Ty1, _Other1>::value
						&& is_constructible<_Ty2, _Other2>::value>,
		enable_if_t<!is_convertible<_Other1, _Ty1>::value
				|| !is_convertible<_Other2, _Ty2>::value, int> = 0>
		constexpr explicit pair(pair<_Other1, _Other2>&& _Right)
			noexcept((is_nothrow_constructible<_Ty1, _Other1>::value && is_nothrow_constructible<_Ty2, _Other2>::value))
#line 212 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		: first(::std:: forward<_Other1>(_Right.first)),
			second(::std:: forward<_Other2>(_Right.second))
		{	
		}

	template<class _Other1,
		class _Other2>
		_Myt& operator=(pair<_Other1, _Other2>&& _Right)
		{	
		first = ::std:: forward<_Other1>(_Right.first);
		second = ::std:: forward<_Other2>(_Right.second);
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept((is_nothrow_move_assignable<_Ty1>::value && is_nothrow_move_assignable<_Ty2>::value))
#line 229 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		{	
		first = ::std:: forward<_Ty1>(_Right.first);
		second = ::std:: forward<_Ty2>(_Right.second);
		return (*this);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		first = _Right.first;
		second = _Right.second;
		return (*this);
		}

	_Ty1 first;		
	_Ty2 second;	

	void swap(_Myt& _Right)
		noexcept(_Is_nothrow_swappable<_Ty1>::value && _Is_nothrow_swappable<_Ty2>::value)
#line 248 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
		{	
		if (this != &_Right)
			{	
			_Swap_adl(first, _Right.first);
			_Swap_adl(second, _Right.second);
			}
		}
	};

		

template<class _Ty1,
	class _Ty2,
	class = enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value>> inline
	void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first == _Right.first && _Left.second == _Right.second);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Left.first < _Right.first ||
		(!(_Right.first < _Left.first) && _Left.second < _Right.second));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left,
		const pair<_Ty1, _Ty2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	

template<class _Ty1,
	class _Ty2> inline
	constexpr pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type>
		make_pair(_Ty1&& _Val1, _Ty2&& _Val2)
	{	
	typedef pair<typename _Unrefwrap<_Ty1>::type,
		typename _Unrefwrap<_Ty2>::type> _Mypair;
	return (_Mypair(::std:: forward<_Ty1>(_Val1),
		::std:: forward<_Ty2>(_Val2)));
	}

		
	namespace rel_ops
		{	
template<class _Ty> inline
	bool operator!=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty> inline
	bool operator>(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty> inline
	bool operator<=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty> inline
	bool operator>=(const _Ty& _Left, const _Ty& _Right)
	{	
	return (!(_Left < _Right));
	}
		}
}

namespace std {
template<class _Ty,
	size_t _Size>
	class array;

	
template<class _Tuple>
	struct tuple_size;

template<class _Ty,
	size_t _Size>
	struct tuple_size<array<_Ty, _Size> >
		: integral_constant<size_t, _Size>
	{	
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_size<pair<_Ty1, _Ty2> >
	: integral_constant<size_t, 2>
	{	
	};

template<class... _Types>
	struct tuple_size<tuple<_Types...> >
	: integral_constant<size_t, sizeof...(_Types)>
	{	
	};


template<class _Tuple>
	struct tuple_size<const _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

template<class _Tuple>
	struct tuple_size<const volatile _Tuple>
	: tuple_size<_Tuple>
	{	
	};

 
template<class _Ty>
	constexpr size_t tuple_size_v = tuple_size<_Ty>::value;
 #line 412 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"

	
template<size_t _Index,
	class _Tuple>
	struct tuple_element;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	struct tuple_element<_Idx, array<_Ty, _Size> >
	{	
	static_assert(_Idx < _Size, "array index out of bounds");

	typedef _Ty type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<0, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty1 type;
	};

template<class _Ty1,
	class _Ty2>
	struct tuple_element<1, pair<_Ty1, _Ty2> >
	{	
	typedef _Ty2 type;
	};

template<size_t _Index>
	struct tuple_element<_Index, tuple<> >
	{	
	static_assert(_Always_false<integral_constant<size_t, _Index> >::value,
		"tuple index out of bounds");
	};

template<class _This,
	class... _Rest>
	struct tuple_element<0, tuple<_This, _Rest...> >
	{	
	typedef _This type;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<size_t _Index,
	class _This,
	class... _Rest>
	struct tuple_element<_Index, tuple<_This, _Rest...> >
		: public tuple_element<_Index - 1, tuple<_Rest...> >
	{	
	};


template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_const<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_volatile<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	struct tuple_element<_Index, const volatile _Tuple>
		: public tuple_element<_Index, _Tuple>
	{	
	typedef tuple_element<_Index, _Tuple> _Mybase;
	typedef typename add_cv<typename _Mybase::type>::type type;
	};

template<size_t _Index,
	class _Tuple>
	using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

	
template<class _Ret,
	class _Pair> inline
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 0>) noexcept
	{	
	return (_Pr.first);
	}

template<class _Ret,
	class _Pair> inline
	constexpr _Ret _Pair_get(_Pair& _Pr,
		integral_constant<size_t, 1>) noexcept
	{	
	return (_Pr.second);
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type& _Rtype;
	return (_Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	typedef const typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&
		_Ctype;
	return (_Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>()));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<0>(_Pr));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
	{	
	return (::std:: get<1>(_Pr));
	}

template<size_t _Idx,
	class _Ty1,
	class _Ty2> inline
	constexpr typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&&
		get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	typedef typename tuple_element<_Idx, pair<_Ty1, _Ty2> >::type&& _RRtype;
	return (::std:: forward<_RRtype>(::std:: get<_Idx>(_Pr)));
	}

template<class _Ty1,
	class _Ty2> inline
	constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	return (::std:: get<0>(::std:: move(_Pr)));
	}

template<class _Ty2,
	class _Ty1> inline
	constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
	{	
	return (::std:: get<1>(::std:: move(_Pr)));
	}

	
template<class _Ty,
	class _Other = _Ty> inline
	_Ty exchange(_Ty& _Val, _Other&& _New_val)
	{	
	_Ty _Old_val = ::std:: move(_Val);
	_Val = ::std:: forward<_Other>(_New_val);
	return (_Old_val);
	}

	
template<class _Ty> inline
	constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept
	{	
	return (_Val);
	}

template<class _Ty>
	void as_const(const _Ty&&) = delete;
}


namespace std {
namespace tr1 {	
using ::std:: get;
using ::std:: tuple_element;
using ::std:: tuple_size;
}	
}
#line 617 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 622 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"
#line 623 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\utility"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\chrono"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {








typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long       tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long       tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;  
        long   tv_nsec; 
    };
#line 44 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"
















  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_daylight" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) int* __cdecl __daylight(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_dstbias" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __dstbias(void);




  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_timezone" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) long* __cdecl __timezone(void);




    __declspec(deprecated("This function or variable may be unsafe. Consider using " "_get_tzname" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char** __cdecl __tzname(void);



  
__declspec(dllimport) errno_t __cdecl _get_daylight(
      int* _Daylight
    );

 
__declspec(dllimport) errno_t __cdecl _get_dstbias(
      long* _DaylightSavingsBias
    );

  
__declspec(dllimport) errno_t __cdecl _get_timezone(
      long* _TimeZone
    );

 
__declspec(dllimport) errno_t __cdecl _get_tzname(
                             size_t* _ReturnValue,
      char*   _Buffer,
                              size_t  _SizeInBytes,
                              int     _Index
    );








 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "asctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl asctime(
      struct tm const* _Tm
    );


     
    
    __declspec(dllimport) errno_t __cdecl asctime_s(
            char*            _Buffer,
                                            size_t           _SizeInBytes,
                                                         struct tm const* _Tm
        );
#line 129 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

extern "C++" { template <size_t _Size> inline errno_t __cdecl asctime_s(  char (&_Buffer)[_Size],   struct tm const* _Time) throw() { return asctime_s(_Buffer, _Size, _Time); } }
#line 135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

 
__declspec(dllimport) clock_t __cdecl clock(void);

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime32_s(
        char*             _Buffer,
                                        size_t            _SizeInBytes,
                                                     __time32_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime32_s(  char (&_Buffer)[_Size],   __time32_t const* _Time) throw() { return _ctime32_s(_Buffer, _Size, _Time); } }
#line 158 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

 
 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_ctime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) char* __cdecl _ctime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _ctime64_s(
        char*             _Buffer,
                                          size_t            _SizeInBytes,
                                                       __time64_t const* _Time
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _ctime64_s(  char (&_Buffer)[_Size],   __time64_t const* _Time) throw() { return _ctime64_s(_Buffer, _Size, _Time); } }
#line 178 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

 
__declspec(dllimport) double __cdecl _difftime32(
      __time32_t _Time1,
      __time32_t _Time2
    );

 
__declspec(dllimport) double __cdecl _difftime64(
      __time64_t _Time1,
      __time64_t _Time2
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_gmtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _gmtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _gmtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime32_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime32(
      __time32_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime32_s(
      struct tm*        _Tm,
       __time32_t const* _Time
    );

 
  __declspec(deprecated("This function or variable may be unsafe. Consider using " "_localtime64_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
__declspec(dllimport) struct tm* __cdecl _localtime64(
      __time64_t const* _Time
    );


__declspec(dllimport) errno_t __cdecl _localtime64_s(
      struct tm*        _Tm,
       __time64_t const* _Time
    );

 
__declspec(dllimport) __time32_t __cdecl _mkgmtime32(
      struct tm* _Tm
    );

 
__declspec(dllimport) __time64_t __cdecl _mkgmtime64(
      struct tm* _Tm
    );


__declspec(dllimport) __time32_t __cdecl _mktime32(
      struct tm* _Tm
    );


__declspec(dllimport) __time64_t __cdecl _mktime64(
      struct tm* _Tm
    );

 

__declspec(dllimport) size_t __cdecl strftime(
       char*            _Buffer,
                               size_t           _SizeInBytes,
        char const*      _Format,
                               struct tm const* _Tm
    );

 

__declspec(dllimport) size_t __cdecl _strftime_l(
           char*            _Buffer,
                               size_t           _MaxSize,
        char const*      _Format,
                               struct tm const* _Tm,
                           _locale_t        _Locale
    );


__declspec(dllimport) errno_t __cdecl _strdate_s(
        char*  _Buffer,
                                    size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strdate_s(  char (&_Buffer)[_Size]) throw() { return _strdate_s(_Buffer, _Size); } }
#line 288 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strdate_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport)  char* __cdecl _strdate( char *_Buffer);
#line 293 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"


__declspec(dllimport) errno_t __cdecl _strtime_s(
        char*  _Buffer,
                                    size_t _SizeInBytes
    );

extern "C++" { template <size_t _Size> inline errno_t __cdecl _strtime_s(  char (&_Buffer)[_Size]) throw() { return _strtime_s(_Buffer, _Size); } }
#line 304 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

__declspec(deprecated("This function or variable may be unsafe. Consider using " "_strtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details.")) __declspec(dllimport) char* __cdecl _strtime( char *_Buffer);
#line 309 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

__declspec(dllimport) __time32_t __cdecl _time32(
      __time32_t* _Time
    );

__declspec(dllimport) __time64_t __cdecl _time64(
      __time64_t* _Time
    );

 
 
__declspec(dllimport) int __cdecl _timespec32_get(
      struct _timespec32* _Ts,
       int                 _Base
    );

 
 
__declspec(dllimport) int __cdecl _timespec64_get(
      struct _timespec64* _Ts,
       int                 _Base
    );










    __declspec(dllimport) void __cdecl _tzset(void);

    
    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "GetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _getsystime(
          struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library " "or operating system functionality. Consider using " "SetLocalTime" " " "instead. See online help for details."))
    __declspec(dllimport) unsigned __cdecl _setsystime(
          struct tm* _Tm,
          unsigned   _Milliseconds
        );

#line 356 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"










    











































































































          __declspec(deprecated("This function or variable may be unsafe. Consider using " "ctime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline char* __cdecl ctime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _ctime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline double __cdecl difftime(
              time_t const _Time1,
              time_t const _Time2
            )
        {
            return _difftime64(_Time1, _Time2);
        }

          __declspec(deprecated("This function or variable may be unsafe. Consider using " "gmtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl gmtime(
              time_t const* const _Time)
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _gmtime64(_Time);
            #pragma warning(pop)
        }

        __declspec(deprecated("This function or variable may be unsafe. Consider using " "localtime_s" " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. " "See online help for details."))
        static __inline struct tm* __cdecl localtime(
              time_t const* const _Time
            )
        {
            #pragma warning(push)
            #pragma warning(disable: 4996)
            return _localtime64(_Time);
            #pragma warning(pop)
        }

         
        static __inline time_t __cdecl _mkgmtime(
              struct tm* const _Tm
            )
        {
            return _mkgmtime64(_Tm);
        }

        
        static __inline time_t __cdecl mktime(
              struct tm* const _Tm
            )
        {
            return _mktime64(_Tm);
        }

        static __inline time_t __cdecl time(
              time_t* const _Time
            )
        {
            return _time64(_Time);
        }

         
        static __inline int __cdecl timespec_get(
              struct timespec* const _Ts,
               int              const _Base
            )
        {
            return _timespec64_get((struct _timespec64*)_Ts, _Base); 
        }

        
            
            static __inline errno_t __cdecl ctime_s(
                    char*         const _Buffer,
                                                    size_t        const _SizeInBytes,
                                                                 time_t const* const _Time
                )
            {
                return _ctime64_s(_Buffer, _SizeInBytes, _Time);
            }

            
            static __inline errno_t __cdecl gmtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _gmtime64_s(_Tm, _Time);
            }

            
            static __inline errno_t __cdecl localtime_s(
                  struct tm*    const _Tm,
                   time_t const* const _Time
                )
            {
                return _localtime64_s(_Tm, _Time);
            }
        #line 576 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

    #line 578 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

#line 580 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"










    

    
        __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C " "and C++ conformant name: " "_tzset" ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
    #line 595 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"

#line 597 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\time.h"



} __pragma(pack(pop))
#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\chrono"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xtimec.h"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xthrcommon.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 
  

 

#line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xthrcommon.h"

 #pragma warning(disable: 4511 4512)

extern "C" {

  #pragma warning(disable:4115 4100 4097 4245)

 

#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xthrcommon.h"
  
 #line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xthrcommon.h"

typedef unsigned int _Thrd_id_t;
typedef struct
	{	
	void *_Hnd;	
	_Thrd_id_t _Id;
	} _Thrd_imp_t;





typedef unsigned int (__stdcall *_Thrd_callback_t)(void *);

 
 












 





  
  
  
  
 #line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xthrcommon.h"
 #line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xthrcommon.h"

typedef struct _Mtx_internal_imp_t *_Mtx_imp_t;

typedef struct _Cnd_internal_imp_t *_Cnd_imp_t;
typedef int _Tss_imp_t;

	
__declspec(dllimport) void __cdecl _Thrd_abort(const char *);
__declspec(dllimport) int __cdecl _Thrd_start(_Thrd_imp_t *, _Thrd_callback_t, void *);
void _Tss_destroy(void);

 
  
  
	
  


 

#line 94 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xthrcommon.h"

}


  
  
  
  

  
  

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 110 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xthrcommon.h"
#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xthrcommon.h"





















#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xtimec.h"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


extern "C" {	
#line 17 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xtimec.h"

typedef struct xtime
	{	
	__time64_t sec;
	long nsec;
	} xtime;

__declspec(dllimport) int __cdecl xtime_get(xtime*, int);

__declspec(dllimport) long __cdecl _Xtime_diff_to_millis(const xtime *);
__declspec(dllimport) long __cdecl _Xtime_diff_to_millis2(const xtime*, const xtime *);
__declspec(dllimport) long long __cdecl _Xtime_get_ticks(void);



__declspec(dllimport) long long __cdecl _Query_perf_counter(void);
__declspec(dllimport) long long __cdecl _Query_perf_frequency(void);


} 
#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xtimec.h"
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xtimec.h"
#line 43 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\thr\\xtimec.h"





















#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\chrono"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4455)
 #pragma warning(disable: 6326)

namespace std {
namespace chrono {
	
template<class _Rep>
	struct treat_as_floating_point
		: is_floating_point<_Rep>
	{	
	};

 
template<class _Rep>
	constexpr bool treat_as_floating_point_v = treat_as_floating_point<_Rep>::value;
 #line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\chrono"

	
template<class _Rep>
	struct duration_values
	{	
	static constexpr _Rep zero()
		{	
		return (_Rep(0));
		}

	static constexpr _Rep (min)()
		{	
		return (numeric_limits<_Rep>::lowest());
		}

	static constexpr _Rep (max)()
		{	
		return ((numeric_limits<_Rep>::max)());
		}
	};

	
template<class _Ty>
	struct _Is_ratio
	{	
	static constexpr bool value = false;
	};

template<intmax_t _R1,
	intmax_t _R2>
	struct _Is_ratio<ratio<_R1, _R2> >
	{	
	static constexpr bool value = true;
	};

	
template<class _Rep,
	class _Period = ratio<1> >
	class duration;

template<class _Ty>
	struct _Is_duration
		: false_type
	{	
	};

template<class _Rep,
	class _Period>
	struct _Is_duration<duration<_Rep, _Period> >
		: true_type
	{	
	};

template<class _To,
	class _Rep,
	class _Period> inline
	constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
		duration_cast(const duration<_Rep, _Period>&);

template<class _Rep,
	class _Period>
	class duration
	{	
public:
	typedef duration<_Rep, _Period> _Myt;
	typedef _Rep rep;
	typedef _Period period;

	static_assert(!_Is_duration<_Rep>::value,
		"duration can't have duration as first template argument");
	static_assert(_Is_ratio<_Period>::value,
		"period not an instance of std::ratio");
	static_assert(0 < _Period::num,
		"period negative or zero");

	constexpr duration() = default;

	template<class _Rep2,
		class = typename enable_if<is_convertible<_Rep2, _Rep>::value
			&& (treat_as_floating_point<_Rep>::value
				|| !treat_as_floating_point<_Rep2>::value),
			void>::type>
		constexpr explicit duration(const _Rep2& _Val)
			: _MyRep(static_cast<_Rep>(_Val))
		{	
		}

	template<class _Rep2,
		class _Period2,
		class = typename enable_if<treat_as_floating_point<_Rep>::value

			|| (_Ratio_divide_sfinae<_Period2, _Period>::den == 1

				&& !treat_as_floating_point<_Rep2>::value),
			void>::type>
		constexpr duration(const duration<_Rep2, _Period2>& _Dur)
			: _MyRep(chrono::duration_cast<_Myt>(_Dur).count())
		{	
		}

	constexpr _Rep count() const
		{	
		return (_MyRep);
		}

	constexpr _Myt operator+() const
		{	
		return (*this);
		}

	constexpr _Myt operator-() const
		{	
		return (_Myt(0 - _MyRep));
		}

	_Myt& operator++()
		{	
		++_MyRep;
		return (*this);
		}

	_Myt operator++(int)
		{	
		return (_Myt(_MyRep++));
		}

	_Myt& operator--()
		{	
		--_MyRep;
		return (*this);
		}

	_Myt operator--(int)
		{	
		return (_Myt(_MyRep--));
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		_MyRep += _Right._MyRep;
		return (*this);
		}

	_Myt& operator-=(const _Myt& _Right)
		{	
		_MyRep -= _Right._MyRep;
		return (*this);
		}

	_Myt& operator*=(const _Rep& _Right)
		{	
		_MyRep *= _Right;
		return (*this);
		}

	_Myt& operator/=(const _Rep& _Right)
		{	
		_MyRep /= _Right;
		return (*this);
		}

	_Myt& operator%=(const _Rep& _Right)
		{	
		_MyRep %= _Right;
		return (*this);
		}

	_Myt& operator%=(const _Myt& _Right)
		{	
		_MyRep %= _Right.count();
		return (*this);
		}

	static constexpr _Myt zero()
		{	
		return (_Myt(duration_values<_Rep>::zero()));
		}

	static constexpr _Myt (min)()
		{	
		return (_Myt((duration_values<_Rep>::min)()));
		}
	static constexpr _Myt (max)()
		{	
		return (_Myt((duration_values<_Rep>::max)()));
		}

private:
	_Rep _MyRep;	
	};

template<class _Clock,
	class _Duration = typename _Clock::duration>
	class time_point
	{	
public:
	typedef _Clock clock;
	typedef _Duration duration;
	typedef typename _Duration::rep rep;
	typedef typename _Duration::period period;

	static_assert(_Is_duration<_Duration>::value,
		"duration must be an instance of std::duration");

	constexpr time_point()
		: _MyDur(_Duration::zero())
		{	
		}

	constexpr explicit time_point(const _Duration& _Other)
		: _MyDur(_Other)
		{	
		}

	template<class _Duration2,
		class = typename enable_if<is_convertible<_Duration2,
			_Duration>::value,
			void>::type>
		constexpr time_point(const time_point<_Clock, _Duration2>& _Tp)
		: _MyDur(_Tp.time_since_epoch())
		{	
		}

	constexpr _Duration time_since_epoch() const
		{	
		return (_MyDur);
		}

	time_point& operator+=(const _Duration& _Dur)
		{	
		_MyDur += _Dur;
		return (*this);
		}

	time_point& operator-=(const _Duration& _Dur)
		{	
		_MyDur -= _Dur;
		return (*this);
		}

	static constexpr time_point (min)()
		{	
		return (time_point((_Duration::min)()));
		}
	static constexpr time_point (max)()
		{	
		return (time_point((_Duration::max)()));
		}

private:
	_Duration _MyDur;	
	};
}	

	
template<intmax_t _Ax,
	intmax_t _Bx>
	struct _Lcm
	{	
	static constexpr intmax_t _Gx = _Gcd<_Ax, _Bx>::value;
	static constexpr intmax_t value = (_Ax / _Gx) * _Bx;
	};

	
template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2>
	struct common_type<
		chrono::duration<_Rep1, _Period1>,
		chrono::duration<_Rep2, _Period2> >
	{	
	typedef chrono::duration<typename common_type<_Rep1, _Rep2>::type,
		ratio<_Gcd<_Period1::num, _Period2::num>::value,
			_Lcm<_Period1::den, _Period2::den>::value> > type;
	};

template<class _Clock,
	class _Duration1,
	class _Duration2>
	struct common_type<
		chrono::time_point<_Clock, _Duration1>,
		chrono::time_point<_Clock, _Duration2> >
	{	
	typedef chrono::time_point<
		_Clock, typename common_type<_Duration1, _Duration2>::type> type;
	};

namespace chrono {
	
template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type
		operator+(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type _CD;
	return (_CD(_CD(_Left).count() + _CD(_Right).count()));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type
		operator-(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
	return (_CD(_CD(_Left).count() - _CD(_Right).count()));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2> inline
	constexpr typename enable_if<is_convertible<_Rep2,
		typename common_type<_Rep1, _Rep2>::type>::value,
		duration<typename common_type<_Rep1, _Rep2>::type, _Period1> >::type
		operator*(
			const duration<_Rep1, _Period1>& _Left,
			const _Rep2& _Right)
	{	
	typedef typename common_type<_Rep1, _Rep2>::type _CR;
	typedef duration<_CR, _Period1> _CD;
	return (_CD(_CD(_Left).count() * _Right));
	}

template<class _Rep1,
	class _Rep2,
	class _Period2> inline
	constexpr typename enable_if<is_convertible<_Rep1,
		typename common_type<_Rep1, _Rep2>::type>::value,
		duration<typename common_type<_Rep1, _Rep2>::type, _Period2> >::type
		operator*(
			const _Rep1& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	return (_Right * _Left);
	}

template<class _CR,
	class _Period1,
	class _Rep2,
	bool = is_convertible<_Rep2, _CR>::value>
	struct _Duration_div_mod1
	{	
	typedef duration<_CR, _Period1> type;
	};

template<class _CR,
	class _Period1,
	class _Rep2>
	struct _Duration_div_mod1<_CR, _Period1, _Rep2, false>
	{	
	};

template<class _Rep1,
	class _Period1,
	class _Rep2,
	bool = _Is_duration<_Rep2>::value>
	struct _Duration_div_mod
	{	
	};

template<class _Rep1,
	class _Period1,
	class _Rep2>
	struct _Duration_div_mod<_Rep1, _Period1, _Rep2, false>
		: _Duration_div_mod1<typename common_type<_Rep1, _Rep2>::type,
			_Period1, _Rep2>
	{	
	};

template<class _Rep1,
	class _Period1,
	class _Rep2> inline
	typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
		constexpr operator/(
			const duration<_Rep1, _Period1>& _Left,
			const _Rep2& _Right)
	{	
	typedef typename common_type<_Rep1, _Rep2>::type _CR;
	typedef duration<_CR, _Period1> _CD;
	return (_CD(_CD(_Left).count() / _Right));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr typename common_type<_Rep1, _Rep2>::type
		operator/(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
	return (_CD(_Left).count() / _CD(_Right).count());
	}

template<class _Rep1,
	class _Period1,
	class _Rep2> inline
	constexpr typename _Duration_div_mod<_Rep1, _Period1, _Rep2>::type
		operator%(
			const duration<_Rep1, _Period1>& _Left,
			const _Rep2& _Right)
	{	
	typedef typename common_type<_Rep1, _Rep2>::type _CR;
	typedef duration<_CR, _Period1> _CD;
	return (_CD(_CD(_Left).count() % _Right));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr typename common_type<
		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type
		operator%(
			const duration<_Rep1, _Period1>& _Left,
			const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>, duration<_Rep2, _Period2> >::type _CD;
	return (_CD(_CD(_Left).count() % _CD(_Right).count()));
	}

	
template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator==(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type _CT;
	return (_CT(_Left).count() == _CT(_Right).count());
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator!=(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator<(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	typedef typename common_type<
		duration<_Rep1, _Period1>,
		duration<_Rep2, _Period2> >::type _CT;
	return (_CT(_Left).count() < _CT(_Right).count());
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator<=(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator>(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Rep1,
	class _Period1,
	class _Rep2,
	class _Period2> inline
	constexpr bool operator>=(
		const duration<_Rep1, _Period1>& _Left,
		const duration<_Rep2, _Period2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	
template<class _To,
	class _Rep,
	class _Period> inline
	constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
		duration_cast(const duration<_Rep, _Period>& _Dur)
	{	
	typedef ratio_divide<_Period, typename _To::period> _CF;

	typedef typename _To::rep _ToRep;
	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
	return (_CF::num == 1 && _CF::den == 1
			? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
		: _CF::num != 1 && _CF::den == 1
			? static_cast<_To>(static_cast<_ToRep>(
				static_cast<_CR>(
					_Dur.count()) * static_cast<_CR>(_CF::num)))
		: _CF::num == 1 && _CF::den != 1
			? static_cast<_To>(static_cast<_ToRep>(
				static_cast<_CR>(_Dur.count())
					/ static_cast<_CR>(_CF::den)))
		: static_cast<_To>(static_cast<_ToRep>(
			static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num)
				/ static_cast<_CR>(_CF::den))));
	}

	
template<class _Dur>
	using _As_integral = duration<
		typename conditional<treat_as_floating_point<typename _Dur::rep>::value,
			intmax_t,
			typename _Dur::rep>::type,
		typename _Dur::period>;

	
template<class _Rep,
	class _Period,
	class _To_integral> inline
	constexpr _To_integral _Floor(const duration<_Rep, _Period>& _Dur,
		const _To_integral& _Dur_integral)
	{
	return (_Dur_integral <= _Dur
		? _Dur_integral
		: _Dur_integral - static_cast<_To_integral>(1));
	}

template<class _To,
	class _Rep,
	class _Period> inline
	constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
		floor(const duration<_Rep, _Period>& _Dur)
	{	
		
	return (_Floor(_Dur, chrono::duration_cast<_As_integral<_To> >(_Dur)));
	}

	
template<class _Rep,
	class _Period,
	class _To_integral> inline
	constexpr _To_integral _Ceil(const duration<_Rep, _Period>& _Dur,
		const _To_integral& _Dur_integral)
	{
	return (_Dur <= _Dur_integral
		? _Dur_integral
		: _Dur_integral + static_cast<_To_integral>(1));
	}

template<class _To,
	class _Rep,
	class _Period> inline
	constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
		ceil(const duration<_Rep, _Period>& _Dur)
	{	
		
	return (_Ceil(_Dur, chrono::duration_cast<_As_integral<_To> >(_Dur)));
	}

	
template<class _Rep> inline
	constexpr typename make_unsigned<_Rep>::type _Make_unsigned(_Rep _Val)
	{	
	return (static_cast<typename make_unsigned<_Rep>::type>(_Val));
	}

	
template<class _Rep> inline
	constexpr bool _Is_even(_Rep _Val)
	{	
	return (_Val % 2 == 0);
	}

	
template<class _Rep> inline
	constexpr _Rep _Bankers_divide_impl(_Rep _Truncated, _Rep _Mod,
		_Rep _Half_divisor, bool _Half_divisor_is_exact)
	{	
	return (_Truncated + static_cast<_Rep>(
		
		_Mod > _Half_divisor
		
			|| (_Mod == _Half_divisor
			
			&& _Half_divisor_is_exact
			&& !_Is_even(_Truncated)
		)));
	}

template<class _Rep> inline
	constexpr _Rep _Bankers_divide_tag(_Rep _Dividend, _Rep _Divisor, false_type)
	{	
	return (_Bankers_divide_impl(
		_Dividend / _Divisor,
		_Dividend % _Divisor,
		_Divisor / static_cast<_Rep>(2),
		_Is_even(_Divisor)));
	}

template<class _Rep> inline
	constexpr _Rep _Bankers_divide_tag(_Rep _Dividend, _Rep _Divisor, true_type)
	{	
	return (static_cast<_Rep>(duration_values<_Rep>::zero() <= _Dividend
		? _Bankers_divide_tag(_Make_unsigned(_Dividend),
			_Make_unsigned(_Divisor), false_type())
		: duration_values<_Rep>::zero() - _Bankers_divide_tag(
			duration_values<_Rep>::zero() - _Make_unsigned(_Dividend),
			_Make_unsigned(_Divisor), false_type())));
	}

template<class _Rep> inline
	constexpr _Rep _Bankers_divide(_Rep _Dividend, _Rep _Divisor)
	{	
		
		
		
	return (_Bankers_divide_tag(_Dividend, _Divisor, is_signed<_Rep>()));
	}

	
template<class _Rep> inline
	constexpr bool _Round_should_truncate(_Rep _Val, intmax_t _Val_trunc)
	{	
	return (_Val - static_cast<_Rep>(_Val_trunc) < static_cast<_Rep>(_Val_trunc + 1) - _Val
		|| (_Val - static_cast<_Rep>(_Val_trunc) == static_cast<_Rep>(_Val_trunc + 1) - _Val
			&& _Is_even(_Val_trunc)));
	}

template<class _Rep> inline
	constexpr intmax_t _Round_fp_non_negative(_Rep _Val, intmax_t _Val_trunc)
	{	
	return (_Round_should_truncate(_Val, _Val_trunc) ? _Val_trunc : _Val_trunc + 1);
	}

template<class _Rep> inline
	constexpr intmax_t _Round_fp_non_negative(_Rep _Val)
	{	
	return (_Round_fp_non_negative(_Val, static_cast<intmax_t>(_Val)));
	}

template<class _Rep> inline
	constexpr _Rep _Round_fp(_Rep _Val)
	{	
		
	static_assert(treat_as_floating_point<_Rep>::value,
		"_Round_fp needs floating input");
	return (static_cast<_Rep>(duration_values<_Rep>::zero() <= _Val
		? _Round_fp_non_negative(_Val)
		: (duration_values<_Rep>::zero()
			- _Round_fp_non_negative(duration_values<_Rep>::zero() - _Val))
		));
	}

	
template<class _To,
	class _Rep,
	class _Period> inline
	constexpr _To _Round(const duration<_Rep, _Period>& _Dur,
		false_type, false_type)
	{	
	typedef ratio_divide<_Period, typename _To::period> _CF;

	typedef typename _To::rep _ToRep;
	typedef typename common_type<_ToRep, _Rep, intmax_t>::type _CR;
	return (_CF::num == 1 && _CF::den == 1
			? static_cast<_To>(static_cast<_ToRep>(_Dur.count()))
		: _CF::num != 1 && _CF::den == 1
			? static_cast<_To>(static_cast<_ToRep>(
				static_cast<_CR>(
					_Dur.count()) * static_cast<_CR>(_CF::num)))
		: _CF::num == 1 && _CF::den != 1
			? static_cast<_To>(static_cast<_ToRep>(_Bankers_divide(
				static_cast<_CR>(_Dur.count()), static_cast<_CR>(_CF::den))))
		: static_cast<_To>(static_cast<_ToRep>(
			_Bankers_divide(
				static_cast<_CR>(_Dur.count()) * static_cast<_CR>(_CF::num),
				static_cast<_CR>(_CF::den)))));
	}

template<class _To,
	class _Rep,
	class _Period> inline
	constexpr _To _Round(const duration<_Rep, _Period>& _Dur,
		false_type, true_type)
	{	
		
		
	typedef duration<_Rep, typename _To::period> _FloatTo;
	return (static_cast<_To>(static_cast<typename _To::rep>(
		_Round_fp(chrono::duration_cast<_FloatTo>(_Dur).count()))));
	}

template<class _To,
	class _Rep,
	class _Period,
	class _Source_integral> inline
	constexpr _To _Round(const duration<_Rep, _Period>& _Dur,
		true_type, _Source_integral)
	{	
		
	return (static_cast<_To>(_Round_fp(chrono::duration_cast<_To>(_Dur).count())));
	}

template<class _To,
	class _Rep,
	class _Period> inline
	constexpr typename enable_if<_Is_duration<_To>::value, _To>::type
		round(const duration<_Rep, _Period>& _Dur)
	{	
	return (_Round<_To>(_Dur,
		treat_as_floating_point<typename _To::rep>(),
		treat_as_floating_point<_Rep>()));
	}

	
template<class _Rep,
	class _Period> inline
	constexpr typename enable_if<numeric_limits<_Rep>::is_signed,
		duration<_Rep, _Period> >::type
		abs(const duration<_Rep, _Period> _Dur)
	{	
	return (_Dur < duration<_Rep, _Period>::zero()
		? duration<_Rep, _Period>::zero() - _Dur
		: _Dur);
	}

	
typedef duration<long long, nano> nanoseconds;
typedef duration<long long, micro> microseconds;
typedef duration<long long, milli> milliseconds;
typedef duration<long long> seconds;
typedef duration<int, ratio<60> > minutes;
typedef duration<int, ratio<3600> > hours;

	
template<class _Clock,
	class _Duration,
	class _Rep,
	class _Period> inline
	constexpr time_point<_Clock,
		typename common_type<_Duration, duration<_Rep, _Period> >::type>
		operator+(
			const time_point<_Clock, _Duration>& _Left,
			const duration<_Rep, _Period>& _Right)
	{	
	typedef time_point<_Clock, typename common_type<
		_Duration, duration<_Rep, _Period> >::type> _RT;
	return (_RT(_Left.time_since_epoch() + _Right));
	}

template<class _Rep,
	class _Period,
	class _Clock,
	class _Duration> inline
	constexpr time_point<_Clock,
		typename common_type<duration<_Rep, _Period>, _Duration>::type>
		operator+(
			const duration<_Rep, _Period>& _Left,
			const time_point<_Clock, _Duration>& _Right)
	{	
	return (_Right + _Left);
	}

template<class _Clock,
	class _Duration,
	class _Rep,
	class _Period> inline
	constexpr time_point<_Clock,
		typename common_type<_Duration, duration<_Rep, _Period> >::type>
		operator-(
			const time_point<_Clock, _Duration>& _Left,
			const duration<_Rep, _Period>& _Right)
	{	
	return (_Left + (-_Right));
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr typename common_type<_Duration1, _Duration2>::type
		operator-(
			const time_point<_Clock, _Duration1>& _Left,
			const time_point<_Clock, _Duration2>& _Right)
	{	
	return (_Left.time_since_epoch() - _Right.time_since_epoch());
	}

	
template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator==(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (_Left.time_since_epoch() == _Right.time_since_epoch());
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator!=(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator<(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (_Left.time_since_epoch() < _Right.time_since_epoch());
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator<=(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator>(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Clock,
	class _Duration1,
	class _Duration2> inline
	constexpr bool operator>=(
		const time_point<_Clock, _Duration1>& _Left,
		const time_point<_Clock, _Duration2>& _Right)
	{	
	return (!(_Left < _Right));
	}

	
template<class _To,
	class _Clock,
	class _Duration> inline
	constexpr typename enable_if<_Is_duration<_To>::value,
		time_point<_Clock, _To> >::type
		time_point_cast(const time_point<_Clock, _Duration>& _Time)
	{	
	return (time_point<_Clock, _To>(
		chrono::duration_cast<_To>(_Time.time_since_epoch())));
	}

	
template<class _To,
	class _Clock,
	class _Duration> inline
	constexpr typename enable_if<_Is_duration<_To>::value,
		time_point<_Clock, _To> >::type
		floor(const time_point<_Clock, _Duration>& _Time)
	{	
	return (time_point<_Clock, _To>(
		chrono::floor<_To>(_Time.time_since_epoch())));
	}

	
template<class _To,
	class _Clock,
	class _Duration> inline
	constexpr typename enable_if<_Is_duration<_To>::value,
		time_point<_Clock, _To> >::type
		ceil(const time_point<_Clock, _Duration>& _Time)
	{	
	return (time_point<_Clock, _To>(
		chrono::ceil<_To>(_Time.time_since_epoch())));
	}

	
template<class _To,
	class _Clock,
	class _Duration> inline
	constexpr typename enable_if<_Is_duration<_To>::value,
		time_point<_Clock, _To> >::type
		round(const time_point<_Clock, _Duration>& _Time)
	{	
	return (time_point<_Clock, _To>(
		chrono::round<_To>(_Time.time_since_epoch())));
	}

	
struct system_clock

	{	
	typedef long long rep;

	typedef ratio_multiply<ratio<100, 1>, nano> period;

	typedef chrono::duration<rep, period> duration;
	typedef chrono::time_point<system_clock> time_point;
	static constexpr bool is_steady = false;

	static time_point now() noexcept
		{	
		return (time_point(duration(_Xtime_get_ticks())));
		}

	static __time64_t to_time_t(const time_point& _Time) noexcept
		{	
		return ((__time64_t)(_Time.time_since_epoch().count()
			/ (long long)10000000));
		}

	static time_point from_time_t(__time64_t _Tm) noexcept
		{	
		return (time_point(duration(_Tm * (long long)10000000)));
		}
	};

struct steady_clock
	{	
	typedef long long rep;
	typedef nano period;
	typedef nanoseconds duration;
	typedef chrono::time_point<steady_clock> time_point;
	static constexpr bool is_steady = true;

	static time_point now() noexcept
		{	
		const long long _Freq = _Query_perf_frequency();	
		const long long _Ctr = _Query_perf_counter();
		static_assert(period::num == 1, "This assumes period::num == 1.");
		const long long _Whole = (_Ctr / _Freq) * period::den;
		const long long _Part = (_Ctr % _Freq) * period::den / _Freq;
		return (time_point(duration(_Whole + _Part)));
		}
	};

typedef steady_clock high_resolution_clock;
}	

	
template<class _Rep,
	class _Period> inline
	xtime _To_xtime(const chrono::duration<_Rep, _Period>& _Rel_time)
	{	
	xtime _Xt;
	if (_Rel_time <= chrono::duration<_Rep, _Period>::zero())
		{	
		_Xt.sec = 0;
		_Xt.nsec = 0;
		}
	else
		{	
		chrono::nanoseconds _T0 =
			chrono::system_clock::now().time_since_epoch();
		_T0 += chrono::duration_cast<chrono::nanoseconds>(_Rel_time);
		_Xt.sec = chrono::duration_cast<chrono::seconds>(_T0).count();
		_T0 -= chrono::seconds(_Xt.sec);
		_Xt.nsec = (long)_T0.count();
		}
	return (_Xt);
	}

	





inline namespace literals {
inline namespace chrono_literals {
inline constexpr chrono::hours operator "" h(unsigned long long _Val)
	{	
	return (chrono::hours(_Val));
	}

inline constexpr chrono::duration<double, ratio<3600> > operator "" h(
	long double _Val)
	{	
	return (chrono::duration<double, ratio<3600> >(_Val));
	}

inline constexpr chrono::minutes (operator "" min)(unsigned long long _Val)
	{	
	return (chrono::minutes(_Val));
	}

inline constexpr chrono::duration<double, ratio<60> > (operator "" min)(
	long double _Val)
	{	
	return (chrono::duration<double, ratio<60> >(_Val));
	}

inline constexpr chrono::seconds operator "" s(unsigned long long _Val)
	{	
	return (chrono::seconds(_Val));
	}

inline constexpr chrono::duration<double> operator "" s(long double _Val)
	{	
	return (chrono::duration<double>(_Val));
	}

inline constexpr chrono::milliseconds operator "" ms(unsigned long long _Val)
	{	
	return (chrono::milliseconds(_Val));
	}

inline constexpr chrono::duration<double, milli> operator "" ms(
	long double _Val)
	{	
	return (chrono::duration<double, milli>(_Val));
	}

inline constexpr chrono::microseconds operator "" us(unsigned long long _Val)
	{	
	return (chrono::microseconds(_Val));
	}

inline constexpr chrono::duration<double, micro> operator "" us(
	long double _Val)
	{	
	return (chrono::duration<double, micro>(_Val));
	}

inline constexpr chrono::nanoseconds operator "" ns(unsigned long long _Val)
	{	
	return (chrono::nanoseconds(_Val));
	}

inline constexpr chrono::duration<double, nano> operator "" ns(
	long double _Val)
	{	
	return (chrono::duration<double, nano>(_Val));
	}
}	
}	

namespace chrono {
	using namespace literals::chrono_literals;
}	





}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1122 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\chrono"
#line 1123 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\chrono"






#line 3 "d:\\users\\stasw\\documents\\virheimur\\game - client\\time.h"
using namespace std;
using namespace std::chrono;

class Time
{
private:
	Time();
	Time(Time&) = delete;
	void operator=(Time&) = delete;
	static Time instance;
	float FrameMS;
	double NewFrameMS;
	double PreviousFrameMS = 0;
public:
	~Time();
	static Time& Instance()
	{
		static Time instance;
		return instance;
	}
	static double Now();
	void CalculateFrame();
	
	float Frame();
};

#line 3 "d:\\users\\stasw\\documents\\virheimur\\game - client\\fps.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\text.h"
#pragma once
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

#pragma once







#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

#pragma once





#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {

  


  



  




  


  #line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

__declspec(dllimport) bool __cdecl uncaught_exception() noexcept;
__declspec(dllimport) int __cdecl uncaught_exceptions() noexcept;

}

 

#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {







    
#line 24 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"















typedef struct _heapinfo
{
    int* _pentry;
    size_t _size;
    int _useflag;
} _HEAPINFO;








   
void* __cdecl _alloca(  size_t _Size);





    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

     
    __declspec(dllimport) int __cdecl _heapmin(void);

    
        __declspec(dllimport) int __cdecl _heapwalk(  _HEAPINFO* _EntryInfo);
    #line 68 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"

    
          __declspec(dllimport) int __cdecl _heapchk(void);
        __declspec(dllimport) int __cdecl _resetstkoflw(void);
    #line 73 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"
     
    
    
    

    


        
    #line 83 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"

    typedef char __static_assert_t[(sizeof(unsigned int) <= 8) != 0];


    #pragma warning(push)
    #pragma warning(disable:6540)

    __inline void* _MarkAllocaS(   void* _Ptr, unsigned int _Marker)
    {
        if (_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 8;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 8;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

    #pragma warning(pop)

#line 109 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"





    
        
        




    #line 122 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"












#line 135 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"




#line 140 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"
#line 141 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"

    

    #pragma warning(push)
    #pragma warning(disable: 6014)
    __inline void __cdecl _freea(    void* _Memory)
    {
        unsigned int _Marker;
        if (_Memory)
        {
            _Memory = (char*)_Memory - 8;
            _Marker = *(unsigned int*)_Memory;
            if (_Marker == 0xDDDD)
            {
                free(_Memory);
            }
            
            else if (_Marker != 0xCCCC)
            {
                (void)( (!!((("Corrupted pointer passed to _freea", 0)))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h", 160, 0, L"%ls", L"(\"Corrupted pointer passed to _freea\", 0)")) || (__debugbreak(), 0) );
            }
            #line 163 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"
        }
    }
    #pragma warning(pop)

#line 168 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"




    
#line 174 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\malloc.h"



} __pragma(pack(pop))
#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_exception.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"







#pragma once


#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_terminate.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* terminate_handler )();
typedef void (__cdecl* terminate_function)();








    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    

        __declspec(dllimport) terminate_handler __cdecl set_terminate(
              terminate_handler _NewTerminateHandler
            ) throw();

        __declspec(dllimport) terminate_handler __cdecl _get_terminate();

    #line 40 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_terminate.h"

#line 42 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_terminate.h"

} __pragma(pack(pop))

#line 46 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\corecrt_terminate.h"
#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"



__pragma(pack(push, 8)) extern "C" {



typedef void (__cdecl* unexpected_handler )();
typedef void (__cdecl* unexpected_function)();






struct _EXCEPTION_POINTERS;


    
    __declspec(dllimport) __declspec(noreturn) void __cdecl unexpected() throw(...);

    

        __declspec(dllimport) unexpected_handler __cdecl set_unexpected(
              unexpected_handler _NewUnexpectedHandler
            ) throw();

        __declspec(dllimport) unexpected_handler __cdecl _get_unexpected();

        typedef void (__cdecl* _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

        __declspec(dllimport) _se_translator_function __cdecl _set_se_translator(
              _se_translator_function _NewSETranslator
            );

    #line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"

    class type_info;

    __declspec(dllimport) int __cdecl _is_exception_typeof(
          type_info const&     _Type,
          _EXCEPTION_POINTERS* _ExceptionPtr
        );

    __declspec(dllimport) bool __cdecl __uncaught_exception();
    __declspec(dllimport) int  __cdecl __uncaught_exceptions();

#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"

} __pragma(pack(pop))

#line 64 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\eh.h"
#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_exception.h"





#pragma pack(push, 8)


__pragma(pack(push, 8)) extern "C" {

struct __std_exception_data
{
    char const* _What;
    bool        _DoFree;
};

__declspec(dllimport) void __cdecl __std_exception_copy(
       __std_exception_data const* _From,
      __std_exception_data*       _To
    );

__declspec(dllimport) void __cdecl __std_exception_destroy(
      __std_exception_data* _Data
    );

} __pragma(pack(pop))



namespace std {

class exception
{
public:

    exception() throw()
        : _Data()
    {
    }

    explicit exception(char const* const _Message) throw()
        : _Data()
    {
        __std_exception_data _InitData = { _Message, true };
        __std_exception_copy(&_InitData, &_Data);
    }

    exception(char const* const _Message, int) throw()
        : _Data()
    {
        _Data._What = _Message;
    }

    exception(exception const& _Other) throw()
        : _Data()
    {
        __std_exception_copy(&_Other._Data, &_Data);
    }

    exception& operator=(exception const& _Other) throw()
    {
        if (this == &_Other)
        {
            return *this;
        }

        __std_exception_destroy(&_Data);
        __std_exception_copy(&_Other._Data, &_Data);
        return *this;
    }

    virtual ~exception() throw()
    {
        __std_exception_destroy(&_Data);
    }

    virtual char const* what() const
    {
        return _Data._What ? _Data._What : "Unknown exception";
    }

private:

    __std_exception_data _Data;
};

class bad_exception
    : public exception
{
public:

    bad_exception() throw()
        : exception("bad exception", 1)
    {
    }
};

class bad_alloc
    : public exception
{
public:

    bad_alloc() throw()
        : exception("bad allocation", 1)
    {
    }

private:

    friend class bad_array_new_length;

    bad_alloc(char const* const _Message) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_array_new_length
    : public bad_alloc
{
public:

    bad_array_new_length() throw()
        : bad_alloc("bad array new length")
    {
    }
};

} 

#line 142 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_exception.h"
#pragma pack(pop)





#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

namespace std {

using ::set_terminate; using ::terminate_handler; using ::terminate; using ::set_unexpected; using ::unexpected_handler; using ::unexpected;

typedef void (__cdecl *_Prhand)(const exception&);


inline terminate_handler __cdecl get_terminate() noexcept
	{	
	return (_get_terminate());
	}

inline unexpected_handler __cdecl get_unexpected() noexcept
	{	
	return (_get_unexpected());
	}
#line 60 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

}

 




































































































































































#line 229 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"









#line 239 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"

__declspec(dllimport) void __cdecl __ExceptionPtrCreate(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(  void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(  void*,   const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(  void*,   const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(  const void*,   const void*);
__declspec(dllimport) bool __cdecl __ExceptionPtrToBool(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrSwap(  void*,   void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(  void*);
[[noreturn]] __declspec(dllimport) void __cdecl __ExceptionPtrRethrow(  const void*);
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(
	  void*,   const void*,   const void*);

namespace std {

class exception_ptr
	{
public:
	exception_ptr() throw ()
		{
		__ExceptionPtrCreate(this);
		}

	exception_ptr(nullptr_t) throw ()
		{
		__ExceptionPtrCreate(this);
		}

	~exception_ptr() throw ()
		{
		__ExceptionPtrDestroy(this);
		}

	exception_ptr(const exception_ptr& _Rhs) throw ()
		{
		__ExceptionPtrCopy(this, &_Rhs);
		}

	exception_ptr& operator=(const exception_ptr& _Rhs) throw ()
		{
		__ExceptionPtrAssign(this, &_Rhs);
		return *this;
		}

	exception_ptr& operator=(nullptr_t) throw ()
		{
		exception_ptr _Ptr;
		__ExceptionPtrAssign(this, &_Ptr);
		return *this;
		}

	explicit operator bool() const throw ()
		{
		return __ExceptionPtrToBool(this);
		}

	[[noreturn]] void _RethrowException() const
		{
		__ExceptionPtrRethrow(this);
		}

	static exception_ptr _Current_exception() throw ()
		{
		exception_ptr _Retval;
		__ExceptionPtrCurrentException(&_Retval);
		return _Retval;
		}

	static exception_ptr _Copy_exception(  void* _Except,   const void* _Ptr)
		{
		exception_ptr _Retval = 0;
		if (!_Ptr)
			{
			
			return _Retval;
			}
		__ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
		return _Retval;
		}

private:
	void* _Data1;
	void* _Data2;
	};

inline void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) throw ()
	{
	__ExceptionPtrSwap(&_Lhs, &_Rhs);
	}

inline bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return __ExceptionPtrCompare(&_Lhs, &_Rhs);
	}

inline bool operator==(nullptr_t, const exception_ptr& _Rhs) throw ()
	{
	return !_Rhs;
	}

inline bool operator==(const exception_ptr& _Lhs, nullptr_t) throw ()
	{
	return !_Lhs;
	}

inline bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) throw ()
	{
	return !(_Lhs == _Rhs);
	}

inline exception_ptr current_exception() noexcept
	{
	return exception_ptr::_Current_exception();
	}

[[noreturn]] inline void rethrow_exception(  exception_ptr _Ptr)
	{
	_Ptr._RethrowException();
	}

template<class _Ex> void *__GetExceptionInfo(_Ex);

template<class _Ex> exception_ptr make_exception_ptr(_Ex _Except) noexcept
	{
	return exception_ptr::_Copy_exception(::std:: addressof(_Except), __GetExceptionInfo(_Except));
	}

	
class nested_exception
	{	
public:
	nested_exception() noexcept
		: _Exc(::std:: current_exception())
		{	
		}

	nested_exception(const nested_exception&) noexcept = default;
	nested_exception& operator=(const nested_exception&) noexcept = default;
	virtual ~nested_exception() noexcept = default;

	[[noreturn]] void rethrow_nested() const
		{	
		if (_Exc)
			::std:: rethrow_exception(_Exc);
		else
			::std:: terminate();
		}

	::std:: exception_ptr nested_ptr() const noexcept
		{	
		return (_Exc);
		}

private:
	::std:: exception_ptr _Exc;
	};

	
template<class _Ty,
	class _Uty>
	struct _With_nested
		: _Uty, nested_exception
	{	
	explicit _With_nested(_Ty&& _Arg)
		: _Uty(::std:: forward<_Ty>(_Arg)), nested_exception()
		{	
		}
	};

template<class _Ty>
	[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, true_type)
	{	
	typedef typename remove_reference<_Ty>::type _Uty;
	typedef _With_nested<_Ty, _Uty> _Glued;

	throw _Glued(::std:: forward<_Ty>(_Arg));
	}

template<class _Ty>
	[[noreturn]] inline void _Throw_with_nested(_Ty&& _Arg, false_type)
	{	
	typedef typename decay<_Ty>::type _Decayed;

	throw _Decayed(::std:: forward<_Ty>(_Arg));
	}

template<class _Ty>
	[[noreturn]] inline void throw_with_nested(_Ty&& _Arg)
	{	
	typedef typename remove_reference<_Ty>::type _Uty;

	integral_constant<bool,
		is_class<_Uty>::value
		&& !is_base_of<nested_exception, _Uty>::value
		&& !is_final<_Uty>::value> _Tag;

	_Throw_with_nested(::std:: forward<_Ty>(_Arg), _Tag);
	}

	
template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *_Ptr, true_type)
	{	
	const auto _Nested = dynamic_cast<const nested_exception *>(_Ptr);

	if (_Nested)
		_Nested->rethrow_nested();
	}

template<class _Ty> inline
	void _Rethrow_if_nested(const _Ty *, false_type)
	{	
	}

template<class _Ty> inline
	void rethrow_if_nested(const _Ty& _Arg)
	{	
	integral_constant<bool,
		is_polymorphic<_Ty>::value
		&& (!is_base_of<nested_exception, _Ty>::value
			|| is_convertible<_Ty *, nested_exception *>::value)> _Tag;

	_Rethrow_if_nested(::std:: addressof(_Arg), _Tag);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 480 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"
#line 481 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\exception"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"

#pragma once










 
#line 15 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"

 
namespace std {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t;  using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t;  using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;


	namespace tr1 {
using :: int8_t; using :: int16_t;
using :: int32_t; using :: int64_t;
using :: uint8_t; using :: uint16_t;
using :: uint32_t; using :: uint64_t;

using :: int_least8_t; using :: int_least16_t;
using :: int_least32_t;  using :: int_least64_t;
using :: uint_least8_t; using :: uint_least16_t;
using :: uint_least32_t; using :: uint_least64_t;

using :: int_fast8_t; using :: int_fast16_t;
using :: int_fast32_t;  using :: int_fast64_t;
using :: uint_fast8_t; using :: uint_fast16_t;
using :: uint_fast32_t; using :: uint_fast64_t;

using :: intmax_t; using :: intptr_t;
using :: uintmax_t; using :: uintptr_t;
	}	
#line 57 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"
}
 #line 59 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"

#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cstdint"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 

  



namespace std {

		
 

typedef void (__cdecl * new_handler) ();
 #line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"

		
__declspec(dllimport) new_handler __cdecl set_new_handler(  new_handler)
	noexcept;	

__declspec(dllimport) new_handler __cdecl get_new_handler()
	noexcept;	
}

 
 #pragma warning(pop)
 #pragma pack(pop)

#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"
#line 39 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\new"





#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

#pragma once







 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		

 

  

  


typedef const wchar_t *_Dbfile_t;
typedef unsigned int _Dbline_t;

__declspec(dllimport) void __cdecl _Debug_message(const wchar_t *,
	const wchar_t *, unsigned int);

 

#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
struct _Container_proxy;
struct _Container_base12;
struct _Iterator_base12;

struct _Container_base0
	{	
	void _Orphan_all()
		{	
		}

	void _Swap_all(_Container_base0&)
		{	
		}
	};

struct _Iterator_base0
	{	
	void _Adopt(const void *)
		{	
		}

	const _Container_base0 *_Getcont() const
		{	
		return (0);
		}
	};

		
struct _Container_proxy
	{	
	_Container_proxy()
		: _Mycont(0), _Myfirstiter(0)
		{	
		}

	const _Container_base12 *_Mycont;
	_Iterator_base12 *_Myfirstiter;
	};

struct _Container_base12
	{	
public:
	_Container_base12()
		: _Myproxy(0)
		{	
		}

	_Container_base12(const _Container_base12&)
		: _Myproxy(0)
		{	
		}

	_Container_base12& operator=(const _Container_base12&)
		{	
		return (*this);
		}

	~_Container_base12() noexcept
		{	
		_Orphan_all();
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);
		}

	void _Orphan_all();	
	void _Swap_all(_Container_base12&);	

	_Container_proxy *_Myproxy;
	};

struct _Iterator_base12
	{	
public:
	_Iterator_base12()
		: _Myproxy(0), _Mynextiter(0)
		{	
		}

	_Iterator_base12(const _Iterator_base12& _Right)
		: _Myproxy(0), _Mynextiter(0)
		{	
		*this = _Right;
		}

	_Iterator_base12& operator=(const _Iterator_base12& _Right)
		{	
		if (_Myproxy == _Right._Myproxy)
			;
		else if (_Right._Myproxy != 0)
			_Adopt(_Right._Myproxy->_Mycont);
		else
			{	
 
			_Lockit _Lock(3);
			_Orphan_me();
 #line 135 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
			}

		return (*this);
		}

	~_Iterator_base12() noexcept
		{	
 
		_Lockit _Lock(3);
		_Orphan_me();
 #line 146 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
		}

	void _Adopt(const _Container_base12 *_Parent)
		{	
		if (_Parent == 0)
			{	
 
			_Lockit _Lock(3);
			_Orphan_me();
 #line 156 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
			}
		else
			{	
			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

 
			if (_Myproxy != _Parent_proxy)
				{	
				_Lockit _Lock(3);
				_Orphan_me();
				_Mynextiter = _Parent_proxy->_Myfirstiter;
				_Parent_proxy->_Myfirstiter = this;
				_Myproxy = _Parent_proxy;
				}

 

#line 174 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
			}
		}

	void _Clrcont()
		{	
		_Myproxy = 0;
		}

	const _Container_base12 *_Getcont() const
		{	
		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);
		}

	_Iterator_base12 **_Getpnext()
		{	
		return (&_Mynextiter);
		}

	void _Orphan_me()
		{	
 
		if (_Myproxy != 0)
			{	
			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			while (*_Pnext != 0 && *_Pnext != this)
				_Pnext = &(*_Pnext)->_Mynextiter;

			if (*_Pnext == 0)
				_Debug_message(L"ITERATOR LIST CORRUPTED!", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 202);
			*_Pnext = _Mynextiter;
			_Myproxy = 0;
			}
 #line 207 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
		}

	_Container_proxy *_Myproxy;
	_Iterator_base12 *_Mynextiter;
	};

		
inline void _Container_base12::_Orphan_all()
	{	
 
	if (_Myproxy != 0)
		{	
		_Lockit _Lock(3);

		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
			(*_Pnext)->_Myproxy = 0;
		_Myproxy->_Myfirstiter = 0;
		}
 #line 227 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	}

inline void _Container_base12::_Swap_all(_Container_base12& _Right)
	{	
 
	_Lockit _Lock(3);
 #line 234 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	_Container_proxy *_Temp = _Myproxy;
	_Myproxy = _Right._Myproxy;
	_Right._Myproxy = _Temp;

	if (_Myproxy != 0)
		_Myproxy->_Mycont = (_Container_base12 *)this;
	if (_Right._Myproxy != 0)
		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;
	}

 



#line 250 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
typedef _Container_base12 _Container_base;
typedef _Iterator_base12 _Iterator_base;
 #line 253 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	
struct _Zero_then_variadic_args_t
	{	
	};	

struct _One_then_variadic_args_t
	{	
	};	

template<class _Ty1,
	class _Ty2,
	bool = is_empty<_Ty1>::value && !is_final<_Ty1>::value>
	class _Compressed_pair final
		: private _Ty1

	{	
private:
	_Ty2 _Myval2;

	typedef _Ty1 _Mybase;	

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Ty1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Ty1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}


	_Ty1& _Get_first() noexcept
		{	
		return (*this);
		}

	const _Ty1& _Get_first() const noexcept
		{	
		return (*this);
		}

	volatile _Ty1& _Get_first() volatile noexcept
		{	
		return (*this);
		}

	const volatile _Ty1& _Get_first() const volatile noexcept
		{	
		return (*this);
		}

	_Ty2& _Get_second() noexcept
		{	
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile noexcept
		{	
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile noexcept
		{	
		return (_Myval2);
		}
	};

template<class _Ty1,
	class _Ty2>
	class _Compressed_pair<_Ty1, _Ty2, false> final

	{	
private:
	_Ty1 _Myval1;
	_Ty2 _Myval2;

public:
	template<class... _Other2>
		constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t,
			_Other2&&... _Val2)
		: _Myval1(), _Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}

	template<class _Other1,
		class... _Other2>
		_Compressed_pair(_One_then_variadic_args_t,
			_Other1&& _Val1, _Other2&&... _Val2)
		: _Myval1(::std:: forward<_Other1>(_Val1)),
			_Myval2(::std:: forward<_Other2>(_Val2)...)
		{	
		}


	_Ty1& _Get_first() noexcept
		{	
		return (_Myval1);
		}

	const _Ty1& _Get_first() const noexcept
		{	
		return (_Myval1);
		}

	volatile _Ty1& _Get_first() volatile noexcept
		{	
		return (_Myval1);
		}

	const volatile _Ty1& _Get_first() const volatile noexcept
		{	
		return (_Myval1);
		}

	_Ty2& _Get_second() noexcept
		{	
		return (_Myval2);
		}

	const _Ty2& _Get_second() const noexcept
		{	
		return (_Myval2);
		}

	volatile _Ty2& _Get_second() volatile noexcept
		{	
		return (_Myval2);
		}

	const volatile _Ty2& _Get_second() const volatile noexcept
		{	
		return (_Myval2);
		}
	};

		
template<class _Ty,
	class = void>
	struct _Is_checked_helper
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_checked_helper<_Ty, void_t<
		typename _Ty::_Unchecked_type> >
		: true_type
	{	
	};

		
template<class _Iter> inline
	typename _Is_checked_helper<_Iter>::type _Is_checked(_Iter)
	{	
	return {};
	}

		
template<class _Iter> inline
	_Iter _Unchecked(_Iter _Src)
	{	
	return (_Src);
	}

 


		
 







#line 444 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

template<class _Iter> inline
	_Iter _Unchecked_idl0(_Iter _Src)
	{	
	return (_Src);
	}

 #line 452 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _Iter,
	class _UIter> inline
	_Iter& _Rechecked(_Iter& _Dest, _UIter _Src)
	{	
	_Dest = _Src;
	return (_Dest);
	}

		




















		
		
		




#line 491 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		


		


		


#line 502 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"


		
		
struct input_iterator_tag
	{	
	};

struct _Mutable_iterator_tag	
	{	
	};

struct output_iterator_tag
	: _Mutable_iterator_tag
	{	
	};

struct forward_iterator_tag
	: input_iterator_tag, _Mutable_iterator_tag
	{	
	};

struct bidirectional_iterator_tag
	: forward_iterator_tag
	{	
	};

struct random_access_iterator_tag
	: bidirectional_iterator_tag
	{	
	};

		
struct _General_ptr_iterator_tag
	{	
	};

struct _Trivially_copyable_ptr_iterator_tag
	: _General_ptr_iterator_tag
	{	
	};

struct _Really_trivial_ptr_iterator_tag
	: _Trivially_copyable_ptr_iterator_tag
	{	
	};

	
struct _Any_tag
	{	
	constexpr _Any_tag() noexcept = default;
	template<class _Ty>
		constexpr _Any_tag(_Ty&&) noexcept {}
	};

		
template<class _Category,
	class _Ty,
	class _Diff = ptrdiff_t,
	class _Pointer = _Ty *,
	class _Reference = _Ty&>
	struct iterator
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;

	typedef _Pointer pointer;
	typedef _Reference reference;
	};

template<class _Category,
	class _Ty,
	class _Diff,
	class _Pointer,
	class _Reference,
	class _Base>
	struct _Iterator012
		: public _Base
	{	
	typedef _Category iterator_category;
	typedef _Ty value_type;
	typedef _Diff difference_type;

	typedef _Pointer pointer;
	typedef _Reference reference;
	};


typedef iterator<output_iterator_tag, void, void, void, void> _Outit;

		
template<class,
	class = void>
	struct _Iterator_traits_base
	{	
	};

template<class _Iter>
	struct _Iterator_traits_base<_Iter, void_t<
		typename _Iter::iterator_category,
		typename _Iter::value_type,
		typename _Iter::difference_type,
		typename _Iter::pointer,
		typename _Iter::reference
		> >
	{	
	typedef typename _Iter::iterator_category iterator_category;
	typedef typename _Iter::value_type value_type;
	typedef typename _Iter::difference_type difference_type;

	typedef typename _Iter::pointer pointer;
	typedef typename _Iter::reference reference;
	};

template<class _Iter>
	struct iterator_traits
		: _Iterator_traits_base<_Iter>
	{	
	};

template<class _Ty>
	struct iterator_traits<_Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;

	typedef _Ty *pointer;
	typedef _Ty& reference;
	};

template<class _Ty>
	struct iterator_traits<const _Ty *>
	{	
	typedef random_access_iterator_tag iterator_category;
	typedef _Ty value_type;
	typedef ptrdiff_t difference_type;

	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	};

		
template<class _Iter>
	using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

		
template<class _Iter>
	using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;

		
template<class _Iter>
	using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

		
template<class _Ty,
	class = void>
	struct _Is_iterator
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_iterator<_Ty, void_t<
		typename iterator_traits<_Ty>::iterator_category
		> >
		: true_type
	{	
	};


		
 






#line 683 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n1(_Iter _Src, _Diff, false_type)
	{	
	return (_Src);
	}

template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n1(_Iter _Src, _Diff _Count, true_type)
	{	
	if (0 < _Count)
		{
		static_cast<void>((_Src) + (_Count));
		}

	return (_Unchecked(_Src));
	}

template<class _Iter,
	class _Diff> inline
	auto _Unchecked_n(_Iter _Src, _Diff _Count)
	{	
	return (_Unchecked_n1(_Src, _Count, is_base_of<random_access_iterator_tag, _Iter_cat_t<_Iter>>()));
	}
 #line 709 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"


		
template<class _Ty1,
	class _Ty2>
	struct _Is_same_size
		: bool_constant<sizeof(_Ty1) == sizeof(_Ty2)>
	{	
	};

		
template<class _Elem,
	bool _Is_enum = is_enum<_Elem>::value>
	struct _Unwrap_enum
	{	
	typedef underlying_type_t<_Elem> type;
	};

template<class _Elem>
	struct _Unwrap_enum<_Elem, false>
	{	
	typedef _Elem type;
	};

		
template<class _Ty1,
	class _Ty2>
	struct _Both_or_neither_bool
		: bool_constant<is_same<bool, _Ty1>::value == is_same<bool, _Ty2>::value>
	{	
	};

		
template<class _Source,
	class _Dest>
	struct _Ptr_cat_helper
	{	
	typedef typename _Unwrap_enum<_Source>::type _USource;
	typedef typename _Unwrap_enum<_Dest>::type _UDest;
	typedef conditional_t<
		conjunction<
			_Is_same_size<_USource, _UDest>,
			is_integral<_USource>,
			is_integral<_UDest>,
			_Both_or_neither_bool<_USource, _UDest>,
			
			negation<is_volatile<_Source>>,
			negation<is_volatile<_Dest>>
		>::value,
		_Really_trivial_ptr_iterator_tag,
		_General_ptr_iterator_tag> type;
	};

template<class _Elem>
	struct _Ptr_cat_helper<_Elem, _Elem>
	{	
	typedef conditional_t<
		is_trivially_copyable<_Elem>::value,
		conditional_t<is_trivial<_Elem>::value,
			_Really_trivial_ptr_iterator_tag,
			_Trivially_copyable_ptr_iterator_tag>,
		_General_ptr_iterator_tag> type;
	};

template<class _Anything>
	struct _Ptr_cat_helper<_Anything *, const _Anything *>
	{	
	typedef _Really_trivial_ptr_iterator_tag type;
	};

template<class _Source,
	class _Dest> inline
	_General_ptr_iterator_tag _Ptr_copy_cat(const _Source&, const _Dest&)
	{	
	return {};
	}

template<class _Source,
	class _Dest> inline
	conditional_t<is_trivially_assignable<_Dest&, _Source&>::value,
		typename _Ptr_cat_helper<remove_const_t<_Source>, _Dest>::type,
		_General_ptr_iterator_tag>
		_Ptr_copy_cat(_Source * const&, _Dest * const&)
	{	
	return {};
	}

template<class _Source,
	class _Dest> inline
	_General_ptr_iterator_tag _Ptr_move_cat(const _Source&, const _Dest&)
	{	
	return {};
	}

template<class _Source,
	class _Dest> inline
	conditional_t<is_trivially_assignable<_Dest&, _Source>::value,
		typename _Ptr_cat_helper<remove_const_t<_Source>, _Dest>::type,
		_General_ptr_iterator_tag>
		_Ptr_move_cat(_Source * const&, _Dest * const&)
	{	
	return {};
	}

		

 











#line 828 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  
   
  #line 834 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 841 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 848 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 855 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  


  
   
  #line 864 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  


  
   
  #line 871 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  


  
   
  #line 880 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

  

  


		
template<class _Pr,
	class _Ty1,
	class _Ty2> inline
	constexpr bool _Debug_lt_pred(_Pr&& _Pred,
		_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
		noexcept(noexcept(!_Pred(_Left, _Right)) && noexcept(_Pred(_Right, _Left)))
#line 895 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	{	
	return (!_Pred(_Left, _Right)
		? false
		: _Pred(_Right, _Left)
			? (_Debug_message(L"invalid comparator", _File, _Line), true)
			: true);
	}

		
template<class _Ty1,
	class _Ty2> inline
	constexpr bool _Debug_lt(_Ty1&& _Left, _Ty2&& _Right,
		_Dbfile_t _File, _Dbline_t _Line)
		noexcept(noexcept(!(_Left < _Right)) && noexcept(_Right < _Left))
#line 910 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	{	
	return (_Debug_lt_pred(less<>(),
		::std:: forward<_Ty1>(_Left), ::std:: forward<_Ty2>(_Right), _File, _Line));
	}

		
template<class _InIt> inline
	void _Debug_pointer(_InIt&, _Dbfile_t, _Dbline_t)
	{	
	}

template<class _Ty> inline
	void _Debug_pointer(_Ty *_Ptr, _Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_Ptr == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}

		
template<class _InIt> inline
	void _Debug_pointer_if(bool, _InIt&, _Dbfile_t, _Dbline_t)
	{	
	}

template<class _Ty> inline
	void _Debug_pointer_if(bool _Test, _Ty *_Ptr,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_Test && _Ptr == 0)
		_Debug_message(L"invalid null pointer", _File, _Line);
	}

		
template<class _InIt> inline
	void _Debug_range2(_InIt _First, _InIt _Last,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	
	static_cast<void>(_First == _Last);	
	}

template<class _RanIt> inline
	void _Debug_range2(_RanIt _First, _RanIt _Last,
		_Dbfile_t _File, _Dbline_t _Line, random_access_iterator_tag)
	{	
	if (_First != _Last)
		{	
		_Debug_pointer(_First, _File, _Line);
		_Debug_pointer(_Last, _File, _Line);
		if (_Last < _First)
			_Debug_message(L"invalid iterator range", _File, _Line);
		}
	}

template<class _InIt> inline
	void _Debug_range(_InIt _First, _InIt _Last,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat_t<_InIt>());
	}

		
template<class _InIt,
	class _Pty> inline
	void _Debug_range_ptr2(_InIt _First, _InIt _Last, _Pty& _Ptr,
		_Dbfile_t _File, _Dbline_t _Line, input_iterator_tag)
	{	
	if (_First != _Last)
		_Debug_pointer(_Ptr, _File, _Line);	
	}

template<class _RanIt,
	class _Pty> inline
	void _Debug_range_ptr2(_RanIt _First, _RanIt _Last, _Pty& _Ptr,
		_Dbfile_t _File, _Dbline_t _Line, random_access_iterator_tag)
	{	
	if (_First != _Last)
		{	
		_Debug_pointer(_First, _File, _Line);
		_Debug_pointer(_Last, _File, _Line);
		if (_Last < _First)
			_Debug_message(L"invalid iterator range", _File, _Line);
		_Debug_pointer(_Ptr, _File, _Line);	
		}
	}

template<class _InIt,
	class _Pty> inline
	void _Debug_range_ptr(_InIt _First, _InIt _Last, _Pty& _Ptr,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range_ptr2(_First, _Last, _Ptr, _File, _Line, _Iter_cat_t<_InIt>());
	}

		
template<class _InIt,
	class _Pr> inline
	void _Debug_order2(_InIt, _InIt, _Pr&,
		_Dbfile_t, _Dbline_t, input_iterator_tag)
	{	
	}

template<class _FwdIt,
	class _Pr> inline
	void _Debug_order2(_FwdIt _First, _FwdIt _Last, _Pr& _Pred,
		_Dbfile_t _File, _Dbline_t _Line, forward_iterator_tag)
	{	
	for (_FwdIt _Next = _First; _First != _Last && ++_Next != _Last; ++_First)
		if (_Debug_lt_pred(_Pred, *_Next, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1017))
			_Debug_message(L"sequence not ordered", _File, _Line);
	}

template<class _InIt,
	class _Pr> inline
	void _Debug_order(_InIt _First, _InIt _Last, _Pr&& _Pred,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, _File, _Line);
	_Debug_order2(_First, _Last, _Pred, _File, _Line, _Iter_cat_t<_InIt>());
	}
 #line 1030 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

 

#line 1034 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"








#line 1043 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
template<class _Ty,
	size_t _Actual,
	class _Diff> inline
	void _Debug_array_size2(_Ty (&)[_Actual], _Diff _Desired,
		_Dbfile_t _File, _Dbline_t _Line)
	{	
	if (_Actual < _Desired)
		_Debug_message(L"array too small", _File, _Line);
	}
  
 #line 1054 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
		
template<class _InIt,
	class _Diff> inline
	void _Advance1(_InIt& _Where, _Diff _Off, input_iterator_tag)
	{	
 
	if (_Off < 0)
		_Debug_message(L"negative offset in advance", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1063);
 #line 1065 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	for (; 0 < _Off; --_Off)
		++_Where;
	}

template<class _BidIt,
	class _Diff> inline
	void _Advance1(_BidIt& _Where, _Diff _Off, bidirectional_iterator_tag)
	{	
	for (; 0 < _Off; --_Off)
		++_Where;
	for (; _Off < 0; ++_Off)
		--_Where;
	}

template<class _RanIt,
	class _Diff> inline
	void _Advance1(_RanIt& _Where, _Diff _Off, random_access_iterator_tag)
	{	
	_Where += _Off;
	}

template<class _InIt,
	class _Diff> inline
	void advance(_InIt& _Where, _Diff _Off)
	{	
		
	_Advance1(_Where, _Off, _Iter_cat_t<remove_const_t<_InIt>>());
	}

		
template<class _InIt> inline
	_Iter_diff_t<_InIt>
		_Distance1(_InIt _First, _InIt _Last, input_iterator_tag)
	{	
	_Iter_diff_t<_InIt> _Off = 0;
	for (; _First != _Last; ++_First)
		++_Off;

	return (_Off);
	}

template<class _RanIt> inline
	_Iter_diff_t<_RanIt>
		_Distance1(_RanIt _First, _RanIt _Last, random_access_iterator_tag)
	{	
 
	if (_First != _Last)
		{	
		_Debug_pointer(_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1114);
		_Debug_pointer(_Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1115);
		}
 #line 1118 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	return (_Last - _First);
	}

template<class _InIt> inline
	_Iter_diff_t<_InIt>
		distance(_InIt _First, _InIt _Last)
	{	
	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));
	}

		
template<class _InIt> inline
	_InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)
	{	
	static_assert(is_base_of<input_iterator_tag,
		typename iterator_traits<_InIt>::iterator_category>::value,
		"next requires input iterator");

	::std:: advance(_First, _Off);
	return (_First);
	}

		
template<class _BidIt> inline
	_BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)
	{	
	static_assert(is_base_of<bidirectional_iterator_tag,
		typename iterator_traits<_BidIt>::iterator_category>::value,
		"prev requires bidirectional iterator");

	::std:: advance(_First, -_Off);
	return (_First);
	}

		
template<class _Ty>
	struct pointer_traits;

template<class _RanIt>
	class reverse_iterator
		: public iterator<
			typename iterator_traits<_RanIt>::iterator_category,
			typename iterator_traits<_RanIt>::value_type,
			typename iterator_traits<_RanIt>::difference_type,
			typename iterator_traits<_RanIt>::pointer,
			typename iterator_traits<_RanIt>::reference>
	{	
	typedef reverse_iterator<_RanIt> _Myt;

public:
	typedef typename iterator_traits<_RanIt>::difference_type difference_type;
	typedef typename iterator_traits<_RanIt>::pointer pointer;
	typedef typename iterator_traits<_RanIt>::reference reference;
	typedef _RanIt iterator_type;

	reverse_iterator()
		: current()
		{	
		}

	explicit reverse_iterator(_RanIt _Right)
		: current(_Right)
		{	
		}

	template<class _Other>
		reverse_iterator(const reverse_iterator<_Other>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _Other>
		_Myt& operator=(const reverse_iterator<_Other>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		_RanIt _Tmp = current;
		return (*--_Tmp);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
		--current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		++current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

protected:
	_RanIt current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<reverse_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt> inline
	reverse_iterator<_RanIt> operator+(
		typename reverse_iterator<_RanIt>::difference_type _Off,
		const reverse_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
			-> decltype(_Right.base() - _Left.base())
	{	
	return (_Right.base() - _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Left.base() == _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right.base() < _Left.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(const reverse_iterator<_RanIt1>& _Left,
		const reverse_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	reverse_iterator<_RanIt> make_reverse_iterator(_RanIt _Iter)
	{	
	return (reverse_iterator<_RanIt>(_Iter));
	}

		

template<class _Container>
	auto inline begin(_Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline begin(const _Container& _Cont) -> decltype(_Cont.begin())
	{	
	return (_Cont.begin());
	}

template<class _Container>
	auto inline end(_Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Container>
	auto inline end(const _Container& _Cont) -> decltype(_Cont.end())
	{	
	return (_Cont.end());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *begin(_Ty (&_Array)[_Size]) noexcept
	{	
	return (_Array);
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *end(_Ty (&_Array)[_Size]) noexcept
	{	
	return (_Array + _Size);
	}

		
template<class _Container>
	constexpr auto inline cbegin(const _Container& _Cont)
		noexcept(noexcept(::std:: begin(_Cont)))
		-> decltype(::std:: begin(_Cont))
	{	
	return (::std:: begin(_Cont));
	}

template<class _Container>
	constexpr auto inline cend(const _Container& _Cont)
		noexcept(noexcept(::std:: end(_Cont)))
		-> decltype(::std:: end(_Cont))
	{	
	return (::std:: end(_Cont));
	}

		
template<class _Container>
	auto inline rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
	{	
	return (_Cont.rbegin());
	}

template<class _Container>
	auto inline rend(_Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Container>
	auto inline rend(const _Container& _Cont) -> decltype(_Cont.rend())
	{	
	return (_Cont.rend());
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rbegin(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array + _Size));
	}

template<class _Ty,
	size_t _Size> inline
	reverse_iterator<_Ty *> rend(_Ty (&_Array)[_Size])
	{	
	return (reverse_iterator<_Ty *>(_Array));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *>
		rbegin(::std:: initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.end()));
	}

template<class _Elem> inline
	reverse_iterator<const _Elem *>
		rend(::std:: initializer_list<_Elem> _Ilist)
	{	
	return (reverse_iterator<const _Elem *>(_Ilist.begin()));
	}

		
template<class _Container>
	auto inline crbegin(const _Container& _Cont)
		-> decltype(::std:: rbegin(_Cont))
	{	
	return (::std:: rbegin(_Cont));
	}

template<class _Container>
	auto inline crend(const _Container& _Cont)
		-> decltype(::std:: rend(_Cont))
	{	
	return (::std:: rend(_Cont));
	}


template<class _Container>
	constexpr auto inline size(const _Container& _Cont)
		-> decltype(_Cont.size())
	{	
	return (_Cont.size());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr size_t size(const _Ty(&)[_Size]) noexcept
	{	
	return (_Size);
	}

template<class _Container>
	constexpr auto inline empty(const _Container& _Cont)
		-> decltype(_Cont.empty())
	{	
	return (_Cont.empty());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr bool empty(const _Ty(&)[_Size]) noexcept
	{	
	return (false);
	}

template<class _Elem> inline
	constexpr bool empty(
		::std:: initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.size() == 0);
	}

template<class _Container>
	constexpr auto inline data(_Container& _Cont)
		-> decltype(_Cont.data())
	{	
	return (_Cont.data());
	}

template<class _Container>
	constexpr auto inline data(const _Container& _Cont)
		-> decltype(_Cont.data())
	{	
	return (_Cont.data());
	}

template<class _Ty,
	size_t _Size> inline
	constexpr _Ty *data(_Ty(&_Array)[_Size]) noexcept
	{	
	return (_Array);
	}

template<class _Elem> inline
	constexpr const _Elem *data(
		::std:: initializer_list<_Elem> _Ilist) noexcept
	{	
	return (_Ilist.begin());
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			_Ty,
			ptrdiff_t,
			const _Ty *,
			const _Ty&,
			_Iterator_base>
	{	
public:
	typedef _Array_const_iterator<_Ty, _Size> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef const _Ty *pointer;
	typedef const _Ty& reference;
	enum {_EEN_SIZE = _Size};	
 




























































































































#line 1687 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	_Array_const_iterator()
		: _Ptr(),
		_Idx(0)
		{	
		}

	explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0)
		: _Ptr(_Parg),
		_Idx(_Off)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Idx = _Right - _Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr + _Idx);
		}

	reference operator*() const
		{	
 
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	
			_Debug_message(L"array iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1718);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1719, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1719, 0); };
			}

 


#line 1726 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		;

		return (_Ptr[_Idx]);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (_Ptr == 0
			|| _Size <= _Idx)
			{	
			_Debug_message(L"array iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1743);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1744, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1744, 0); };
			}

 


#line 1751 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		++_Idx;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (_Ptr == 0
			|| _Idx <= 0)
			{	
			_Debug_message(L"array iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1769);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1770, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1770, 0); };
			}

 


#line 1777 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		--_Idx;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (_Size < _Idx + _Off)
			{	
			_Debug_message(L"array iterator + offset out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1794);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1795, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1795, 0); };
			}

 

#line 1801 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		_Idx += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx < _Right._Idx
			? -(difference_type)(_Right._Idx - _Idx)
			: (difference_type)_Idx - _Right._Idx);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx == _Right._Idx);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Idx < _Right._Idx);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (_Ptr != _Right._Ptr)
			{	
			_Debug_message(L"array iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1873);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1874, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 1874, 0); };
			}
		}

 




#line 1884 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

	pointer _Ptr;	
	size_t _Idx;	
 #line 1888 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_const_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_const_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size>&
		_Rechecked(_Array_const_iterator<_Ty, _Size>& _Iter,
			typename _Array_const_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_const_iterator<_Ty, _Size> operator+(
		typename _Array_const_iterator<_Ty, _Size>::difference_type _Off,
		_Array_const_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Ty,
	size_t _Size>
	class _Array_iterator
		: public _Array_const_iterator<_Ty, _Size>
	{	
public:
	typedef _Array_iterator<_Ty, _Size> _Myiter;
	typedef _Array_const_iterator<_Ty, _Size> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef _Ty value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef _Ty *pointer;
	typedef _Ty& reference;

	_Array_iterator()
		{	
		}

	explicit _Array_iterator(pointer _Parg, size_t _Off = 0)
		: _Mybase(_Parg, _Off)
		{	
		}
	enum {_EEN_SIZE = _Size};	
	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		((_Mybase *)this)->_Rechecked(_Right);
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return ((pointer)((_Mybase *)this)->_Unchecked());
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Ty,
	size_t _Size> inline
	typename _Array_iterator<_Ty, _Size>::_Unchecked_type
		_Unchecked(_Array_iterator<_Ty, _Size> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size>&
		_Rechecked(_Array_iterator<_Ty, _Size>& _Iter,
			typename _Array_iterator<_Ty, _Size>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Ty,
	size_t _Size> inline
	_Array_iterator<_Ty, _Size> operator+(
		typename _Array_iterator<_Ty, _Size>::difference_type _Off,
		_Array_iterator<_Ty, _Size> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _RanIt>
	class move_iterator
	{	
public:
	typedef move_iterator<_RanIt> _Myt;
	typedef typename iterator_traits<_RanIt>::iterator_category
		iterator_category;
	typedef typename iterator_traits<_RanIt>::value_type
		value_type;
	typedef typename iterator_traits<_RanIt>::difference_type
		difference_type;
	typedef _RanIt pointer;
	typedef typename iterator_traits<_RanIt>::reference _Ref0;
	typedef conditional_t<is_reference<_Ref0>::value,
		remove_reference_t<_Ref0>&&, _Ref0> reference;
	typedef _RanIt iterator_type;

	move_iterator()
		: current()
		{	
		}

	explicit move_iterator(iterator_type _Right)
		: current(_Right)
		{	
		}

	template<class _RanIt2>
		move_iterator(const move_iterator<_RanIt2>& _Right)
		: current(_Right.base())
		{	
		}

	template<class _RanIt2>
		_Myt& operator=(const move_iterator<_RanIt2>& _Right)
		{	
		current = _Right.base();
		return (*this);
		}

	_RanIt base() const
		{	
		return (current);
		}

	reference operator*() const
		{	
		return (static_cast<reference>(*current));
		}

	pointer operator->() const
		{	
		return (current);
		}

	_Myt& operator++()
		{	
		++current;
		return (*this);
		}

	_Myt operator++(int)
		{	
		_Myt _Tmp = *this;
		++current;
		return (_Tmp);
		}

	_Myt& operator--()
		{	
		--current;
		return (*this);
		}

	_Myt operator--(int)
		{	
		_Myt _Tmp = *this;
		--current;
		return (_Tmp);
		}

	template<class _RanIt2>
		bool _Equal(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current == _Right.base());
		}



	_Myt& operator+=(difference_type _Off)
		{	
		current += _Off;
		return (*this);
		}

	_Myt operator+(difference_type _Off) const
		{	
		return (_Myt(current + _Off));
		}

	_Myt& operator-=(difference_type _Off)
		{	
		current -= _Off;
		return (*this);
		}

	_Myt operator-(difference_type _Off) const
		{	
		return (_Myt(current - _Off));
		}

	reference operator[](difference_type _Off) const
		{	
		return (::std:: move(current[_Off]));
		}

	template<class _RanIt2>
		bool _Less(const move_iterator<_RanIt2>& _Right) const
		{	
		return (current < _Right.base());
		}

	difference_type operator-(const _Myt& _Right) const
		{	
		return (current - _Right.base());
		}

protected:
	iterator_type current;	
	};

template<class _RanIt>
	struct _Is_checked_helper<move_iterator<_RanIt> >
		: public _Is_checked_helper<_RanIt>
	{	
	};

		
template<class _RanIt,
	class _Diff> inline
	move_iterator<_RanIt>
		operator+(_Diff _Off,
		const move_iterator<_RanIt>& _Right)
	{	
	return (_Right + _Off);
	}

template<class _RanIt1,
	class _RanIt2>
	auto inline operator-(
		move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
			-> decltype(_Left.base() - _Right.base())
	{	
	return (_Left.base() - _Right.base());
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator==(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Equal(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator!=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator<=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _RanIt1,
	class _RanIt2> inline
	bool operator>=(
		const move_iterator<_RanIt1>& _Left,
		const move_iterator<_RanIt2>& _Right)
	{	
	return (!(_Left < _Right));
	}

		
template<class _RanIt> inline
	move_iterator<_RanIt> make_move_iterator(_RanIt _Iter)
	{	
	return (move_iterator<_RanIt>(_Iter));
	}

		
template<class _Traits>
	struct _Char_traits_eq
	{
	typedef typename _Traits::char_type _Elem;

	bool operator()(_Elem _Left, _Elem _Right) const
		{
		return (_Traits::eq(_Left, _Right));
		}
	};

		
template<class _Traits>
	struct _Char_traits_lt
	{
	typedef typename _Traits::char_type _Elem;

	bool operator()(_Elem _Left, _Elem _Right) const
		{
		return (_Traits::lt(_Left, _Right));
		}
	};

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_memmove(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	const char * const _First_ch = reinterpret_cast<const char *>(_First);
	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
	const size_t _Count = _Last_ch - _First_ch;
	:: memmove(_Dest_ch, _First_ch, _Count);
	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
		
	return (_Copy_unchecked1(_First, _Last,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Copy_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Copy_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2362);
	return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt copy(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Copy_no_deprecate(_First, _Last, _Dest));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		_Copy_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2388 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
		_OutIt _Dest, input_iterator_tag)
	{	
	if (0 < _Count)
		{
		*_Dest = *_First;
		while (0 < --_Count)
			*++_Dest = *++_First;
		return (++_Dest);
		}

	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked2(_InIt _First, _Diff _Count,
		_OutIt _Dest, forward_iterator_tag)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		*_Dest = *_First;
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	
		
		
	return (_Copy_n_unchecked2(_First, _Count,
		_Dest, _Iter_cat_t<_InIt>()));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked1(_InIt _First, _Diff _Count,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	if (0 < _Count)
		return (_Copy_memmove(_First, _First + _Count, _Dest));
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt _Copy_n_unchecked(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
	return (_Copy_n_unchecked1(_First, _Count,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InIt _First, _Diff _Count,
		_OutIt _Dest)
	{	
		
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "copy_n" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Rechecked(_Dest,
		_Copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
	}

 
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutIt> inline
	_OutIt copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutIt _Dest)
	{	
		
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "copy_n" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_array_size2(_First, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2473);
	return (_Rechecked(_Dest,
		_Copy_n_unchecked(_First, _Count, _Unchecked_n(_Dest, _Count))));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	_Debug_array_size2(_Dest, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2485);
	return (_Copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Dest));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	_Debug_array_size2(_First, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2497);
	_Debug_array_size2(_Dest, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2498);
	return (_Copy_n_unchecked(_First, _Count, _Dest));
	}
 #line 2502 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	const char * const _First_ch = reinterpret_cast<const char *>(_First);
	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
	const size_t _Count = _Last_ch - _First_ch;
	return (static_cast<_BidIt2>(
		:: memmove(_Dest_ch - _Count, _First_ch, _Count)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _General_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = *--_Last;
	return (_Dest);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	return (_Copy_backward_memmove(_First, _Last, _Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Copy_backward_unchecked1(_First, _Last,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Copy_backward_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Copy_backward1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) - ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Copy_backward_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "copy_backward" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2569);
	return (_Copy_backward1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_BidIt1>(), _Iter_cat_t<_BidIt2>()));
	}

		
template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _General_ptr_iterator_tag)
	{	
	for (; _First != _Last; ++_Dest, (void)++_First)
		*_Dest = ::std:: move(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	return (_Move_unchecked1(_First, _Last,
		_Dest, _Ptr_move_cat(_First, _Dest)));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Move_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Move_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt _Move_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2626);
	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
	}

template<class _InIt,
	class _OutIt> inline
	_OutIt move(_InIt _First, _InIt _Last,
		_OutIt _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "move" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Move_no_deprecate(_First, _Last, _Dest));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *move(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		_Move_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 2652 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _General_ptr_iterator_tag)
	{	
	while (_First != _Last)
		*--_Dest = ::std:: move(*--_Last);
	return (_Dest);
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, _Trivially_copyable_ptr_iterator_tag)
	{	
	return (_Copy_backward_memmove(_First, _Last, _Dest));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	return (_Move_backward_unchecked1(_First, _Last,
		_Dest, _Ptr_move_cat(_First, _Dest)));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Move_backward_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 _Move_backward1(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) - ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Move_backward_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _BidIt1,
	class _BidIt2> inline
	_BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last,
		_BidIt2 _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "move_backward" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2706);
	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_BidIt1>(), _Iter_cat_t<_BidIt2>()));
	}

		
template<class _Ty>
	struct _Is_character
		: false_type
		{	
		};

template<>
	struct _Is_character<char>
		: true_type
		{	
		};

template<>
	struct _Is_character<signed char>
		: true_type
		{	
		};

template<>
	struct _Is_character<unsigned char>
		: true_type
		{	
		};

template<class _FwdIt,
	class _Ty>
	struct _Fill_memset_is_safe_helper
	{	
	typedef _Iter_value_t<_FwdIt> _Value_type;
	typedef typename conjunction<
		is_pointer<_FwdIt>,
		disjunction<
			conjunction<
				_Is_character<_Ty>,
				_Is_character<_Value_type>>,
			conjunction<
				is_same<bool, _Ty>,
				is_same<bool, _Value_type>>
		>>::type type;
	};

template<class _FwdIt,
	class _Ty> inline
	typename _Fill_memset_is_safe_helper<_FwdIt, _Ty>::type
	_Fill_memset_is_safe(const _FwdIt&, const _Ty&)
	{	
	return {};
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, false_type)
	{	
	for (; _First != _Last; ++_First)
		*_First = _Val;
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Ty& _Val, true_type)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt,
	class _Ty> inline
	void _Fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_Fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
	}

template<class _FwdIt,
	class _Ty> inline
	void fill(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2787);
	_Fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

		
template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, false_type)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest)
		*_Dest = _Val;
	return (_Dest);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked1(_OutIt _Dest, _Diff _Count, const _Ty& _Val, true_type)
	{	
	if (0 < _Count)
		{
		:: memset(_Dest, _Val, _Count);
		return (_Dest + _Count);
		}

	return (_Dest);
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt _Fill_n_unchecked(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
		
	return (_Fill_n_unchecked1(_Dest, _Count, _Val, _Fill_memset_is_safe(_Dest, _Val)));
	}

template<class _OutIt,
	class _Diff,
	class _Ty> inline
	_OutIt fill_n(_OutIt _Dest, _Diff _Count, const _Ty& _Val)
	{	
	return (_Rechecked(_Dest,
		_Fill_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Val)));
	}

		
template<class _Elem1,
	class _Elem2>
	struct _Value_equality_is_bitwise_equality
		: bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)>
	{	
		
		
		
	};

template<class _Elem1,
	class _Elem2,
	class _Pr>
	struct _Equal_memcmp_is_safe_helper
		: false_type
	{	
		
	};

template<class _Elem1,
	class _Elem2>
	struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, equal_to<>>
		: conjunction<
			_Is_same_size<_Elem1, _Elem2>,
			is_integral<_Elem1>,
			is_integral<_Elem2>,
			negation<is_same<bool, _Elem1>>,
			negation<is_same<bool, _Elem2>>,
			negation<is_volatile<_Elem1>>,
			negation<is_volatile<_Elem2>>,
			
			
			_Value_equality_is_bitwise_equality<_Elem1, _Elem2>
		>::type
	{	
	};

template<class _Elem1,
	class _Elem2>
	struct _Equal_memcmp_is_safe_helper<_Elem1 *, _Elem2 *, equal_to<>>
		: is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2>>::type
	{	
	};

template<class _Elem>
	struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
		: _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
	{	
	};

template<class _Elem>
	struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<_Elem>>
		: _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
	{	
		
	};

template<class _Iter1,
	class _Iter2,
	class _Pr> inline
	false_type _Equal_memcmp_is_safe(const _Iter1&, const _Iter2&, const _Pr&)
	{	
	return {};
	}

template<class _Obj1,
	class _Obj2,
	class _Pr> inline
	typename _Equal_memcmp_is_safe_helper<
		remove_const_t<_Obj1>,
		remove_const_t<_Obj2>,
		_Pr>::type
		_Equal_memcmp_is_safe(_Obj1 * const&, _Obj2 * const&, const _Pr&)
	{	
	return {};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred, false_type)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (true);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr&, true_type)
	{	
	const char * const _First1_ch = reinterpret_cast<const char *>(_First1);
	const char * const _First2_ch = reinterpret_cast<const char *>(_First2);
	const size_t _Count = reinterpret_cast<const char *>(_Last1) - _First1_ch;
	return (:: memcmp(_First1_ch, _First2_ch, _Count) == 0);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred)
	{	
	return (_Equal_unchecked1(_First1, _Last1, _First2, _Pred,
		_Equal_memcmp_is_safe(_First1, _First2, _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred, input_iterator_tag, input_iterator_tag)
	{	
	return (_Equal_unchecked(_First1, _Last1, _Unchecked_idl0(_First2), _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_First2) + ((_Last1) - (_First1)));
	return (_Equal_unchecked(_First1, _Last1, _Unchecked(_First2), _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2971);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 2972);
	return (_Equal_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Pred, _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "equal" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
	return (_Equal_no_deprecate(_First1, _Last1, _First2, _Pred));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _Pr,
	class = enable_if_t<!is_same<_InTy *, _Pr>::value>> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _Pr _Pred)
	{	
	return (_Equal_no_deprecate(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	}
 #line 3000 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2)
	{	
	return (::std:: equal(_First1, _Last1, _First2,
		equal_to<>()));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize])
	{	
	return (::std:: equal(_First1, _Last1, _First2,
		equal_to<>()));
	}
 #line 3022 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred,
			input_iterator_tag, input_iterator_tag)
	{	
		
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3032);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			return (false);
	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Equal_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred,
			random_access_iterator_tag, random_access_iterator_tag)
	{	
		
	if (_Last1 - _First1 != _Last2 - _First2)
		return (false);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3049);
	return (_Equal_unchecked(_First1, _Last1, _First2, _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3059);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3060);
	return (_Equal_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool equal(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: equal(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _Elem1,
	class _Elem2,
	class _FTy>
	struct _Lex_compare_check_element_types_helper
		: conjunction<
			_Is_character<_Elem1>,
			_Is_character<_Elem2>,
			_Is_character<_FTy>,
			is_unsigned<_FTy>
		>::type
	{	
	};

template<class _Elem1,
	class _Elem2>
	struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
		: conjunction<
			_Is_character<_Elem1>,
			_Is_character<_Elem2>,
			is_unsigned<_Elem1>,
			is_unsigned<_Elem2>
		>::type
	{	
	};

template<class _Memcmp_pr>
	struct _Lex_compare_optimize
	{	
	};

template<class _Memcmp_pr,
	class _Obj1,
	class _Obj2,
	class _FTy>
	using _Lex_compare_check_element_types = _Lex_compare_optimize<conditional_t<
		_Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value,
		_Memcmp_pr, void>>;	

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	_Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&)
	{	
		
	return {};
	}

template<class _Obj1,
	class _Obj2,
	class _FTy> inline
	_Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy>
		_Lex_compare_memcmp_classify(_Obj1 * const&, _Obj2 * const&, const less<_FTy>&)
	{	
	return {};
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lex_compare_unchecked1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred, _Lex_compare_optimize<void>)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		{	
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3141))
			return (true);
		else if (_Pred(*_First2, *_First1))
			return (false);
		}

	return (_First1 == _Last1 && _First2 != _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr,
	class _Memcmp_pr> inline
	bool _Lex_compare_unchecked1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr&, _Lex_compare_optimize<_Memcmp_pr>)
	{	
	const size_t _Num1 = _Last1 - _First1;
	const size_t _Num2 = _Last2 - _First2;
	const int _Ans = :: memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
	return (_Memcmp_pr{}(_Ans, 0) || _Ans == 0 && _Num1 < _Num2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred)
	{	
	return (_Lex_compare_unchecked1(_First1, _Last1, _First2, _Last2, _Pred,
		_Lex_compare_memcmp_classify(_First1, _First2, _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3179);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3180);
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3181);
	return (_Lex_compare_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: lexicographical_compare(_First1, _Last1,
		_First2, _Last2, less<>()));
	}

		
template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag)
	{	
	return ((-128) <= _Val && _Val <= 127);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
	{	
	return (_Val <= 127 || static_cast<_Ty>((-128)) <= _Val);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
	{	
	return (_Val <= 127);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag)
	{	
	return (0 <= _Val && _Val <= 0xff);
	}

template<class _Ty> inline
	bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag)
	{	
	return (_Val <= 0xff);
	}

template<class _InIt,
	class _Ty> inline
	bool _Within_limits(_InIt, const _Ty& _Val)
	{	
	typedef typename remove_pointer<_InIt>::type _Elem;
	return (_Within_limits(_Val, is_signed<_Elem>(), is_signed<_Ty>(),
		integral_constant<bool, -1 == static_cast<_Ty>(-1)>()));
	}

template<class _InIt> inline
	bool _Within_limits(_InIt, const bool&)
	{	
	return (true);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked1(_InIt _First, _InIt _Last, const _Ty& _Val, true_type)
	{	
	if (!_Within_limits(_First, _Val))
		return (_Last);
	_First = static_cast<_InIt>(:: memchr(
		_First, static_cast<unsigned char>(_Val), _Last - _First));
	return (_First ? _First : _Last);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked1(_InIt _First, _InIt _Last, const _Ty& _Val, false_type)
	{	
	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			break;
	return (_First);
	}

template<class _InIt,
	class _Ty> inline
	_InIt _Find_unchecked(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	
	typedef integral_constant<bool,
		(is_same<_InIt, char *>::value
		|| is_same<_InIt, signed char *>::value
		|| is_same<_InIt, unsigned char *>::value
		|| is_same<_InIt, const char *>::value
		|| is_same<_InIt, const signed char *>::value
		|| is_same<_InIt, const unsigned char *>::value)
		&& is_integral<_Ty>::value
	> _Memchr_opt;
	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));
	}

template<class _InIt,
	class _Ty> inline
	_InIt find(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3284);
	return (_Rechecked(_First,
		_Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			break;
	return (_First);
	}

		
template<class _InIt,
	class _Ty> inline
	_Iter_diff_t<_InIt>
		_Count_unchecked(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Iter_diff_t<_InIt> _Count = 0;

	for (; _First != _Last; ++_First)
		if (*_First == _Val)
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Ty> inline
	_Iter_diff_t<_InIt>
		count(_InIt _First, _InIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3320);
	return (_Count_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val));
	}

		
template<class _InIt,
	class _Ty,
	class _Pr> inline
	_Iter_diff_t<_InIt>
		_Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr& _Pred)
	{	
	_Iter_diff_t<_InIt> _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			++_Count;
	return (_Count);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr&,
		forward_iterator_tag, forward_iterator_tag)
	{	
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr& _Pred,
		bidirectional_iterator_tag, bidirectional_iterator_tag)
	{	
	
	while (_Pred(*--_Last1, *--_Last2))
		;	
	++_Last1;
	++_Last2;
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred)
	{	
	_Trim_matching_suffixes(_Last1, _Last2, _Pred,
		_Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
	for (_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
		if (_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
			{	
			_Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
			if (_Count2 == 0)
				return (false);	
			_FwdIt1 _Skip1 = ::std:: next(_Next1);
			_Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
			if (_Count2 != _Count1)
				return (false);	
			}

	return (true);
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr& _Pred)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			{	
			_FwdIt2 _Last2 = ::std:: next(_First2,
				::std:: distance(_First1, _Last1));
			return (_Check_match_counts(_First1, _Last1,
				_First2, _Last2, _Pred));
			}

	return (true);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_no_deprecate1(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr& _Pred, forward_iterator_tag, forward_iterator_tag)
	{	
	return (_Is_permutation_unchecked(_First1, _Last1, _Unchecked_idl0(_First2), _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_no_deprecate1(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr& _Pred, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_First2) + ((_Last1) - (_First1)));
	return (_Is_permutation_unchecked(_First1, _Last1, _Unchecked(_First2), _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_no_deprecate(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr& _Pred)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3429);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3430);
	return (_Is_permutation_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Pred, _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "is_permutation" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
	return (_Is_permutation_no_deprecate(_First1, _Last1, _First2, _Pred));
	}

 
template<class _FwdIt1,
	class _InTy,
	size_t _InSize,
	class _Pr,
	class = enable_if_t<!is_same<_InTy *, _Pr>::value>> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_InTy (&_First2)[_InSize], _Pr _Pred)
	{	
	return (_Is_permutation_no_deprecate(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Pred));
	}
 #line 3458 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_First2, equal_to<>()));
	}


 
template<class _FwdIt1,
	class _InTy,
	size_t _InSize> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_InTy (&_First2)[_InSize])
	{	
	return (::std:: is_permutation(_First1, _Last1, _First2, equal_to<>()));
	}
 #line 3480 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
		forward_iterator_tag, forward_iterator_tag)
	{	
		
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3490);
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
		if (!_Pred(*_First1, *_First2))
			{	
			if (::std:: distance(_First1, _Last1)
				!= ::std:: distance(_First2, _Last2))
				return (false);	
			else
				return (_Check_match_counts(_First1, _Last1,
					_First2, _Last2, _Pred));
			}

	return (_First1 == _Last1 && _First2 == _Last2);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
		
	if (_Last1 - _First1 != _Last2 - _First2)
		return (false);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3515);
	return (_Is_permutation_unchecked(_First1, _Last1, _First2, _Pred));
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
		
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3526);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3527);
	return (_Is_permutation_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred,
		_Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: is_permutation(_First1, _Last1,
		_First2, _Last2, equal_to<>()));
	}

		
template<class _BidIt> inline
	void _Reverse_unchecked(_BidIt _First, _BidIt _Last)
	{	
	for (; _First != _Last && _First != --_Last; ++_First)
		::std:: iter_swap(_First, _Last);
	}

template<class _BidIt> inline
	void reverse(_BidIt _First, _BidIt _Last)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3554);
	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));
	}

		
template<class _FwdIt> inline
	_FwdIt _Rotate_unchecked1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		forward_iterator_tag)
	{	
	for (_FwdIt _Next = _Mid, _Res = _Last; ; )
		{	
		::std:: iter_swap(_First, _Next);
		if (++_First == _Mid)
			{	
			if (++_Next == _Last)
				return (_Res == _Last ? _Mid : _Res);
			else
				_Mid = _Next;	
			}
		else if (++_Next == _Last)
			{	
			if (_Res == _Last)
				_Res = _First;
			_Next = _Mid;
			}
		}
	}

template<class _BidIt> inline
	pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(
		_BidIt _First, _BidIt _Sentinel, _BidIt _Last)
	{	
	while (_First != _Sentinel && _Last != _Sentinel)
		::std:: iter_swap(_First++, --_Last);
	return (::std:: make_pair(_First, _Last));
	}

template<class _BidIt> inline
	_BidIt _Rotate_unchecked1(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		bidirectional_iterator_tag)
	{	
	_Reverse_unchecked(_First, _Mid);
	_Reverse_unchecked(_Mid, _Last);
	pair<_BidIt, _BidIt> _Tmp = _Reverse_until_sentinel_unchecked(_First, _Mid, _Last);
	_Reverse_unchecked(_Tmp.first, _Tmp.second);
	return (_Mid != _Tmp.first ? _Tmp.first : _Tmp.second);
	}

template<class _RanIt> inline
	_RanIt _Rotate_unchecked1(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		random_access_iterator_tag)
	{	
	_Reverse_unchecked(_First, _Mid);
	_Reverse_unchecked(_Mid, _Last);
	_Reverse_unchecked(_First, _Last);
	return (_First + (_Last - _Mid));
	}

template<class _FwdIt> inline
	_FwdIt _Rotate_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	
	if (_First == _Mid)
		return (_Last);
	if (_Mid == _Last)
		return (_First);
	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));
	}

template<class _FwdIt> inline
	_FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
	{	
	_Debug_range(_First, _Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3625);
	_Debug_range(_Mid, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3626);
	return (_Rechecked(_First,
		_Rotate_unchecked(_Unchecked(_First), _Unchecked(_Mid),
		_Unchecked(_Last))));
	}

	
template<class _Diff,
	class _Urng>
	class _Rng_from_urng
	{	
public:
	typedef typename make_unsigned<_Diff>::type _Ty0;
	typedef typename _Urng::result_type _Ty1;

	typedef typename _If<sizeof (_Ty1) < sizeof (_Ty0),
		_Ty0, _Ty1>::type _Udiff;


	explicit _Rng_from_urng(_Urng& _Func)
		: _Ref(_Func), _Bits(8 * sizeof (_Udiff)), _Bmask(_Udiff(-1))
		{	
		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
			--_Bits;
		}

	_Diff operator()(_Diff _Index)
		{	
		for (; ; )
			{	
			_Udiff _Ret = 0;	
			_Udiff _Mask = 0;	

			while (_Mask < _Udiff(_Index - 1))
				{	
				_Ret <<= _Bits - 1;	
				_Ret <<= 1;
				_Ret |= _Get_bits();
				_Mask <<= _Bits - 1;	
				_Mask <<= 1;
				_Mask |= _Bmask;
				}

			
			if (_Ret / _Index < _Mask / _Index
				|| _Mask % _Index == _Udiff(_Index - 1))
				return (_Ret % _Index);
			}
		}

	_Udiff _Get_all_bits()
		{	
		_Udiff _Ret = 0;

		for (size_t _Num = 0; _Num < 8 * sizeof (_Udiff);
			_Num += _Bits)
			{	
			_Ret <<= _Bits - 1;	
			_Ret <<= 1;
			_Ret |= _Get_bits();
			}

		return (_Ret);
		}

	_Rng_from_urng(const _Rng_from_urng&) = delete;
	_Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

private:
	_Udiff _Get_bits()
		{	
		for (; ; )
			{	
			_Udiff _Val = _Ref() - (_Urng::min)();

			if (_Val <= _Bmask)
				return (_Val);
			}
		}

	_Urng& _Ref;	
	size_t _Bits;	
	_Udiff _Bmask;	
	};

		
template<class _Elem>
	class __declspec(dllimport) _Yarn
	{	
public:
	typedef _Yarn<_Elem> _Myt;

	 _Yarn()
		: _Myptr(0), _Nul(0)
		{	
		}

	 _Yarn(const _Myt& _Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	 _Yarn(const _Elem *_Right)
		: _Myptr(0), _Nul(0)
		{	
		*this = _Right;
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		return (*this = _Right._Myptr);
		}

	_Myt&  operator=(const _Elem *_Right)
		{	
		if (_Myptr != _Right)
			{	
			_Tidy();

			if (_Right != 0)
				{	
				const _Elem *_Ptr = _Right;
				while (*_Ptr != (_Elem)0)
					++_Ptr;
				size_t _Count = ((const char *)++_Ptr - (const char *)_Right);

 
				_Myptr = (_Elem *)_malloc_dbg(_Count, 2,
					"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility", 3755);

 

#line 3760 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

				if (_Myptr != 0)
					:: memcpy(_Myptr, _Right, _Count);
				}
			}

		return (*this);
		}

	 ~_Yarn() noexcept
		{	
		_Tidy();
		}

	bool  empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * c_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

	bool  _Empty() const
		{	
		return (_Myptr == 0);
		}

	const _Elem * _C_str() const
		{	
		return (_Myptr != 0 ? _Myptr : &_Nul);
		}

private:
	void  _Tidy()
		{	
		if (_Myptr != 0)

 
			_free_dbg(_Myptr, 2);

 

#line 3805 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"

		_Myptr = 0;
		}

	_Elem *_Myptr;	
	_Elem _Nul;		
	};

	
template<class _Ty,
	class _Alloc>
	struct _Has_allocator_type
	{	
	template<class _Uty>
		static auto _Fn(int)
			-> is_convertible<_Alloc,
				typename _Uty::allocator_type>;
	template<class _Uty>
		static auto _Fn(_Wrap_int)
			-> false_type;

	typedef decltype(_Fn<_Ty>(0)) type;
	};

		
struct allocator_arg_t
	{	
	};

constexpr allocator_arg_t allocator_arg{};

[[noreturn]] __declspec(dllimport) void __cdecl _Xbad_alloc();
[[noreturn]] __declspec(dllimport) void __cdecl _Xinvalid_argument(  const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xlength_error(  const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xout_of_range(  const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xoverflow_error(  const char *);
[[noreturn]] __declspec(dllimport) void __cdecl _Xruntime_error(  const char *);
}

namespace std {
		
template<class _Ty,
	class _Alloc>
	struct uses_allocator
		: _Has_allocator_type<_Ty, _Alloc>::type
	{	
	};

 
template<class _Ty,
	class _Alloc>
	constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;
 #line 3858 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
}	
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3863 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"
#line 3864 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xutility"






#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 
  
 #line 20 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 #pragma warning(disable: 4100)

namespace std {



 


 

#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 

  


#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

  #line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
 #line 43 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
inline
	__declspec(allocator) void *_Allocate(size_t _Count, size_t _Sz,
		bool _Try_aligned_allocation = true)
	{	
	void *_Ptr = 0;

	if (_Count == 0)
		return (_Ptr);

	
	if ((size_t)(-1) / _Sz < _Count)
		_Xbad_alloc();	
	const size_t _User_size = _Count * _Sz;

 
	if (_Try_aligned_allocation
		&& 4096 <= _User_size)
		{	
		static_assert(sizeof (void *) < 32,
			"Big allocations should at least match vector register size");
		const size_t _Block_size = (2 * sizeof(void *) + 32 - 1) + _User_size;
		if (_Block_size <= _User_size)
			_Xbad_alloc();	
		const uintptr_t _Ptr_container =
			reinterpret_cast<uintptr_t>(::operator new(_Block_size));
		{ if (!(_Ptr_container != 0)) { (void)( (!!(("_Ptr_container != 0" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 70, 0, L"%ls", L"\"_Ptr_container != 0\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 70, 0); } ; };
		_Ptr = reinterpret_cast<void *>((_Ptr_container + (2 * sizeof(void *) + 32 - 1))
			& ~(32 - 1));
		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

 
		static_cast<uintptr_t *>(_Ptr)[-2] = 0xFAFAFAFAUL;
 #line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
		}
	else
 #line 81 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		{	
		_Ptr = ::operator new(_User_size);
		{ if (!(_Ptr != 0)) { (void)( (!!(("_Ptr != 0" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 84, 0, L"%ls", L"\"_Ptr != 0\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 84, 0); } ; };
		}
	return (_Ptr);
	}

		
inline
	void _Deallocate(void * _Ptr, size_t _Count, size_t _Sz)
	{	
 
	{ if (!(_Count <= (size_t)(-1) / _Sz)) { (void)( (!!(("_Count <= (size_t)(-1) / _Sz" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 94, 0, L"%ls", L"\"_Count <= (size_t)(-1) / _Sz\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 94, 0); } ; };
	const size_t _User_size = _Count * _Sz;
	if (4096 <= _User_size)
		{	
		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
		{ if (!((_Ptr_user & (32 - 1)) == 0)) { (void)( (!!(("(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 100, 0, L"%ls", L"\"(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 100, 0); } ; };
#line 101 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
		const uintptr_t _Ptr_container =
			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

 
		
		
		{ if (!(reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == 0xFAFAFAFAUL)) { (void)( (!!(("reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_SENTINEL" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 110, 0, L"%ls", L"\"reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_SENTINEL\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 110, 0); } ; };
#line 111 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
 #line 112 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
		{ if (!(_Ptr_container < _Ptr_user)) { (void)( (!!(("_Ptr_container < _Ptr_user" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 114, 0, L"%ls", L"\"_Ptr_container < _Ptr_user\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 114, 0); } ; };

 
		{ if (!(2 * sizeof(void *) <= _Ptr_user - _Ptr_container)) { (void)( (!!(("2 * sizeof(void *) <= _Ptr_user - _Ptr_container" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 118, 0, L"%ls", L"\"2 * sizeof(void *) <= _Ptr_user - _Ptr_container\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 118, 0); } ; };
#line 119 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 


#line 124 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		{ if (!(_Ptr_user - _Ptr_container <= (2 * sizeof(void *) + 32 - 1))) { (void)( (!!(("_Ptr_user - _Ptr_container <= _NON_USER_SIZE" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 126, 0, L"%ls", L"\"_Ptr_user - _Ptr_container <= _NON_USER_SIZE\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 126, 0); } ; };
#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		_Ptr = reinterpret_cast<void *>(_Ptr_container);
		}
 #line 131 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

	::operator delete(_Ptr);
	}

		
template<class _Ty1,
	class _Ty2> inline
	void _Construct(_Ty1 *_Ptr, _Ty2&& _Val)
	{	
	void *_Vptr = _Ptr;
	::new (_Vptr) _Ty1(::std:: forward<_Ty2>(_Val));
	}

template<class _Ty1> inline
	void _Construct(_Ty1 *_Ptr)
	{	
	void *_Vptr = _Ptr;

	::new (_Vptr) _Ty1();
	}

		
template<class _Alty>
	struct _Is_simple_alloc
		: _Cat_base<is_same<typename _Alty::size_type, size_t>::value
		&& is_same<typename _Alty::difference_type, ptrdiff_t>::value
		&& is_same<typename _Alty::pointer,
			typename _Alty::value_type *>::value
		&& is_same<typename _Alty::const_pointer,
			const typename _Alty::value_type *>::value
		&& is_same<typename _Alty::reference,
			typename _Alty::value_type&>::value
		&& is_same<typename _Alty::const_reference,
			const typename _Alty::value_type&>::value>
	{	
	};

		
template<class _Value_type>
	struct _Simple_types
	{	
	typedef _Value_type value_type;
	typedef size_t size_type;
	typedef ptrdiff_t difference_type;
	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef value_type& reference;
	typedef const value_type& const_reference;
	};

		
template<class _Alty,
	class _Pointer>
	struct _Get_voidptr
	{	
	typedef typename _Alty::template rebind<void>::other _Alvoid;
	typedef typename _Alvoid::pointer type;
	};

template<class _Alty,
	class _Ty>
	struct _Get_voidptr<_Alty, _Ty *>
	{	
	typedef void *type;
	};

		
template<class _Ty>
	struct _Get_first_parameter;

template<template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Get_first_parameter<_Ty<_First, _Rest...> >
	{	
	typedef _First type;
	};

		
template<class _Newfirst,
	class _Ty>
	struct _Replace_first_parameter;

template<class _Newfirst,
	template<class, class...> class _Ty,
	class _First,
	class... _Rest>
	struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...> >
	{	
	typedef _Ty<_Newfirst, _Rest...> type;
	};

		
template<class _Ty>
	struct _Get_element_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::element_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_first_parameter<_Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 228 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_ptr_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<ptrdiff_t>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 234 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty,
	class _Other>
	struct _Get_rebind_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::template rebind<_Other>::other>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Replace_first_parameter<_Other , _Uty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 241 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct pointer_traits
	{	
	typedef typename _Get_element_type<_Ty>::type element_type;
	typedef _Ty pointer;
	typedef typename _Get_ptr_difference_type<_Ty>::type difference_type;

	template<class _Other>
		using rebind = typename _Get_rebind_type<_Ty, _Other>::type;

	typedef typename _If<is_void<element_type>::value,
		char&,
		typename add_lvalue_reference<element_type>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (_Ty::pointer_to(_Val));
		}
	};

		
template<class _Ty>
	struct pointer_traits<_Ty *>
	{	
	typedef _Ty element_type;
	typedef _Ty *pointer;
	typedef ptrdiff_t difference_type;

	template<class _Other>
		using rebind = _Other *;

	typedef typename _If<is_void<_Ty>::value,
		char&,
		typename add_lvalue_reference<_Ty>::type>::type _Reftype;

	static pointer pointer_to(_Reftype _Val)
		{	
		return (::std:: addressof(_Val));
		}
	};


		
template<class _Ptrty> inline
	void _Destroy(_Ptrty _Ptr)
	{	
	typedef typename pointer_traits<_Ptrty>::element_type _Ty;
	_Ptr->~_Ty();
	}

		
template<class _Ptrty> inline
	auto _Const_cast(_Ptrty _Ptr)
	{	
	using _Elem = typename pointer_traits<_Ptrty>::element_type;
	using _Modifiable = remove_const_t<_Elem>;
	using _Dest = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

	return (pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr)));
	}

template<class _Ty> inline
	auto _Const_cast(_Ty * _Ptr)
	{	
	return (const_cast<remove_const_t<_Ty> *>(_Ptr));
	}


		
template<class _Ty>
	struct _Get_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Ty::value_type *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 316 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const typename _Ty::value_type>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 323 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 330 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_const_void_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::const_void_pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename pointer_traits<typename _Get_pointer_type<_Ty>::type> ::template rebind<const void>>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 337 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_difference_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::difference_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename _Get_ptr_difference_type< typename _Get_pointer_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 344 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_size_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::size_type>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename make_unsigned< typename _Get_difference_type<_Ty>::type>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 351 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_copy
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_copy_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 357 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_move
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_move_assignment>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 363 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_propagate_on_container_swap
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::propagate_on_container_swap>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<false_type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 369 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	struct _Get_is_always_equal
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::is_always_equal>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<typename is_empty<_Ty>::type>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 375 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

		
template<class _Ty>
	class allocator;
template<class _Alloc>
	struct _Wrap_alloc;

template<class _Alloc>
	struct _Unwrap_alloc
	{	
	typedef _Alloc type;
	};

template<class _Alloc>
	struct _Unwrap_alloc<_Wrap_alloc<_Alloc>>
	{	
	typedef _Alloc type;
	};


		
template<class _Alloc>
	using _Unwrap_alloc_t = typename _Unwrap_alloc<_Alloc>::type;


		
template<class _Alloc,
	class = void>
	struct _Is_default_allocator
		: false_type
	{	
	};

template<class _Ty>
	struct _Is_default_allocator<allocator<_Ty>, typename allocator<_Ty>::_Not_user_specialized>
		: true_type
	{	
	};

		
struct _Alloc_allocate
	{	
		

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer _Hint)
			-> decltype(_Al.allocate(_Count, _Hint))
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	template<class _Alloc,
		class _Size_type,
		class _Const_void_pointer>
		static auto _Fn(_Wrap_int, _Alloc& _Al,
			_Size_type _Count,
			_Const_void_pointer)
			-> decltype(_Al.allocate(_Count))
		{	
		return (_Al.allocate(_Count));
		}
	};

		
struct _Has_no_alloc_construct_tag
	{	
	};

template<class _Void,
	class... _Types>
	struct _Has_no_alloc_construct
		: true_type
	{	
	};

template<class _Alloc,
	class _Ptr,
	class... _Args>
	struct _Has_no_alloc_construct<
		void_t<
			_Has_no_alloc_construct_tag,	
			decltype(::std:: declval<_Alloc&>().construct(::std:: declval<_Ptr>(), ::std:: declval<_Args>()...))>,
		_Alloc, _Ptr, _Args...>
		: false_type
	{	
	};

template<class _Alloc,
	class _Ptr,
	class... _Args>
	using _Uses_default_construct = disjunction<
		_Is_default_allocator<_Alloc>,
		_Has_no_alloc_construct<void, _Alloc, _Ptr, _Args...>>;

template<class _Alloc,
	class _Ptr,
	class... _Args>
	using _Uses_default_construct_t = typename _Uses_default_construct<_Alloc, _Ptr, _Args...>::type;


		
struct _Has_no_alloc_destroy_tag
	{	
	};

template<class _Alloc,
	class _Ptr,
	class = void>
	struct _Has_no_alloc_destroy
		: true_type
	{	
	};

template<class _Alloc,
	class _Ptr>
	struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<
			_Has_no_alloc_destroy_tag,	
			decltype(::std:: declval<_Alloc&>().destroy(::std:: declval<_Ptr>()))>>
		: false_type
	{	
	};

template<class _Alloc,
	class _Ptr>
	using _Uses_default_destroy = disjunction<
		_Is_default_allocator<_Alloc>,
		_Has_no_alloc_destroy<_Alloc, _Ptr>>;

template<class _Alloc,
	class _Ptr>
	using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;


		
struct _Alloc_max_size
	{	
	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al) noexcept
			-> decltype(_Al.max_size())
		{	
		return (_Al.max_size());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty&) noexcept
			-> typename _Get_size_type<_Ty>::type
		{	
		return ((numeric_limits<typename _Get_size_type<_Ty>::type>::max)()
			/ sizeof(typename _Ty::value_type));
		}
	};

		
struct _Alloc_select
	{	
		

	template<class _Ty>
		static auto _Fn(int, const _Ty& _Al)
			-> decltype((_Ty)_Al.select_on_container_copy_construction())
		{	
		return (_Al.select_on_container_copy_construction());
		}

	template<class _Ty>
		static auto _Fn(_Wrap_int, const _Ty& _Al)
			-> _Ty
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct allocator_traits
	{	
	typedef _Alloc allocator_type;
	typedef typename _Alloc::value_type value_type;

	typedef typename _Get_pointer_type<_Alloc>::type
		pointer;
	typedef typename _Get_const_pointer_type<_Alloc>::type
		const_pointer;
	typedef typename _Get_void_pointer_type<_Alloc>::type
		void_pointer;
	typedef typename _Get_const_void_pointer_type<_Alloc>::type
		const_void_pointer;

	typedef typename _Get_size_type<_Alloc>::type size_type;
	typedef typename _Get_difference_type<_Alloc>::type difference_type;

	typedef typename _Get_propagate_on_container_copy<_Alloc>::type
		propagate_on_container_copy_assignment;
	typedef typename _Get_propagate_on_container_move<_Alloc>::type
		propagate_on_container_move_assignment;
	typedef typename _Get_propagate_on_container_swap<_Alloc>::type
		propagate_on_container_swap;
	typedef typename _Get_is_always_equal<_Alloc>::type
		is_always_equal;

	template<class _Other>
		using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

	template<class _Other>
		using rebind_traits = allocator_traits<rebind_alloc<_Other> >;

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Alloc_allocate::_Fn(0, _Al, _Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		static void _Construct1(true_type, _Alloc&, _Ty *_Ptr,
			_Types&&... _Args)
		{	
		::new (static_cast<void *>(_Ptr))
			_Ty(::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class... _Types>
		static void _Construct1(false_type, _Alloc& _Al, _Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty,
		class... _Types>
		static void construct(_Alloc& _Al, _Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Construct1(_Uses_default_construct_t<_Unwrap_alloc_t<_Alloc>, _Ty *, _Types...>(),
			_Al, _Ptr, ::std:: forward<_Types>(_Args)...);
		}

	template<class _Ty>
		static void _Destroy1(_Alloc&, _Ty *_Ptr, true_type)
		{	
		_Ptr->~_Ty();
		}

	template<class _Ty>
		static void _Destroy1(_Alloc& _Al, _Ty *_Ptr, false_type)
		{	
		_Al.destroy(_Ptr);
		}

	template<class _Ty>
		static void destroy(_Alloc& _Al, _Ty *_Ptr)
		{	
		_Destroy1(_Al, _Ptr, _Uses_default_destroy_t<_Unwrap_alloc_t<_Alloc>, _Ty *>());
		}

	static size_type max_size(const _Alloc& _Al) noexcept
		{	
		return (_Alloc_max_size::_Fn(0, _Al));
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Alloc_select::_Fn(0, _Al));
		}
	};

		
template<class _Ty>
	class allocator
	{	
public:
	static_assert(!is_const<_Ty>::value,
		"The C++ Standard forbids containers of const elements "
		"because allocator<const T> is ill-formed.");

	typedef void _Not_user_specialized;

	typedef _Ty value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;

	typedef value_type& reference;
	typedef const value_type& const_reference;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef true_type propagate_on_container_move_assignment;
	typedef true_type is_always_equal;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const noexcept
		{	
		return (::std:: addressof(_Val));
		}

	const_pointer address(const_reference _Val) const noexcept
		{	
		return (::std:: addressof(_Val));
		}

	allocator() noexcept
		{	
		}

	allocator(const allocator<_Ty>&) noexcept
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) noexcept
		{	
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Deallocate(_Ptr, _Count, sizeof (_Ty));
		}

	__declspec(allocator) pointer allocate(size_type _Count)
		{	
		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
		}

	__declspec(allocator) pointer allocate(size_type _Count, const void *)
		{	
		return (allocate(_Count));
		}

	template<class _Objty,
		class... _Types>
		void construct(_Objty *_Ptr, _Types&&... _Args)
		{	
		::new ((void *)_Ptr) _Objty(::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		void destroy(_Uty *_Ptr)
		{	
		_Ptr->~_Uty();
		}

	size_t max_size() const noexcept
		{	
		return ((size_t)(-1) / sizeof (_Ty));
		}
	};

		
template<>
	class allocator<void>
	{	
public:
	typedef void _Not_user_specialized;

	typedef void value_type;

	typedef void *pointer;
	typedef const void *const_pointer;

	template<class _Other>
		struct rebind
		{	
		typedef allocator<_Other> other;
		};

	allocator() noexcept
		{	
		}

	allocator(const allocator<void>&) noexcept
		{	
		}

	template<class _Other>
		allocator(const allocator<_Other>&) noexcept
		{	
		}

	template<class _Other>
		allocator<void>& operator=(const allocator<_Other>&)
		{	
		return (*this);
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&,
		const allocator<_Other>&) noexcept
	{	
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>& _Left,
		const allocator<_Other>& _Right) noexcept
	{	
	return (false);
	}

		
template<class _Ty>
	struct allocator_traits<allocator<_Ty> >
	{	
	typedef allocator<_Ty> _Alloc;

	typedef _Alloc allocator_type;
	typedef _Ty value_type;

	typedef value_type *pointer;
	typedef const value_type *const_pointer;
	typedef void *void_pointer;
	typedef const void *const_void_pointer;

	typedef size_t size_type;
	typedef ptrdiff_t difference_type;

	typedef false_type propagate_on_container_copy_assignment;
	typedef true_type propagate_on_container_move_assignment;
	typedef false_type propagate_on_container_swap;
	typedef true_type is_always_equal;

	template<class _Other>
		using rebind_alloc = allocator<_Other>;

	template<class _Other>
		using rebind_traits = allocator_traits<allocator<_Other> >;

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count)
		{	
		return (_Al.allocate(_Count));
		}

	static __declspec(allocator) pointer allocate(_Alloc& _Al, size_type _Count,
		const_void_pointer _Hint)
		{	
		return (_Al.allocate(_Count, _Hint));
		}

	static void deallocate(_Alloc& _Al,
		pointer _Ptr, size_type _Count)
		{	
		_Al.deallocate(_Ptr, _Count);
		}

	template<class _Objty,
		class... _Types>
		static void construct(_Alloc& _Al, _Objty *_Ptr,
			_Types&&... _Args)
		{	
		_Al.construct(_Ptr, ::std:: forward<_Types>(_Args)...);
		}


	template<class _Uty>
		static void destroy(_Alloc& _Al, _Uty *_Ptr)
		{	
		_Al.destroy(_Ptr);
		}

	static size_type max_size(const _Alloc& _Al) noexcept
		{	
		return (_Al.max_size());
		}

	static _Alloc select_on_container_copy_construction(
		const _Alloc& _Al)
		{	
		return (_Al);
		}
	};

		
template<class _Alloc>
	struct _Wrap_alloc
		: public _Alloc
	{	
	typedef _Alloc _Mybase;
	typedef allocator_traits<_Alloc> _Mytraits;

	typedef typename _Mytraits::value_type value_type;

	typedef typename _Mytraits::pointer pointer;
	typedef typename _Mytraits::const_pointer const_pointer;
	typedef typename _Mytraits::void_pointer void_pointer;
	typedef typename _Mytraits::const_void_pointer const_void_pointer;

	typedef typename _If<is_void<value_type>::value,
		int, value_type>::type& reference;
	typedef typename _If<is_void<const value_type>::value,
		const int, const value_type>::type& const_reference;

	typedef typename _Mytraits::size_type size_type;
	typedef typename _Mytraits::difference_type difference_type;

	typedef typename _Mytraits::propagate_on_container_copy_assignment
		propagate_on_container_copy_assignment;
	typedef typename _Mytraits::propagate_on_container_move_assignment
		propagate_on_container_move_assignment;
	typedef typename _Mytraits::propagate_on_container_swap
		propagate_on_container_swap;
	typedef typename _Mytraits::is_always_equal
		is_always_equal;

	_Wrap_alloc select_on_container_copy_construction(_Nil = _Nil()) const
		{	
		return (_Mytraits::select_on_container_copy_construction(*this));
		}

	template<class _Other>
		struct rebind
		{	
		typedef typename _Mytraits::template rebind_alloc<_Other>
			_Other_alloc;
		typedef _Wrap_alloc<_Other_alloc> other;
		};

	pointer address(reference _Val) const
		{	
		return (pointer_traits<pointer>::pointer_to(_Val));
		}

	const_pointer address(const_reference _Val) const
		{	
		return (pointer_traits<const_pointer>::pointer_to(_Val));
		}

	_Wrap_alloc() noexcept(is_nothrow_default_constructible<_Alloc>::value)
		: _Mybase()
		{	
		}

	_Wrap_alloc(const _Wrap_alloc& _Right) noexcept
		: _Mybase(_Right)
		{	
		}

	_Wrap_alloc(_Wrap_alloc&& _Right) noexcept
		: _Mybase(::std:: move(_Right))
		{	
		}

	template<class _Other>
		_Wrap_alloc(_Other&& _Right) noexcept
		: _Mybase(::std:: forward<_Other>(_Right))
		{	
		}

	_Wrap_alloc& operator=(const _Wrap_alloc& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	_Wrap_alloc& operator=(_Wrap_alloc&& _Right)
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	template<class _Other>
		_Wrap_alloc& operator=(_Other&& _Right)
		{	
		_Mybase::operator=(::std:: forward<_Other>(_Right));
		return (*this);
		}

	__declspec(allocator) pointer allocate(size_type _Count)
		{	
		return (_Mybase::allocate(_Count));
		}

	__declspec(allocator) pointer allocate(size_type _Count,
		const_void_pointer _Hint, _Nil = _Nil())
		{	
		return (_Mytraits::allocate(*this, _Count, _Hint));
		}

	void deallocate(pointer _Ptr, size_type _Count)
		{	
		_Mybase::deallocate(_Ptr, _Count);
		}

	template<class _Ty,
		class... _Types>
		void construct(_Ty *_Ptr,
			_Types&&... _Args)
		{	
		_Mytraits::construct(*this, _Ptr,
			::std:: forward<_Types>(_Args)...);
		}


	template<class _Ty>
		void destroy(_Ty *_Ptr)
		{	
		_Mytraits::destroy(*this, _Ptr);
		}

	size_type max_size(_Nil = _Nil()) const noexcept
		{	
		return (_Mytraits::max_size(*this));
		}
	};

template<class _Ty,
	class _Other> inline
	bool operator==(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) noexcept
	{	
	return (static_cast<const _Ty&>(_Left)
		== static_cast<const _Other&>(_Right));
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const _Wrap_alloc<_Ty>& _Left,
		const _Wrap_alloc<_Other>& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

		
template<class _Alty> inline
	void _Pocca(_Alty& _Left, const _Alty& _Right, true_type) noexcept
	{	
	_Left = _Right;
	}

template<class _Alty> inline
	void _Pocca(_Alty&, const _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocca(_Alty& _Left, const _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_copy_assignment _Tag;
	_Pocca(_Left, _Right, _Tag);
	}

		
template<class _Alty> inline
	void _Pocma(_Alty& _Left, _Alty& _Right, true_type) noexcept
	{	
	_Left = ::std:: move(_Right);
	}

template<class _Alty> inline
	void _Pocma(_Alty&, _Alty&, false_type) noexcept
	{	
	}

template<class _Alty> inline
	void _Pocma(_Alty& _Left, _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_move_assignment _Tag;
	_Pocma(_Left, _Right, _Tag);
	}

		
template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right, true_type) noexcept
	{	
	_Swap_adl(_Left, _Right);
	}

template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right, false_type) noexcept
	{	
	if (_Left != _Right)
		{	
 
		_Debug_message(L"containers incompatible for swap", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0", 1080);
 

#line 1084 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
		}
	}

template<class _Alty> inline
	void _Pocs(_Alty& _Left, _Alty& _Right) noexcept
	{	
	typename _Alty::propagate_on_container_swap _Tag;
	_Pocs(_Left, _Right, _Tag);
	}


		
template<class _Alloc,
	class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
	void _Destroy_range1(_Ptr _First, _Ptr _Last, _Wrap_alloc<_Alloc>& _Al, false_type)
	{	
	for (; _First != _Last; ++_First)
		_Al.destroy(_Unfancy(_First));
	}

template<class _Alloc,
	class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
	void _Destroy_range1(_Ptr, _Ptr, _Wrap_alloc<_Alloc>&, true_type)
	{	
		
	}

template<class _Alloc,
	class _Ptr = typename _Wrap_alloc<_Alloc>::pointer> inline
	void _Destroy_range(_Ptr _First, _Ptr _Last, _Wrap_alloc<_Alloc>& _Al)
	{	
		
		
	typedef typename _Alloc::value_type _Val;
	_Destroy_range1(_First, _Last, _Al, typename conjunction<
		is_trivially_destructible<_Val>,
		_Uses_default_destroy<_Alloc, _Val *>>::type());
	}


		
template<class _FwdIt> inline
	void _Destroy_range1(_FwdIt _First, _FwdIt _Last, false_type)
	{	
	for (; _First != _Last; ++_First)
		_Destroy(_First);
	}

template<class _FwdIt> inline
	void _Destroy_range1(_FwdIt, _FwdIt, true_type)
	{	
		
	}

template<class _FwdIt> inline
	void _Destroy_range(_FwdIt _First, _FwdIt _Last)
	{	
		
		
	_Destroy_range1(_First, _Last, is_trivially_destructible<_Iter_value_t<_FwdIt>>());
	}
}

		
  #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
		
typedef enum memory_order {
	memory_order_relaxed,
	memory_order_consume,
	memory_order_acquire,
	memory_order_release,
	memory_order_acq_rel,
	memory_order_seq_cst
	} memory_order;

typedef _Uint32t _Uint4_t;
typedef _Uint4_t _Atomic_integral_t;

	
	




  
  
  
  
  

  

#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"
   
  #line 44 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"

		

typedef long _Atomic_flag_t;

  

		
typedef _Atomic_integral_t _Atomic_counter_t;

inline _Atomic_integral_t
	_Get_atomic_count(const _Atomic_counter_t& _Counter)
	{	
	return (_Counter);
	}

inline void _Init_atomic_counter(_Atomic_counter_t& _Counter,
	_Atomic_integral_t _Value)
	{	
	_Counter = _Value;
	}

 
  
   
  

#line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"
 #line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"

		
extern "C" {
__declspec(dllimport) void __cdecl _Lock_shared_ptr_spin_lock();
__declspec(dllimport) void __cdecl _Unlock_shared_ptr_spin_lock();
}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 84 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"
#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xatomic0.h"





#line 1149 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

  
   #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"












#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"







#pragma once


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"









__pragma(pack(push, 8)) extern "C" {






    
    

    typedef struct __JUMP_BUFFER
    {
        unsigned long Ebp;
        unsigned long Ebx;
        unsigned long Edi;
        unsigned long Esi;
        unsigned long Esp;
        unsigned long Eip;
        unsigned long Registration;
        unsigned long TryLevel;
        unsigned long Cookie;
        unsigned long UnwindFunc;
        unsigned long UnwindData[6];
    } _JUMP_BUFFER;





























































































#line 139 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"





    
    typedef int jmp_buf[16];
#line 147 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"




    
#line 153 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"




int __cdecl _setjmp(
      jmp_buf _Buf
    );


    #pragma warning(push)
    #pragma warning(disable:4987) 
    __declspec(noreturn) void __cdecl longjmp(
          jmp_buf _Buf,
          int     _Value
        ) throw(...);
    #pragma warning(pop)





#line 175 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\setjmp.h"


} __pragma(pack(pop))
#line 20 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"



    
        #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"













#pragma once



#line 19 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"







#line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
















#pragma once



#line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"







#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"

















#pragma once



#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"







#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

















#pragma once



#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"







#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"










#pragma once



#line 16 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"







#line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
















#pragma once



#line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"







#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"




















#pragma once



#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"







#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"



#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"



























#pragma once



#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"







#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"














#pragma once






#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"



#line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"


extern "C" { 


#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(8)) __m64
{
    unsigned __int64    m64_u64;
    float               m64_f32[2];
    __int8              m64_i8[8];
    __int16             m64_i16[4];
    __int32             m64_i32[2];
    __int64             m64_i64;
    unsigned __int8     m64_u8[8];
    unsigned __int16    m64_u16[4];
    unsigned __int32    m64_u32[2];
} __m64;



void  _m_empty(void);
__m64 _m_from_int(int _I);
int   _m_to_int(__m64 _M);
__m64 _m_packsswb(__m64 _MM1, __m64 _MM2);
__m64 _m_packssdw(__m64 _MM1, __m64 _MM2);
__m64 _m_packuswb(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2);
__m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2);
__m64 _m_punpckldq(__m64 _MM1, __m64 _MM2);


__m64 _m_paddb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddd(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddsw(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusb(__m64 _MM1, __m64 _MM2);
__m64 _m_paddusw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubd(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubsw(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusb(__m64 _MM1, __m64 _MM2);
__m64 _m_psubusw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2);
__m64 _m_pmulhw(__m64 _MM1, __m64 _MM2);
__m64 _m_pmullw(__m64 _MM1, __m64 _MM2);


__m64 _m_psllw(__m64 _M, __m64 _Count);
__m64 _m_psllwi(__m64 _M, int _Count);
__m64 _m_pslld(__m64 _M, __m64 _Count);
__m64 _m_pslldi(__m64 _M, int _Count);
__m64 _m_psllq(__m64 _M, __m64 _Count);
__m64 _m_psllqi(__m64 _M, int _Count);
__m64 _m_psraw(__m64 _M, __m64 _Count);
__m64 _m_psrawi(__m64 _M, int _Count);
__m64 _m_psrad(__m64 _M, __m64 _Count);
__m64 _m_psradi(__m64 _M, int _Count);
__m64 _m_psrlw(__m64 _M, __m64 _Count);
__m64 _m_psrlwi(__m64 _M, int _Count);
__m64 _m_psrld(__m64 _M, __m64 _Count);
__m64 _m_psrldi(__m64 _M, int _Count);
__m64 _m_psrlq(__m64 _M, __m64 _Count);
__m64 _m_psrlqi(__m64 _M, int _Count);


__m64 _m_pand(__m64 _MM1, __m64 _MM2);
__m64 _m_pandn(__m64 _MM1, __m64 _MM2);
__m64 _m_por(__m64 _MM1, __m64 _MM2);
__m64 _m_pxor(__m64 _MM1, __m64 _MM2);


__m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2);
__m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2);


__m64 _mm_setzero_si64(void);
__m64 _mm_set_pi32(int _I1, int _I0);
__m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4,
                  char _B3, char _B2, char _B1, char _B0);
__m64 _mm_set1_pi32(int _I);
__m64 _mm_set1_pi16(short _S);
__m64 _mm_set1_pi8(char _B);
__m64 _mm_setr_pi32(int _I1, int _I0);
__m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0);
__m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4,
                   char _B3, char _B2, char _B1, char _B0);

























































#line 184 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"


}; 
#line 188 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"

#line 190 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"
#line 191 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"
#line 192 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mmintrin.h"
#line 47 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 48 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"

















typedef union __declspec(intrin_type) __declspec(align(16)) __m128 {
     float               m128_f32[4];
     unsigned __int64    m128_u64[2];
     __int8              m128_i8[16];
     __int16             m128_i16[8];
     __int32             m128_i32[4];
     __int64             m128_i64[2];
     unsigned __int8     m128_u8[16];
     unsigned __int16    m128_u16[8];
     unsigned __int32    m128_u32[4];
 } __m128;




#line 81 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 82 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"

 
 
 
 
 
 
 
 
 
 




 
 
 
 
 
 
 
 
 
 












































































 
 
 


extern "C" { 
  
#line 191 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





extern __m128 _mm_add_ss(__m128 _A, __m128 _B);
extern __m128 _mm_add_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ss(__m128 _A, __m128 _B);
extern __m128 _mm_sub_ps(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ss(__m128 _A, __m128 _B);
extern __m128 _mm_mul_ps(__m128 _A, __m128 _B);
extern __m128 _mm_div_ss(__m128 _A, __m128 _B);
extern __m128 _mm_div_ps(__m128 _A, __m128 _B);
extern __m128 _mm_sqrt_ss(__m128 _A);
extern __m128 _mm_sqrt_ps(__m128 _A);
extern __m128 _mm_rcp_ss(__m128 _A);
extern __m128 _mm_rcp_ps(__m128 _A);
extern __m128 _mm_rsqrt_ss(__m128 _A);
extern __m128 _mm_rsqrt_ps(__m128 _A);
extern __m128 _mm_min_ss(__m128 _A, __m128 _B);
extern __m128 _mm_min_ps(__m128 _A, __m128 _B);
extern __m128 _mm_max_ss(__m128 _A, __m128 _B);
extern __m128 _mm_max_ps(__m128 _A, __m128 _B);





extern __m128 _mm_and_ps(__m128 _A, __m128 _B);
extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B);
extern __m128 _mm_or_ps(__m128 _A, __m128 _B);
extern __m128 _mm_xor_ps(__m128 _A, __m128 _B);





extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B);
extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B);
extern int _mm_comieq_ss(__m128 _A, __m128 _B);
extern int _mm_comilt_ss(__m128 _A, __m128 _B);
extern int _mm_comile_ss(__m128 _A, __m128 _B);
extern int _mm_comigt_ss(__m128 _A, __m128 _B);
extern int _mm_comige_ss(__m128 _A, __m128 _B);
extern int _mm_comineq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomieq_ss(__m128 _A, __m128 _B);
extern int _mm_ucomilt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomile_ss(__m128 _A, __m128 _B);
extern int _mm_ucomigt_ss(__m128 _A, __m128 _B);
extern int _mm_ucomige_ss(__m128 _A, __m128 _B);
extern int _mm_ucomineq_ss(__m128 _A, __m128 _B);





extern int _mm_cvt_ss2si(__m128 _A);
extern int _mm_cvtt_ss2si(__m128 _A);
extern __m128 _mm_cvt_si2ss(__m128, int);
extern float _mm_cvtss_f32(__m128 _A);





extern __m64 _mm_cvt_ps2pi(__m128 _A);
extern __m64 _mm_cvtt_ps2pi(__m128 _A);
extern __m128 _mm_cvt_pi2ps(__m128, __m64);
#line 282 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"








#line 291 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned int _Imm8);
extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B);
extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B);
extern __m128 _mm_loadh_pi(__m128, __m64 const*);
extern __m128 _mm_movehl_ps(__m128, __m128);
extern __m128 _mm_movelh_ps(__m128, __m128);
extern void _mm_storeh_pi(__m64 *, __m128);
extern __m128 _mm_loadl_pi(__m128, __m64 const*);
extern void _mm_storel_pi(__m64 *, __m128);
extern int _mm_movemask_ps(__m128 _A);






extern int _m_pextrw(__m64, int);
extern __m64 _m_pinsrw(__m64, int, int);
extern __m64 _m_pmaxsw(__m64, __m64);
extern __m64 _m_pmaxub(__m64, __m64);
extern __m64 _m_pminsw(__m64, __m64);
extern __m64 _m_pminub(__m64, __m64);
extern int _m_pmovmskb(__m64);
extern __m64 _m_pmulhuw(__m64, __m64);
extern __m64 _m_pshufw(__m64, int);
extern void _m_maskmovq(__m64, __m64, char *);
extern __m64 _m_pavgb(__m64, __m64);
extern __m64 _m_pavgw(__m64, __m64);
extern __m64 _m_psadbw(__m64, __m64);
#line 326 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"





extern __m128 _mm_set_ss(float _A);
extern __m128 _mm_set_ps1(float _A);
extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D);
extern __m128 _mm_setzero_ps(void);
extern __m128 _mm_load_ss(float const*_A);
extern __m128 _mm_load_ps1(float const*_A);
extern __m128 _mm_load_ps(float const*_A);
extern __m128 _mm_loadr_ps(float const*_A);
extern __m128 _mm_loadu_ps(float const*_A);
extern void _mm_store_ss(float *_V, __m128 _A);
extern void _mm_store_ps1(float *_V, __m128 _A);
extern void _mm_store_ps(float *_V, __m128 _A);
extern void _mm_storer_ps(float *_V, __m128 _A);
extern void _mm_storeu_ps(float *_V, __m128 _A);
extern void _mm_prefetch(char const*_A, int _Sel);

extern void _mm_stream_pi(__m64 *, __m64);
#line 350 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
extern void _mm_stream_ps(float *, __m128);
extern __m128 _mm_move_ss(__m128 _A, __m128 _B);

extern void _mm_sfence(void);
extern unsigned int _mm_getcsr(void);
extern void _mm_setcsr(unsigned int);
























#line 381 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"







 
 
 


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64  _Ext_val = _m_pcmpgtw(_mm_setzero_si64(), _A);

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu16_ps(__m64 _A)
{
  __m128 _Tmp;
  __m64  _Ext_val = _mm_setzero_si64();

  _Tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(_A, _Ext_val));
  return(_mm_cvt_pi2ps(_mm_movelh_ps(_Tmp, _Tmp),
                        _m_punpcklwd(_A, _Ext_val)));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi16(__m128 _A)
{
  return _m_packssdw(_mm_cvt_ps2pi(_A),
                        _mm_cvt_ps2pi(_mm_movehl_ps(_A, _A)));
}


 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi8_ps(__m64 _A)
{
  __m64  _Ext_val = _m_pcmpgtb(_mm_setzero_si64(), _A);

  return _mm_cvtpi16_ps(_m_punpcklbw(_A, _Ext_val));
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpu8_ps(__m64 _A)
{
  return _mm_cvtpu16_ps(_m_punpcklbw(_A, _mm_setzero_si64()));
}


 
 
 
 
 
 
 
 
__inline __m64 _mm_cvtps_pi8(__m128 _A)
{
  return _m_packsswb(_mm_cvtps_pi16(_A), _mm_setzero_si64());
}


 
 
 
 
 
 
 
 
 
__inline __m128 _mm_cvtpi32x2_ps(__m64 _A, __m64 _B)
{
  return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), _A),
                       _mm_cvt_pi2ps(_mm_setzero_ps(), _B));
}
#line 506 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"



}; 
#line 511 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"

#line 513 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 514 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 515 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmmintrin.h"
#line 43 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"

typedef union __declspec(intrin_type) __declspec(align(16)) __m128i {
    __int8              m128i_i8[16];
    __int16             m128i_i16[8];
    __int32             m128i_i32[4];
    __int64             m128i_i64[2];
    unsigned __int8     m128i_u8[16];
    unsigned __int16    m128i_u16[8];
    unsigned __int32    m128i_u32[4];
    unsigned __int64    m128i_u64[2];
} __m128i;

typedef struct __declspec(intrin_type) __declspec(align(16)) __m128d {
    double              m128d_f64[2];
} __m128d;






 
 
 


extern "C" { 
  
#line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"





extern __m128d _mm_add_sd(__m128d _A, __m128d _B);
extern __m128d _mm_add_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sub_pd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_sd(__m128d _A, __m128d _B);
extern __m128d _mm_mul_pd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_sqrt_pd(__m128d _A);
extern __m128d _mm_div_sd(__m128d _A, __m128d _B);
extern __m128d _mm_div_pd(__m128d _A, __m128d _B);
extern __m128d _mm_min_sd(__m128d _A, __m128d _B);
extern __m128d _mm_min_pd(__m128d _A, __m128d _B);
extern __m128d _mm_max_sd(__m128d _A, __m128d _B);
extern __m128d _mm_max_pd(__m128d _A, __m128d _B);





extern __m128d _mm_and_pd(__m128d _A, __m128d _B);
extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B);
extern __m128d _mm_or_pd(__m128d _A, __m128d _B);
extern __m128d _mm_xor_pd(__m128d _A, __m128d _B);





extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B);
extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B);
extern int _mm_comieq_sd(__m128d _A, __m128d _B);
extern int _mm_comilt_sd(__m128d _A, __m128d _B);
extern int _mm_comile_sd(__m128d _A, __m128d _B);
extern int _mm_comigt_sd(__m128d _A, __m128d _B);
extern int _mm_comige_sd(__m128d _A, __m128d _B);
extern int _mm_comineq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomieq_sd(__m128d _A, __m128d _B);
extern int _mm_ucomilt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomile_sd(__m128d _A, __m128d _B);
extern int _mm_ucomigt_sd(__m128d _A, __m128d _B);
extern int _mm_ucomige_sd(__m128d _A, __m128d _B);
extern int _mm_ucomineq_sd(__m128d _A, __m128d _B);





extern __m128d _mm_cvtepi32_pd(__m128i _A);
extern __m128i _mm_cvtpd_epi32(__m128d _A);
extern __m128i _mm_cvttpd_epi32(__m128d _A);
extern __m128 _mm_cvtepi32_ps(__m128i _A);
extern __m128i _mm_cvtps_epi32(__m128 _A);
extern __m128i _mm_cvttps_epi32(__m128 _A);
extern __m128 _mm_cvtpd_ps(__m128d _A);
extern __m128d _mm_cvtps_pd(__m128 _A);
extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B);
extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B);

extern int _mm_cvtsd_si32(__m128d _A);
extern int _mm_cvttsd_si32(__m128d _A);
extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B);


extern __m64 _mm_cvtpd_pi32(__m128d _A);
extern __m64 _mm_cvttpd_pi32(__m128d _A);
extern __m128d _mm_cvtpi32_pd(__m64 _A);
#line 166 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"





extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B);
extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B);
extern int _mm_movemask_pd(__m128d _A);
extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I);





extern __m128d _mm_load_pd(double const*_Dp);
extern __m128d _mm_load1_pd(double const*_Dp);
extern __m128d _mm_loadr_pd(double const*_Dp);
extern __m128d _mm_loadu_pd(double const*_Dp);
extern __m128d _mm_load_sd(double const*_Dp);
extern __m128d _mm_loadh_pd(__m128d _A, double const*_Dp);
extern __m128d _mm_loadl_pd(__m128d _A, double const*_Dp);





extern __m128d _mm_set_sd(double _W);
extern __m128d _mm_set1_pd(double _A);
extern __m128d _mm_set_pd(double _Z, double _Y);
extern __m128d _mm_setr_pd(double _Y, double _Z);
extern __m128d _mm_setzero_pd(void);
extern __m128d _mm_move_sd(__m128d _A, __m128d _B);





extern void _mm_store_sd(double *_Dp, __m128d _A);
extern void _mm_store1_pd(double *_Dp, __m128d _A);
extern void _mm_store_pd(double *_Dp, __m128d _A);
extern void _mm_storeu_pd(double *_Dp, __m128d _A);
extern void _mm_storer_pd(double *_Dp, __m128d _A);
extern void _mm_storeh_pd(double *_Dp, __m128d _A);
extern void _mm_storel_pd(double *_Dp, __m128d _A);





extern __m128i _mm_add_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_add_epi32(__m128i _A, __m128i _B);

extern __m64 _mm_add_si64(__m64 _A, __m64 _B);
#line 221 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_add_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_max_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_min_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_min_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B);
extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B);

extern __m64 _mm_mul_su32(__m64 _A, __m64 _B);
#line 239 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B);
extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B);

extern __m64 _mm_sub_si64(__m64 _A, __m64 _B);
#line 247 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B);
extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B);





extern __m128i _mm_and_si128(__m128i _A, __m128i _B);
extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B);
extern __m128i _mm_or_si128(__m128i _A, __m128i _B);
extern __m128i _mm_xor_si128(__m128i _A, __m128i _B);





extern __m128i _mm_slli_si128(__m128i _A, int _Imm);
extern __m128i _mm_slli_epi16(__m128i _A, int _Count);
extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi32(__m128i _A, int _Count);
extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_slli_epi64(__m128i _A, int _Count);
extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi16(__m128i _A, int _Count);
extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srai_epi32(__m128i _A, int _Count);
extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_si128(__m128i _A, int _Imm);
extern __m128i _mm_srli_epi16(__m128i _A, int _Count);
extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi32(__m128i _A, int _Count);
extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count);
extern __m128i _mm_srli_epi64(__m128i _A, int _Count);
extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count);





extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B);





extern __m128i _mm_cvtsi32_si128(int _A);
extern int _mm_cvtsi128_si32(__m128i _A);





extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B);
extern int _mm_extract_epi16(__m128i _A, int _Imm);
extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm);
extern int _mm_movemask_epi8(__m128i _A);
extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm);
extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm);
extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm);
extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B);
extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B);





extern __m128i _mm_load_si128(__m128i const*_P);
extern __m128i _mm_loadu_si128(__m128i const*_P);
extern __m128i _mm_loadl_epi64(__m128i const*_P);






extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0);
#line 343 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_set_epi64x(__int64 _I1,__int64 _I0);
extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0);
extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4,
                             short _W3, short _W2, short _W1, short _W0);
extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12,
                            char _B11, char _B10, char _B9, char _B8,
                            char _B7, char _B6, char _B5, char _B4,
                            char _B3, char _B2, char _B1, char _B0);

extern __m128i _mm_set1_epi64(__m64 _Q);
#line 354 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_set1_epi64x(__int64 i);
extern __m128i _mm_set1_epi32(int _I);
extern __m128i _mm_set1_epi16(short _W);
extern __m128i _mm_set1_epi8(char _B);
extern __m128i _mm_setl_epi64(__m128i _Q);

extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1);
#line 362 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3);
extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3,
                              short _W4, short _W5, short _W6, short _W7);
extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12,
                             char _B11, char _B10, char _B9, char _B8,
                             char _B7, char _B6, char _B5, char _B4,
                             char _B3, char _B2, char _B1, char _B0);
extern __m128i _mm_setzero_si128(void);





extern void _mm_store_si128(__m128i *_P, __m128i _B);
extern void _mm_storeu_si128(__m128i *_P, __m128i _B);
extern void _mm_storel_epi64(__m128i *_P, __m128i _Q);
extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char *_P);





extern __m128i _mm_move_epi64(__m128i _Q);

extern __m128i _mm_movpi64_epi64(__m64 _Q);
extern __m64 _mm_movepi64_pi64(__m128i _Q);
#line 389 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"





extern void _mm_stream_pd(double *_Dp, __m128d _A);
extern void _mm_stream_si128(__m128i *_P, __m128i _A);
extern void _mm_clflush(void const*_P);
extern void _mm_lfence(void);
extern void _mm_mfence(void);
extern void _mm_stream_si32(int *_P, int _I);
extern void _mm_pause(void);





extern double _mm_cvtsd_f64(__m128d _A);







extern __m128  _mm_castpd_ps(__m128d);
extern __m128i _mm_castpd_si128(__m128d);
extern __m128d _mm_castps_pd(__m128);
extern __m128i _mm_castps_si128(__m128);
extern __m128  _mm_castsi128_ps(__m128i);
extern __m128d _mm_castsi128_pd(__m128i);













#line 434 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"


}; 
#line 438 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"

#line 440 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
#line 441 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
#line 442 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\emmintrin.h"
#line 35 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"

 
 
 














 
 
 


extern "C" { 
  
#line 61 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"





extern __m128 _mm_addsub_ps(__m128 , __m128 );
extern __m128 _mm_hadd_ps(__m128 , __m128 );
extern __m128 _mm_hsub_ps(__m128 , __m128 );
extern __m128 _mm_movehdup_ps(__m128 );
extern __m128 _mm_moveldup_ps(__m128 );





extern __m128d _mm_addsub_pd(__m128d , __m128d );
extern __m128d _mm_hadd_pd(__m128d , __m128d );
extern __m128d _mm_hsub_pd(__m128d , __m128d );
extern __m128d _mm_loaddup_pd(double const * );
extern __m128d _mm_movedup_pd(__m128d );




extern __m128i _mm_lddqu_si128(__m128i const * );







extern void _mm_monitor(void const * , unsigned , unsigned );




extern void _mm_mwait(unsigned , unsigned );


}; 
#line 103 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"

#line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
#line 106 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
#line 107 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\pmmintrin.h"
#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"









extern "C" {
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    
    
    
    
    

    extern __m128i _mm_hadd_epi16 (__m128i, __m128i);
    extern __m128i _mm_hadd_epi32 (__m128i, __m128i);
    extern __m128i _mm_hadds_epi16 (__m128i, __m128i);


    extern __m64 _mm_hadd_pi16 (__m64, __m64);
    extern __m64 _mm_hadd_pi32 (__m64, __m64);
    extern __m64 _mm_hadds_pi16 (__m64, __m64);
#line 54 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    
    
    
    
    
    

    extern __m128i _mm_hsub_epi16 (__m128i, __m128i);
    extern __m128i _mm_hsub_epi32 (__m128i, __m128i);
    extern __m128i _mm_hsubs_epi16 (__m128i, __m128i);


    extern __m64 _mm_hsub_pi16 (__m64, __m64);
    extern __m64 _mm_hsub_pi32 (__m64, __m64);
    extern __m64 _mm_hsubs_pi16 (__m64, __m64);
#line 72 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    
    
    
    
    
    
    

    extern __m128i _mm_maddubs_epi16 (__m128i, __m128i);


    extern __m64 _mm_maddubs_pi16 (__m64, __m64);
#line 87 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_mulhrs_epi16 (__m128i, __m128i);


    extern __m64 _mm_mulhrs_pi16 (__m64, __m64);
#line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_shuffle_epi8 (__m128i, __m128i);


    extern __m64 _mm_shuffle_pi8 (__m64, __m64);
#line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_sign_epi8 (__m128i, __m128i);
    extern __m128i _mm_sign_epi16 (__m128i, __m128i);
    extern __m128i _mm_sign_epi32 (__m128i, __m128i);


    extern __m64 _mm_sign_pi8 (__m64, __m64);
    extern __m64 _mm_sign_pi16 (__m64, __m64);
    extern __m64 _mm_sign_pi32 (__m64, __m64);
#line 118 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_alignr_epi8 (__m128i, __m128i, int);


    extern __m64 _mm_alignr_pi8 (__m64, __m64, int);
#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

    
    

    extern __m128i _mm_abs_epi8 (__m128i);
    extern __m128i _mm_abs_epi16 (__m128i);
    extern __m128i _mm_abs_epi32 (__m128i);


    extern __m64 _mm_abs_pi8 (__m64);
    extern __m64 _mm_abs_pi16 (__m64);
    extern __m64 _mm_abs_pi32 (__m64);
#line 140 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"


};
#line 144 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"

#line 146 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"
#line 147 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"
#line 148 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tmmintrin.h"
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"


















































extern "C" {
#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

        
        

        extern __m128i _mm_blend_epi16 (__m128i, __m128i, const int );
        extern __m128i _mm_blendv_epi8 (__m128i, __m128i, __m128i mask);

        
        

        extern __m128  _mm_blend_ps (__m128, __m128, const int );
        extern __m128  _mm_blendv_ps(__m128, __m128, __m128 );

        
        

        extern __m128d _mm_blend_pd (__m128d, __m128d, const int );
        extern __m128d _mm_blendv_pd(__m128d, __m128d, __m128d );

        
        

        extern __m128  _mm_dp_ps(__m128, __m128, const int );
        extern __m128d _mm_dp_pd(__m128d, __m128d, const int );

        
        

        extern __m128i _mm_cmpeq_epi64(__m128i, __m128i);

        

        extern __m128i _mm_min_epi8 (__m128i, __m128i);
        extern __m128i _mm_max_epi8 (__m128i, __m128i);

        extern __m128i _mm_min_epu16(__m128i, __m128i);
        extern __m128i _mm_max_epu16(__m128i, __m128i);

        extern __m128i _mm_min_epi32(__m128i, __m128i);
        extern __m128i _mm_max_epi32(__m128i, __m128i);
        extern __m128i _mm_min_epu32(__m128i, __m128i);
        extern __m128i _mm_max_epu32(__m128i, __m128i);

        
        

        extern __m128i _mm_mullo_epi32(__m128i, __m128i);

        
        

        extern __m128i _mm_mul_epi32(__m128i, __m128i);

        
        

        extern int _mm_testz_si128(__m128i , __m128i );

        
        

        extern int _mm_testc_si128(__m128i , __m128i );

        
        
        

        extern int _mm_testnzc_si128(__m128i , __m128i );

        
        
        
        
        

        extern __m128 _mm_insert_ps(__m128 , __m128 , const int );

        




        
        

        extern int _mm_extract_ps(__m128 , const int );

        
        




        
        





        
        

        extern __m128i _mm_insert_epi8 (__m128i , int , const int );
        extern __m128i _mm_insert_epi32(__m128i , int , const int );



#line 194 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
        
        

        extern int   _mm_extract_epi8 (__m128i , const int );
        extern int   _mm_extract_epi32(__m128i , const int );



#line 203 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

        
        

        extern __m128i _mm_minpos_epu16(__m128i);

        

        extern __m128d _mm_round_pd(__m128d , int );
        extern __m128d _mm_round_sd(__m128d , __m128d , int );

        

        extern __m128  _mm_round_ps(__m128  , int );
        extern __m128  _mm_round_ss(__m128 , __m128  , int );

        

        extern __m128i _mm_cvtepi8_epi32 (__m128i);
        extern __m128i _mm_cvtepi16_epi32(__m128i);
        extern __m128i _mm_cvtepi8_epi64 (__m128i);
        extern __m128i _mm_cvtepi32_epi64(__m128i);
        extern __m128i _mm_cvtepi16_epi64(__m128i);
        extern __m128i _mm_cvtepi8_epi16 (__m128i);

        

        extern __m128i _mm_cvtepu8_epi32 (__m128i);
        extern __m128i _mm_cvtepu16_epi32(__m128i);
        extern __m128i _mm_cvtepu8_epi64 (__m128i);
        extern __m128i _mm_cvtepu32_epi64(__m128i);
        extern __m128i _mm_cvtepu16_epi64(__m128i);
        extern __m128i _mm_cvtepu8_epi16 (__m128i);


        
        

        extern __m128i _mm_packus_epi32(__m128i, __m128i);

        
        
        

        extern __m128i _mm_mpsadbw_epu8(__m128i , __m128i , const int );

        



        extern __m128i _mm_stream_load_si128(const __m128i*);


}; 
#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"

#line 260 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
#line 261 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
#line 262 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\smmintrin.h"
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"



extern "C" {
#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"













































    extern __m128i _mm_cmpistrm (__m128i , __m128i , const int );
    extern int     _mm_cmpistri (__m128i , __m128i , const int );

    extern __m128i _mm_cmpestrm (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestri (__m128i , int , __m128i , int , const int );





    extern int     _mm_cmpistrz (__m128i , __m128i , const int );
    extern int     _mm_cmpistrc (__m128i , __m128i , const int );
    extern int     _mm_cmpistrs (__m128i , __m128i , const int );
    extern int     _mm_cmpistro (__m128i , __m128i , const int );
    extern int     _mm_cmpistra (__m128i , __m128i , const int );

    extern int     _mm_cmpestrz (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrc (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestrs (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestro (__m128i , int , __m128i , int , const int );
    extern int     _mm_cmpestra (__m128i , int , __m128i , int , const int );






    extern __m128i _mm_cmpgt_epi64(__m128i , __m128i );





    extern int _mm_popcnt_u32(unsigned int );



#line 121 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"





    extern unsigned int _mm_crc32_u8 (unsigned int , unsigned char );
    extern unsigned int _mm_crc32_u16(unsigned int , unsigned short );
    extern unsigned int _mm_crc32_u32(unsigned int , unsigned int );



#line 133 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"


}; 
#line 137 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"

#line 139 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"
#line 140 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"
#line 141 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\nmmintrin.h"
#line 32 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"



extern "C" {
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"





extern __m128i _mm_aesdec_si128(__m128i , __m128i );





extern __m128i _mm_aesdeclast_si128(__m128i , __m128i );





extern __m128i _mm_aesenc_si128(__m128i , __m128i );





extern __m128i _mm_aesenclast_si128(__m128i , __m128i );





extern __m128i _mm_aesimc_si128(__m128i );






extern __m128i _mm_aeskeygenassist_si128(__m128i , const int );







extern __m128i _mm_clmulepi64_si128(__m128i , __m128i ,
                                            const int );



}; 
#line 88 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"

#line 90 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
#line 91 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
#line 92 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\wmmintrin.h"
#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"


extern "C" {
#line 33 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"




typedef union __declspec(intrin_type) __declspec(align(32)) __m256 {
    float m256_f32[8];
} __m256;

typedef struct __declspec(intrin_type) __declspec(align(32)) __m256d {
    double m256d_f64[4];
} __m256d;

typedef union  __declspec(intrin_type) __declspec(align(32)) __m256i {
    __int8              m256i_i8[32];
    __int16             m256i_i16[16];
    __int32             m256i_i32[8];
    __int64             m256i_i64[4];
    unsigned __int8     m256i_u8[32];
    unsigned __int16    m256i_u16[16];
    unsigned __int32    m256i_u32[8];
    unsigned __int64    m256i_u64[4];
} __m256i;



















































extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_add_ps(__m256, __m256);












extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d);












extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_and_ps(__m256, __m256);








extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256);













extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int);













extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int);









extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d);









extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256);








extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_div_ps(__m256, __m256);














extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256);








extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_max_ps(__m256, __m256);








extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_min_ps(__m256, __m256);









extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_mul_ps(__m256, __m256);








extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_or_ps(__m256, __m256);











extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int);












extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int);








extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d);









extern __m256 __cdecl _mm256_sub_ps(__m256, __m256);








extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d);








extern __m256 __cdecl _mm256_xor_ps(__m256, __m256);















extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int);
extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int);















extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int);
extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int);












extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int);





extern int __cdecl _mm_comi_sd(__m128d, __m128d, const int);












extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int);





extern int __cdecl _mm_comi_ss(__m128, __m128, const int);








extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i);








extern __m256  __cdecl _mm256_cvtepi32_ps(__m256i);









extern __m128  __cdecl _mm256_cvtpd_ps(__m256d);








extern __m256i __cdecl _mm256_cvtps_epi32(__m256);









extern __m256d __cdecl _mm256_cvtps_pd(__m128);












extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d);








extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d);












extern __m256i __cdecl _mm256_cvttps_epi32(__m256);







extern __m128  __cdecl _mm256_extractf128_ps(__m256, const int);
extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int);
extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int);






extern void __cdecl _mm256_zeroall(void);







extern void __cdecl _mm256_zeroupper(void);









extern __m256  __cdecl _mm256_permutevar_ps(__m256, __m256i);
extern __m128  __cdecl _mm_permutevar_ps(__m128, __m128i);









extern __m256  __cdecl _mm256_permute_ps(__m256, int);
extern __m128  __cdecl _mm_permute_ps(__m128, int);









extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i);
extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i);









extern __m256d __cdecl _mm256_permute_pd(__m256d, int);
extern __m128d __cdecl _mm_permute_pd(__m128d, int);








extern __m256  __cdecl _mm256_permute2f128_ps(__m256, __m256, int);
extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int);
extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int);








extern __m256  __cdecl _mm256_broadcast_ss(float const *);
extern __m128  __cdecl _mm_broadcast_ss(float const *);







extern __m256d __cdecl _mm256_broadcast_sd(double const *);







extern __m256  __cdecl _mm256_broadcast_ps(__m128 const *);
extern __m256d __cdecl _mm256_broadcast_pd(__m128d const *);









extern __m256  __cdecl _mm256_insertf128_ps(__m256, __m128, int);
extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int);
extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int);








extern __m256d __cdecl _mm256_load_pd(double const *);
extern void    __cdecl _mm256_store_pd(double *, __m256d);








extern __m256  __cdecl _mm256_load_ps(float const *);
extern void    __cdecl _mm256_store_ps(float *, __m256);








extern __m256d __cdecl _mm256_loadu_pd(double const *);
extern void    __cdecl _mm256_storeu_pd(double *, __m256d);








extern __m256  __cdecl _mm256_loadu_ps(float const *);
extern void    __cdecl _mm256_storeu_ps(float *, __m256);








extern __m256i __cdecl _mm256_load_si256(__m256i const *);
extern void    __cdecl _mm256_store_si256(__m256i *, __m256i);








extern __m256i __cdecl _mm256_loadu_si256(__m256i const *);
extern void    __cdecl _mm256_storeu_si256(__m256i *, __m256i);







































































extern __m256d __cdecl _mm256_maskload_pd(double const *, __m256i);
extern void    __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d);
extern __m128d __cdecl _mm_maskload_pd(double const *, __m128i);
extern void    __cdecl _mm_maskstore_pd(double *, __m128i, __m128d);



















extern __m256  __cdecl _mm256_maskload_ps(float const *, __m256i);
extern void    __cdecl _mm256_maskstore_ps(float *, __m256i, __m256);
extern __m128  __cdecl _mm_maskload_ps(float const *, __m128i);
extern void    __cdecl _mm_maskstore_ps(float *, __m128i, __m128);







extern __m256  __cdecl _mm256_movehdup_ps(__m256);







extern __m256  __cdecl _mm256_moveldup_ps(__m256);







extern __m256d __cdecl _mm256_movedup_pd(__m256d);









extern __m256i __cdecl _mm256_lddqu_si256(__m256i const *);







extern void    __cdecl _mm256_stream_si256(__m256i *, __m256i);








extern void    __cdecl _mm256_stream_pd(double *, __m256d);








extern void    __cdecl _mm256_stream_ps(float *, __m256);









extern __m256  __cdecl _mm256_rcp_ps(__m256);










extern __m256  __cdecl _mm256_rsqrt_ps(__m256);








extern __m256d __cdecl _mm256_sqrt_pd(__m256d);








extern __m256  __cdecl _mm256_sqrt_ps(__m256);












extern __m256d __cdecl _mm256_round_pd(__m256d, int);














extern __m256  __cdecl _mm256_round_ps(__m256, int);









extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpackhi_ps(__m256, __m256);







extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d);







extern __m256  __cdecl _mm256_unpacklo_ps(__m256, __m256);









extern int     __cdecl _mm256_testz_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testc_si256(__m256i, __m256i);



extern int     __cdecl _mm256_testnzc_si256(__m256i, __m256i);














extern int     __cdecl _mm256_testz_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testc_pd(__m256d, __m256d);
extern int     __cdecl _mm256_testnzc_pd(__m256d, __m256d);
extern int     __cdecl _mm_testz_pd(__m128d, __m128d);
extern int     __cdecl _mm_testc_pd(__m128d, __m128d);
extern int     __cdecl _mm_testnzc_pd(__m128d, __m128d);












extern int     __cdecl _mm256_testz_ps(__m256, __m256);
extern int     __cdecl _mm256_testc_ps(__m256, __m256);
extern int     __cdecl _mm256_testnzc_ps(__m256, __m256);
extern int     __cdecl _mm_testz_ps(__m128, __m128);
extern int     __cdecl _mm_testc_ps(__m128, __m128);
extern int     __cdecl _mm_testnzc_ps(__m128, __m128);








extern int     __cdecl _mm256_movemask_pd(__m256d);








extern int     __cdecl _mm256_movemask_ps(__m256);




extern __m256d __cdecl _mm256_setzero_pd(void);
extern __m256  __cdecl _mm256_setzero_ps(void);
extern __m256i __cdecl _mm256_setzero_si256(void);




extern __m256d __cdecl _mm256_set_pd(double, double, double, double);
extern __m256  __cdecl _mm256_set_ps(float, float, float, float,
                                            float, float, float, float);
extern __m256i __cdecl _mm256_set_epi8(char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char,
                                              char, char, char, char);
extern __m256i __cdecl _mm256_set_epi16(short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short,
                                               short, short, short, short);
extern __m256i __cdecl _mm256_set_epi32(int, int, int, int,
                                               int, int, int, int);
extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64,
                                                __int64, __int64);










extern __m256d __cdecl _mm256_setr_pd(double, double, double, double);
extern __m256  __cdecl _mm256_setr_ps(float, float, float, float,
                                             float, float, float, float);
extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char,
                                               char, char, char, char);
extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short,
                                                short, short, short, short);
extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int,
                                                int, int, int, int);
extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64,
                                                 __int64, __int64);







extern __m256d __cdecl _mm256_set1_pd(double);
extern __m256  __cdecl _mm256_set1_ps(float);
extern __m256i __cdecl _mm256_set1_epi8(char);
extern __m256i __cdecl _mm256_set1_epi16(short);
extern __m256i __cdecl _mm256_set1_epi32(int);
extern __m256i __cdecl _mm256_set1_epi64x(long long);







extern __m256  __cdecl _mm256_castpd_ps(__m256d);
extern __m256d __cdecl _mm256_castps_pd(__m256);
extern __m256i __cdecl _mm256_castps_si256(__m256);
extern __m256i __cdecl _mm256_castpd_si256(__m256d);
extern __m256  __cdecl _mm256_castsi256_ps(__m256i);
extern __m256d __cdecl _mm256_castsi256_pd(__m256i);
extern __m128  __cdecl _mm256_castps256_ps128(__m256);
extern __m128d __cdecl _mm256_castpd256_pd128(__m256d);
extern __m128i __cdecl _mm256_castsi256_si128(__m256i);
extern __m256  __cdecl _mm256_castps128_ps256(__m128);
extern __m256d __cdecl _mm256_castpd128_pd256(__m128d);
extern __m256i __cdecl _mm256_castsi128_si256(__m128i);






extern __m128  __cdecl _mm_cvtph_ps(__m128i);
extern __m256  __cdecl _mm256_cvtph_ps(__m128i);
extern __m128i __cdecl _mm_cvtps_ph(__m128 , const int );
extern __m128i __cdecl _mm256_cvtps_ph(__m256, int);




















extern unsigned __int64 __cdecl _xgetbv(unsigned int);


extern void __cdecl _xsetbv(unsigned int, unsigned __int64);






extern void __cdecl _xsave(void *, unsigned __int64);


#line 1233 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xsaveopt(void *, unsigned __int64);


#line 1243 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern void __cdecl _xsavec(void *, unsigned __int64);


#line 1252 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xrstor(void const *, unsigned __int64);


#line 1262 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xsaves(void *, unsigned __int64);


#line 1272 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _xrstors(void const *, unsigned __int64);


#line 1282 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern void __cdecl _fxsave(void *);


#line 1291 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern void __cdecl _fxrstor(void const *);


#line 1300 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"







extern int __cdecl _rdrand16_step(unsigned short *);
extern int __cdecl _rdrand32_step(unsigned int *);


#line 1312 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

















#line 1330 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"




extern __m128  __cdecl _mm_fmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmadd_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fnmsub_ss(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d);





extern __m128  __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d);
extern __m128  __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128);
extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d);

extern __m256  __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d);
extern __m256  __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256);
extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d);





extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i);





extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i);

extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i);
extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i);





extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i);
extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i);





extern __m256i __cdecl _mm256_abs_epi8(__m256i);
extern __m256i __cdecl _mm256_abs_epi16(__m256i);
extern __m256i __cdecl _mm256_abs_epi32(__m256i);

extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i);

extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i);
extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i);

extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i);
extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int);





extern __m256i __cdecl _mm256_slli_si256(__m256i, const int);

extern __m256i __cdecl _mm256_srli_si256(__m256i, const int);


extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_slli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_slli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i);

extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i);

extern __m256i __cdecl _mm256_srai_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srai_epi32(__m256i, int);

extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i);

extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i);

extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i);
extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i);

extern __m256i __cdecl _mm256_srli_epi16(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi32(__m256i, int);
extern __m256i __cdecl _mm256_srli_epi64(__m256i, int);

extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i);

extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i);
extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i);





extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int);

extern __m256i __cdecl _mm256_blend_epi32(__m256i,__m256i, const int);

extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i);
extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int);

extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i);
extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i);

extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i);
extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int);

extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int);
extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int);

extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int);
extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int);





extern __m128  __cdecl _mm_broadcastss_ps(__m128);
extern __m128d __cdecl _mm_broadcastsd_pd(__m128d);

extern __m128i __cdecl _mm_broadcastb_epi8(__m128i);
extern __m128i __cdecl _mm_broadcastw_epi16(__m128i);
extern __m128i __cdecl _mm_broadcastd_epi32(__m128i);
extern __m128i __cdecl _mm_broadcastq_epi64(__m128i);

extern __m256  __cdecl _mm256_broadcastss_ps(__m128);
extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d);

extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i);
extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i);
extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i);
extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i);

extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i);






extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i);

extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i);
extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i);
extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i);






extern int __cdecl _mm256_movemask_epi8(__m256i);





extern __m128i __cdecl _mm_maskload_epi32(int const * ,
                                          __m128i     );
extern __m128i __cdecl _mm_maskload_epi64(__int64 const * ,
                                          __m128i         );

extern void __cdecl _mm_maskstore_epi32(int *   ,
                                        __m128i ,
                                        __m128i );
extern void __cdecl _mm_maskstore_epi64(__int64 * ,
                                        __m128i   ,
                                        __m128i   );

extern __m256i __cdecl _mm256_maskload_epi32(int const * ,
                                             __m256i     );
extern __m256i __cdecl _mm256_maskload_epi64(__int64 const * ,
                                             __m256i         );

extern void __cdecl _mm256_maskstore_epi32(int *   ,
                                           __m256i ,
                                           __m256i );
extern void __cdecl _mm256_maskstore_epi64(__int64 * ,
                                           __m256i   ,
                                           __m256i   );





extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i);
extern __m256  __cdecl _mm256_permutevar8x32_ps(__m256, __m256i);

extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int);
extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int);

extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int);





extern __m256i  __cdecl _mm256_stream_load_si256(__m256i const *);






extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d        ,
                                                double const * ,
                                                __m128i        ,
                                                __m256d        ,
                                                const int      );
extern __m256  __cdecl _mm256_mask_i32gather_ps(__m256         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m256         ,
                                                const int      );
extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d        ,
                                                double const * ,
                                                __m256i        ,
                                                __m256d        ,
                                                const int      );
extern __m128  __cdecl _mm256_mask_i64gather_ps(__m128         ,
                                                float const *  ,
                                                __m256i        ,
                                                __m128         ,
                                                const int      );

extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i32gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );
extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d        ,
                                             double const * ,
                                             __m128i        ,
                                             __m128d        ,
                                             const int      );
extern __m128  __cdecl _mm_mask_i64gather_ps(__m128         ,
                                             float const *  ,
                                             __m128i        ,
                                             __m128         ,
                                             const int      );


extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i     ,
                                                   int const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m128i     ,
                                                   __m256i     ,
                                                   const int   );
extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i     ,
                                                   int     const * ,
                                                   __m256i     ,
                                                   __m128i     ,
                                                   const int   );
extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i     ,
                                                   __int64 const * ,
                                                   __m256i     ,
                                                   __m256i     ,
                                                   const int   );

extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i         ,
                                                int const *     ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i         ,
                                                int     const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );
extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i         ,
                                                __int64 const * ,
                                                __m128i         ,
                                                __m128i         ,
                                                const int       );





extern __m256d __cdecl _mm256_i32gather_pd(double const * ,
                                           __m128i        ,
                                           const int      );
extern __m256  __cdecl _mm256_i32gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );
extern __m256d __cdecl _mm256_i64gather_pd(double const * ,
                                           __m256i        ,
                                           const int      );
extern __m128  __cdecl _mm256_i64gather_ps(float  const * ,
                                           __m256i        ,
                                           const int      );

extern __m128d __cdecl _mm_i32gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i32gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );
extern __m128d __cdecl _mm_i64gather_pd(double const * ,
                                        __m128i        ,
                                        const int      );
extern __m128  __cdecl _mm_i64gather_ps(float  const * ,
                                        __m128i        ,
                                        const int      );

extern __m256i __cdecl _mm256_i32gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i32gather_epi64(__int64 const * ,
                                              __m128i         ,
                                              const int       );
extern __m128i __cdecl _mm256_i64gather_epi32(int const *     ,
                                              __m256i         ,
                                              const int       );
extern __m256i __cdecl _mm256_i64gather_epi64(__int64 const * ,
                                              __m256i         ,
                                              const int       );

extern __m128i __cdecl _mm_i32gather_epi32(int const *     ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i32gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi32(int     const * ,
                                           __m128i         ,
                                           const int       );
extern __m128i __cdecl _mm_i64gather_epi64(__int64 const * ,
                                           __m128i         ,
                                           const int       );







extern unsigned int     _bextr_u32(unsigned int ,
                                   unsigned int ,
                                   unsigned int );
extern unsigned int     _blsi_u32(unsigned int);
extern unsigned int     _blsmsk_u32(unsigned int);
extern unsigned int     _blsr_u32(unsigned int);
extern unsigned int     _bzhi_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _mulx_u32(unsigned int ,
                                  unsigned int ,
                                  unsigned int * );
extern unsigned int     _pdep_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _pext_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _rorx_u32(unsigned int ,
                                  const unsigned int );
extern int              _sarx_i32(int ,
                                  unsigned int );
extern unsigned int     _shlx_u32(unsigned int ,
                                  unsigned int );
extern unsigned int     _shrx_u32(unsigned int ,
                                          unsigned int );

























#line 1854 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"








extern unsigned int     _lzcnt_u32(unsigned int);


#line 1866 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"








extern unsigned int     _tzcnt_u32(unsigned int);


#line 1878 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"






extern void __cdecl _invpcid(unsigned int , void * );


extern void _Store_HLERelease(long volatile *,long);
extern void _StorePointer_HLERelease(void * volatile *,void *);

extern long _InterlockedExchange_HLEAcquire(long volatile *,long);
extern long _InterlockedExchange_HLERelease(long volatile *,long);
extern void * _InterlockedExchangePointer_HLEAcquire(void *volatile *,void *);
extern void * _InterlockedExchangePointer_HLERelease(void *volatile *,void *);

extern long _InterlockedCompareExchange_HLEAcquire(long volatile *,long,long);
extern long _InterlockedCompareExchange_HLERelease(long volatile *,long,long);
extern __int64 _InterlockedCompareExchange64_HLEAcquire(__int64 volatile *,__int64,__int64);
extern __int64 _InterlockedCompareExchange64_HLERelease(__int64 volatile *,__int64,__int64);
extern void * _InterlockedCompareExchangePointer_HLEAcquire(void *volatile *,void *,void *);
extern void * _InterlockedCompareExchangePointer_HLERelease(void *volatile *,void *,void *);

extern long _InterlockedExchangeAdd_HLEAcquire(long volatile *,long);
extern long _InterlockedExchangeAdd_HLERelease(long volatile *,long);

extern long _InterlockedAnd_HLEAcquire(long volatile *,long);
extern long _InterlockedAnd_HLERelease(long volatile *,long);
extern long _InterlockedOr_HLEAcquire(long volatile *,long);
extern long _InterlockedOr_HLERelease(long volatile *,long);
extern long _InterlockedXor_HLEAcquire(long volatile *,long);
extern long _InterlockedXor_HLERelease(long volatile *,long);

extern unsigned char _interlockedbittestandset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandset_HLERelease(long *,long);
extern unsigned char _interlockedbittestandreset_HLEAcquire(long *,long);
extern unsigned char _interlockedbittestandreset_HLERelease(long *,long);




















#line 1937 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"











extern unsigned int     __cdecl _xbegin(void);
extern void             __cdecl _xend(void);
extern void             __cdecl _xabort(const unsigned int);
extern unsigned char    __cdecl _xtest(void);








extern int __cdecl _rdseed16_step(unsigned short *);
extern int __cdecl _rdseed32_step(unsigned int *);


#line 1965 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"










extern unsigned char __cdecl _addcarryx_u32(unsigned char ,
                                                   unsigned int ,
                                                   unsigned int ,
                                                   unsigned int * );







#line 1987 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"





extern unsigned short   __cdecl _load_be_u16(void const*);
extern unsigned int     __cdecl _load_be_u32(void const*);
extern unsigned __int64 __cdecl _load_be_u64(void const*);







extern void __cdecl _store_be_u16(void *, unsigned short);
extern void __cdecl _store_be_u32(void *, unsigned int);
extern void __cdecl _store_be_u64(void *, unsigned __int64);







extern __m128i __cdecl _mm_sha1msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1nexte_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha1rnds4_epu32(__m128i, __m128i, const int);

extern __m128i __cdecl _mm_sha256msg1_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256msg2_epu32(__m128i, __m128i);
extern __m128i __cdecl _mm_sha256rnds2_epu32(__m128i, __m128i, __m128i);




extern void * __cdecl _bnd_set_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_narrow_ptr_bounds(const void *, const void *, size_t);
extern void * __cdecl _bnd_copy_ptr_bounds(const void *, const void *);
extern void * __cdecl _bnd_init_ptr_bounds(const void *);
extern void __cdecl _bnd_store_ptr_bounds(const void **, const void *);
extern void __cdecl _bnd_chk_ptr_lbounds(const void *);
extern void __cdecl _bnd_chk_ptr_ubounds(const void *);
extern void __cdecl _bnd_chk_ptr_bounds(const void *, size_t);
extern void * __cdecl _bnd_load_ptr_bounds(const void **, const void *);
extern const void * __cdecl _bnd_get_ptr_lbound(const void *);
extern const void * __cdecl _bnd_get_ptr_ubound(const void *);


}; 
#line 2039 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

#line 2041 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"
#line 2042 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"
#line 2043 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\immintrin.h"

#line 25 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
        #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"












#pragma once



#line 18 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"







#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"



#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"


extern "C" { 
#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"





























































































__m128 _mm_macc_ps(__m128, __m128, __m128);
__m128d _mm_macc_pd(__m128d, __m128d, __m128d);
__m128 _mm_macc_ss(__m128, __m128, __m128);
__m128d _mm_macc_sd(__m128d, __m128d, __m128d);
__m128 _mm_maddsub_ps(__m128, __m128, __m128);
__m128d _mm_maddsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msubadd_ps(__m128, __m128, __m128);
__m128d _mm_msubadd_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ps(__m128, __m128, __m128);
__m128d _mm_msub_pd(__m128d, __m128d, __m128d);
__m128 _mm_msub_ss(__m128, __m128, __m128);
__m128d _mm_msub_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ps(__m128, __m128, __m128);
__m128d _mm_nmacc_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmacc_ss(__m128, __m128, __m128);
__m128d _mm_nmacc_sd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ps(__m128, __m128, __m128);
__m128d _mm_nmsub_pd(__m128d, __m128d, __m128d);
__m128 _mm_nmsub_ss(__m128, __m128, __m128);
__m128d _mm_nmsub_sd(__m128d, __m128d, __m128d);


__m128i _mm_maccs_epi16(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maccs_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macc_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macclo_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_macchi_epi32(__m128i, __m128i, __m128i);
__m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i);
__m128i _mm_maddd_epi16(__m128i, __m128i, __m128i);


__m128i _mm_haddw_epi8(__m128i);
__m128i _mm_haddd_epi8(__m128i);
__m128i _mm_haddq_epi8(__m128i);
__m128i _mm_haddd_epi16(__m128i);
__m128i _mm_haddq_epi16(__m128i);
__m128i _mm_haddq_epi32(__m128i);
__m128i _mm_haddw_epu8(__m128i);
__m128i _mm_haddd_epu8(__m128i);
__m128i _mm_haddq_epu8(__m128i);
__m128i _mm_haddd_epu16(__m128i);
__m128i _mm_haddq_epu16(__m128i);
__m128i _mm_haddq_epu32(__m128i);
__m128i _mm_hsubw_epi8(__m128i);
__m128i _mm_hsubd_epi16(__m128i);
__m128i _mm_hsubq_epi32(__m128i);


__m128i _mm_cmov_si128(__m128i, __m128i, __m128i);
__m128i _mm_perm_epi8(__m128i, __m128i, __m128i);


__m128i _mm_rot_epi8(__m128i, __m128i);
__m128i _mm_rot_epi16(__m128i, __m128i);
__m128i _mm_rot_epi32(__m128i, __m128i);
__m128i _mm_rot_epi64(__m128i, __m128i);
__m128i _mm_roti_epi8(__m128i, int);
__m128i _mm_roti_epi16(__m128i, int);
__m128i _mm_roti_epi32(__m128i, int);
__m128i _mm_roti_epi64(__m128i, int);
__m128i _mm_shl_epi8(__m128i, __m128i);
__m128i _mm_shl_epi16(__m128i, __m128i);
__m128i _mm_shl_epi32(__m128i, __m128i);
__m128i _mm_shl_epi64(__m128i, __m128i);
__m128i _mm_sha_epi8(__m128i, __m128i);
__m128i _mm_sha_epi16(__m128i, __m128i);
__m128i _mm_sha_epi32(__m128i, __m128i);
__m128i _mm_sha_epi64(__m128i, __m128i);



__m128i _mm_com_epu8(__m128i, __m128i, int);
__m128i _mm_com_epu16(__m128i, __m128i, int);
__m128i _mm_com_epu32(__m128i, __m128i, int);
__m128i _mm_com_epu64(__m128i, __m128i, int);
__m128i _mm_com_epi8(__m128i, __m128i, int);
__m128i _mm_com_epi16(__m128i, __m128i, int);
__m128i _mm_com_epi32(__m128i, __m128i, int);
__m128i _mm_com_epi64(__m128i, __m128i, int);



__m128 _mm_frcz_ps(__m128);
__m128d _mm_frcz_pd(__m128d);
__m128 _mm_frcz_ss(__m128, __m128);
__m128d _mm_frcz_sd(__m128d, __m128d);








__m128 _mm_permute2_ps(__m128, __m128, __m128i, int);
__m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int);



__m256 _mm256_macc_ps(__m256, __m256, __m256);
__m256d _mm256_macc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_maddsub_ps(__m256, __m256, __m256);
__m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msubadd_ps(__m256, __m256, __m256);
__m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d);
__m256 _mm256_msub_ps(__m256, __m256, __m256);
__m256d _mm256_msub_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmacc_ps(__m256, __m256, __m256);
__m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d);
__m256 _mm256_nmsub_ps(__m256, __m256, __m256);
__m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d);
__m256i _mm256_cmov_si256(__m256i, __m256i, __m256i);
__m256 _mm256_frcz_ps(__m256);
__m256d _mm256_frcz_pd(__m256d);
__m256 _mm256_permute2_ps(__m256, __m256, __m256i, int);
__m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int);


void __llwpcb(void *);
void *__slwpcb();
void __lwpval32(unsigned int, unsigned int, unsigned int);
unsigned char __lwpins32(unsigned int, unsigned int, unsigned int);



#line 258 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"


unsigned int _bextr_u32(unsigned int, unsigned int, unsigned int);
unsigned int _andn_u32(unsigned int, unsigned int);
unsigned int _tzcnt_u32(unsigned int);
unsigned int _lzcnt_u32(unsigned int);
unsigned int _blsr_u32(unsigned int);
unsigned int _blsmsk_u32(unsigned int);
unsigned int _blsi_u32(unsigned int);








#line 276 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"


unsigned int _bextri_u32(unsigned int, unsigned int);
unsigned int _blcfill_u32(unsigned int);
unsigned int _blsfill_u32(unsigned int);
unsigned int _blcs_u32(unsigned int);
unsigned int _tzmsk_u32(unsigned int);
unsigned int _blcic_u32(unsigned int);
unsigned int _blsic_u32(unsigned int);
unsigned int _t1mskc_u32(unsigned int);
unsigned int _blcmsk_u32(unsigned int);
unsigned int _blci_u32(unsigned int);











#line 300 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"

void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);

void _mm_clzero(void const *);


}; 
#line 309 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"

#line 311 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"
#line 312 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"
#line 313 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ammintrin.h"
#line 26 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
    #line 27 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

    
        #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"















#pragma once



#line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"







#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"




extern "C" { 
#line 37 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"



void _m_femms(void);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pf2id(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pmulhrw(__m64, __m64);
void _m_prefetch(void*);
void _m_prefetchw(volatile const void*_Source);

__m64 _m_from_float(float);
float _m_to_float(__m64);



__m64 _m_pf2iw(__m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pswapd(__m64);


}; 
#line 77 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"
#line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"
#line 79 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\mm3dnow.h"
#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
    #line 31 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

    


#line 36 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

    


#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 42 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"


extern "C" {
#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




























#line 75 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"


#line 78 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"






#line 85 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 90 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 95 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 100 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 105 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

#line 107 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 112 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 117 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 122 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"




#line 127 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"


void * _AddressOfReturnAddress(void);
unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask);


unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask);





















long _InterlockedAddLargeStatistic(__int64 volatile * _Addend, long _Value);



long _InterlockedAnd(long volatile * _Value, long _Mask);
short _InterlockedAnd16(short volatile * _Value, short _Mask);









char _InterlockedAnd8(char volatile * _Value, char _Mask);








long __cdecl _InterlockedCompareExchange(long volatile * _Destination, long _Exchange, long _Comparand);






short _InterlockedCompareExchange16(short volatile * _Destination, short _Exchange, short _Comparand);




__int64 _InterlockedCompareExchange64(__int64 volatile * _Destination, __int64 _Exchange, __int64 _Comparand);




char _InterlockedCompareExchange8(char volatile * _Destination, char _Exchange, char _Comparand);



void * _InterlockedCompareExchangePointer(void * volatile * _Destination, void * _Exchange, void * _Comparand);








long __cdecl _InterlockedDecrement(long volatile * _Addend);

short _InterlockedDecrement16(short volatile * _Addend);










long __cdecl _InterlockedExchange(long volatile * _Target, long _Value);

short _InterlockedExchange16(short volatile * _Target, short _Value);







char _InterlockedExchange8(char volatile * _Target, char _Value);



long __cdecl _InterlockedExchangeAdd(long volatile * _Addend, long _Value);
short _InterlockedExchangeAdd16(short volatile * _Addend, short _Value);







char _InterlockedExchangeAdd8(char volatile * _Addend, char _Value);






void * _InterlockedExchangePointer(void * volatile * _Target, void * _Value);






long __cdecl _InterlockedIncrement(long volatile * _Addend);

short _InterlockedIncrement16(short volatile * _Addend);










long _InterlockedOr(long volatile * _Value, long _Mask);
short _InterlockedOr16(short volatile * _Value, short _Mask);









char _InterlockedOr8(char volatile * _Value, char _Mask);








long _InterlockedXor(long volatile * _Value, long _Mask);
short _InterlockedXor16(short volatile * _Value, short _Mask);









char _InterlockedXor8(char volatile * _Value, char _Mask);
















void _ReadBarrier(void);






void _ReadWriteBarrier(void);
void * _ReturnAddress(void);

void _WriteBarrier(void);






void __addfsbyte(unsigned long, unsigned char);
void __addfsdword(unsigned long, unsigned long);
void __addfsword(unsigned long, unsigned short);








void __code_seg(const char *);
void __cpuid(int[4], int);
void __cpuidex(int[4], int, int);
void __cdecl __debugbreak(void);

__int64 __emul(int, int);
unsigned __int64 __emulu(unsigned int, unsigned int);
__declspec(noreturn) void __fastfail(unsigned int);

unsigned int __getcallerseflags(void);
void __halt(void);


unsigned char __inbyte(unsigned short);
void __inbytestring(unsigned short, unsigned char *, unsigned long);
void __incfsbyte(unsigned long);
void __incfsdword(unsigned long);
void __incfsword(unsigned long);








unsigned long __indword(unsigned short);
void __indwordstring(unsigned short, unsigned long *, unsigned long);
void __int2c(void);
void __invlpg(void *);
unsigned short __inword(unsigned short);
void __inwordstring(unsigned short, unsigned short *, unsigned long);









void __lidt(void *);
unsigned __int64 __ll_lshift(unsigned __int64, int);
__int64 __ll_rshift(__int64, int);
unsigned int __lzcnt(unsigned int);
unsigned short __lzcnt16(unsigned short);

void __movsb(unsigned char *, unsigned char const *, size_t);
void __movsd(unsigned long *, unsigned long const *, size_t);

void __movsw(unsigned short *, unsigned short const *, size_t);

void __nop(void);
void __nvreg_restore_fence(void);
void __nvreg_save_fence(void);
void __outbyte(unsigned short, unsigned char);
void __outbytestring(unsigned short, unsigned char *, unsigned long);
void __outdword(unsigned short, unsigned long);
void __outdwordstring(unsigned short, unsigned long *, unsigned long);
void __outword(unsigned short, unsigned short);
void __outwordstring(unsigned short, unsigned short *, unsigned long);
unsigned int __popcnt(unsigned int);
unsigned short __popcnt16(unsigned short);




unsigned __int64 __rdtsc(void);
unsigned __int64 __rdtscp(unsigned int *);

unsigned long __readcr0(void);

unsigned long __readcr2(void);

unsigned long __readcr3(void);

unsigned long __readcr4(void);

unsigned long __readcr8(void);

unsigned int __readdr(unsigned int);

unsigned int __readeflags(void);
unsigned char __readfsbyte(unsigned long);
unsigned long __readfsdword(unsigned long);
unsigned __int64 __readfsqword(unsigned long);
unsigned short __readfsword(unsigned long);




unsigned __int64 __readmsr(unsigned long);
unsigned __int64 __readpmc(unsigned long);




unsigned long __segmentlimit(unsigned long);



void __sidt(void *);

void __stosb(unsigned char *, unsigned char, size_t);
void __stosd(unsigned long *, unsigned long, size_t);

void __stosw(unsigned short *, unsigned short, size_t);
void __svm_clgi(void);
void __svm_invlpga(void *, int);
void __svm_skinit(int);
void __svm_stgi(void);
void __svm_vmload(size_t);
void __svm_vmrun(size_t);
void __svm_vmsave(size_t);





void __ud2(void);
unsigned __int64 __ull_rshift(unsigned __int64, int);

void __vmx_off(void);




void __vmx_vmptrst(unsigned __int64 *);



void __wbinvd(void);



void __writecr0(unsigned int);

void __writecr3(unsigned int);

void __writecr4(unsigned int);

void __writecr8(unsigned int);

void __writedr(unsigned int, unsigned int);

void __writeeflags(unsigned int);
void __writefsbyte(unsigned long, unsigned char);
void __writefsdword(unsigned long, unsigned long);
void __writefsqword(unsigned long, unsigned __int64);
void __writefsword(unsigned long, unsigned short);




void __writemsr(unsigned long, unsigned __int64);





unsigned char _bittest(long const *, long);

unsigned char _bittestandcomplement(long *, long);

unsigned char _bittestandreset(long *, long);

unsigned char _bittestandset(long *, long);

  unsigned __int64 __cdecl _byteswap_uint64(  unsigned __int64);
  unsigned long __cdecl _byteswap_ulong(  unsigned long);
  unsigned short __cdecl _byteswap_ushort(  unsigned short);
void __cdecl _disable(void);
void __cdecl _enable(void);
unsigned char _interlockedbittestandreset(long volatile *, long);







unsigned char _interlockedbittestandset(long volatile *, long);

















  unsigned long __cdecl _lrotl(  unsigned long,   int);
  unsigned long __cdecl _lrotr(  unsigned long,   int);
void _m_empty(void);
void _m_femms(void);
__m64 _m_from_float(float);
__m64 _m_from_int(int);
void _m_maskmovq(__m64, __m64, char *);
__m64 _m_packssdw(__m64, __m64);
__m64 _m_packsswb(__m64, __m64);
__m64 _m_packuswb(__m64, __m64);
__m64 _m_paddb(__m64, __m64);
__m64 _m_paddd(__m64, __m64);
__m64 _m_paddsb(__m64, __m64);
__m64 _m_paddsw(__m64, __m64);
__m64 _m_paddusb(__m64, __m64);
__m64 _m_paddusw(__m64, __m64);
__m64 _m_paddw(__m64, __m64);
__m64 _m_pand(__m64, __m64);
__m64 _m_pandn(__m64, __m64);
__m64 _m_pavgb(__m64, __m64);
__m64 _m_pavgusb(__m64, __m64);
__m64 _m_pavgw(__m64, __m64);
__m64 _m_pcmpeqb(__m64, __m64);
__m64 _m_pcmpeqd(__m64, __m64);
__m64 _m_pcmpeqw(__m64, __m64);
__m64 _m_pcmpgtb(__m64, __m64);
__m64 _m_pcmpgtd(__m64, __m64);
__m64 _m_pcmpgtw(__m64, __m64);
int _m_pextrw(__m64, int);
__m64 _m_pf2id(__m64);
__m64 _m_pf2iw(__m64);
__m64 _m_pfacc(__m64, __m64);
__m64 _m_pfadd(__m64, __m64);
__m64 _m_pfcmpeq(__m64, __m64);
__m64 _m_pfcmpge(__m64, __m64);
__m64 _m_pfcmpgt(__m64, __m64);
__m64 _m_pfmax(__m64, __m64);
__m64 _m_pfmin(__m64, __m64);
__m64 _m_pfmul(__m64, __m64);
__m64 _m_pfnacc(__m64, __m64);
__m64 _m_pfpnacc(__m64, __m64);
__m64 _m_pfrcp(__m64);
__m64 _m_pfrcpit1(__m64, __m64);
__m64 _m_pfrcpit2(__m64, __m64);
__m64 _m_pfrsqit1(__m64, __m64);
__m64 _m_pfrsqrt(__m64);
__m64 _m_pfsub(__m64, __m64);
__m64 _m_pfsubr(__m64, __m64);
__m64 _m_pi2fd(__m64);
__m64 _m_pi2fw(__m64);
__m64 _m_pinsrw(__m64, int, int);
__m64 _m_pmaddwd(__m64, __m64);
__m64 _m_pmaxsw(__m64, __m64);
__m64 _m_pmaxub(__m64, __m64);
__m64 _m_pminsw(__m64, __m64);
__m64 _m_pminub(__m64, __m64);
int _m_pmovmskb(__m64);
__m64 _m_pmulhrw(__m64, __m64);
__m64 _m_pmulhuw(__m64, __m64);
__m64 _m_pmulhw(__m64, __m64);
__m64 _m_pmullw(__m64, __m64);
__m64 _m_por(__m64, __m64);
void _m_prefetch(void *);
void _m_prefetchw(volatile const void *);
__m64 _m_psadbw(__m64, __m64);
__m64 _m_pshufw(__m64, int);
__m64 _m_pslld(__m64, __m64);
__m64 _m_pslldi(__m64, int);
__m64 _m_psllq(__m64, __m64);
__m64 _m_psllqi(__m64, int);
__m64 _m_psllw(__m64, __m64);
__m64 _m_psllwi(__m64, int);
__m64 _m_psrad(__m64, __m64);
__m64 _m_psradi(__m64, int);
__m64 _m_psraw(__m64, __m64);
__m64 _m_psrawi(__m64, int);
__m64 _m_psrld(__m64, __m64);
__m64 _m_psrldi(__m64, int);
__m64 _m_psrlq(__m64, __m64);
__m64 _m_psrlqi(__m64, int);
__m64 _m_psrlw(__m64, __m64);
__m64 _m_psrlwi(__m64, int);
__m64 _m_psubb(__m64, __m64);
__m64 _m_psubd(__m64, __m64);
__m64 _m_psubsb(__m64, __m64);
__m64 _m_psubsw(__m64, __m64);
__m64 _m_psubusb(__m64, __m64);
__m64 _m_psubusw(__m64, __m64);
__m64 _m_psubw(__m64, __m64);
__m64 _m_pswapd(__m64);
__m64 _m_punpckhbw(__m64, __m64);
__m64 _m_punpckhdq(__m64, __m64);
__m64 _m_punpckhwd(__m64, __m64);
__m64 _m_punpcklbw(__m64, __m64);
__m64 _m_punpckldq(__m64, __m64);
__m64 _m_punpcklwd(__m64, __m64);
__m64 _m_pxor(__m64, __m64);
float _m_to_float(__m64);
int _m_to_int(__m64);
__m128i _mm_abs_epi16(__m128i);
__m128i _mm_abs_epi32(__m128i);
__m128i _mm_abs_epi8(__m128i);
__m64 _mm_abs_pi16(__m64);
__m64 _mm_abs_pi32(__m64);
__m64 _mm_abs_pi8(__m64);
__m128i _mm_add_epi16(__m128i, __m128i);
__m128i _mm_add_epi32(__m128i, __m128i);
__m128i _mm_add_epi64(__m128i, __m128i);
__m128i _mm_add_epi8(__m128i, __m128i);
__m128d _mm_add_pd(__m128d, __m128d);
__m128 _mm_add_ps(__m128, __m128);
__m128d _mm_add_sd(__m128d, __m128d);
__m64 _mm_add_si64(__m64, __m64);
__m128 _mm_add_ss(__m128, __m128);
__m128i _mm_adds_epi16(__m128i, __m128i);
__m128i _mm_adds_epi8(__m128i, __m128i);
__m128i _mm_adds_epu16(__m128i, __m128i);
__m128i _mm_adds_epu8(__m128i, __m128i);
__m128d _mm_addsub_pd(__m128d, __m128d);
__m128 _mm_addsub_ps(__m128, __m128);
__m128i _mm_alignr_epi8(__m128i, __m128i, int);
__m64 _mm_alignr_pi8(__m64, __m64, int);
__m128d _mm_and_pd(__m128d, __m128d);
__m128 _mm_and_ps(__m128, __m128);
__m128i _mm_and_si128(__m128i, __m128i);
__m128d _mm_andnot_pd(__m128d, __m128d);
__m128 _mm_andnot_ps(__m128, __m128);
__m128i _mm_andnot_si128(__m128i, __m128i);
__m128i _mm_avg_epu16(__m128i, __m128i);
__m128i _mm_avg_epu8(__m128i, __m128i);
__m128i _mm_blend_epi16(__m128i, __m128i, int);
__m128d _mm_blend_pd(__m128d, __m128d, int);
__m128 _mm_blend_ps(__m128, __m128, int);
__m128i _mm_blendv_epi8(__m128i, __m128i, __m128i);
__m128d _mm_blendv_pd(__m128d, __m128d, __m128d);
__m128 _mm_blendv_ps(__m128, __m128, __m128);
void _mm_clflush(void const *);
void _mm_clflushopt(void const *);
void _mm_clwb(void const *);
void _mm_clzero(void const *);
__m128i _mm_cmpeq_epi16(__m128i, __m128i);
__m128i _mm_cmpeq_epi32(__m128i, __m128i);
__m128i _mm_cmpeq_epi64(__m128i, __m128i);
__m128i _mm_cmpeq_epi8(__m128i, __m128i);
__m128d _mm_cmpeq_pd(__m128d, __m128d);
__m128 _mm_cmpeq_ps(__m128, __m128);
__m128d _mm_cmpeq_sd(__m128d, __m128d);
__m128 _mm_cmpeq_ss(__m128, __m128);
int _mm_cmpestra(__m128i, int, __m128i, int, int);
int _mm_cmpestrc(__m128i, int, __m128i, int, int);
int _mm_cmpestri(__m128i, int, __m128i, int, int);
__m128i _mm_cmpestrm(__m128i, int, __m128i, int, int);
int _mm_cmpestro(__m128i, int, __m128i, int, int);
int _mm_cmpestrs(__m128i, int, __m128i, int, int);
int _mm_cmpestrz(__m128i, int, __m128i, int, int);
__m128d _mm_cmpge_pd(__m128d, __m128d);
__m128 _mm_cmpge_ps(__m128, __m128);
__m128d _mm_cmpge_sd(__m128d, __m128d);
__m128 _mm_cmpge_ss(__m128, __m128);
__m128i _mm_cmpgt_epi16(__m128i, __m128i);
__m128i _mm_cmpgt_epi32(__m128i, __m128i);
__m128i _mm_cmpgt_epi64(__m128i, __m128i);
__m128i _mm_cmpgt_epi8(__m128i, __m128i);
__m128d _mm_cmpgt_pd(__m128d, __m128d);
__m128 _mm_cmpgt_ps(__m128, __m128);
__m128d _mm_cmpgt_sd(__m128d, __m128d);
__m128 _mm_cmpgt_ss(__m128, __m128);
int _mm_cmpistra(__m128i, __m128i, int);
int _mm_cmpistrc(__m128i, __m128i, int);
int _mm_cmpistri(__m128i, __m128i, int);
__m128i _mm_cmpistrm(__m128i, __m128i, int);
int _mm_cmpistro(__m128i, __m128i, int);
int _mm_cmpistrs(__m128i, __m128i, int);
int _mm_cmpistrz(__m128i, __m128i, int);
__m128d _mm_cmple_pd(__m128d, __m128d);
__m128 _mm_cmple_ps(__m128, __m128);
__m128d _mm_cmple_sd(__m128d, __m128d);
__m128 _mm_cmple_ss(__m128, __m128);
__m128i _mm_cmplt_epi16(__m128i, __m128i);
__m128i _mm_cmplt_epi32(__m128i, __m128i);
__m128i _mm_cmplt_epi8(__m128i, __m128i);
__m128d _mm_cmplt_pd(__m128d, __m128d);
__m128 _mm_cmplt_ps(__m128, __m128);
__m128d _mm_cmplt_sd(__m128d, __m128d);
__m128 _mm_cmplt_ss(__m128, __m128);
__m128d _mm_cmpneq_pd(__m128d, __m128d);
__m128 _mm_cmpneq_ps(__m128, __m128);
__m128d _mm_cmpneq_sd(__m128d, __m128d);
__m128 _mm_cmpneq_ss(__m128, __m128);
__m128d _mm_cmpnge_pd(__m128d, __m128d);
__m128 _mm_cmpnge_ps(__m128, __m128);
__m128d _mm_cmpnge_sd(__m128d, __m128d);
__m128 _mm_cmpnge_ss(__m128, __m128);
__m128d _mm_cmpngt_pd(__m128d, __m128d);
__m128 _mm_cmpngt_ps(__m128, __m128);
__m128d _mm_cmpngt_sd(__m128d, __m128d);
__m128 _mm_cmpngt_ss(__m128, __m128);
__m128d _mm_cmpnle_pd(__m128d, __m128d);
__m128 _mm_cmpnle_ps(__m128, __m128);
__m128d _mm_cmpnle_sd(__m128d, __m128d);
__m128 _mm_cmpnle_ss(__m128, __m128);
__m128d _mm_cmpnlt_pd(__m128d, __m128d);
__m128 _mm_cmpnlt_ps(__m128, __m128);
__m128d _mm_cmpnlt_sd(__m128d, __m128d);
__m128 _mm_cmpnlt_ss(__m128, __m128);
__m128d _mm_cmpord_pd(__m128d, __m128d);
__m128 _mm_cmpord_ps(__m128, __m128);
__m128d _mm_cmpord_sd(__m128d, __m128d);
__m128 _mm_cmpord_ss(__m128, __m128);
__m128d _mm_cmpunord_pd(__m128d, __m128d);
__m128 _mm_cmpunord_ps(__m128, __m128);
__m128d _mm_cmpunord_sd(__m128d, __m128d);
__m128 _mm_cmpunord_ss(__m128, __m128);
int _mm_comieq_sd(__m128d, __m128d);
int _mm_comieq_ss(__m128, __m128);
int _mm_comige_sd(__m128d, __m128d);
int _mm_comige_ss(__m128, __m128);
int _mm_comigt_sd(__m128d, __m128d);
int _mm_comigt_ss(__m128, __m128);
int _mm_comile_sd(__m128d, __m128d);
int _mm_comile_ss(__m128, __m128);
int _mm_comilt_sd(__m128d, __m128d);
int _mm_comilt_ss(__m128, __m128);
int _mm_comineq_sd(__m128d, __m128d);
int _mm_comineq_ss(__m128, __m128);
unsigned int _mm_crc32_u16(unsigned int, unsigned short);
unsigned int _mm_crc32_u32(unsigned int, unsigned int);

unsigned int _mm_crc32_u8(unsigned int, unsigned char);
__m128 _mm_cvt_pi2ps(__m128, __m64);
__m64 _mm_cvt_ps2pi(__m128);
__m128 _mm_cvt_si2ss(__m128, int);
int _mm_cvt_ss2si(__m128);
__m128i _mm_cvtepi16_epi32(__m128i);
__m128i _mm_cvtepi16_epi64(__m128i);
__m128i _mm_cvtepi32_epi64(__m128i);
__m128d _mm_cvtepi32_pd(__m128i);
__m128 _mm_cvtepi32_ps(__m128i);
__m128i _mm_cvtepi8_epi16(__m128i);
__m128i _mm_cvtepi8_epi32(__m128i);
__m128i _mm_cvtepi8_epi64(__m128i);
__m128i _mm_cvtepu16_epi32(__m128i);
__m128i _mm_cvtepu16_epi64(__m128i);
__m128i _mm_cvtepu32_epi64(__m128i);
__m128i _mm_cvtepu8_epi16(__m128i);
__m128i _mm_cvtepu8_epi32(__m128i);
__m128i _mm_cvtepu8_epi64(__m128i);
__m128i _mm_cvtpd_epi32(__m128d);
__m64 _mm_cvtpd_pi32(__m128d);
__m128 _mm_cvtpd_ps(__m128d);
__m128d _mm_cvtpi32_pd(__m64);
__m128i _mm_cvtps_epi32(__m128);
__m128d _mm_cvtps_pd(__m128);
int _mm_cvtsd_si32(__m128d);


__m128 _mm_cvtsd_ss(__m128, __m128d);
int _mm_cvtsi128_si32(__m128i);


__m128d _mm_cvtsi32_sd(__m128d, int);
__m128i _mm_cvtsi32_si128(int);






__m128d _mm_cvtss_sd(__m128d, __m128);


__m64 _mm_cvtt_ps2pi(__m128);
int _mm_cvtt_ss2si(__m128);
__m128i _mm_cvttpd_epi32(__m128d);
__m64 _mm_cvttpd_pi32(__m128d);
__m128i _mm_cvttps_epi32(__m128);
int _mm_cvttsd_si32(__m128d);




__m128d _mm_div_pd(__m128d, __m128d);
__m128 _mm_div_ps(__m128, __m128);
__m128d _mm_div_sd(__m128d, __m128d);
__m128 _mm_div_ss(__m128, __m128);
__m128d _mm_dp_pd(__m128d, __m128d, int);
__m128 _mm_dp_ps(__m128, __m128, int);
int _mm_extract_epi16(__m128i, int);
int _mm_extract_epi32(__m128i, int);

int _mm_extract_epi8(__m128i, int);
int _mm_extract_ps(__m128, int);
__m128i _mm_extract_si64(__m128i, __m128i);
__m128i _mm_extracti_si64(__m128i, int, int);
unsigned int _mm_getcsr(void);
__m128i _mm_hadd_epi16(__m128i, __m128i);
__m128i _mm_hadd_epi32(__m128i, __m128i);
__m128d _mm_hadd_pd(__m128d, __m128d);
__m64 _mm_hadd_pi16(__m64, __m64);
__m64 _mm_hadd_pi32(__m64, __m64);
__m128 _mm_hadd_ps(__m128, __m128);
__m128i _mm_hadds_epi16(__m128i, __m128i);
__m64 _mm_hadds_pi16(__m64, __m64);
__m128i _mm_hsub_epi16(__m128i, __m128i);
__m128i _mm_hsub_epi32(__m128i, __m128i);
__m128d _mm_hsub_pd(__m128d, __m128d);
__m64 _mm_hsub_pi16(__m64, __m64);
__m64 _mm_hsub_pi32(__m64, __m64);
__m128 _mm_hsub_ps(__m128, __m128);
__m128i _mm_hsubs_epi16(__m128i, __m128i);
__m64 _mm_hsubs_pi16(__m64, __m64);
__m128i _mm_insert_epi16(__m128i, int, int);
__m128i _mm_insert_epi32(__m128i, int, int);

__m128i _mm_insert_epi8(__m128i, int, int);
__m128 _mm_insert_ps(__m128, __m128, int);
__m128i _mm_insert_si64(__m128i, __m128i);
__m128i _mm_inserti_si64(__m128i, __m128i, int, int);
__m128i _mm_lddqu_si128(__m128i const *);
void _mm_lfence(void);
__m128d _mm_load1_pd(double const *);
__m128d _mm_load_pd(double const *);
__m128 _mm_load_ps(float const *);
__m128 _mm_load_ps1(float const *);
__m128d _mm_load_sd(double const *);
__m128i _mm_load_si128(__m128i const *);
__m128 _mm_load_ss(float const *);
__m128d _mm_loaddup_pd(double const *);
__m128d _mm_loadh_pd(__m128d, double const *);
__m128 _mm_loadh_pi(__m128, __m64 const *);
__m128i _mm_loadl_epi64(__m128i const *);
__m128d _mm_loadl_pd(__m128d, double const *);
__m128 _mm_loadl_pi(__m128, __m64 const *);
__m128d _mm_loadr_pd(double const *);
__m128 _mm_loadr_ps(float const *);
__m128d _mm_loadu_pd(double const *);
__m128 _mm_loadu_ps(float const *);
__m128i _mm_loadu_si128(__m128i const *);
__m128i _mm_madd_epi16(__m128i, __m128i);
__m128i _mm_maddubs_epi16(__m128i, __m128i);
__m64 _mm_maddubs_pi16(__m64, __m64);
void _mm_maskmoveu_si128(__m128i, __m128i, char *);
__m128i _mm_max_epi16(__m128i, __m128i);
__m128i _mm_max_epi32(__m128i, __m128i);
__m128i _mm_max_epi8(__m128i, __m128i);
__m128i _mm_max_epu16(__m128i, __m128i);
__m128i _mm_max_epu32(__m128i, __m128i);
__m128i _mm_max_epu8(__m128i, __m128i);
__m128d _mm_max_pd(__m128d, __m128d);
__m128 _mm_max_ps(__m128, __m128);
__m128d _mm_max_sd(__m128d, __m128d);
__m128 _mm_max_ss(__m128, __m128);
void _mm_mfence(void);
__m128i _mm_min_epi16(__m128i, __m128i);
__m128i _mm_min_epi32(__m128i, __m128i);
__m128i _mm_min_epi8(__m128i, __m128i);
__m128i _mm_min_epu16(__m128i, __m128i);
__m128i _mm_min_epu32(__m128i, __m128i);
__m128i _mm_min_epu8(__m128i, __m128i);
__m128d _mm_min_pd(__m128d, __m128d);
__m128 _mm_min_ps(__m128, __m128);
__m128d _mm_min_sd(__m128d, __m128d);
__m128 _mm_min_ss(__m128, __m128);
__m128i _mm_minpos_epu16(__m128i);
void _mm_monitor(void const *, unsigned int, unsigned int);
__m128i _mm_move_epi64(__m128i);
__m128d _mm_move_sd(__m128d, __m128d);
__m128 _mm_move_ss(__m128, __m128);
__m128d _mm_movedup_pd(__m128d);
__m128 _mm_movehdup_ps(__m128);
__m128 _mm_movehl_ps(__m128, __m128);
__m128 _mm_moveldup_ps(__m128);
__m128 _mm_movelh_ps(__m128, __m128);
int _mm_movemask_epi8(__m128i);
int _mm_movemask_pd(__m128d);
int _mm_movemask_ps(__m128);
__m64 _mm_movepi64_pi64(__m128i);
__m128i _mm_movpi64_epi64(__m64);
__m128i _mm_mpsadbw_epu8(__m128i, __m128i, int);
__m128i _mm_mul_epi32(__m128i, __m128i);
__m128i _mm_mul_epu32(__m128i, __m128i);
__m128d _mm_mul_pd(__m128d, __m128d);
__m128 _mm_mul_ps(__m128, __m128);
__m128d _mm_mul_sd(__m128d, __m128d);
__m128 _mm_mul_ss(__m128, __m128);
__m64 _mm_mul_su32(__m64, __m64);
__m128i _mm_mulhi_epi16(__m128i, __m128i);
__m128i _mm_mulhi_epu16(__m128i, __m128i);
__m128i _mm_mulhrs_epi16(__m128i, __m128i);
__m64 _mm_mulhrs_pi16(__m64, __m64);
__m128i _mm_mullo_epi16(__m128i, __m128i);
__m128i _mm_mullo_epi32(__m128i, __m128i);
void _mm_mwait(unsigned int, unsigned int);
__m128d _mm_or_pd(__m128d, __m128d);
__m128 _mm_or_ps(__m128, __m128);
__m128i _mm_or_si128(__m128i, __m128i);
__m128i _mm_packs_epi16(__m128i, __m128i);
__m128i _mm_packs_epi32(__m128i, __m128i);
__m128i _mm_packus_epi16(__m128i, __m128i);
__m128i _mm_packus_epi32(__m128i, __m128i);
void _mm_pause(void);
int _mm_popcnt_u32(unsigned int);

void _mm_prefetch(char const *, int);
__m128 _mm_rcp_ps(__m128);
__m128 _mm_rcp_ss(__m128);
__m128d _mm_round_pd(__m128d, int);
__m128 _mm_round_ps(__m128, int);
__m128d _mm_round_sd(__m128d, __m128d, int);
__m128 _mm_round_ss(__m128, __m128, int);
__m128 _mm_rsqrt_ps(__m128);
__m128 _mm_rsqrt_ss(__m128);
__m128i _mm_sad_epu8(__m128i, __m128i);
__m128i _mm_set1_epi16(short);
__m128i _mm_set1_epi32(int);
__m128i _mm_set1_epi64(__m64);
__m128i _mm_set1_epi64x(__int64);
__m128i _mm_set1_epi8(char);
__m128d _mm_set1_pd(double);
__m64 _mm_set1_pi16(short);
__m64 _mm_set1_pi32(int);
__m64 _mm_set1_pi8(char);
__m128i _mm_set_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_set_epi32(int, int, int, int);
__m128i _mm_set_epi64(__m64, __m64);
__m128i _mm_set_epi64x(__int64, __int64);
__m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_set_pd(double, double);
__m64 _mm_set_pi16(short, short, short, short);
__m64 _mm_set_pi32(int, int);
__m64 _mm_set_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_set_ps(float, float, float, float);
__m128 _mm_set_ps1(float);
__m128d _mm_set_sd(double);
__m128 _mm_set_ss(float);
void _mm_setcsr(unsigned int);
__m128i _mm_setl_epi64(__m128i);
__m128i _mm_setr_epi16(short, short, short, short, short, short, short, short);
__m128i _mm_setr_epi32(int, int, int, int);
__m128i _mm_setr_epi64(__m64, __m64);
__m128i _mm_setr_epi64x(__int64, __int64);
__m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char);
__m128d _mm_setr_pd(double, double);
__m64 _mm_setr_pi16(short, short, short, short);
__m64 _mm_setr_pi32(int, int);
__m64 _mm_setr_pi8(char, char, char, char, char, char, char, char);
__m128 _mm_setr_ps(float, float, float, float);
__m128d _mm_setzero_pd(void);
__m128 _mm_setzero_ps(void);
__m128i _mm_setzero_si128(void);
__m64 _mm_setzero_si64(void);
void _mm_sfence(void);
__m128i _mm_shuffle_epi32(__m128i, int);
__m128i _mm_shuffle_epi8(__m128i, __m128i);
__m128d _mm_shuffle_pd(__m128d, __m128d, int);
__m64 _mm_shuffle_pi8(__m64, __m64);
__m128 _mm_shuffle_ps(__m128, __m128, unsigned int);
__m128i _mm_shufflehi_epi16(__m128i, int);
__m128i _mm_shufflelo_epi16(__m128i, int);
__m128i _mm_sign_epi16(__m128i, __m128i);
__m128i _mm_sign_epi32(__m128i, __m128i);
__m128i _mm_sign_epi8(__m128i, __m128i);
__m64 _mm_sign_pi16(__m64, __m64);
__m64 _mm_sign_pi32(__m64, __m64);
__m64 _mm_sign_pi8(__m64, __m64);
__m128i _mm_sll_epi16(__m128i, __m128i);
__m128i _mm_sll_epi32(__m128i, __m128i);
__m128i _mm_sll_epi64(__m128i, __m128i);
__m128i _mm_slli_epi16(__m128i, int);
__m128i _mm_slli_epi32(__m128i, int);
__m128i _mm_slli_epi64(__m128i, int);
__m128i _mm_slli_si128(__m128i, int);
__m128d _mm_sqrt_pd(__m128d);
__m128 _mm_sqrt_ps(__m128);
__m128d _mm_sqrt_sd(__m128d, __m128d);
__m128 _mm_sqrt_ss(__m128);
__m128i _mm_sra_epi16(__m128i, __m128i);
__m128i _mm_sra_epi32(__m128i, __m128i);
__m128i _mm_srai_epi16(__m128i, int);
__m128i _mm_srai_epi32(__m128i, int);
__m128i _mm_srl_epi16(__m128i, __m128i);
__m128i _mm_srl_epi32(__m128i, __m128i);
__m128i _mm_srl_epi64(__m128i, __m128i);
__m128i _mm_srli_epi16(__m128i, int);
__m128i _mm_srli_epi32(__m128i, int);
__m128i _mm_srli_epi64(__m128i, int);
__m128i _mm_srli_si128(__m128i, int);
void _mm_store1_pd(double *, __m128d);
void _mm_store_pd(double *, __m128d);
void _mm_store_ps(float *, __m128);
void _mm_store_ps1(float *, __m128);
void _mm_store_sd(double *, __m128d);
void _mm_store_si128(__m128i *, __m128i);
void _mm_store_ss(float *, __m128);
void _mm_storeh_pd(double *, __m128d);
void _mm_storeh_pi(__m64 *, __m128);
void _mm_storel_epi64(__m128i *, __m128i);
void _mm_storel_pd(double *, __m128d);
void _mm_storel_pi(__m64 *, __m128);
void _mm_storer_pd(double *, __m128d);
void _mm_storer_ps(float *, __m128);
void _mm_storeu_pd(double *, __m128d);
void _mm_storeu_ps(float *, __m128);
void _mm_storeu_si128(__m128i *, __m128i);
__m128i _mm_stream_load_si128(const __m128i *);
void _mm_stream_pd(double *, __m128d);
void _mm_stream_pi(__m64 *, __m64);
void _mm_stream_ps(float *, __m128);
void _mm_stream_sd(double *, __m128d);
void _mm_stream_si128(__m128i *, __m128i);
void _mm_stream_si32(int *, int);

void _mm_stream_ss(float *, __m128);
__m128i _mm_sub_epi16(__m128i, __m128i);
__m128i _mm_sub_epi32(__m128i, __m128i);
__m128i _mm_sub_epi64(__m128i, __m128i);
__m128i _mm_sub_epi8(__m128i, __m128i);
__m128d _mm_sub_pd(__m128d, __m128d);
__m128 _mm_sub_ps(__m128, __m128);
__m128d _mm_sub_sd(__m128d, __m128d);
__m64 _mm_sub_si64(__m64, __m64);
__m128 _mm_sub_ss(__m128, __m128);
__m128i _mm_subs_epi16(__m128i, __m128i);
__m128i _mm_subs_epi8(__m128i, __m128i);
__m128i _mm_subs_epu16(__m128i, __m128i);
__m128i _mm_subs_epu8(__m128i, __m128i);
int _mm_testc_si128(__m128i, __m128i);
int _mm_testnzc_si128(__m128i, __m128i);
int _mm_testz_si128(__m128i, __m128i);
int _mm_ucomieq_sd(__m128d, __m128d);
int _mm_ucomieq_ss(__m128, __m128);
int _mm_ucomige_sd(__m128d, __m128d);
int _mm_ucomige_ss(__m128, __m128);
int _mm_ucomigt_sd(__m128d, __m128d);
int _mm_ucomigt_ss(__m128, __m128);
int _mm_ucomile_sd(__m128d, __m128d);
int _mm_ucomile_ss(__m128, __m128);
int _mm_ucomilt_sd(__m128d, __m128d);
int _mm_ucomilt_ss(__m128, __m128);
int _mm_ucomineq_sd(__m128d, __m128d);
int _mm_ucomineq_ss(__m128, __m128);
__m128i _mm_unpackhi_epi16(__m128i, __m128i);
__m128i _mm_unpackhi_epi32(__m128i, __m128i);
__m128i _mm_unpackhi_epi64(__m128i, __m128i);
__m128i _mm_unpackhi_epi8(__m128i, __m128i);
__m128d _mm_unpackhi_pd(__m128d, __m128d);
__m128 _mm_unpackhi_ps(__m128, __m128);
__m128i _mm_unpacklo_epi16(__m128i, __m128i);
__m128i _mm_unpacklo_epi32(__m128i, __m128i);
__m128i _mm_unpacklo_epi64(__m128i, __m128i);
__m128i _mm_unpacklo_epi8(__m128i, __m128i);
__m128d _mm_unpacklo_pd(__m128d, __m128d);
__m128 _mm_unpacklo_ps(__m128, __m128);
__m128d _mm_xor_pd(__m128d, __m128d);
__m128 _mm_xor_ps(__m128, __m128);
__m128i _mm_xor_si128(__m128i, __m128i);

unsigned int __cdecl _rotl(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotl64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift);
unsigned int __cdecl _rotr(  unsigned int _Value,   int _Shift);
unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift);
unsigned __int64 __cdecl _rotr64(  unsigned __int64 _Value,   int _Shift);
unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift);
int __cdecl _setjmp(jmp_buf);


void _rsm(void);
void _lgdt(void *);
void _sgdt(void *);
void _clac(void);
void _stac(void);
unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *);
unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *);
unsigned char __cdecl _addcarry_u32(unsigned char, unsigned int, unsigned int, unsigned int *);
unsigned char __cdecl _subborrow_u32(unsigned char, unsigned int, unsigned int, unsigned int *);


void _mm_monitorx(void const *, unsigned int, unsigned int);
void _mm_mwaitx(unsigned int, unsigned int, unsigned int);


}
#line 1134 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 1135 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"
#line 1136 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\intrin.h"

#line 1152 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

   

   


  






#line 1166 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1171 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"
#line 1172 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory0"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

  #pragma warning(disable: 4251)

template<class _Elem,
	class _Traits = char_traits<_Elem>,
	class _Ax = allocator<_Elem> >
	class basic_string;

		
template<class _Mystr>
	class _String_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Mystr::value_type,
			typename _Mystr::difference_type,
			typename _Mystr::const_pointer,
			typename _Mystr::const_reference,
			_Iterator_base>
	{	
public:
	typedef _String_const_iterator<_Mystr> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::const_pointer pointer;
	typedef typename _Mystr::const_reference reference;

	_String_const_iterator()
		: _Ptr()
		{	
		}

	_String_const_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Ptr(_Parg)
		{	
		this->_Adopt(_Pstring);
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr);
		}

	reference operator*() const
		{	
 
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Unfancy(_Ptr) < _Contptr
			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
			{	
			_Debug_message(L"string iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 76);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 77, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 77, 0); };
			}

 





#line 87 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		;

		return (*_Ptr);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Mycont->_Myptr() + _Mycont->_Mysize <= _Unfancy(_Ptr))
			{	
			_Debug_message(L"string iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 106);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 107, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 107, 0); };
			}

 




#line 116 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		++_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Unfancy(_Ptr) <= _Mycont->_Myptr())
			{	
			_Debug_message(L"string iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 136);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 137, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 137, 0); };
			}

 




#line 146 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		--_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (_Off != 0)
			{
			const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
			const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
			if (_Mycont == 0
				|| _Ptr == nullptr_t{}
				|| _Unfancy(_Ptr) + _Off < _Contptr
				|| _Contptr + _Mycont->_Mysize < _Unfancy(_Ptr) + _Off)
				{
				_Debug_message(L"string iterator + offset out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 170);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 171, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 171, 0); };
				}
			}

 









#line 186 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			{
			_Debug_message(L"string iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 256);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 257, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 257, 0); };
			}
		}

 









#line 272 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

	pointer _Ptr;	
	};

template<class _Mystr> inline
	typename _String_const_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_const_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr>
		_Rechecked(_String_const_iterator<_Mystr>& _Iter,
			typename _String_const_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_const_iterator<_Mystr> operator+(
		typename _String_const_iterator<_Mystr>
			::difference_type _Off,
		_String_const_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Mystr>
	class _String_iterator
		: public _String_const_iterator<_Mystr>
	{	
public:
	typedef _String_iterator<_Mystr> _Myiter;
	typedef _String_const_iterator<_Mystr> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Mystr::value_type value_type;
	typedef typename _Mystr::difference_type difference_type;
	typedef typename _Mystr::pointer pointer;
	typedef typename _Mystr::reference reference;

	_String_iterator()
		{	
		}

	_String_iterator(pointer _Parg, const _Container_base *_Pstring)
		: _Mybase(_Parg, _Pstring)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Const_cast(this->_Ptr));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Mystr> inline
	typename _String_iterator<_Mystr>::_Unchecked_type
		_Unchecked(_String_iterator<_Mystr> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mystr> inline
	_String_iterator<_Mystr>
		_Rechecked(_String_iterator<_Mystr>& _Iter,
			typename _String_iterator<_Mystr>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Mystr> inline
	_String_iterator<_Mystr> operator+(
		typename _String_iterator<_Mystr>
			::difference_type _Off,
		_String_iterator<_Mystr> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _String_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _String_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _String_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_String_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _String_val
		: public _Container_base
	{	
public:
	typedef _String_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_Myt> iterator;
	typedef _String_const_iterator<_Myt> const_iterator;

	_String_val()
		: _Bx(),
		_Mysize(0),
		_Myres(0)
		{	
		}

	enum
		{	
		_BUF_SIZE = 16 / sizeof (value_type) < 1 ? 1
			: 16 / sizeof (value_type)};
	enum
		{	
		_ALLOC_MASK = sizeof (value_type) <= 1 ? 15
			: sizeof (value_type) <= 2 ? 7
			: sizeof (value_type) <= 4 ? 3
			: sizeof (value_type) <= 8 ? 1 : 0};

	value_type *_Myptr()
		{	
		return (this->_BUF_SIZE <= _Myres
			? _Unfancy(_Bx._Ptr)
			: _Bx._Buf);
		}

	const value_type *_Myptr() const
		{	
		return (this->_BUF_SIZE <= _Myres
			? _Unfancy(_Bx._Ptr)
			: _Bx._Buf);
		}

	union _Bxty
		{	
		_Bxty()
			{	
			}

		~_Bxty() noexcept
			{	
			}

		value_type _Buf[_BUF_SIZE];
		pointer _Ptr;
		char _Alias[_BUF_SIZE];	
		} _Bx;

	size_type _Mysize;	
	size_type _Myres;	
	};

		
template<class _Alloc_types>
	class _String_alloc
	{	
public:
	typedef _String_alloc<_Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alty _Alty;
	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _String_iterator<_String_val<_Val_types> > iterator;
	typedef _String_const_iterator<_String_val<_Val_types> > const_iterator;

	enum
		{	
		_BUF_SIZE = _String_val<_Val_types>::_BUF_SIZE
		};

	enum
		{	
		_ALLOC_MASK = _String_val<_Val_types>::_ALLOC_MASK
		};

	value_type *_Myptr()
		{	
		return (_Get_data()._Myptr());
		}

	const value_type *_Myptr() const
		{	
		return (_Get_data()._Myptr());
		}

 























#line 611 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
	_String_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	
		_Alloc_proxy();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
		_String_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	
		_Alloc_proxy();
		}

	~_String_alloc() noexcept
		{	
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		_Pocca(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Free_proxy();
		_Pocma(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Myproxy() = _Unfancy(_Alproxy.allocate(1));
		_Alproxy.construct(_Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = &_Get_data();
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Orphan_all();
		_Alproxy.destroy(_Myproxy());
		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	
		return (_Get_data()._Myproxy);
		}
 #line 679 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_String_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second());
		}

	const _String_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second());
		}

	typedef typename _String_val<_Val_types>::_Bxty _Bxty;

	_Bxty& _Bx() noexcept
		{	
		return (_Get_data()._Bx);
		}

	const _Bxty& _Bx() const noexcept
		{	
		return (_Get_data()._Bx);
		}

	size_type& _Mysize() noexcept
		{	
		return (_Get_data()._Mysize);
		}

	const size_type& _Mysize() const noexcept
		{	
		return (_Get_data()._Mysize);
		}

	size_type& _Myres() noexcept
		{	
		return (_Get_data()._Myres);
		}

	const size_type& _Myres() const noexcept
		{	
		return (_Get_data()._Myres);
		}

private:
	_Compressed_pair<_Alty, _String_val<_Val_types> > _Mypair;
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_string
		: public _String_alloc<_String_base_types<_Elem, _Alloc> >
	{	
public:
	typedef basic_string<_Elem, _Traits, _Alloc> _Myt;
	typedef _String_alloc<_String_base_types<_Elem, _Alloc> > _Mybase;
	typedef _Traits traits_type;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	basic_string(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, 0, npos);
		}

	basic_string() noexcept(is_nothrow_default_constructible<_Alloc>::value)
		: _Mybase()
		{	
		_Tidy();
		}

	explicit basic_string(const _Alloc& _Al) noexcept
		: _Mybase(_Al)
		{	
		_Tidy();
		}

	basic_string(const _Myt& _Right, size_type _Roff,
		size_type _Count = npos)
		: _Mybase(_Right._Getal())
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Myt& _Right, size_type _Roff, size_type _Count,
		const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Right, _Roff, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr, size_type _Count, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr, _Count);
		}

	basic_string(const _Elem *_Ptr)
		: _Mybase()
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(const _Elem *_Ptr, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ptr);
		}

	basic_string(size_type _Count, _Elem _Ch)
		: _Mybase()
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	basic_string(size_type _Count, _Elem _Ch, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Count, _Ch);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(_Al)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 868);
		_Tidy();
		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>());
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, input_iterator_tag)
		{	
		try {
		for (; _First != _Last; ++_First)
			append((size_type)1, (_Elem)*_First);
		} catch (...) {
		_Tidy(true);
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First,
			_Iter _Last, forward_iterator_tag)
		{	
		size_type _Count = ::std:: distance(_First, _Last);
		reserve(_Count);
		_Construct(_First, _Last, input_iterator_tag());
		}

	void _Construct(_Elem *_First,
		_Elem *_Last, random_access_iterator_tag)
		{	
		if (_First != _Last)
			assign(_First, _Last - _First);
		}

	void _Construct(const _Elem *_First,
		const _Elem *_Last, random_access_iterator_tag)
		{	
		if (_First != _Last)
			assign(_First, _Last - _First);
		}

	basic_string(_Myt&& _Right) noexcept
		: _Mybase(::std:: move(_Right._Getal()))
		{	
		_Tidy();
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	basic_string(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (this->_Getal() != _Right._Getal())
			assign(_Right.begin(), _Right.end());
		else
			_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)
#line 928 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
		{	
		if (this != &_Right)
			{	
			_Tidy(true);

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			if (this->_Getal() != _Right._Getal())
				assign(_Right.begin(), _Right.end());
			else
				_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	_Myt& assign(_Myt&& _Right) noexcept
		{	
		if (this == &_Right)
			;
		else if (get_allocator() != _Right.get_allocator()
			&& this->_BUF_SIZE <= _Right._Myres())
			*this = _Right;
		else
			{	
			_Tidy(true);
			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (_Right._Myres() < this->_BUF_SIZE)
			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,
				_Right._Mysize() + 1);
		else
			{	
			this->_Getal().construct(::std:: addressof(this->_Bx()._Ptr), _Right._Bx()._Ptr);
			_Right._Bx()._Ptr = pointer();
			}
		this->_Mysize() = _Right._Mysize();
		this->_Myres() = _Right._Myres();
		_Right._Tidy();
		}

	basic_string(::std:: initializer_list<_Elem> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		_Tidy();
		assign(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& operator+=(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& assign(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (assign(_Ilist.begin(), _Ilist.end()));
		}

	_Myt& append(::std:: initializer_list<_Elem> _Ilist)
		{	
		return (append(_Ilist.begin(), _Ilist.end()));
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		::std:: initializer_list<_Elem> _Ilist)
		{	
		return (replace(_First, _Last, _Ilist.begin(), _Ilist.end()));
		}

	~basic_string() noexcept
		{	
		_Tidy(true);
		}

	 static const size_type npos;	

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy(true);
				this->_Copy_alloc(_Right._Getal());
				}

			assign(_Right);
			}
		return (*this);
		}

	_Myt& operator=(const _Elem *_Ptr)
		{	
		return (assign(_Ptr));
		}

	_Myt& operator=(_Elem _Ch)
		{	
		return (assign(1, _Ch));
		}

	_Myt& operator+=(const _Myt& _Right)
		{	
		return (append(_Right));
		}

	_Myt& operator+=(const _Elem *_Ptr)
		{	
		return (append(_Ptr));
		}

	_Myt& operator+=(_Elem _Ch)
		{	
		return (append((size_type)1, _Ch));
		}

	_Myt& append(const _Myt& _Right)
		{	
		return (append(_Right, 0, npos));
		}

	_Myt& append(const _Myt& _Right,
		size_type _Roff, size_type _Count = npos)
		{	
		_Right._Check_offset(_Roff);
		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize(),
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1088);
		if (_Inside(_Ptr))
			return (append(*this,
				_Ptr - this->_Myptr(), _Count));	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& append(const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1106);
		return (append(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& append(size_type _Count, _Elem _Ch)
		{	
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Chassign(this->_Mysize(), _Count, _Ch);
			_Eos(_Num);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		append(_Iter _First, _Iter _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_pointer _First, const_pointer _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& append(const_iterator _First, const_iterator _Last)
		{	
		return (replace(end(), end(), _First, _Last));
		}

	_Myt& assign(const _Myt& _Right)
		{	
		return (assign(_Right, 0, npos));
		}

	_Myt& assign(const _Myt& _Right,
		size_type _Roff, size_type _Count = npos)
		{	
		_Right._Check_offset(_Roff);
		_Count = _Right._Clamp_suffix_size(_Roff, _Count);

		if (this == &_Right)
			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	
		else if (_Grow(_Count))
			{	
			_Traits::copy(this->_Myptr(),
				_Right._Myptr() + _Roff, _Count);
			_Eos(_Count);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1166);
		if (_Inside(_Ptr))
			return (assign(*this,
				_Ptr - this->_Myptr(), _Count));	

		if (_Grow(_Count))
			{	
			_Traits::copy(this->_Myptr(), _Ptr, _Count);
			_Eos(_Count);
			}
		return (*this);
		}

	_Myt& assign(const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1181);
		return (assign(_Ptr, _Traits::length(_Ptr)));
		}

	_Myt& assign(size_type _Count, _Elem _Ch)
		{	
		if (_Count == npos)
			_Xlen();	

		if (_Grow(_Count))
			{	
			_Chassign(0, _Count, _Ch);
			_Eos(_Count);
			}
		return (*this);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		assign(_Iter _First, _Iter _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_pointer _First, const_pointer _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& assign(const_iterator _First, const_iterator _Last)
		{	
		return (replace(begin(), end(), _First, _Last));
		}

	_Myt& insert(size_type _Off, const _Myt& _Right)
		{	
		return (insert(_Off, _Right, 0, npos));
		}

	_Myt& insert(size_type _Off,
		const _Myt& _Right, size_type _Roff, size_type _Count = npos)
		{	
		_Check_offset(_Off);
		_Right._Check_offset(_Roff);
		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	

		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			if (this == &_Right)
				_Traits::move(this->_Myptr() + _Off,
					this->_Myptr() + (_Off < _Roff ? _Roff + _Count : _Roff),
						_Count);	
			else
				_Traits::copy(this->_Myptr() + _Off,
					_Right._Myptr() + _Roff, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off,
		const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1251);
		if (_Inside(_Ptr))
			return (insert(_Off, *this,
				_Ptr - this->_Myptr(), _Count));	
		_Check_offset(_Off);
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	
		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& insert(size_type _Off, const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1272);
		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& insert(size_type _Off,
		size_type _Count, _Elem _Ch)
		{	
		_Check_offset(_Off);
		if (npos - this->_Mysize() <= _Count)
			_Xlen();	
		const size_type _Num = this->_Mysize() + _Count;
		if (0 < _Count && _Grow(_Num))
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off,
				this->_Mysize() - _Off);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	iterator insert(const_iterator _Where)
		{	
		return (insert(_Where, _Elem()));
		}

	iterator insert(const_iterator _Where, _Elem _Ch)
		{	
		size_type _Off = _Where - begin();
		insert(_Off, 1, _Ch);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where, size_type _Count, _Elem _Ch)
		{	
		size_type _Off = _Where - begin();
		insert(_Off, _Count, _Ch);
		return (begin() + _Off);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_pointer _First, const_pointer _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	iterator insert(const_iterator _Where,
		const_iterator _First, const_iterator _Last)
		{	
		size_type _Off = _Where - begin();
		replace(_Where, _Where, _First, _Last);
		return (begin() + _Off);
		}

	_Myt& erase(size_type _Off = 0)
		{	
		_Check_offset(_Off);
		_Eos(_Off);
		return (*this);
		}

	_Myt& erase(size_type _Off, size_type _Count)
		{	
		_Check_offset(_Off);
		if (this->_Mysize() - _Off <= _Count)
			_Eos(_Off);	
		else if (0 < _Count)
			{	
			value_type *_Ptr = this->_Myptr() + _Off;
			size_type _Newsize = this->_Mysize() - _Count;
			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);
			_Eos(_Newsize);
			}
		return (*this);
		}

	iterator erase(const_iterator _Where)
		{	
		size_type _Count = _Where - begin();
		erase(_Count, 1);
		return (begin() + _Count);
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1370);
		size_type _Count = _First - begin();
		erase(_Count, _Last - _First);
		return (begin() + _Count);
		}

	void clear() noexcept
		{	
		_Eos(0);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Myt& _Right)
		{	
		return (replace(_Off, _N0, _Right, 0, npos));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Myt& _Right, size_type _Roff,
			size_type _Count = npos)
		{	
		_Check_offset(_Off);
		_Right._Check_offset(_Roff);
		_N0 = _Clamp_suffix_size(_Off, _N0);
		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	

		const size_type _Nm = this->_Mysize() - _N0 - _Off;	
		const size_type _Newsize = this->_Mysize() + _Count - _N0;
		if (this->_Mysize() < _Newsize)
			_Grow(_Newsize);

		if (_Count == _N0)
			{	
			_Traits::move(this->_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);	
			}
		else if (this != &_Right)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off,
				_Right._Myptr() + _Roff, _Count);	
			}
		else if (_Count < _N0)
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			}
		else if (_Roff <= _Off)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _Count);	
			}
		else if (_Off + _N0 <= _Roff)
			{	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + (_Roff + _Count - _N0),
				_Count);	
			}
		else
			{	
			_Traits::move(this->_Myptr() + _Off,
				this->_Myptr() + _Roff, _N0);	
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::move(this->_Myptr() + _Off + _N0,
				this->_Myptr() + _Roff + _Count,
				_Count - _N0);	
			}

		_Eos(_Newsize);
		return (*this);
		}

	_Myt& replace(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count)
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1454);
		if (_Inside(_Ptr))
			return (replace(_Off, _N0, *this,
				_Ptr - this->_Myptr(),
				_Count));	
		_Check_offset(_Off);
		_N0 = _Clamp_suffix_size(_Off, _N0);
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize() - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		const size_type _Num = this->_Mysize() + _Count - _N0;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(size_type _Off, size_type _N0, const _Elem *_Ptr)
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1484);
		return (replace(_Off, _N0, _Ptr, _Traits::length(_Ptr)));
		}

	_Myt& replace(size_type _Off,
		size_type _N0, size_type _Count, _Elem _Ch)
		{	
		_Check_offset(_Off);
		_N0 = _Clamp_suffix_size(_Off, _N0);
		if (npos - _Count <= this->_Mysize() - _N0)
			_Xlen();	
		size_type _Nm = this->_Mysize() - _N0 - _Off;

		if (_Count < _N0)
			_Traits::move(this->_Myptr() + _Off + _Count,
				this->_Myptr() + _Off + _N0,
				_Nm);	
		const size_type _Num = this->_Mysize() + _Count - _N0;
		if ((0 < _Count || 0 < _N0)
			&& _Grow(_Num))
			{	
			if (_N0 < _Count)
				_Traits::move(this->_Myptr() + _Off + _Count,
					this->_Myptr() + _Off + _N0, _Nm);	
			_Chassign(_Off, _Count, _Ch);	
			_Eos(_Num);
			}
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Myt& _Right)
		{	
		return (replace(_First - begin(), _Last - _First, _Right));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr, size_type _Count)
		{	
		return (replace(_First - begin(), _Last - _First, _Ptr, _Count));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const _Elem *_Ptr)
		{	
		return (replace(_First - begin(), _Last - _First, _Ptr));
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		size_type _Count, _Elem _Ch)
		{	
		return (replace(_First - begin(), _Last - _First, _Count, _Ch));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			_Myt&>::type
		replace(const_iterator _First, const_iterator _Last,
			_Iter _First2, _Iter _Last2)
		{	
		_Myt _Right(_First2, _Last2);
		replace(_First, _Last, _Right);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_pointer _First2, const_pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		pointer _First2, pointer _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		const_iterator _First2, const_iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	_Myt& replace(const_iterator _First, const_iterator _Last,
		iterator _First2, iterator _Last2)
		{	
		if (_First2 == _Last2)
			erase(_First - begin(), _Last - _First);
		else
			replace(_First - begin(), _Last - _First,
				&*_First2, _Last2 - _First2);
		return (*this);
		}

	iterator begin() noexcept
		{	
		auto _Mydata = &this->_Get_data();
		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
		}

	const_iterator begin() const noexcept
		{	
		auto _Mydata = &this->_Get_data();
		return (const_iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
		}

	iterator end() noexcept
		{	
		auto _Mydata = &this->_Get_data();
		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));
		}

	const_iterator end() const noexcept
		{	
		auto _Mydata = &this->_Get_data();
		return (const_iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if ((size() | this->_ALLOC_MASK) < capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}

	reference at(size_type _Off)
		{	
		_Check_offset_exclusive(_Off);
		return (this->_Myptr()[_Off]);
		}

	const_reference at(size_type _Off) const
		{	
		_Check_offset_exclusive(_Off);
		return (this->_Myptr()[_Off]);
		}

	reference operator[](size_type _Off)
		{	
 
		if (this->_Mysize() < _Off)	
			_Debug_message(L"string subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1682);

 

#line 1687 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
 
		if (this->_Mysize() < _Off)	
			_Debug_message(L"string subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1695);

 

#line 1700 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

		return (this->_Myptr()[_Off]);
		}

	void push_back(_Elem _Ch)
		{	
		auto& _Dx = this->_Get_data();
		auto& _Sz = _Dx._Mysize;
		if (_Sz == _Dx._Myres)
			_Grow(_Sz + 1); 
		auto _Ptr = _Dx._Myptr();
		_Traits::assign(_Ptr[_Sz], _Ch);
		++_Sz;
		_Traits::assign(_Ptr[_Sz], _Elem());
		}

	void pop_back()
		{	
		erase(this->_Mysize() - 1);	
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	const _Elem *c_str() const noexcept
		{	
		return (this->_Myptr());
		}

	const _Elem *data() const noexcept
		{	
		return (this->_Myptr());
		}






#line 1757 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"

	size_type length() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type max_size() const noexcept
		{	
		const size_type _Num = this->_Getal().max_size();
		return (_Num <= 1 ? 1 : _Num - 1);
		}

	void resize(size_type _Newsize)
		{	
		resize(_Newsize, _Elem());
		}

	void resize(size_type _Newsize, _Elem _Ch)
		{	
		if (_Newsize <= this->_Mysize())
			_Eos(_Newsize);
		else
			append(_Newsize - this->_Mysize(), _Ch);
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myres());
		}

	void reserve(size_type _Newcap = 0)
		{	
		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)
			{	
			size_type _Size = this->_Mysize();
			if (_Grow(_Newcap, true))
				_Eos(_Size);
			}
		}

	bool empty() const noexcept
		{	
		return (this->_Mysize() == 0);
		}

	__declspec(deprecated("Call to 'std::" "basic_string::copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'"))
	size_type copy(_Elem *_Ptr,
		size_type _Count, size_type _Off = 0) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1811);
		_Check_offset(_Off);
		_Count = _Clamp_suffix_size(_Off, _Count);
		_Traits::copy(_Ptr, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	size_type _Copy_s(_Elem *_Dest, size_type _Dest_size,
		size_type _Count, size_type _Off = 0) const
		{	
		_Debug_pointer_if(_Count != 0, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1821);
		_Check_offset(_Off);
		_Count = _Clamp_suffix_size(_Off, _Count);
		_Traits::_Copy_s(_Dest, _Dest_size, this->_Myptr() + _Off, _Count);
		return (_Count);
		}

	void _Swap_bx(_Myt& _Right)
		{	
		if (this->_BUF_SIZE <= this->_Myres())
			if (this->_BUF_SIZE <= _Right._Myres())
				_Swap_adl(this->_Bx()._Ptr, _Right._Bx()._Ptr);
			else
				{	
				pointer _Ptr = this->_Bx()._Ptr;
				this->_Getal().destroy(::std:: addressof(this->_Bx()._Ptr));
				_Traits::copy(this->_Bx()._Buf,
					_Right._Bx()._Buf, _Right._Mysize() + 1);
				this->_Getal().construct(::std:: addressof(_Right._Bx()._Ptr), _Ptr);
				}
		else
			if (_Right._Myres() < this->_BUF_SIZE)
				::std:: swap(this->_Bx()._Buf, _Right._Bx()._Buf);
			else
				{	
				pointer _Ptr = _Right._Bx()._Ptr;
				this->_Getal().destroy(::std:: addressof(_Right._Bx()._Ptr));
				_Traits::copy(_Right._Bx()._Buf,
					this->_Bx()._Buf, this->_Mysize() + 1);
				this->_Getal().construct(::std:: addressof(this->_Bx()._Ptr), _Ptr);
				}
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)
#line 1857 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
		{	
		if (this != &_Right)
			{	
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			_Swap_bx(_Right);
			::std:: swap(this->_Mysize(), _Right._Mysize());
			::std:: swap(this->_Myres(), _Right._Myres());
			}
		}

	size_type find(const _Myt& _Right, size_type _Off = 0) const noexcept
		{	
		return (find(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1876);
		if (_Count == 0 && _Off <= this->_Mysize())
			return (_Off);	

		size_type _Nm;
		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))
			{	
			const _Elem *_Uptr, *_Vptr;
			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;
				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;
				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)
				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find(const _Elem *_Ptr, size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1896);
		return (find(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find(_Elem _Ch, size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type rfind(const _Myt& _Right, size_type _Off = npos) const noexcept
		{	
		return (rfind(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type rfind(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1913);
		if (_Count == 0)
			return (_Off < this->_Mysize() ? _Off
				: this->_Mysize());	
		if (_Count <= this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr() +
				(_Off < this->_Mysize() - _Count ? _Off
					: this->_Mysize() - _Count);
			for (; ; --_Uptr)
				if (_Traits::eq(*_Uptr, *_Ptr)
					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type rfind(const _Elem *_Ptr, size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1935);
		return (rfind(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type rfind(_Elem _Ch, size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_of(const _Myt& _Right,
		size_type _Off = 0) const noexcept
		{	
		return (find_first_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1953);
		if (0 < _Count && _Off < this->_Mysize())
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
			}

		return (npos);	
		}

	size_type find_first_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1969);
		return (find_first_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_of(const _Myt& _Right,
		size_type _Off = npos) const noexcept
		{	
		return (find_last_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 1988);
		if (0 < _Count && 0 < this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) != 0)
					return (_Uptr - this->_Myptr());	
				else if (_Uptr == this->_Myptr())
					break;	
			}

		return (npos);	
		}

	size_type find_last_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2006);
		return (find_last_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (rfind((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_first_not_of(const _Myt& _Right,
		size_type _Off = 0) const noexcept
		{	
		return (find_first_not_of(_Right._Myptr(), _Off,
			_Right.size()));
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2026);
		if (_Off < this->_Mysize())
			{	
			const _Elem *const _Vptr = this->_Myptr() + this->_Mysize();
			for (const _Elem *_Uptr = this->_Myptr() + _Off;
				_Uptr < _Vptr; ++_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
			}
		return (npos);
		}

	size_type find_first_not_of(const _Elem *_Ptr,
		size_type _Off = 0) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2041);
		return (find_first_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_first_not_of(_Elem _Ch,
		size_type _Off = 0) const
		{	
		return (find_first_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	size_type find_last_not_of(const _Myt& _Right,
		size_type _Off = npos) const noexcept
		{	
		return (find_last_not_of(_Right._Myptr(), _Off, _Right.size()));
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2060);
		if (0 < this->_Mysize())
			{	
			const _Elem *_Uptr = this->_Myptr()
				+ (_Off < this->_Mysize() ? _Off : this->_Mysize() - 1);
			for (; ; --_Uptr)
				if (_Traits::find(_Ptr, _Count, *_Uptr) == 0)
					return (_Uptr - this->_Myptr());
				else if (_Uptr == this->_Myptr())
					break;
			}
		return (npos);
		}

	size_type find_last_not_of(const _Elem *_Ptr,
		size_type _Off = npos) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2077);
		return (find_last_not_of(_Ptr, _Off, _Traits::length(_Ptr)));
		}

	size_type find_last_not_of(_Elem _Ch,
		size_type _Off = npos) const
		{	
		return (find_last_not_of((const _Elem *)&_Ch, _Off, 1));
		}

	_Myt substr(size_type _Off = 0, size_type _Count = npos) const
		{	
		return (_Myt(*this, _Off, _Count, get_allocator()));
		}

	static int _Traits_compare(const _Elem * const _Left, const size_type _Left_size,
		const _Elem * const _Right, const size_type _Right_size)
		{	
		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;
		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

		if (_Ans != 0)
			return (_Ans);

		if (_Left_size < _Right_size)
			return (-1);

		if (_Left_size > _Right_size)
			return (1);

		return (0);
		}

	size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const
		{	
		const size_type _Max_effective_size = this->_Mysize() - _Off;
		if (_Size <= _Max_effective_size)
			return (_Size);
		else
			return (_Max_effective_size);
		}

	int compare(const _Myt& _Right) const noexcept
		{	
		return (_Traits_compare(this->_Myptr(), this->_Mysize(),
			_Right._Myptr(), _Right._Mysize()));
		}

	int compare(size_type _Off,
		size_type _N0, const _Myt& _Right) const
		{	
		_Check_offset(_Off);
		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
			_Right._Myptr(), _Right._Mysize()));
		}

	int compare(size_type _Off,
		size_type _N0, const _Myt& _Right,
		size_type _Roff, size_type _Count = npos) const
		{	
		_Check_offset(_Off);
		_Right._Check_offset(_Roff);
		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
			_Right._Myptr() + _Roff, _Right._Clamp_suffix_size(_Roff, _Count)));
		}

	int compare(const _Elem *_Ptr) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2145);
		return (_Traits_compare(this->_Myptr(), this->_Mysize(),
			_Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off, size_type _N0, const _Elem *_Ptr) const
		{	
		_Debug_pointer(_Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2152);
		_Check_offset(_Off);
		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
			_Ptr, _Traits::length(_Ptr)));
		}

	int compare(size_type _Off,
		size_type _N0, const _Elem *_Ptr, size_type _Count) const
		{	
		_Debug_pointer_if(_Count != 0, _Ptr, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring", 2161);
		_Check_offset(_Off);
		return (_Traits_compare(this->_Myptr() + _Off, _Clamp_suffix_size(_Off, _N0),
			_Ptr, _Count));
		}

	allocator_type get_allocator() const noexcept
		{	
		allocator_type _Ret(this->_Getal());
		return (_Ret);
		}

	void _Chassign(size_type _Off, size_type _Count, _Elem _Ch)
		{	
		if (_Count == 1)
			_Traits::assign(*(this->_Myptr() + _Off), _Ch);
		else
			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);
		}

	void _Copy(size_type _Newsize, size_type _Oldlen)
		{	
		size_type _Newres = _Newsize | this->_ALLOC_MASK;
		if (max_size() < _Newres)
			_Newres = _Newsize;	
		else if (this->_Myres() / 2 <= _Newres / 3)
			;
		else if (this->_Myres() <= max_size() - this->_Myres() / 2)
			_Newres = this->_Myres()
				+ this->_Myres() / 2;	
		else
			_Newres = max_size();	

		pointer _Ptr;
		try {
			_Ptr = this->_Getal().allocate(_Newres + 1);
		} catch (...) {
			_Newres = _Newsize;	
			try {
				_Ptr = this->_Getal().allocate(_Newres + 1);
			} catch (...) {
			_Tidy(true);	
			throw;
			}
		}

		if (0 < _Oldlen)
			_Traits::copy(_Unfancy(_Ptr), this->_Myptr(),
				_Oldlen);	
		_Tidy(true);
		this->_Getal().construct(::std:: addressof(this->_Bx()._Ptr), _Ptr);
		this->_Myres() = _Newres;
		_Eos(_Oldlen);
		}

	void _Eos(size_type _Newsize)
		{	
		auto& _Dx = this->_Get_data();
		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());
		}

	bool _Grow(size_type _Newsize,
		bool _Trim = false)
		{	
		if (max_size() < _Newsize)
			_Xlen();	
		if (this->_Myres() < _Newsize)
			_Copy(_Newsize, this->_Mysize());	
		else if (_Trim && _Newsize < this->_BUF_SIZE)
			_Tidy(true,	
				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
		else if (_Newsize == 0)
			_Eos(0);	
		return (0 < _Newsize);	
		}

	bool _Inside(const _Elem *_Ptr)
		{	
		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
			|| this->_Myptr() + this->_Mysize() <= _Ptr)
			return (false);	
		else
			return (true);
		}

	void _Tidy(bool _Built = false,
		size_type _Newsize = 0)
		{	
		if (!_Built)
			;
		else if (this->_BUF_SIZE <= this->_Myres())
			{	
			pointer _Ptr = this->_Bx()._Ptr;
			this->_Getal().destroy(::std:: addressof(this->_Bx()._Ptr));
			if (0 < _Newsize)
				_Traits::copy(this->_Bx()._Buf,
					_Unfancy(_Ptr), _Newsize);
			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);
			}
		this->_Myres() = this->_BUF_SIZE - 1;
		_Eos(_Newsize);
		}

	[[noreturn]] void _Xlen() const
		{	
		_Xlength_error("string too long");
		}

	void _Check_offset(const size_type _Off) const
		{	
		if (this->_Mysize() < _Off)
			_Xran();
		}

	void _Check_offset_exclusive(const size_type _Off) const
		{	
		if (this->_Mysize() <= _Off)
			_Xran();
		}

	[[noreturn]] void _Xran() const
		{	
		_Xout_of_range("invalid string position");
		}
	};

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	 const typename basic_string<_Elem, _Traits, _Alloc>::size_type
		basic_string<_Elem, _Traits, _Alloc>::npos =
			(typename basic_string<_Elem, _Traits, _Alloc>::size_type)(-1);

		

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>& _Right)
			noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Traits::length(_Left) + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(1 + _Right.size());
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + _Traits::length(_Right));
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem _Right)
	{	
	basic_string<_Elem, _Traits, _Alloc> _Ans;
	_Ans.reserve(_Left.size() + 1);
	_Ans += _Left;
	_Ans += _Right;
	return (_Ans);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	if (_Right.size() <= _Left.capacity() - _Left.size()
		|| _Right.capacity() - _Right.size() < _Left.size())
		return (::std:: move(_Left.append(_Right)));
	else
		return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem *_Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	return (::std:: move(_Right.insert(0, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		const _Elem _Left,
		basic_string<_Elem, _Traits, _Alloc>&& _Right)
	{	
	typedef typename basic_string<_Elem, _Traits, _Alloc>::size_type
		size_type;
	return (::std:: move(_Right.insert((size_type)0, (size_type)1, _Left)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem *_Right)
	{	
	return (::std:: move(_Left.append(_Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_string<_Elem, _Traits, _Alloc> operator+(
		basic_string<_Elem, _Traits, _Alloc>&& _Left,
		const _Elem _Right)
	{	
	return (::std:: move(_Left.append(1, _Right)));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator==(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) == 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const _Elem *_Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator!=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right.compare(_Left) > 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Left.compare(_Right) < 0);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (_Right < _Left);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator<=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const _Elem * _Left,
		const basic_string<_Elem, _Traits, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	bool operator>=(
		const basic_string<_Elem, _Traits, _Alloc>& _Left,
		const _Elem *_Right)
	{	
	return (!(_Left < _Right));
	}

typedef basic_string<char, char_traits<char>, allocator<char> >
	string;
typedef basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t> >
	wstring;

	
template<class _Elem,
	class _Traits,
	class _Alloc>
	struct hash<basic_string<_Elem, _Traits, _Alloc> >
	{	
	typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (_Hash_seq((const unsigned char *)_Keyval.c_str(),
			_Keyval.size() * sizeof (_Elem)));
		}
	};

typedef basic_string<char16_t, char_traits<char16_t>, allocator<char16_t> >
	u16string;
typedef basic_string<char32_t, char_traits<char32_t>, allocator<char32_t> >
	u32string;
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2664 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"
#line 2665 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xstring"






#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
		
class logic_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit logic_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit logic_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class domain_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit domain_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit domain_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 68 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class invalid_argument
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit invalid_argument(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit invalid_argument(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class length_error
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit length_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit length_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 124 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class out_of_range
	: public logic_error
	{	
public:
	typedef logic_error _Mybase;

	explicit out_of_range(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit out_of_range(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 152 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class runtime_error
	: public ::std:: exception
	{	
public:
	typedef ::std:: exception _Mybase;

	explicit runtime_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit runtime_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 180 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class overflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit overflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit overflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 208 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class underflow_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit underflow_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit underflow_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 236 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};

		
class range_error
	: public runtime_error
	{	
public:
	typedef runtime_error _Mybase;

	explicit range_error(const string& _Message)
		: _Mybase(_Message.c_str())
		{	
		}

	explicit range_error(const char *_Message)
		: _Mybase(_Message)
		{	
		}

 

 





#line 264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
	};
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"
#line 271 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdexcept"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"














#pragma once







#pragma pack(push,8)
#pragma warning(push,3)


#pragma warning(disable: 4275)

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"







#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"


#pragma pack(push, 8)






#line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
    struct __type_info_node;
#line 23 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"




    extern __type_info_node __type_info_root_node;
#line 29 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"



__pragma(pack(push, 8)) extern "C" {


#pragma warning(push)
#pragma warning(disable: 4510 4512 4610) 
struct __std_type_info_data
{
    char const* _UndecoratedName;
    char const  _DecoratedName[1];
};
#pragma warning(pop)

__declspec(dllimport) int __cdecl __std_type_info_compare(
      __std_type_info_data const* _Lhs,
      __std_type_info_data const* _Rhs
    );

__declspec(dllimport) size_t __cdecl __std_type_info_hash(
      __std_type_info_data const* _Data
    );

__declspec(dllimport) char const* __cdecl __std_type_info_name(
      __std_type_info_data* _Data,
      __type_info_node*     _RootNode
    );

} __pragma(pack(pop))



class type_info
{
public:

    type_info(type_info const&) = delete;
    type_info& operator=(type_info const&) = delete;

    size_t hash_code() const throw()
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(type_info const& _Other) const throw()
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    char const* name() const throw()
    {
        


        return __std_type_info_name(&_Data, &__type_info_root_node);
        #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
    }

    char const* raw_name() const throw()
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() throw();

private:

    mutable __std_type_info_data _Data;
};

namespace std {
	using ::type_info;
}



namespace std {

class bad_cast
    : public exception
{
public:

    bad_cast() throw()
        : exception("bad cast", 1)
    {
    }

    static bad_cast __construct_from_string_literal(char const* const _Message) throw()
    {
        return bad_cast(_Message, 1);
    }

private:

    bad_cast(char const* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class bad_typeid
    : public exception
{
public:

    bad_typeid() throw()
        : exception("bad typeid", 1)
    {
    }

    static bad_typeid __construct_from_string_literal(char const* const _Message) throw()
    {
        return bad_typeid(_Message, 1);
    }

private:

    friend class __non_rtti_object;

    bad_typeid(char const* const _Message, int) throw()
        : exception(_Message, 1)
    {
    }
};

class __non_rtti_object
    : public bad_typeid
{
public:

    static __non_rtti_object __construct_from_string_literal(char const* const _Message) throw()
    {
        return __non_rtti_object(_Message, 1);
    }

private:

    __non_rtti_object(char const* const _Message, int) throw()
        : bad_typeid(_Message, 1)
    {
    }
};

} 

#line 187 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
#line 188 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime_typeinfo.h"
#pragma pack(pop)
#line 30 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"

 























































#line 88 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"


#pragma pack(pop)
#pragma warning(pop)
#line 93 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"
#line 94 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\typeinfo"







#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

#pragma once



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"







#pragma once





__pragma(pack(push, 8)) extern "C" {









  __declspec(dllimport) int __cdecl _isctype(  int _C,   int _Type);
  __declspec(dllimport) int __cdecl _isctype_l(  int _C,   int _Type,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalpha(  int _C);
  __declspec(dllimport) int __cdecl _isalpha_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isupper(  int _C);
  __declspec(dllimport) int __cdecl _isupper_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl islower(  int _C);
  __declspec(dllimport) int __cdecl _islower_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isdigit(  int _C);

  __declspec(dllimport) int __cdecl _isdigit_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isxdigit(  int _C);
  __declspec(dllimport) int __cdecl _isxdigit_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl isspace(  int _C);

  __declspec(dllimport) int __cdecl _isspace_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl ispunct(  int _C);
  __declspec(dllimport) int __cdecl _ispunct_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isblank(  int _C);
  __declspec(dllimport) int __cdecl _isblank_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl isalnum(  int _C);
  __declspec(dllimport) int __cdecl _isalnum_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isprint(  int _C);
  __declspec(dllimport) int __cdecl _isprint_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl isgraph(  int _C);
  __declspec(dllimport) int __cdecl _isgraph_l(  int _C,   _locale_t _Locale);
  __declspec(dllimport) int __cdecl iscntrl(  int _C);
  __declspec(dllimport) int __cdecl _iscntrl_l(  int _C,   _locale_t _Locale);


   __declspec(dllimport) int __cdecl toupper(  int _C);


   __declspec(dllimport) int __cdecl tolower(  int _C);

   __declspec(dllimport) int __cdecl _tolower(  int _C);
  __declspec(dllimport) int __cdecl _tolower_l(  int _C,   _locale_t _Locale);
   __declspec(dllimport) int __cdecl _toupper(  int _C);
  __declspec(dllimport) int __cdecl _toupper_l(  int _C,   _locale_t _Locale);

  __declspec(dllimport) int __cdecl __isascii(  int _C);
  __declspec(dllimport) int __cdecl __toascii(  int _C);
  __declspec(dllimport) int __cdecl __iscsymf(  int _C);
  __declspec(dllimport) int __cdecl __iscsym(  int _C);









 
    
    
    






















    
    
    
        __declspec(dllimport) int __cdecl _chvalidator(  int _Ch,   int _Mask);
        
    

#line 115 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"



    
    
    
    
    
    
    
    



    












#line 143 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    
    __declspec(dllimport) int __cdecl _chvalidator_l(  _locale_t,   int _Ch,   int _Mask);
    #line 153 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"

    __inline int __cdecl _chvalidchk_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        
        return _chvalidator_l(_Locale, _C, _Mask);
        






#line 170 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"
    }

    
    

    __inline int __cdecl _ischartype_l(
              int       const _C,
              int       const _Mask,
          _locale_t const _Locale
        )
    {
        if (_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }

    
    
    
    
    
    
    
    
    
    
    
    

    
    

    
    


    
    
    
    
    

    
    
    
    

#line 221 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"



    
    
    
    
    
#line 230 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"



#line 234 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\ctype.h"
} __pragma(pack(pop))
#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\locale.h"







#pragma once




__pragma(pack(push, 8)) extern "C" {















struct lconv
{
    char*    decimal_point;
    char*    thousands_sep;
    char*    grouping;
    char*    int_curr_symbol;
    char*    currency_symbol;
    char*    mon_decimal_point;
    char*    mon_thousands_sep;
    char*    mon_grouping;
    char*    positive_sign;
    char*    negative_sign;
    char     int_frac_digits;
    char     frac_digits;
    char     p_cs_precedes;
    char     p_sep_by_space;
    char     n_cs_precedes;
    char     n_sep_by_space;
    char     p_sign_posn;
    char     n_sign_posn;
    wchar_t* _W_decimal_point;
    wchar_t* _W_thousands_sep;
    wchar_t* _W_int_curr_symbol;
    wchar_t* _W_currency_symbol;
    wchar_t* _W_mon_decimal_point;
    wchar_t* _W_mon_thousands_sep;
    wchar_t* _W_positive_sign;
    wchar_t* _W_negative_sign;
};





















__declspec(dllimport) void __cdecl _lock_locales(void);
__declspec(dllimport) void __cdecl _unlock_locales(void);


__declspec(dllimport) int __cdecl _configthreadlocale(
      int _Flag
    );


__declspec(dllimport) char* __cdecl setlocale(
            int         _Category,
      char const* _Locale
    );


__declspec(dllimport) struct lconv* __cdecl localeconv(void);


__declspec(dllimport) _locale_t __cdecl _get_current_locale(void);


__declspec(dllimport) _locale_t __cdecl _create_locale(
        int         _Category,
      char const* _Locale
    );

__declspec(dllimport) void __cdecl _free_locale(
      _locale_t _Locale
    );



__declspec(dllimport) wchar_t* __cdecl _wsetlocale(
            int            _Category,
      wchar_t const* _Locale
    );


__declspec(dllimport) _locale_t __cdecl _wcreate_locale(
        int            _Category,
      wchar_t const* _Locale
    );



__declspec(dllimport) wchar_t**    __cdecl ___lc_locale_name_func(void);
__declspec(dllimport) unsigned int __cdecl ___lc_codepage_func   (void);
__declspec(dllimport) unsigned int __cdecl ___lc_collate_cp_func (void);



} __pragma(pack(pop))
#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


 
  
extern "C" {
  #line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
 #line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

		












		










 
 
 
 
 
 
 
 

typedef struct _Collvec
	{	
	unsigned int _Page;		
	wchar_t *_LocaleName;
	} _Collvec;

typedef struct _Ctypevec
	{	
	unsigned int _Page;		
	const short *_Table;
	int _Delfl;
	wchar_t *_LocaleName;
	} _Ctypevec;

typedef struct _Cvtvec
	{	
	unsigned int _Page;		
	unsigned int _Mbcurmax;
	int _Isclocale;	
	unsigned char _Isleadbyte[32];	
	} _Cvtvec;

		
__declspec(dllimport) _Collvec __cdecl _Getcoll(void);
__declspec(dllimport) _Ctypevec __cdecl _Getctype(void);
__declspec(dllimport) _Cvtvec __cdecl _Getcvt(void);
__declspec(dllimport) int __cdecl _Getdateorder(void);

 








__declspec(dllimport) int __cdecl _Mbrtowc(  wchar_t *, const char *, size_t,
	mbstate_t *, const _Cvtvec *);
 #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

__declspec(dllimport) float __cdecl _Stof(const char *,
	    char **, long);
__declspec(dllimport) double __cdecl _Stod(const char *,
	    char **, long);
__declspec(dllimport) long double __cdecl _Stold(const char *,
	    char **, long);

__declspec(dllimport) int __cdecl _Strcoll(const char *, const char *,
	const char *, const char *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Strxfrm(
	    char *_String1,
	  char *_End1, const char *, const char *, const _Collvec *);
__declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *);
__declspec(dllimport) int __cdecl _Wcrtomb(  char *, wchar_t, mbstate_t *,
	const _Cvtvec *);
__declspec(dllimport) int __cdecl _Wcscoll(const wchar_t *, const wchar_t *,
	const wchar_t *, const wchar_t *, const _Collvec *);
__declspec(dllimport) size_t __cdecl _Wcsxfrm(
	    wchar_t *_String1,
	  wchar_t *_End1, const wchar_t *, const wchar_t *, const _Collvec *);

__declspec(dllimport) short __cdecl _Getwctype(wchar_t, const _Ctypevec *);
__declspec(dllimport) const wchar_t *__cdecl _Getwctypes(const wchar_t *,
	const wchar_t *, short *, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec *);
__declspec(dllimport) wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec *);

 
  
}
  #line 129 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
 #line 130 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"


extern "C" {
 
 
__declspec(dllimport) char *__cdecl _Getdays(void);

 
 
__declspec(dllimport) char *__cdecl _Getmonths(void);

__declspec(dllimport) void *__cdecl _Gettnames(void);

 
__declspec(dllimport) size_t __cdecl _Strftime(  char *,
	  size_t _Maxsize,   const char *,   const struct tm *,
	  void *);

 
 
__declspec(dllimport) wchar_t *__cdecl _W_Getdays(void);

 
 
__declspec(dllimport) wchar_t *__cdecl _W_Getmonths(void);

__declspec(dllimport) void *__cdecl _W_Gettnames(void);

 
__declspec(dllimport) size_t __cdecl _Wcsftime(  wchar_t *,
	  size_t _Maxsize,   const wchar_t *,   const struct tm *,
	  void *);
}

 







__declspec(dllimport) _locale_t __cdecl _GetLocaleForCP(unsigned int);
 #line 174 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 179 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"
#line 180 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo.h"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

namespace std {
		
class __declspec(dllimport) _Timevec
	{	
public:
	 _Timevec(void *_Ptr = 0)
		: _Timeptr(_Ptr)
		{	
		}

	 _Timevec(const _Timevec& _Right)
		{	
		*this = _Right;
		}

	 ~_Timevec() noexcept
		{	
		free(_Timeptr);
		}

	_Timevec&  operator=(const _Timevec& _Right)
		{	
		_Timeptr = _Right._Timeptr;
		((_Timevec *)&_Right)->_Timeptr = 0;
		return (*this);
		}

	void * _Getptr() const
		{	
		return (_Timeptr);
		}

private:
	void *_Timeptr;	
	};

		
class __declspec(dllimport) _Locinfo
	{	
public:
	typedef ::_Collvec _Collvec;
	typedef ::_Ctypevec _Ctypevec;
	typedef ::_Cvtvec _Cvtvec;
	typedef ::std:: _Timevec _Timevec;

	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, const char *);
	static  void __cdecl _Locinfo_ctor(
		_Locinfo *, int, const char *);
	static  void __cdecl _Locinfo_dtor(
		_Locinfo *);
	static  _Locinfo& __cdecl _Locinfo_Addcats(
		_Locinfo *, int, const char *);

	 _Locinfo(const char *_Pch = "C")
 
		: _Lock(0)
 #line 75 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Pch);
		}

	 _Locinfo(int _Cat, const char *_Pch)
 
		: _Lock(0)
 #line 86 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		_Locinfo_ctor(this, _Cat, _Pch);
		}

	 ~_Locinfo() noexcept
		{	
		_Locinfo_dtor(this);
		}

	_Locinfo&  _Addcats(int _Cat, const char *_Pch)
		{	
		if (_Pch == 0)
			throw runtime_error("bad locale name");
		return (_Locinfo_Addcats(this, _Cat, _Pch));
		}

	const char * _Getname() const
		{	
		return (_Newlocname._C_str());
		}

	_Collvec  _Getcoll() const
		{	
		return (::_Getcoll());
		}

	_Ctypevec  _Getctype() const
		{	
		return (::_Getctype());
		}

	_Cvtvec  _Getcvt() const
		{	
		return (::_Getcvt());
		}

	const lconv * _Getlconv() const
		{	
		return (localeconv());
		}

	_Timevec  _Gettnames() const
		{	
		return (_Timevec(::_Gettnames()));
		}

	const char * _Getdays() const
		{	
		const char *_Ptr = ::_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Days = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Days._Empty() ? _Days._C_str()
			: ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				":Thu:Thursday:Fri:Friday:Sat:Saturday");
		}

	const char * _Getmonths() const
		{	
		const char *_Ptr = ::_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_Months = _Ptr;
			free((void *)_Ptr);
			}
		return (!_Months._Empty() ? _Months._C_str()
			: ":Jan:January:Feb:February:Mar:March"
				":Apr:April:May:May:Jun:June"
				":Jul:July:Aug:August:Sep:September"
				":Oct:October:Nov:November:Dec:December");
		}

	const char * _Getfalse() const
		{	
		return ("false");
		}

	const char * _Gettrue() const
		{	
		return ("true");
		}

	int  _Getdateorder() const
		{	
		return (::_Getdateorder());
		}

	_Timevec  _W_Gettnames() const
		{	
		return (_Timevec(::_W_Gettnames()));
		}

	const unsigned short * _W_Getdays() const
		{	
		const wchar_t *_Ptr = ::_W_Getdays();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Days = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Days._Empty()
			? _W_Days._C_str()
			: L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
				L":Thu:Thursday:Fri:Friday:Sat:Saturday"));
		}

	const unsigned short * _W_Getmonths() const
		{	
		const wchar_t *_Ptr = ::_W_Getmonths();

		if (_Ptr != 0)
			{	
			((_Locinfo *)this)->_W_Months = _Ptr;
			free((void *)_Ptr);
			}
		return ((const unsigned short *)(!_W_Months._Empty()
			? _W_Months._C_str()
			: L":Jan:January:Feb:February:Mar:March"
				L":Apr:April:May:May:Jun:June"
				L":Jul:July:Aug:August:Sep:September"
				L":Oct:October:Nov:November:Dec:December"));
		}

	_Locinfo(const _Locinfo&) = delete;
	_Locinfo& operator=(const _Locinfo&) = delete;

private:
 



	_Lockit _Lock;	
 #line 227 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"

	_Yarn<char> _Days;	
	_Yarn<char> _Months;	
	_Yarn<wchar_t> _W_Days;	
	_Yarn<wchar_t> _W_Months;	
	_Yarn<char> _Oldlocname;	
	_Yarn<char> _Newlocname;	
	};

		
template<class _Elem> inline
	int __cdecl _LStrcoll(const _Elem *_First1, const _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
		if (*_First1 < *_First2)
			return (-1);	
		else if (*_First2 < *_First1)
			return (+1);	
	return (_First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0);
	}

template<> inline
	int __cdecl _LStrcoll(const char *_First1, const char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strcoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	int __cdecl _LStrcoll(const wchar_t *_First1, const wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcscoll(_First1, _Last1, _First2, _Last2, _Vector));
	}

		
template<class _Elem> inline
	size_t __cdecl _LStrxfrm(_Elem *_First1, _Elem *_Last1,
		const _Elem *_First2, const _Elem *_Last2,
			const _Locinfo::_Collvec *)
	{	
	size_t _Count = _Last2 - _First2;
	if (_Count <= (size_t)(_Last1 - _First1))
		::memcpy_s((_First1), ((_Last1 - _First1) * sizeof (_Elem)), (_First2), (_Count * sizeof (_Elem)));
#line 276 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"
	return (_Count);
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  char *_First1,   char *_Last1,
		const char *_First2, const char *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Strxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}

template<> inline
	size_t __cdecl _LStrxfrm( 
		  wchar_t *_First1,   wchar_t *_Last1,
		const wchar_t *_First2, const wchar_t *_Last2,
			const _Locinfo::_Collvec *_Vector)
	{	
	return (_Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 301 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"
#line 302 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocinfo"





#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 






namespace std {
	
class __declspec(dllimport) _Facet_base
	{	
public:
	virtual  ~_Facet_base() noexcept
		{	
		}

	
	virtual void  _Incref() = 0;

	
	virtual _Facet_base *  _Decref() = 0;
	};

 


#line 38 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"
void __cdecl _Facet_Register(_Facet_base *);
 #line 40 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"
#line 46 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xfacet"

 



#line 13 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412 28197)

namespace std {
		
template<class _Dummy>
	class _Locbase
	{	
public:
	 static const int collate = ((1 << (1)) >> 1);
	 static const int ctype = ((1 << (2)) >> 1);
	 static const int monetary = ((1 << (3)) >> 1);
	 static const int numeric = ((1 << (4)) >> 1);
	 static const int time = ((1 << (5)) >> 1);
	 static const int messages = ((1 << (6)) >> 1);
	 static const int all = (((1 << ((6 + 1))) >> 1) - 1);
	 static const int none = 0;
	};

template<class _Dummy>
	const int _Locbase<_Dummy>::collate;
template<class _Dummy>
	const int _Locbase<_Dummy>::ctype;
template<class _Dummy>
	const int _Locbase<_Dummy>::monetary;
template<class _Dummy>
	const int _Locbase<_Dummy>::numeric;
template<class _Dummy>
	const int _Locbase<_Dummy>::time;
template<class _Dummy>
	const int _Locbase<_Dummy>::messages;
template<class _Dummy>
	const int _Locbase<_Dummy>::all;
template<class _Dummy>
	const int _Locbase<_Dummy>::none;

		
class locale;
template<class _Facet>
	const _Facet& __cdecl use_facet(const locale&);
template<class _Elem>
	class collate;

struct __declspec(dllimport) _Crt_new_delete
	{	
  
	void * __cdecl operator new(size_t _Size)
		{	
		void * _Ptr = operator new(_Size, nothrow);
		if (!_Ptr)
			_Xbad_alloc();
		return (_Ptr);
		}

	void * __cdecl operator new(size_t _Size, const nothrow_t&) noexcept
		{	
		return (_malloc_dbg(_Size > 0 ? _Size : 1, 2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 74));
		}

	void __cdecl operator delete(void * _Ptr) noexcept
		{	
		:: free(_Ptr);
		}

	void __cdecl operator delete(void * _Ptr, const nothrow_t&) noexcept
		{	
		operator delete(_Ptr);
		}

	void * __cdecl operator new(size_t, void *_Ptr) noexcept
		{	
		return (_Ptr);
		}

	void __cdecl operator delete(void *, void *) noexcept
		{	
		}
  #line 96 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	};

class locale
	: public _Locbase<int>, public _Crt_new_delete
	{	
public:
	typedef int category;

			
	class __declspec(dllimport) id
		{	
	public:
		 id(size_t _Val = 0)
			: _Id(_Val)
			{	
			}

		 operator size_t()
			{	
			if (_Id == 0)
				{	
				{ ::std:: _Lockit _Lock(0);
					if (_Id == 0)
						_Id = ++_Id_cnt;
				}
				}
			return (_Id);
			}

	private:
		size_t _Id;	

		 static int _Id_cnt;

	public:
		 id(const id&) = delete;
		id&  operator=(const id&) = delete;
		};

	class _Locimp;

			
	class __declspec(dllimport) facet
		: public _Facet_base, public _Crt_new_delete
		{	
	public:
		static size_t __cdecl _Getcat(const facet ** = 0,
			const locale * = 0)
			{	
			return ((size_t)(-1));
			}

		virtual void  _Incref()
			{	
			_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Myrefs));
			}

		virtual _Facet_base * _Decref()
			{	
			if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Myrefs)) == 0)
				return (this);
			else
				return (0);
			}

	private:
		_Atomic_counter_t _Myrefs;	

	protected:
		explicit  facet(size_t _Initrefs = 0)
			{	
			_Init_atomic_counter(_Myrefs, (_Atomic_integral_t)_Initrefs);
			}

		virtual  ~facet() noexcept
			{	
			}

	public:
		 facet(const facet&) = delete;
		facet&  operator=(const facet&) = delete;
		};

			
 #pragma warning(push)
 #pragma warning(disable: 4275)

	class __declspec(dllimport) _Locimp
		: public facet
		{	
	protected:
		 ~_Locimp() noexcept
		{	
		_Locimp_dtor(this);
		}

	private:
		static  _Locimp *__cdecl
			_New_Locimp(bool _Transparent = false);
		static  _Locimp *__cdecl
			_New_Locimp(const _Locimp& _Right);

		static  void __cdecl
			_Locimp_dtor(_Locimp *);
		static  void __cdecl
			_Locimp_Addfac(_Locimp *, facet *, size_t);	
		static void __cdecl
			_Locimp_ctor(_Locimp *, const _Locimp&);

		friend class locale;

		 _Locimp(bool _Transparent)
			: locale::facet(1), _Facetvec(0), _Facetcount(0),
				_Catmask(none), _Xparent(_Transparent),
					_Name("*")
			{	
			}

		 _Locimp(const _Locimp& _Right)
			: locale::facet(1), _Facetvec(0), _Facetcount(_Right._Facetcount),
				_Catmask(_Right._Catmask), _Xparent(_Right._Xparent),
					_Name(_Right._Name.c_str())
			{	
			_Locimp_ctor(this, _Right);
			}

		void  _Addfac(facet *_Pfacet, size_t _Id)
			{	
			_Locimp_Addfac(this, _Pfacet, _Id);
			}

		static _Locimp *__cdecl _Makeloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		static void __cdecl _Makewloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

 
		static void __cdecl _Makeushloc(const _Locinfo&,
			category, _Locimp *, const locale *);	
 #line 237 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		static void __cdecl _Makexloc(const _Locinfo&,
			category, _Locimp *, const locale *);	

		facet **_Facetvec;	
		size_t _Facetcount;	
		category _Catmask;	
		bool _Xparent;	
		_Yarn<char> _Name;	

		 static _Locimp *_Clocptr;

public:
		_Locimp&  operator=(const _Locimp&) = delete;
		};

 #pragma warning(pop)

	template<class _Elem,
		class _Traits,
		class _Alloc>
		bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left,
			const basic_string<_Elem, _Traits, _Alloc>& _Right) const
		{	
		const ::std:: collate<_Elem>& _Coll_fac =
			use_facet< ::std:: collate<_Elem> >(*this);

		return (_Coll_fac.compare(_Left.c_str(), _Left.c_str() + _Left.size(),
			_Right.c_str(), _Right.c_str() + _Right.size()) < 0);
		}

	template<class _Facet>
		locale combine(const locale& _Loc) const
		{	
		_Facet *_Facptr;

		try {
			_Facptr = (_Facet *)&use_facet<_Facet>(_Loc);
		} catch (...) {
			_Xruntime_error("locale::combine facet missing");
		}

		_Locimp *_Newimp = _Locimp::_New_Locimp(*_Ptr);
		_Newimp->_Addfac(_Facptr, _Facet::id);
		_Newimp->_Catmask = none;
		_Newimp->_Name = "*";
		return (locale(_Newimp));
		}

	template<class _Facet>
		locale(const locale& _Loc, const _Facet *_Facptr)
			: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Facptr != 0)
			{	
			_Ptr->_Addfac((_Facet *)_Facptr, _Facet::id);
			_Ptr->_Catmask = none;
			_Ptr->_Name = "*";
			}
		}

	locale(_Uninitialized)
		{	
		}

 



















#line 323 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	locale(const locale& _Right) noexcept
		: _Ptr(_Right._Ptr)
		{	
		_Ptr->_Incref();
		}

	locale() noexcept
		: _Ptr(_Init(true))
		{	
		}

 
	locale(const locale& _Loc, const locale& _Other,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		if (_Cat != none)
			{	
			try {
				{ _Locinfo _Lobj;
					_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
					_Lobj._Addcats(_Loc._Ptr->_Catmask,
						_Loc.name().c_str());
					_Lobj._Addcats(_Other._Ptr->_Catmask,
						_Other.name().c_str());
					_Ptr->_Catmask = _Loc._Ptr->_Catmask
						| _Other._Ptr->_Catmask;
					_Ptr->_Name = _Lobj._Getname();
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}
		}

private:
	void _Construct(const string &_Str,
		category _Cat)
		{	
		bool _Bad = false;
		_Init();
		if (_Cat != none)
			{	
			try {
				{ _Locinfo _Lobj(_Cat, _Str.c_str());
					if (_Badname(_Lobj))
						_Bad = true;
					else
						{	
						_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0);
						_Ptr->_Catmask = _Cat;
						_Ptr->_Name = _Str.c_str();
						}
				}
			} catch (...) {
			delete _Ptr->_Decref();
			throw;
			}
			}

		if (_Bad)
			{	
			delete _Ptr->_Decref();
			_Xruntime_error("bad locale name");
			}
		}

public:
	explicit locale(const char *_Locname,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	locale(const locale& _Loc, const char *_Locname,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		
		
		if (_Locname == 0)
			_Xruntime_error("bad locale name");
		_Construct(_Locname, _Cat);
		}

	explicit locale(const string& _Str,
		category _Cat = all)
		: _Ptr(_Locimp::_New_Locimp())
		{	
		_Construct(_Str, _Cat);
		}

	locale(const locale& _Loc, const string& _Str,
		category _Cat)
		: _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
		{	
		_Construct(_Str, _Cat);
		}
 #line 428 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

	~locale() noexcept
		{	
		if (_Ptr != 0)
			delete _Ptr->_Decref();
		}

	locale& operator=(const locale& _Right) noexcept
		{	
		if (_Ptr != _Right._Ptr)
			{	
			delete _Ptr->_Decref();
			_Ptr = _Right._Ptr;
			_Ptr->_Incref();
			}
		return (*this);
		}
 #line 446 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

	string name() const
		{	
		return (_Ptr == 0 ? string() : _Ptr->_Name.c_str());
		}

	const char *c_str() const
		{	
		return (_Ptr == 0 ? "" : _Ptr->_Name.c_str());
		}

	const facet *_Getfacet(size_t _Id) const
		{	
		const facet *_Facptr = _Id < _Ptr->_Facetcount
			? _Ptr->_Facetvec[_Id] : 0;	
		if (_Facptr != 0 || !_Ptr->_Xparent)
			return (_Facptr);	
		else
			{	
			locale::_Locimp *_Ptr0 = _Getgloballocale();
			return (_Id < _Ptr0->_Facetcount
				? _Ptr0->_Facetvec[_Id]	
				: 0);	
			}
		}

	bool operator==(const locale& _Loc) const
		{	
		return (_Ptr == _Loc._Ptr
			|| (name().compare("*") != 0
				&& name().compare(_Loc.name()) == 0));
		}

	bool operator!=(const locale& _Right) const
		{	
		return (!(*this == _Right));
		}

	static __declspec(dllimport) const locale& __cdecl
		classic();	

	static __declspec(dllimport) locale __cdecl
		global(const locale&);	

	static __declspec(dllimport) locale __cdecl
		empty();	

private:
	locale(_Locimp *_Ptrimp)
		: _Ptr(_Ptrimp)
		{	
		}

	static __declspec(dllimport) _Locimp *__cdecl
		_Init(bool _Do_incref = false);	
	static __declspec(dllimport) _Locimp *__cdecl
		_Getgloballocale();
	static __declspec(dllimport) void __cdecl
		_Setgloballocale(void *);

	bool _Badname(const _Locinfo& _Lobj)
		{	
		return (:: strcmp(_Lobj._Getname(), "*") == 0);
		}

	_Locimp *_Ptr;	
	};

		

 
















#line 534 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

template<class _Facet>
	struct _Facetptr
	{	
	 static const locale::facet *_Psave;
	};

template<class _Facet>
	 const locale::facet *_Facetptr<_Facet>::
		_Psave = 0;

  

  


template<class _Facet> inline
	const _Facet& __cdecl use_facet(const locale& _Loc)

	{	
 



#line 559 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	{ ::std:: _Lockit _Lock(0);	
		const locale::facet *_Psave =
			_Facetptr<_Facet>::_Psave;	

		size_t _Id = _Facet::id;
		const locale::facet *_Pf = _Loc._Getfacet(_Id);

		if (_Pf != 0)
			;	
		else if (_Psave != 0)
			_Pf = _Psave;	
		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

 

			throw ::std:: bad_cast();	

 

#line 579 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		else
			{	
			_Pf = _Psave;
			_Facetptr<_Facet>::_Psave = _Psave;

			locale::facet *_Pfmod = (_Facet *)_Psave;
			_Pfmod->_Incref();

 


#line 592 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
			_Facet_Register(_Pfmod);
 #line 594 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
			}

		return ((const _Facet&)(*_Pf));	
	}
 #line 599 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
	}	

		
template<class _Elem,
	class _InIt> inline
	int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields,
		const _Elem *_Ptr)
	{	
	for (size_t _Off = 0; _Ptr[_Off] != (_Elem)0; ++_Off)
		if (_Ptr[_Off] == _Ptr[0])
			++_Numfields;	
	string _Str(_Numfields, '\0');	

	int _Ans = -2;	
	for (size_t _Column = 1; ; ++_Column, (void)++_First, _Ans = -1)
		{	
		bool _Prefix = false;	
		size_t _Off = 0;	
		size_t _Field = 0;	

		for (; _Field < _Numfields; ++_Field)
			{	
			for (; _Ptr[_Off] != (_Elem)0 && _Ptr[_Off] != _Ptr[0]; ++_Off)
				;	

			if (_Str[_Field] != '\0')
				_Off += _Str[_Field];	
			else if (_Ptr[_Off += _Column] == _Ptr[0]
				|| _Ptr[_Off] == (_Elem)0)
				{	
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
				_Ans = (int)_Field;	
				}
			else if (_First == _Last || _Ptr[_Off] != *_First)
				_Str[_Field] = (char)(_Column < 127
					? _Column : 127);	
			else
				_Prefix = true;	
			}

		if (!_Prefix || _First == _Last)
			break;	
		}
	return (_Ans);	
	}

		



template<class _Elem> inline
	char __cdecl _Maklocbyte(_Elem _Char,
		const _Locinfo::_Cvtvec&)
	{	
	return ((char)(unsigned char)_Char);
	}

template<> inline
	char __cdecl _Maklocbyte(wchar_t _Char,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}

 
template<> inline
	char __cdecl _Maklocbyte(unsigned short _Char,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	char _Byte = '\0';
	mbstate_t _Mbst1 = {};
	_Wcrtomb(&_Byte, (wchar_t)_Char, &_Mbst1, &_Cvt);
	return (_Byte);
	}
 #line 678 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		



template<class _Elem> inline
	_Elem __cdecl _Maklocchr(char _Byte, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	return ((_Elem)(unsigned char)_Byte);
	}

template<> inline
	wchar_t __cdecl _Maklocchr(char _Byte, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	wchar_t _Wc = L'\0';
	mbstate_t _Mbst1 = {};
	_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}

 
template<> inline
	unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	unsigned short _Wc = (unsigned short)0;
	mbstate_t _Mbst1 = {};
	_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
	return (_Wc);
	}
 #line 711 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		



template<class _Elem> inline
	_Elem *__cdecl _Maklocstr(const char *_Ptr, _Elem *,
		const _Locinfo::_Cvtvec&)
	{	
	size_t _Count = :: strlen(_Ptr) + 1;

	_Elem *_Ptrdest = (_Elem *)_calloc_dbg(_Count, sizeof (_Elem),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 723);

	if (!_Ptrdest)
		_Xbad_alloc();

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (_Elem *_Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
		*_Ptrnext = (_Elem)(unsigned char)*_Ptr;
 #pragma warning(pop)

	return (_Ptrdest);
	}

template<> inline
	wchar_t *__cdecl _Maklocstr(const char *_Ptr, wchar_t *,
		const _Locinfo::_Cvtvec& _Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	wchar_t _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 756);

	if (!_Ptrdest)
		_Xbad_alloc();
	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};

 #pragma warning(push)
 #pragma warning(disable: 6011)	
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
 #pragma warning(pop)

	return (_Ptrdest);
	}

 
template<> inline
	unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *,
		const _Locinfo::_Cvtvec &_Cvt)
	{	
	size_t _Count, _Count1;
	size_t _Wchars;
	const char *_Ptr1;
	int _Bytes;
	unsigned short _Wc;
	mbstate_t _Mbst1 = {};

	_Count1 = :: strlen(_Ptr) + 1;
	for (_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count;
		_Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
		if ((_Bytes =
			_Mbrtowc((wchar_t *)&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
			break;
	++_Wchars;	

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Wchars, sizeof (wchar_t),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 796);

	if (!_Ptrdest)
		_Xbad_alloc();

	wchar_t *_Ptrnext = _Ptrdest;
	mbstate_t _Mbst2 = {};
	for (; 0 < _Wchars;
		_Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
		if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
			break;
	*_Ptrnext = L'\0';
	return ((unsigned short *)_Ptrdest);
	}
 #line 811 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

class __declspec(dllimport) codecvt_base
	: public locale::facet
	{	
public:
	enum
		{	
		ok, partial, error, noconv};
	typedef int result;

	 codecvt_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	bool  always_noconv() const noexcept
		{	
		return (do_always_noconv());
		}

	int  max_length() const noexcept
		{	
		return (do_max_length());
		}

	int  encoding() const noexcept
		{	
		return (do_encoding());
		}

	 ~codecvt_base() noexcept
		{	
		}

protected:
	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (1);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (1);	
		}
	};

 #pragma warning(pop)

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt
		: public codecvt_base
	{	
public:
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State, _First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;	

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Locinfo());
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (is_same<_Byte, _Elem>::value);
		}

	virtual result  do_in(_Statype&,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Elem)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_out(_Statype&,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Mid1 = _First1, _Mid2 = _First2;
		if (is_same<_Byte, _Elem>::value)
			return (noconv);	
		else
			{	
			for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++_Mid1, ++_Mid2)
				*_Mid2 = (_Byte)*_Mid1;
			return (ok);
			}
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *&_Mid2) const
		{	
		_Mid2 = _First2;
		return (ok);	
		}

	virtual int  do_length(_Statype&, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return ((int)(_Count < (size_t)(_Last1 - _First1)
			? _Count : _Last1 - _First1));	
		}
	};

		
template<class _Elem,
	class _Byte,
	class _Statype>
	 locale::id codecvt<_Elem, _Byte, _Statype>::id;

		
enum _Codecvt_mode {
	_Consume_header = 4,
	_Generate_header = 2
	};

		
template<>
	class __declspec(dllimport) codecvt<char16_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef codecvt<char16_t, char, _Mbstatet> _Mybase;
	typedef char16_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
		{	
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra, _Nskip;

			if (*_Pstate <= 1)
				;	
			else if (_By < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	
			else
				{	
				++_Mid1;
				*_Mid2++ = (_Elem)(*_Pstate | (_By & 0x3f));
				*_Pstate = 1;
				continue;
				}

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			_Nskip = _Nextra < 3 ? 0 : 1;	
			_First1 = _Mid1;	

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
				break;	
			else
				for (++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	
					else
						_Ch = _Ch << 6 | (_By & 0x3f);
			if (0 < _Nskip)
				_Ch <<= 6;	

			if ((_Maxcode < 0x10ffff ? _Maxcode : 0x10ffff) < _Ch)
				return (_Mybase::error);	
			else if (0xffff < _Ch)
				{	
				unsigned short _Ch0 =
					(unsigned short)(0xd800 | (_Ch >> 10) - 0x0040);

				*_Mid2++ = (_Elem)_Ch0;
				*_Pstate = (unsigned short)(0xdc00 | (_Ch & 0x03ff));
				continue;
				}

			if (_Nskip == 0)
				;
			else if (_Mid1 == _Last1)
				{	
				_Mid1 = _First1;
				break;
				}
			else if ((_By = (unsigned char)*_Mid1++) < 0x80 || 0xc0 <= _By)
				return (_Mybase::error);	
			else
				_Ch |= _By & 0x3f;	

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned long _Ch;
			unsigned short _Ch1 = (unsigned short)*_Mid1;
			bool _Save = false;

			if (1 < *_Pstate)
				{	
				if (_Ch1 < 0xdc00 || 0xe000 <= _Ch1)
					return (_Mybase::error);	
				_Ch = (*_Pstate << 10) | (_Ch1 - 0xdc00);
				}
			else if (0xd800 <= _Ch1 && _Ch1 < 0xdc00)
				{	
				_Ch = (_Ch1 - 0xd800 + 0x0040) << 10;
				_Save = true;	
				}
			else
				_Ch = _Ch1;	

			_Byte _By;
			int _Nextra;

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x10000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;

			int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

			if (_Last2 - _Mid2 < _Nput)
				break;	
			else if (*_Pstate != 0 || (_Mode & _Generate_header) == 0)
				;	
			else if (_Last2 - _Mid2 < 3 + _Nput)
				break;	
			else
				{	
				*_Mid2++ = (_Byte)(unsigned char)0xef;
				*_Mid2++ = (_Byte)(unsigned char)0xbb;
				*_Mid2++ = (_Byte)(unsigned char)0xbf;
				}

			++_Mid1;
			if (_Save || _Nextra < 3)
				{	
				*_Mid2++ = _By;
				--_Nput;
				}
			for (; 0 < _Nput; --_Nput)
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);

			*_Pstate = (unsigned short)(_Save ? _Ch >> 10 : 1);
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	
		unsigned short *_Pstate = (unsigned short *)&_State;
		_Mid2 = _First2;

		return (1 < *_Pstate
			? _Mybase::error : _Mybase::ok);	
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		size_t _Wchars = 0;
		_Statype _Mystate = _State;

		for (; _Wchars < _Count && _First1 != _Last1; )
			{	
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	
			case _Mybase::noconv:
				return ((int)(_Wchars + (_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	
				}
			}

		return ((int)_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return ((_Mode & _Consume_header) != 0 ? 9	
			: (_Mode & _Generate_header) != 0 ? 7	
			: 6);	
		}

	virtual int do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	unsigned long _Maxcode;	
	_Codecvt_mode _Mode;	
	};

		
template<>
	class __declspec(dllimport) codecvt<char32_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef codecvt<char32_t, char, _Mbstatet> _Mybase;
	typedef char32_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
		{	
		_Init(_Lobj);
		}

	 codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg,
		_Codecvt_mode _Mode_arg, size_t _Refs = 0)
		: codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			unsigned char _By = (unsigned char)*_Mid1;
			unsigned long _Ch;
			int _Nextra;

			if (_By < 0x80)
				_Ch = _By, _Nextra = 0;
			else if (_By < 0xc0)
				{	
				++_Mid1;
				return (_Mybase::error);
				}
			else if (_By < 0xe0)
				_Ch = _By & 0x1f, _Nextra = 1;
			else if (_By < 0xf0)
				_Ch = _By & 0x0f, _Nextra = 2;
			else if (_By < 0xf8)
				_Ch = _By & 0x07, _Nextra = 3;
			else
				_Ch = _By & 0x03, _Nextra = _By < 0xfc ? 4 : 5;

			if (_Nextra == 0)
				++_Mid1;
			else if (_Last1 - _Mid1 < _Nextra + 1)
				break;	
			else
				for (++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
					if ((_By = (unsigned char)*_Mid1) < 0x80 || 0xc0 <= _By)
						return (_Mybase::error);	
					else
						_Ch = _Ch << 6 | (_By & 0x3f);

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;

				if ((_Mode & _Consume_header) != 0 && _Ch == 0xfeff)
					{	
					result _Ans = do_in(_State, _Mid1, _Last1, _Mid1,
						_First2, _Last2, _Mid2);

					if (_Ans == _Mybase::partial)
						{	
						*_Pstate = 0;
						_Mid1 = _First1;
						}
					return (_Ans);
					}
				}

			if (_Maxcode < _Ch)
				return (_Mybase::error);	
			*_Mid2++ = (_Elem)_Ch;
			}

		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		char *_Pstate = (char *)&_State;
		_Mid1 = _First1;
		_Mid2 = _First2;

		for (; _Mid1 != _Last1 && _Mid2 != _Last2; )
			{	
			_Byte _By;
			int _Nextra;
			unsigned long _Ch = (unsigned long)*_Mid1;

			if (_Maxcode < _Ch)
				return (_Mybase::error);

			if (_Ch < 0x0080)
				_By = (_Byte)_Ch, _Nextra = 0;
			else if (_Ch < 0x0800)
				_By = (_Byte)(0xc0 | _Ch >> 6), _Nextra = 1;
			else if (_Ch < 0x00010000)
				_By = (_Byte)(0xe0 | _Ch >> 12), _Nextra = 2;
			else if (_Ch < 0x00200000)
				_By = (_Byte)(0xf0 | _Ch >> 18), _Nextra = 3;
			else if (_Ch < 0x04000000)
				_By = (_Byte)(0xf8 | _Ch >> 24), _Nextra = 4;
			else
				_By = (_Byte)(0xfc | (_Ch >> 30 & 0x03)), _Nextra = 5;

			if (*_Pstate == 0)
				{	
				*_Pstate = 1;
				if ((_Mode & _Generate_header) == 0)
					;
				else if (_Last2 - _Mid2 < 3 + 1 + _Nextra)
					return (_Mybase::partial);	
				else
					{	
					*_Mid2++ = (_Byte)(unsigned char)0xef;
					*_Mid2++ = (_Byte)(unsigned char)0xbb;
					*_Mid2++ = (_Byte)(unsigned char)0xbf;
					}
				}

			if (_Last2 - _Mid2 < 1 + _Nextra)
				break;	

			++_Mid1;
			for (*_Mid2++ = _By; 0 < _Nextra; )
				*_Mid2++ = (_Byte)((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
			}
		return (_First1 == _Mid1 ? _Mybase::partial : _Mybase::ok);
		}

	virtual result  do_unshift(_Statype&,
		_Byte *_First2, _Byte *, _Byte *& _Mid2) const
		{	
		_Mid2 = _First2;
		return (_Mybase::ok);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		int _Wchars = 0;
		_Statype _Mystate = _State;

		for (; (size_t)_Wchars < _Count && _First1 != _Last1; )
			{	
			const _Byte *_Mid1;
			_Elem *_Mid2;
			_Elem _Ch;

			switch (do_in(_Mystate, _First1, _Last1, _Mid1,
				&_Ch, &_Ch + 1, _Mid2))
				{	
			case _Mybase::noconv:
				return ((int)(_Wchars + (int)(_Last1 - _First1)));

			case _Mybase::ok:
				if (_Mid2 == &_Ch + 1)
					++_Wchars;	
				_First1 = _Mid1;
				break;

			default:
				return ((int)_Wchars);	
				}
			}

		return ((int)_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? 9 : 6);
		}

	virtual int  do_encoding() const noexcept
		{	
		return ((_Mode & (_Consume_header | _Generate_header)) != 0
			? -1 : 0);	
		}

private:
	unsigned long _Maxcode;	
	_Codecvt_mode _Mode;	
	};

		
template<>
	class __declspec(dllimport) codecvt<wchar_t, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef wchar_t _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1674);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1675);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1710);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1711);
		_Mid1 = _First1, _Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)5 <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					break;
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes;
					}
				}
		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1747);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1772);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (5);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};

 
		
template<>
	class __declspec(dllimport) codecvt<unsigned short, char, _Mbstatet>
	: public codecvt_base
	{	
public:
	typedef unsigned short _Elem;
	typedef char _Byte;
	typedef _Mbstatet _Statype;
	typedef _Elem intern_type;
	typedef _Byte extern_type;
	typedef _Statype state_type;

	result  in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
		_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		return (do_in(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_out(_State,
			_First1, _Last1, _Mid1, _First2, _Last2, _Mid2));
		}

	result  unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		return (do_unshift(_State,
			_First2, _Last2, _Mid2));
		}

	int  length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		return (do_length(_State, _First1, _Last1, _Count));
		}

	 static locale::id id;

	explicit  codecvt(size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
		: codecvt_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new codecvt<_Elem, _Byte, _Statype>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~codecvt() noexcept
		{	
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Cvt = _Lobj._Getcvt();
		}

	virtual result  do_in(_Statype& _State,
		const _Byte *_First1, const _Byte *_Last1, const _Byte *& _Mid1,
			_Elem *_First2, _Elem *_Last2, _Elem *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1908);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1909);
		_Mid1 = _First1, _Mid2 = _First2;
		result _Ans = _Mid1 == _Last1 ? ok : partial;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			switch (_Bytes = _Mbrtowc((wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1,
				&_State, &_Cvt))
			{	
			case -2:	
				_Mid1 = _Last1;
				return (_Ans);

			case -1:	
				return (error);

			case 0:	
				if (*_Mid2 == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Mid2;
				_Ans = ok;
			}
		return (_Ans);
		}

	virtual result  do_out(_Statype& _State,
		const _Elem *_First1, const _Elem *_Last1, const _Elem *& _Mid1,
			_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1944);
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1945);
		_Mid1 = _First1, _Mid2 = _First2;
		int _Bytes;

		while (_Mid1 != _Last1 && _Mid2 != _Last2)
			if ((int)5 <= _Last2 - _Mid2)
				if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else
					++_Mid1, _Mid2 += _Bytes;
			else
				{	
				_Byte _Buf[5];
				_Statype _Stsave = _State;

				if ((_Bytes = _Wcrtomb(_Buf, *_Mid1,
					&_State, &_Cvt)) < 0)
					return (error);	
				else if (_Last2 - _Mid2 < _Bytes)
					{	
					_State = _Stsave;
					break;
					}
				else
					{	
					:: memcpy(_Mid2, _Buf, _Bytes);
					++_Mid1, _Mid2 += _Bytes;
					}
				}
		return (_Mid1 == _Last1 ? ok : partial);
		}

	virtual result  do_unshift(_Statype& _State,
		_Byte *_First2, _Byte *_Last2, _Byte *& _Mid2) const
		{	
		_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 1981);
		_Mid2 = _First2;
		result _Ans = ok;
		int _Bytes;
		_Byte _Buf[5];
		_Statype _Stsave = _State;

		if ((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
			_Ans = error;	
		else if (_Last2 - _Mid2 < --_Bytes)
			{	
			_State = _Stsave;
			_Ans = partial;
			}
		else if (0 < _Bytes)
			{	
			:: memcpy(_Mid2, _Buf, _Bytes);
			_Mid2 += _Bytes;
			}
		return (_Ans);
		}

	virtual int  do_length(_Statype& _State, const _Byte *_First1,
		const _Byte *_Last1, size_t _Count) const
		{	
		_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2006);
		int _Wchars;
		const _Byte *_Mid1;
		_Statype _Mystate = _State;

		for (_Wchars = 0, _Mid1 = _First1;
			(size_t)_Wchars < _Count && _Mid1 != _Last1; )
			{	
			int _Bytes;
			_Elem _Ch;

			switch (_Bytes = _Mbrtowc((wchar_t *)&_Ch, _Mid1, _Last1 - _Mid1,
				&_Mystate, &_Cvt))
				{	
			case -2:	
				return (_Wchars);

			case -1:	
				return (_Wchars);

			case 0:	
				if (_Ch == (_Elem)0)
					_Bytes = (int):: strlen(_Mid1) + 1;
				

			default:	
				if (_Bytes == -3)
					_Bytes = 0;	
				_Mid1 += _Bytes;
				++_Wchars;
				}
			}
		return (_Wchars);
		}

	virtual bool  do_always_noconv() const noexcept
		{	
		return (false);
		}

	virtual int  do_max_length() const noexcept
		{	
		return (5);
		}

	virtual int  do_encoding() const noexcept
		{	
		return (0);	
		}

private:
	_Locinfo::_Cvtvec _Cvt;	
	};
 #line 2060 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		
template<class _Elem,
	class _Byte,
	class _Statype>
	class codecvt_byname
		: public codecvt<_Elem, _Byte, _Statype>
	{	
public:
	explicit  codecvt_byname(const char *_Locname, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  codecvt_byname(const string& _Str, size_t _Refs = 0)
		: codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~codecvt_byname() noexcept
		{	
		}
	};

		
 #pragma warning(push)
 #pragma warning(disable: 4275)

struct __declspec(dllimport) ctype_base
	: public locale::facet
	{	
	enum
		{	
		alnum = 0x04 | 0x02 | 0x01 | 0x100, alpha = 0x02 | 0x01 | 0x100,
		cntrl = 0x20, digit = 0x04, graph = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
		lower = 0x02, print = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
		punct = 0x10, space = 0x08 | 0x40 | 0x000, upper = 0x01,
		xdigit = 0x80, blank = 0x08 | 0x40 | 0x000 | 0x000};
	typedef short mask;	

	 ctype_base(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		}

	 ~ctype_base() noexcept
		{	
		}
	};

 #pragma warning(pop)

		
template<class _Elem>
	class ctype
		: public ctype_base
	{	
public:
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)narrow(_Ch)]
			& _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2235);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)narrow(*_First)];
		return (_First);
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2244);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2253);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Tolower(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2271);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Tolower(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		unsigned char _Byte = (unsigned char)narrow(_Ch, '\0');
		if (_Byte == '\0')
			return (_Ch);
		else
			return (widen((char)_Toupper(_Byte, &_Ctype)));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2293);
		for (; _First != _Last; ++_First)
			{	
			unsigned char _Byte = (unsigned char)narrow(*_First, '\0');
			if (_Byte != '\0')
				*_First = (widen((char)_Toupper(_Byte, &_Ctype)));
			}
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Maklocchr(_Byte, (_Elem *)0, _Cvt));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2311);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Maklocchr(*_First, (_Elem *)0, _Cvt);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Byte;
		if (_Ch == (_Elem)0)
			return ('\0');
		else if ((_Byte = _Maklocbyte((_Elem)_Ch, _Cvt)) == '\0')
			return (_Dflt);
		else
			return (_Byte);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2336);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

		
template<class _Elem>
	locale::id ctype<_Elem>::id;

		
template<>
	class __declspec(dllimport) ctype<char>
	: public ctype_base
	{	
	typedef ctype<char> _Myt;

public:
	typedef char _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);
		}

	const _Elem * is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2370);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Ctype._Table[(unsigned char)*_First];
		return (_First);
		}

	const _Elem * scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2379);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	const _Elem * scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2388);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const _Elem * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	_Elem  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(const mask *_Table = 0,
		bool _Deletetable = false,
		size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}

		_Tidy();	
		if (_Table != 0)
			{	
			_Ctype._Table = _Table;
			_Ctype._Delfl = _Deletetable ? -1 : 0;
			}
		else
			{	
			_Ctype._Table = classic_table();
			_Ctype._Delfl = 0;
			}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

	const mask * table() const noexcept
		{	
		return (_Ctype._Table);
		}

	static const mask *__cdecl classic_table() noexcept
		{	
		const _Myt& _Ctype_fac = use_facet< _Myt >(locale::classic());
		return (_Ctype_fac.table());
		}

	 static const size_t table_size =
		1 << 8;	

protected:
	virtual  ~ctype() noexcept
		{	
		_Tidy();
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		}

	void  _Tidy()
		{	
		if (0 < _Ctype._Delfl)
			:: free((void *)_Ctype._Table);
		else if (_Ctype._Delfl < 0)
			delete[] _Ctype._Table;

		:: free(_Ctype._LocaleName);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return ((_Elem)_Tolower((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2518);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Tolower((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return ((_Elem)_Toupper((unsigned char)_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2532);
		for (; _First != _Last; ++_First)
			*_First = (_Elem)_Toupper((unsigned char)*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Byte);
		}

	virtual const _Elem * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2546);
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

	virtual _Elem  do_narrow(_Elem _Ch, char) const
		{	
		return (_Ch);
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2559);
		:: memcpy(_Dest, _First, _Last - _First);
		return (_Last);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	};

		
template<>
	class __declspec(dllimport) ctype<wchar_t>
	: public ctype_base
	{	
	typedef ctype<wchar_t> _Myt;

public:
	typedef wchar_t _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2692);
		return (:: _Getwctypes(_First, _Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2699);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2708);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2722);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2736);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {};
		wchar_t _Wc;
		return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (wchar_t)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2758);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2780);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};

 
		
template<>
	class __declspec(dllimport) ctype<unsigned short>
	: public ctype_base
	{	
	typedef ctype<unsigned short> _Myt;

public:
	typedef unsigned short _Elem;
	typedef _Elem char_type;

	bool  is(mask _Maskval, _Elem _Ch) const
		{	
		return (do_is(_Maskval, _Ch));
		}

	const _Elem * is(const _Elem *_First, const _Elem *_Last,
		mask *_Dest) const
		{	
		return (do_is(_First, _Last, _Dest));
		}

	const _Elem * scan_is(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_is(_Maskval, _First, _Last));
		}

	const _Elem * scan_not(mask _Maskval, const _Elem *_First,
		const _Elem *_Last) const
		{	
		return (do_scan_not(_Maskval, _First, _Last));
		}

	_Elem  tolower(_Elem _Ch) const
		{	
		return (do_tolower(_Ch));
		}

	const _Elem * tolower(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_tolower(_First, _Last));
		}

	_Elem  toupper(_Elem _Ch) const
		{	
		return (do_toupper(_Ch));
		}

	const _Elem * toupper(_Elem *_First, const _Elem *_Last) const
		{	
		return (do_toupper(_First, _Last));
		}

	_Elem  widen(char _Byte) const
		{	
		return (do_widen(_Byte));
		}

	const char * widen(const char *_First, const char *_Last,
		_Elem *_Dest) const
		{	
		return (do_widen(_First, _Last, _Dest));
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		return (do_narrow(_Ch, _Dflt));
		}

	const _Elem * narrow(const _Elem *_First, const _Elem *_Last,
		char _Dflt, char *_Dest) const
		{	
		return (do_narrow(_First, _Last, _Dflt, _Dest));
		}

	 static locale::id id;

	explicit  ctype(size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 ctype(const _Locinfo& _Lobj, size_t _Refs = 0)
		: ctype_base(_Refs)
		{	
		_Init(_Lobj);
		}

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new ctype<_Elem>(
				_Locinfo(_Ploc->c_str()));
		return (2);
		}

protected:
	virtual  ~ctype() noexcept
		{	
		if (_Ctype._Delfl)
			:: free((void *)_Ctype._Table);

		:: free(_Ctype._LocaleName);
		}

	void  _Init(const _Locinfo& _Lobj)
		{	
		_Ctype = _Lobj._Getctype();
		_Cvt = _Lobj._Getcvt();
		}

	virtual bool  do_is(mask _Maskval, _Elem _Ch) const
		{	
		return ((:: _Getwctype(_Ch, &_Ctype) & _Maskval) != 0);
		}

	virtual const _Elem * do_is(const _Elem *_First,
		const _Elem *_Last, mask *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2916);
		return ((const _Elem *):: _Getwctypes((const wchar_t *)_First,
			(const wchar_t *)_Last, _Dest, &_Ctype));
		}

	virtual const _Elem * do_scan_is(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2924);
		for (; _First != _Last && !is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual const _Elem * do_scan_not(mask _Maskval,
		const _Elem *_First, const _Elem *_Last) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2933);
		for (; _First != _Last && is(_Maskval, *_First); ++_First)
			;
		return (_First);
		}

	virtual _Elem  do_tolower(_Elem _Ch) const
		{	
		return (_Towlower(_Ch, &_Ctype));
		}

	virtual const _Elem * do_tolower(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2947);
		for (; _First != _Last; ++_First)
			*_First = _Towlower(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	virtual _Elem  do_toupper(_Elem _Ch) const
		{	
		return (_Towupper(_Ch, &_Ctype));
		}

	virtual const _Elem * do_toupper(_Elem *_First,
		const _Elem *_Last) const
		{	
		_Debug_range((const _Elem *)_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2961);
		for (; _First != _Last; ++_First)
			*_First = _Towupper(*_First, &_Ctype);
		return ((const _Elem *)_First);
		}

	_Elem  _Dowiden(char _Byte) const
		{	
		mbstate_t _Mbst = {};
		unsigned short _Wc;
		return (_Mbrtowc((wchar_t *)&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0
			? (unsigned short)((wint_t)(0xFFFF)) : _Wc);
		}

	virtual _Elem  do_widen(char _Byte) const
		{	
		return (_Dowiden(_Byte));
		}

	virtual const char * do_widen(const char *_First,
		const char *_Last, _Elem *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 2983);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Dowiden(*_First);
		return (_First);
		}

	char  _Donarrow(_Elem _Ch, char _Dflt) const
		{	
		char _Buf[5];
		mbstate_t _Mbst = {};
		return (_Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1
			? _Dflt : _Buf[0]);
		}

	virtual char  do_narrow(_Elem _Ch, char _Dflt) const
		{	
		return (_Donarrow(_Ch, _Dflt));
		}

	virtual const _Elem * do_narrow(const _Elem *_First,
		const _Elem *_Last, char _Dflt, char *_Dest) const
		{	
		_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale", 3005);
		for (; _First != _Last; ++_First, ++_Dest)
			*_Dest = _Donarrow(*_First, _Dflt);
		return (_First);
		}

private:
	_Locinfo::_Ctypevec _Ctype;	
	_Locinfo::_Cvtvec _Cvt;		
	};
 #line 3016 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"

		
template<class _Elem>
	class ctype_byname
	: public ctype<_Elem>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	
		}
	};

		
template<>
	class ctype_byname<char>
	: public ctype<char>
	{	
public:
	explicit  ctype_byname(const char *_Locname, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Locname), _Refs)
		{	
		}

	explicit  ctype_byname(const string& _Str, size_t _Refs = 0)
		: ctype<char>(_Locinfo(_Str.c_str()), _Refs)
		{	
		}

protected:
	virtual  ~ctype_byname() noexcept
		{	
		}
	};

 

  
template class __declspec(dllimport) codecvt<char, char, _Mbstatet>;
  #line 3066 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
 #line 3067 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3072 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"
#line 3073 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocale"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

 #line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"

#pragma once











 
#line 16 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"




#line 21 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"
#line 22 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cerrno"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"



 #pragma pack(push,8)
 #pragma warning(push,3)
 
 


 




namespace std {
		

enum class errc {	
	address_family_not_supported = 102,
	address_in_use = 100,
	address_not_available = 101,
	already_connected = 113,
	argument_list_too_long = 7,
	argument_out_of_domain = 33,
	bad_address = 14,
	bad_file_descriptor = 9,
	bad_message = 104,
	broken_pipe = 32,
	connection_aborted = 106,
	connection_already_in_progress = 103,
	connection_refused = 107,
	connection_reset = 108,
	cross_device_link = 18,
	destination_address_required = 109,
	device_or_resource_busy = 16,
	directory_not_empty = 41,
	executable_format_error = 8,
	file_exists = 17,
	file_too_large = 27,
	filename_too_long = 38,
	function_not_supported = 40,
	host_unreachable = 110,
	identifier_removed = 111,
	illegal_byte_sequence = 42,
	inappropriate_io_control_operation = 25,
	interrupted = 4,
	invalid_argument = 22,
	invalid_seek = 29,
	io_error = 5,
	is_a_directory = 21,
	message_size = 115,
	network_down = 116,
	network_reset = 117,
	network_unreachable = 118,
	no_buffer_space = 119,
	no_child_process = 10,
	no_link = 121,
	no_lock_available = 39,
	no_message_available = 120,
	no_message = 122,
	no_protocol_option = 123,
	no_space_on_device = 28,
	no_stream_resources = 124,
	no_such_device_or_address = 6,
	no_such_device = 19,
	no_such_file_or_directory = 2,
	no_such_process = 3,
	not_a_directory = 20,
	not_a_socket = 128,
	not_a_stream = 125,
	not_connected = 126,
	not_enough_memory = 12,
	not_supported = 129,
	operation_canceled = 105,
	operation_in_progress = 112,
	operation_not_permitted = 1,
	operation_not_supported = 130,
	operation_would_block = 140,
	owner_dead = 133,
	permission_denied = 13,
	protocol_error = 134,
	protocol_not_supported = 135,
	read_only_file_system = 30,
	resource_deadlock_would_occur = 36,
	resource_unavailable_try_again = 11,
	result_out_of_range = 34,
	state_not_recoverable = 127,
	stream_timeout = 137,
	text_file_busy = 139,
	timed_out = 138,
	too_many_files_open_in_system = 23,
	too_many_files_open = 24,
	too_many_links = 31,
	too_many_symbolic_link_levels = 114,
	value_too_large = 132,
	wrong_protocol_type = 136
	};

typedef errc _Errc;

		

enum class io_errc {	
	stream = 1
	};

typedef io_errc _Io_errc;

		
template<class _Enum>
	struct is_error_code_enum
		: public false_type
	{	
	};

template<>
	struct is_error_code_enum<_Io_errc>
		: public true_type
	{	
	};

 
template<class _Ty>
	constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;
 #line 132 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"

		
template<class _Enum>
	struct is_error_condition_enum
		: public false_type
	{	
	};

template<>
	struct is_error_condition_enum<_Errc>
		: public true_type
	{	
	};

 
template<class _Ty>
	constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;
 #line 150 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"

class error_code;
class error_condition;
error_code make_error_code(_Errc) noexcept;
error_code make_error_code(_Io_errc) noexcept;
error_condition make_error_condition(_Errc) noexcept;
error_condition make_error_condition(_Io_errc) noexcept;

		
class error_category;

const error_category& generic_category() noexcept;
const error_category& iostream_category() noexcept;
const error_category& system_category() noexcept;

class error_category
	{	
public:
	 error_category() noexcept	
		{	
		_Addr = reinterpret_cast<uintptr_t>(this);
		}

	virtual ~error_category() noexcept
		{	
		}

	virtual const char *name() const noexcept = 0;

	virtual string message(int _Errval) const = 0;

	virtual error_condition
		default_error_condition(int _Errval) const noexcept;

	virtual bool equivalent(int _Errval,
		const error_condition& _Cond) const noexcept;

	virtual bool equivalent(const error_code& _Code,
		int _Errval) const noexcept;

	bool operator==(const error_category& _Right) const noexcept
		{	
		return (_Addr == _Right._Addr);
		}

	bool operator!=(const error_category& _Right) const noexcept
		{	
		return (!(*this == _Right));
		}

	bool operator<(const error_category& _Right) const noexcept
		{	
		return (_Addr < _Right._Addr);
		}

	error_category(const error_category&) = delete;
	error_category& operator=(const error_category&) = delete;

protected:
	uintptr_t _Addr;

	enum : uintptr_t
		{	
		_Future_addr = 1,
		_Generic_addr = 3,
		_Iostream_addr = 5,
		_System_addr = 7
		};
	};

		
class error_code
	{	
public:
	typedef error_code _Myt;

	error_code() noexcept
		: _Myval(0),
			_Mycat(&system_category())
		{	
		}

	error_code(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_code_enum<_Enum>::value,
			void>::type>
		error_code(_Enum _Errcode) noexcept
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_code(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_code_enum<_Enum>::value,
			error_code>::type& operator=(_Enum _Errcode) noexcept
		{	
		*this = make_error_code(_Errcode);	
		return (*this);
		}

	void clear() noexcept
		{	
		_Myval = 0;
		_Mycat = &system_category();
		}

	int value() const noexcept
		{	
		return (_Myval);
		}

	const error_category& category() const noexcept
		{	
		return (*_Mycat);
		}

	error_condition default_error_condition() const noexcept;

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	
		return (value() != 0);
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
class error_condition
	{	
public:
	typedef error_condition _Myt;

	error_condition() noexcept
		: _Myval(0),
			_Mycat(&generic_category())
		{	
		}

	error_condition(int _Val, const error_category& _Cat) noexcept
		: _Myval(_Val), _Mycat(&_Cat)
		{	
		}

	template<class _Enum,
		class = typename enable_if<is_error_condition_enum<_Enum>::value,
			void>::type>
		error_condition(_Enum _Errcode) noexcept
		: _Myval(0), _Mycat(0)
		{	
		*this = make_error_condition(_Errcode);	
		}

	void assign(int _Val, const error_category& _Cat) noexcept
		{	
		_Myval = _Val;
		_Mycat = &_Cat;
		}

	template<class _Enum>
		typename enable_if<is_error_condition_enum<_Enum>::value,
			error_condition>::type& operator=(_Enum _Errcode) noexcept
		{	
		*this = make_error_condition(_Errcode);	
		return (*this);
		}

	void clear() noexcept
		{	
		_Myval = 0;
		_Mycat = &generic_category();
		}

	int value() const noexcept
		{	
		return (_Myval);
		}

	const error_category& category() const noexcept
		{	
		return (*_Mycat);
		}

	string message() const
		{	
		return (category().message(value()));
		}

	explicit operator bool() const noexcept
		{	
		return (value() != 0);
		}

private:
	int _Myval;	
	const error_category *_Mycat;	
	};

		
inline bool operator==(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

inline bool operator==(
	const error_code& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category().equivalent(_Left.value(), _Right)
		|| _Right.category().equivalent(_Left, _Right.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Right.category().equivalent(_Right.value(), _Left)
		|| _Left.category().equivalent(_Right, _Left.value()));
	}

inline bool operator==(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category() == _Right.category()
		&& _Left.value() == _Right.value());
	}

		
inline bool operator!=(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_code& _Left,
	const error_condition& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_code& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

inline bool operator!=(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

		
inline bool operator<(
	const error_code& _Left,
	const error_code& _Right) noexcept
	{	
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

inline bool operator<(
	const error_condition& _Left,
	const error_condition& _Right) noexcept
	{	
	return (_Left.category() < _Right.category()
		|| (_Left.category() == _Right.category()
			&& _Left.value() < _Right.value()));
	}

		
inline error_condition
	error_category::default_error_condition(int _Errval) const noexcept
	{	
	return (error_condition(_Errval, *this));
	}

inline bool
	error_category::equivalent(int _Errval,
		const error_condition& _Cond) const noexcept
	{	
	return (default_error_condition(_Errval) == _Cond);
	}

inline bool
	error_category::equivalent(const error_code& _Code,
		int _Errval) const noexcept
	{	
	return (*this == _Code.category() && _Code.value() == _Errval);
	}

		
inline error_condition error_code::default_error_condition() const noexcept
	{	
	return (category().default_error_condition(value()));
	}

		
inline error_code make_error_code(_Errc _Errno) noexcept
	{	
	return (error_code((int)_Errno, generic_category()));
	}

inline error_code make_error_code(_Io_errc _Errno) noexcept
	{	
	return (error_code((int)_Errno, iostream_category()));
	}

		
inline error_condition make_error_condition(_Errc _Errno) noexcept
	{	
	return (error_condition((int)_Errno, generic_category()));
	}

inline error_condition make_error_condition(_Io_errc _Errno) noexcept
	{	
	return (error_condition((int)_Errno, iostream_category()));
	}

		
template<>
	struct hash<error_code>
	{	
	typedef error_code argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (hash<int>()(_Keyval.value()));
		}
	};

		
class _System_error
	: public runtime_error
	{	
private:
	static string _Makestr(error_code _Errcode, string _Message)
		{	
		if (!_Message.empty())
			_Message.append(": ");
		_Message.append(_Errcode.message());
		return (_Message);
		}

protected:
	_System_error(error_code _Errcode, const string& _Message)
		: runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
		{	
		}

	error_code _Mycode;	
	};

class system_error
	: public _System_error
	{	
private:
	typedef _System_error _Mybase;

public:
	system_error(error_code _Errcode)
		: _Mybase(_Errcode, "")
		{	
		}

	system_error(error_code _Errcode, const string& _Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(error_code _Errcode, const char *_Message)
		: _Mybase(_Errcode, _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat)
		: _Mybase(error_code(_Errval, _Errcat), "")
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const string& _Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	system_error(int _Errval, const error_category& _Errcat,
		const char *_Message)
		: _Mybase(error_code(_Errval, _Errcat), _Message)
		{	
		}

	const error_code& code() const noexcept
		{	
		return (_Mycode);
		}

 

 





#line 582 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"
	};

__declspec(dllimport) const char *__cdecl _Syserror_map(int);
__declspec(dllimport) int __cdecl _Winerror_map(int);
__declspec(dllimport) unsigned long __cdecl _Winerror_message(
	unsigned long _Message_id, char *_Narrow, unsigned long _Size);

		
class _Generic_error_category
	: public error_category
	{	
public:
	_Generic_error_category() noexcept
		{	
		_Addr = _Generic_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("generic");
		}

	virtual string message(int _Errcode) const
		{	
		return (_Syserror_map(_Errcode));
		}
	};

		
class _Iostream_error_category
	: public _Generic_error_category
	{	
public:
	_Iostream_error_category() noexcept
		{	
		_Addr = _Iostream_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("iostream");
		}

	virtual string message(int _Errcode) const
		{	
		if (_Errcode == (int)io_errc::stream)
			return ("iostream stream error");
		else
			return (_Generic_error_category::message(_Errcode));
		}
	};

		
class _System_error_category
	: public error_category
	{	
public:
	_System_error_category() noexcept
		{	
		_Addr = _System_addr;
		}

	virtual const char *name() const noexcept
		{	
		return ("system");
		}

	virtual string message(int _Errcode) const
		{	
		const unsigned long _Size = 32767;
		string _Narrow(_Size, '\0');

		const unsigned long _Val = _Winerror_message(
			static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);

		if (_Val == 0)
			return ("unknown error");

		_Narrow.resize(_Val);
		_Narrow.shrink_to_fit();
		return (_Narrow);
		}

	virtual error_condition
		default_error_condition(int _Errval) const noexcept
		{	
		int _Posv = _Winerror_map(_Errval);

		if (_Posv != 0)
			return (error_condition(_Posv, generic_category()));
		else
			return (error_condition(_Errval, system_category()));
		}
	};

template<class _Ty>
	struct _Immortalizer
	{	
	_Immortalizer()
		{	
		::new (static_cast<void *>(&_Storage)) _Ty();
		}

	~_Immortalizer() noexcept
		{	
		}

	_Immortalizer(const _Immortalizer&) = delete;
	_Immortalizer& operator=(const _Immortalizer&) = delete;

	typename aligned_union<1, _Ty>::type _Storage;
	};

template<class _Ty> inline
	_Ty& _Immortalize()
	{	
	 static _Immortalizer<_Ty> _Static;
	return (*reinterpret_cast<_Ty *>(&_Static._Storage));
	}

inline const error_category& generic_category() noexcept
	{	
	return (_Immortalize<_Generic_error_category>());
	}

inline const error_category& iostream_category() noexcept
	{	
	return (_Immortalize<_Iostream_error_category>());
	}

inline const error_category& system_category() noexcept
	{	
	return (_Immortalize<_System_error_category>());
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 721 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"
#line 722 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\system_error"





#line 9 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

 #line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\share.h"







#pragma once



#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4412)

 

namespace std {
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 
 

 
 
 

		
template<class _Dummy>
	class _Iosb
	{	
public:
	enum _Dummy_enum {_Dummy_enum_val = 1};	
	enum _Fmtflags
		{	
		_Fmtmask = 0xffff, _Fmtzero = 0};

	static constexpr _Fmtflags skipws = (_Fmtflags)0x0001;
	static constexpr _Fmtflags unitbuf = (_Fmtflags)0x0002;
	static constexpr _Fmtflags uppercase = (_Fmtflags)0x0004;
	static constexpr _Fmtflags showbase = (_Fmtflags)0x0008;
	static constexpr _Fmtflags showpoint = (_Fmtflags)0x0010;
	static constexpr _Fmtflags showpos = (_Fmtflags)0x0020;
	static constexpr _Fmtflags left = (_Fmtflags)0x0040;
	static constexpr _Fmtflags right = (_Fmtflags)0x0080;
	static constexpr _Fmtflags internal = (_Fmtflags)0x0100;
	static constexpr _Fmtflags dec = (_Fmtflags)0x0200;
	static constexpr _Fmtflags oct = (_Fmtflags)0x0400;
	static constexpr _Fmtflags hex = (_Fmtflags)0x0800;
	static constexpr _Fmtflags scientific = (_Fmtflags)0x1000;
	static constexpr _Fmtflags fixed = (_Fmtflags)0x2000;

	static constexpr _Fmtflags hexfloat =
		(_Fmtflags)0x3000;	

	static constexpr _Fmtflags boolalpha = (_Fmtflags)0x4000;
	static constexpr _Fmtflags _Stdio = (_Fmtflags)0x8000;
	static constexpr _Fmtflags adjustfield = (_Fmtflags)(0x0040
		| 0x0080 | 0x0100);
	static constexpr _Fmtflags basefield = (_Fmtflags)(0x0200
		| 0x0400 | 0x0800);
	static constexpr _Fmtflags floatfield = (_Fmtflags)(0x1000
		| 0x2000);

	enum _Iostate
		{	
		_Statmask = 0x17};

	static constexpr _Iostate goodbit = (_Iostate)0x0;
	static constexpr _Iostate eofbit = (_Iostate)0x1;
	static constexpr _Iostate failbit = (_Iostate)0x2;
	static constexpr _Iostate badbit = (_Iostate)0x4;

	enum _Openmode
		{	
		_Openmask = 0xff};

	static constexpr _Openmode in = (_Openmode)0x01;
	static constexpr _Openmode out = (_Openmode)0x02;
	static constexpr _Openmode ate = (_Openmode)0x04;
	static constexpr _Openmode app = (_Openmode)0x08;
	static constexpr _Openmode trunc = (_Openmode)0x10;
	static constexpr _Openmode _Nocreate = (_Openmode)0x40;
	static constexpr _Openmode _Noreplace = (_Openmode)0x80;
	static constexpr _Openmode binary = (_Openmode)0x20;

	enum _Seekdir
		{	
		_Seekbeg,
		_Seekcur,
		_Seekend
		};

	static constexpr _Seekdir beg = _Seekbeg;
	static constexpr _Seekdir cur = _Seekcur;
	static constexpr _Seekdir end = _Seekend;

	enum
		{	
		_Openprot = 0x40};
	};

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags
		_Iosb<_Dummy>::hexfloat;	

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
template<class _Dummy>
	const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

		
class __declspec(dllimport) ios_base
	: public _Iosb<int>
	{	
public:
	typedef int fmtflags;
	typedef int iostate;
	typedef int openmode;
	typedef int seekdir;

 
	typedef ::std:: streamoff streamoff;
	typedef ::std:: streampos streampos;
 #line 212 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

	enum event
		{	
		erase_event, imbue_event, copyfmt_event};

	typedef void (__cdecl *event_callback)(event, ios_base&, int);

 
	typedef unsigned int io_state, open_mode, seek_dir;
 #line 222 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

			
	class failure

		: public system_error
		{	
	public:
		explicit failure(const string &_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}

		explicit failure(const char *_Message,
			const error_code& _Errcode = make_error_code(io_errc::stream))
			: system_error(_Errcode, _Message)
			{	
			}


 

 





#line 251 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"
		};

			
	class __declspec(dllimport) Init
		{	
	public:
		 Init()
			{	
			_Init_ctor(this);
			}

		 ~Init() noexcept
			{	
			_Init_dtor(this);
			}

	private:
		static  void __cdecl _Init_ctor(Init *);
		static  void __cdecl _Init_dtor(Init *);

		 static int _Init_cnt;	

		static  int& __cdecl _Init_cnt_func();
		};

	explicit  operator bool() const
		{	
		return (!fail());
		}

	bool  operator!() const
		{	
		return (fail());
		}

	void  clear(iostate _State, bool _Reraise)
		{	
		_Mystate = (iostate)(_State & _Statmask);
		if ((_Mystate & _Except) == 0)
			;
		else if (_Reraise)
			throw;
		else if (_Mystate & _Except & badbit)
			throw failure("ios_base::badbit set");
		else if (_Mystate & _Except & failbit)
			throw failure("ios_base::failbit set");
		else
			throw failure("ios_base::eofbit set");
		}

	void  clear(iostate _State = goodbit)
		{	
		clear(_State, false);
		}

 
	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}
 #line 312 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

	iostate  rdstate() const
		{	
		return (_Mystate);
		}

	void  setstate(iostate _State, bool _Exreraise)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Exreraise);
		}

	void  setstate(iostate _State)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), false);
		}

 
	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}
 #line 336 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

	bool  good() const
		{	
		return (rdstate() == goodbit);
		}

	bool  eof() const
		{	
		return ((int)rdstate() & (int)eofbit);
		}

	bool  fail() const
		{	
		return (((int)rdstate()
			& ((int)badbit | (int)failbit)) != 0);
		}

	bool  bad() const
		{	
		return (((int)rdstate() & (int)badbit) != 0);
		}

	iostate  exceptions() const
		{	
		return (_Except);
		}

	void  exceptions(iostate _Newexcept)
		{	
		_Except = (iostate)((int)_Newexcept & (int)_Statmask);
		clear(_Mystate);
		}

 
	void  exceptions(io_state _State)
		{	
		exceptions((iostate)_State);
		}
 #line 375 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"

	fmtflags  flags() const
		{	
		return (_Fmtfl);
		}

	fmtflags  flags(fmtflags _Newfmtflags)
		{	
		fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Newfmtflags & (int)_Fmtmask);
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)((int)_Fmtfl
			| ((int)_Newfmtflags & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	fmtflags  setf(fmtflags _Newfmtflags, fmtflags _Mask)
		{	
		ios_base::fmtflags _Oldfmtflags = _Fmtfl;
		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)
			| ((int)_Newfmtflags & (int)_Mask & (int)_Fmtmask));
		return (_Oldfmtflags);
		}

	void  unsetf(fmtflags _Mask)
		{	
		_Fmtfl = (fmtflags)((int)_Fmtfl & (int)~_Mask);
		}

	streamsize  precision() const
		{	
		return (_Prec);
		}

	streamsize  precision(streamsize _Newprecision)
		{	
		streamsize _Oldprecision = _Prec;
		_Prec = _Newprecision;
		return (_Oldprecision);
		}

	streamsize  width() const
		{	
		return (_Wide);
		}

	streamsize  width(streamsize _Newwidth)
		{	
		streamsize _Oldwidth = _Wide;
		_Wide = _Newwidth;
		return (_Oldwidth);
		}

	locale  getloc() const
		{	
		return (*_Ploc);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = *_Ploc;
		*_Ploc = _Loc;
		_Callfns(imbue_event);
		return (_Oldlocale);
		}

	static int __cdecl xalloc()
		{	
		{ ::std:: _Lockit _Lock(2);	
			return (_Index++);
		}
		}

	long&  iword(int _Idx)
		{	
		return (_Findarr(_Idx)._Lo);
		}

	void *&  pword(int _Idx)
		{	
		return (_Findarr(_Idx)._Vp);
		}

	void  register_callback(event_callback _Pfn,
		int _Idx)
		{	
		_Calls = new _Fnarray(_Idx, _Pfn, _Calls);
		}

	ios_base&  copyfmt(const ios_base& _Other)
		{	
		if (this != &_Other)
			{	
			_Tidy();
			*_Ploc = *_Other._Ploc;
			_Fmtfl = _Other._Fmtfl;
			_Prec = _Other._Prec;
			_Wide = _Other._Wide;
			_Iosarray *_Ptr = _Other._Arr;

			for (_Arr = 0; _Ptr != 0; _Ptr = _Ptr->_Next)
				if (_Ptr->_Lo != 0 || _Ptr->_Vp != 0)
					{	
					iword(_Ptr->_Index) = _Ptr->_Lo;
					pword(_Ptr->_Index) = _Ptr->_Vp;
					}

			for (_Fnarray *_Pfa = _Other._Calls; _Pfa != 0;
				_Pfa = _Pfa->_Next)
				register_callback(_Pfa->_Pfn, _Pfa->_Index);

			_Callfns(copyfmt_event);	
			exceptions(_Other._Except);	
			}
		return (*this);
		}

	static bool __cdecl sync_with_stdio(bool _Newsync = true)
		{	
		{ ::std:: _Lockit _Lock(2);	
			const bool _Oldsync = _Sync;
			_Sync = _Newsync;
			return (_Oldsync);
		}
		}

	void  swap(ios_base& _Right)
		{	
		if (this != &_Right)
			{	
			::std:: swap(_Mystate, _Right._Mystate);
			::std:: swap(_Except, _Right._Except);
			::std:: swap(_Fmtfl, _Right._Fmtfl);
			::std:: swap(_Prec, _Right._Prec);
			::std:: swap(_Wide, _Right._Wide);

			::std:: swap(_Arr, _Right._Arr);
			::std:: swap(_Calls, _Right._Calls);
			::std:: swap(_Ploc, _Right._Ploc);
			}
		}

	virtual  ~ios_base() noexcept	
		{	
		_Ios_base_dtor(this);
		}

	static  void __cdecl
		_Addstd(ios_base *);	

	size_t _Stdstr;	

protected:
	 ios_base()
		{	
		}

	void  _Init()
		{	
		_Ploc = 0;
		_Stdstr = 0;
		_Except = goodbit;
		_Fmtfl = (fmtflags)(skipws | dec);
		_Prec = 6;
		_Wide = 0;
		_Arr = 0;
		_Calls = 0;
		clear(goodbit);
		_Ploc = new locale;
		}

private:
			
	struct _Iosarray
		: public _Crt_new_delete
		{	
	public:
		 _Iosarray(int _Idx, _Iosarray *_Link)
			: _Next(_Link), _Index(_Idx), _Lo(0), _Vp(0)
			{	
			}

		_Iosarray *_Next;	
		int _Index;	
		long _Lo;	
		void *_Vp;	
		};

			
	struct _Fnarray
		: public _Crt_new_delete
		{	
		 _Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link)
			: _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
			{	
			}

		_Fnarray *_Next;	
		int _Index;	
		event_callback _Pfn;	
		};

	void  _Callfns(event _Ev)
		{	
		for (_Fnarray *_Pfa = _Calls; _Pfa != 0; _Pfa = _Pfa->_Next)
			(*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
		}

	_Iosarray&  _Findarr(int _Idx)
		{	
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr, _Ptr2 = 0; _Ptr1 != 0; _Ptr1 = _Ptr1->_Next)
			if (_Ptr1->_Index == _Idx)
				return (*_Ptr1);	
			else if (_Ptr2 == 0 && _Ptr1->_Lo == 0 && _Ptr1->_Vp == 0)
				_Ptr2 = _Ptr1;	

		if (_Ptr2 != 0)
			{	
			_Ptr2->_Index = _Idx;
			return (*_Ptr2);
			}

		_Arr = new _Iosarray(_Idx, _Arr);	
		return (*_Arr);
		}

	void  _Tidy()
		{	
		_Callfns(erase_event);
		_Iosarray *_Ptr1, *_Ptr2;

		for (_Ptr1 = _Arr; _Ptr1 != 0; _Ptr1 = _Ptr2)
			{	
			_Ptr2 = _Ptr1->_Next;
			delete _Ptr1;
			}
		_Arr = 0;

		_Fnarray *_Pfa1, *_Pfa2;
		for (_Pfa1 = _Calls; _Pfa1 != 0; _Pfa1 = _Pfa2)
			{	
			_Pfa2 = _Pfa1->_Next;
			delete _Pfa1;
			}
		_Calls = 0;
		}

	iostate _Mystate;	
	iostate _Except;	
	fmtflags _Fmtfl;	
	streamsize _Prec;	
	streamsize _Wide;	
	_Iosarray *_Arr;	
	_Fnarray *_Calls;	
	locale *_Ploc;	

	 static int _Index;
	 static bool _Sync;

	static  void __cdecl
		_Ios_base_dtor(ios_base *);

public:
	ios_base(const ios_base&) = delete;
	ios_base& operator=(const ios_base&) = delete;
	};





}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 658 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"
#line 659 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xiosbase"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4251)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_streambuf
	{	
	typedef basic_streambuf<_Elem, _Traits> _Myt;

protected:
	 basic_streambuf()
		: _Plocale(new locale)
		{	
		_Init();
		}

	 basic_streambuf(_Uninitialized)
		{	
		}

	 basic_streambuf(const _Myt& _Right)
		: _Plocale(new locale(_Right.getloc()))
		{	
		_Init();
		setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
		setg(_Right.eback(), _Right.gptr(), _Right.egptr());
		}

	_Myt&  operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			pubimbue(_Right.getloc());
			}
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Elem *_Pfirst0 = pbase();
			_Elem *_Pnext0 = pptr();
			_Elem *_Pend = epptr();
			_Elem *_Gfirst0 = eback();
			_Elem *_Gnext0 = gptr();
			_Elem *_Gend = egptr();

			setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			_Right.setp(_Pfirst0, _Pnext0, _Pend);

			setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			_Right.setg(_Gfirst0, _Gnext0, _Gend);

			::std:: swap(_Plocale, _Right._Plocale);
			}
		}

public:
	typedef _Elem char_type;
	typedef _Traits traits_type;

	virtual  ~basic_streambuf() noexcept
		{	
		delete _Plocale;
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	pos_type  pubseekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekoff(_Off, _Way, _Mode));
		}

 
	pos_type  pubseekoff(off_type _Off,
		ios_base::seek_dir _Way,
		ios_base::open_mode _Mode)
		{	
		return (pubseekoff(_Off, (ios_base::seekdir)_Way,
			(ios_base::openmode)_Mode));
		}
 #line 103 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

	pos_type  pubseekpos(pos_type _Pos,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		return (seekpos(_Pos, _Mode));
		}

 
	pos_type  pubseekpos(pos_type _Pos,
		ios_base::open_mode _Mode)
		{	
		return (seekpos(_Pos, (ios_base::openmode)_Mode));
		}
 #line 117 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

	_Myt * pubsetbuf(_Elem *_Buffer,
		streamsize _Count)
		{	
		return (setbuf(_Buffer, _Count));
		}

	locale  pubimbue(const locale &_Newlocale)
		{	
		locale _Oldlocale = *_Plocale;
		imbue(_Newlocale);
		*_Plocale = _Newlocale;
		return (_Oldlocale);
		}

	locale  getloc() const
		{	
		return (*_Plocale);
		}

	streamsize  in_avail()
		{	
		streamsize _Res = _Gnavail();
		return (0 < _Res ? _Res : showmanyc());
		}

	int  pubsync()
		{	
		return (sync());
		}

	int_type  sbumpc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*_Gninc()) : uflow());
		}

	int_type  sgetc()
		{	
		return (0 < _Gnavail()
			? _Traits::to_int_type(*gptr()) : underflow());
		}

	streamsize  sgetn(_Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsgetn(_Ptr, _Count));
		}

	int_type  snextc()
		{	
		return (1 < _Gnavail()
			? _Traits::to_int_type(*_Gnpreinc())
			: _Traits::eq_int_type(_Traits::eof(), sbumpc())
				? _Traits::eof() : sgetc());
		}

	int_type  sputbackc(_Elem _Ch)
		{	
		return (gptr() != 0 && eback() < gptr()
			&& _Traits::eq(_Ch, gptr()[-1])
			? _Traits::to_int_type(*_Gndec())
			: pbackfail(_Traits::to_int_type(_Ch)));
		}

 
	void  stossc()
		{	
		if (0 < _Gnavail())
			_Gninc();
		else
			uflow();
		}
 #line 191 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

	int_type  sungetc()
		{	
		return (gptr() != 0 && eback() < gptr()
			? _Traits::to_int_type(*_Gndec()) : pbackfail());
		}

	int_type  sputc(_Elem _Ch)
		{	
		return (0 < _Pnavail()
			? _Traits::to_int_type(*_Pninc() = _Ch)
			: overflow(_Traits::to_int_type(_Ch)));
		}

	streamsize  sputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		return (xsputn(_Ptr, _Count));
		}

	virtual void  _Lock()
		{	
		}

	virtual void  _Unlock()
		{	
		}

protected:
	_Elem * eback() const
		{	
		return (*_IGfirst);
		}

	_Elem * gptr() const
		{	
		return (*_IGnext);
		}

	_Elem * pbase() const
		{	
		return (*_IPfirst);
		}

	_Elem * pptr() const
		{	
		return (*_IPnext);
		}

	_Elem * egptr() const
		{	
		return (*_IGnext + *_IGcount);
		}

	void  gbump(int _Off)
		{	
		*_IGcount -= _Off;
		*_IGnext += _Off;
		}

	void  setg(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IGfirst = _First;
		*_IGnext = _Next;
		*_IGcount = (int)(_Last - _Next);
		}

	_Elem * epptr() const
		{	
		return (*_IPnext + *_IPcount);
		}

	_Elem * _Gndec()
		{	
		++*_IGcount;
		return (--*_IGnext);
		}

	_Elem * _Gninc()
		{	
		--*_IGcount;
		return ((*_IGnext)++);
		}

	_Elem * _Gnpreinc()
		{	
		--*_IGcount;
		return (++(*_IGnext));
		}

	streamsize  _Gnavail() const
		{	
		return (*_IGnext != 0 ? *_IGcount : 0);
		}

	void  pbump(int _Off)
		{	
		*_IPcount -= _Off;
		*_IPnext += _Off;
		}

	void  setp(_Elem *_First, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _First;
		*_IPcount = (int)(_Last - _First);
		}

	void  setp(_Elem *_First, _Elem *_Next, _Elem *_Last)
		{	
		*_IPfirst = _First;
		*_IPnext = _Next;
		*_IPcount = (int)(_Last - _Next);
		}

	_Elem * _Pninc()
		{	
		--*_IPcount;
		return ((*_IPnext)++);
		}

	streamsize  _Pnavail() const
		{	
		return (*_IPnext != 0 ? *_IPcount : 0);
		}

	void  _Init()
		{	
		_IGfirst = &_Gfirst;
		_IPfirst = &_Pfirst;
		_IGnext = &_Gnext;
		_IPnext = &_Pnext;
		_IGcount = &_Gcount;
		_IPcount = &_Pcount;
		setp(0, 0);
		setg(0, 0, 0);
		}

	void  _Init(_Elem **_Gf, _Elem **_Gn, int *_Gc,
		_Elem **_Pf, _Elem **_Pn, int *_Pc)
		{	
		_IGfirst = _Gf;
		_IPfirst = _Pf;
		_IGnext = _Gn;
		_IPnext = _Pn;
		_IGcount = _Gc;
		_IPcount = _Pc;
		}

	virtual int_type  overflow(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual int_type  pbackfail(int_type = _Traits::eof())
		{	
		return (_Traits::eof());
		}

	virtual streamsize  showmanyc()
		{	
		return (0);
		}

	virtual int_type  underflow()
		{	
		return (_Traits::eof());
		}

	virtual int_type  uflow()
		{	
		return (_Traits::eq_int_type(_Traits::eof(), underflow())
			? _Traits::eof() : _Traits::to_int_type(*_Gninc()));
		}

	virtual streamsize  xsgetn(_Elem * _Ptr,
		streamsize _Count)
		{	
		int_type _Meta;
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Gnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(_Ptr, gptr(), (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				gbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
				break;	
			else
				{	
				*_Ptr++ = _Traits::to_char_type(_Meta);
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual streamsize  xsputn(const _Elem *_Ptr,
		streamsize _Count)
		{	
		streamsize _Size, _Copied;

		for (_Copied = 0; 0 < _Count; )
			if (0 < (_Size = _Pnavail()))
				{	
				if (_Count < _Size)
					_Size = _Count;
				_Traits::copy(pptr(), _Ptr, (size_t)_Size);
				_Ptr += _Size;
				_Copied += _Size;
				_Count -= _Size;
				pbump((int)_Size);
				}
			else if (_Traits::eq_int_type(_Traits::eof(),
				overflow(_Traits::to_int_type(*_Ptr))))
				break;	
			else
				{	
				++_Ptr;
				++_Copied;
				--_Count;
				}

		return (_Copied);
		}

	virtual pos_type  seekoff(off_type,
		ios_base::seekdir,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual pos_type  seekpos(pos_type,
		ios_base::openmode = ios_base::in | ios_base::out)
		{	
		return (streampos(_BADOFF));
		}

	virtual _Myt * setbuf(_Elem *, streamsize)
		{	
		return (this);
		}

	virtual int  sync()
		{	
		return (0);
		}

	virtual void  imbue(const locale&)
		{	
		}

private:
	_Elem *_Gfirst;	
	_Elem *_Pfirst;	
	_Elem **_IGfirst;	
	_Elem **_IPfirst;	
	_Elem *_Gnext;	
	_Elem *_Pnext;	
	_Elem **_IGnext;	
	_Elem **_IPnext;	

	int _Gcount;	
	int _Pcount;	
	int *_IGcount;	
	int *_IPcount;	

protected:
	locale *_Plocale;	
	};

 

  
template class __declspec(dllimport) basic_streambuf<char, char_traits<char> >;
template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t> >;
  #line 476 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

  



 #line 482 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

		
template<class _Elem,
	class _Traits>
	class istreambuf_iterator
		: public iterator<input_iterator_tag,
			_Elem, typename _Traits::off_type, const _Elem *, _Elem>
	{	
	typedef istreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_istream<_Elem, _Traits> istream_type;

	typedef typename traits_type::int_type int_type;
	typedef const _Elem *pointer;

	constexpr istreambuf_iterator(streambuf_type *_Sb = 0) noexcept
		: _Strbuf(_Sb), _Got(_Sb == 0), _Val()
		{	
		}

	istreambuf_iterator(istream_type& _Istr) noexcept
		: _Strbuf(_Istr.rdbuf()), _Got(_Istr.rdbuf() == 0)
		{	
		}

	_Elem operator*() const
		{	
		if (!_Got)
			_Peek();

 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf", 517);
 #line 519 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

		return (_Val);
		}

	const _Elem *operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myt& operator++()
		{	
 
		if (_Strbuf == 0)
			_Debug_message(L"istreambuf_iterator is not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf", 532);
 #line 534 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"

		_Inc();
		return (*this);
		}

	_Myt operator++(int)
		{	
		if (!_Got)
			_Peek();
		_Myt _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	bool equal(const _Myt& _Right) const
		{	
		if (!_Got)
			_Peek();
		if (!_Right._Got)
			_Right._Peek();
		return ((_Strbuf == 0 && _Right._Strbuf == 0)
			|| (_Strbuf != 0 && _Right._Strbuf != 0));
		}

private:
	void _Inc()
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Strbuf->sbumpc()))
			_Strbuf = 0, _Got = true;
		else
			_Got = false;
		}

	_Elem _Peek() const
		{	
		int_type _Meta;
		if (_Strbuf == 0
			|| traits_type::eq_int_type(traits_type::eof(),
				_Meta = _Strbuf->sgetc()))
			_Strbuf = 0;
		else
			_Val = traits_type::to_char_type(_Meta);
		_Got = true;
		return (_Val);
		}

	mutable streambuf_type *_Strbuf;	
	mutable bool _Got;	
	mutable _Elem _Val;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<istreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};

		
template<class _Elem,
	class _Traits> inline
	bool  operator==(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (_Left.equal(_Right));
	}

template<class _Elem,
	class _Traits> inline
	bool  operator!=(
		const istreambuf_iterator<_Elem, _Traits>& _Left,
		const istreambuf_iterator<_Elem, _Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

		
template<class _Elem,
	class _Traits>
	class ostreambuf_iterator
		: public _Outit
	{	
	typedef ostreambuf_iterator<_Elem, _Traits> _Myt;
public:
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef basic_streambuf<_Elem, _Traits> streambuf_type;
	typedef basic_ostream<_Elem, _Traits> ostream_type;

	ostreambuf_iterator(streambuf_type *_Sb) noexcept
		: _Failed(false), _Strbuf(_Sb)
		{	
		}

	ostreambuf_iterator(ostream_type& _Ostr) noexcept
		: _Failed(false), _Strbuf(_Ostr.rdbuf())
		{	
		}

	_Myt& operator=(_Elem _Right)
		{	
		if (_Strbuf == 0
			|| traits_type::eq_int_type(_Traits::eof(),
				_Strbuf->sputc(_Right)))
			_Failed = true;
		return (*this);
		}

	_Myt& operator*()
		{	
		return (*this);
		}

	_Myt& operator++()
		{	
		return (*this);
		}

	_Myt& operator++(int)
		{	
		return (*this);
		}

	bool failed() const noexcept
		{	
		return (_Failed);
		}

private:
	bool _Failed;	
	streambuf_type *_Strbuf;	
	};

template<class _Elem,
	class _Traits>
	struct _Is_checked_helper<ostreambuf_iterator<_Elem, _Traits> >
		: public true_type
	{	
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 682 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"
#line 683 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\streambuf"





#line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4275)

		

 
extern "C" {
 #line 24 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

extern __declspec(dllimport) float __cdecl _Stofx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) double __cdecl _Stodx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long double __cdecl _Stoldx(const char *,
	    char **,
	long, int *);
extern __declspec(dllimport) long __cdecl _Stolx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned long __cdecl _Stoulx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) long long __cdecl _Stollx(const char *,
	    char **,
	int, int *);
extern __declspec(dllimport) unsigned long long __cdecl _Stoullx(const char *,
	    char **,
	int, int *);

 
}
 #line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

namespace std {

	
inline double _Stodx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
	{	
	int& _Errno_ref = (*_errno());	
	const int _Orig = _Errno_ref;

	_Errno_ref = 0;
	double _Val = :: strtod(_Str, _Endptr);
	*_Perr = _Errno_ref;
	_Errno_ref = _Orig;

	if (_Pten != 0)
		_Val *= :: pow(10.0, static_cast<double>(_Pten));

	return (_Val);
	}

	
inline float _Stofx_v2(const char *_Str, char **_Endptr, int _Pten, int *_Perr)
	{	
	int& _Errno_ref = (*_errno());	
	const int _Orig = _Errno_ref;

	_Errno_ref = 0;
	float _Val = :: strtof(_Str, _Endptr);
	*_Perr = _Errno_ref;
	_Errno_ref = _Orig;

	if (_Pten != 0)
		_Val *= :: powf(10.0f, static_cast<float>(_Pten));

	return (_Val);
	}


template<class _Elem> inline
	size_t _Find_elem(_Elem *_Base, _Elem _Ch)
	{	
	_Elem *_Ptr = _Base;
	for (; *_Ptr != (_Elem)0 && *_Ptr != _Ch; ++_Ptr)
		;
	return ((size_t)(_Ptr - _Base));
	}

inline wchar_t *_Maklocwcs(const wchar_t *_Ptr)
	{	
	size_t _Count = :: wcslen(_Ptr) + 1;

	wchar_t *_Ptrdest = (wchar_t *)_calloc_dbg(_Count, sizeof (wchar_t),
		2, "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 102);

	if (!_Ptrdest)
		_Xbad_alloc();
	:: wmemcpy(_Ptrdest, _Ptr, _Count);
	return (_Ptrdest);
	}

		
template<class _Elem>
	class numpunct
		: public locale::facet
	{	
public:
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		string_type;
	typedef _Elem char_type;

	 __declspec(dllimport) static locale::id id;	

	_Elem decimal_point() const
		{	
		return (do_decimal_point());
		}

	_Elem thousands_sep() const
		{	
		return (do_thousands_sep());
		}

	string grouping() const
		{	
		return (do_grouping());
		}

	string_type falsename() const
		{	
		return (do_falsename());
		}

	string_type truename() const
		{	
		return (do_truename());
		}

	explicit numpunct(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
			if (_Kseparator == 0)
				_Kseparator =	
					_Maklocchr(',', (_Elem *)0, _Lobj._Getcvt());
		}
		}

	numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj, _Isdef);
		}

	static size_t _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new numpunct<_Elem>(
				_Locinfo(_Ploc->c_str()), 0, true);
		return (4);
		}

protected:
	virtual  ~numpunct() noexcept
		{	
		_Tidy();
		}

	numpunct(const char *_Locname, size_t _Refs = 0, bool _Isdef = false)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj(_Locname);
			_Init(_Lobj, _Isdef);
		}
		}

	template<class _Elem2>
		void _Getvals(_Elem2, const lconv *_Ptr, _Locinfo::_Cvtvec _Cvt)
		{	
		_Dp = _Maklocchr(_Ptr->decimal_point[0], (_Elem2 *)0, _Cvt);
		_Kseparator = _Maklocchr(_Ptr->thousands_sep[0], (_Elem2 *)0, _Cvt);
		}

	template<>
		void _Getvals(wchar_t, const lconv *_Ptr, _Locinfo::_Cvtvec)
		{	
		_Dp = (_Elem)_Ptr->_W_decimal_point[0];
		_Kseparator = (_Elem)_Ptr->_W_thousands_sep[0];
		}

	void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
		{	
		const lconv *_Ptr = _Lobj._Getlconv();
		_Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();	

		_Grouping = 0;
		_Falsename = 0;
		_Truename = 0;

		try {
		_Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, (char *)0, _Lobj._Getcvt());
#line 213 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
		_Falsename = _Maklocstr(_Lobj._Getfalse(), (_Elem *)0, _Cvt);
		_Truename = _Maklocstr(_Lobj._Gettrue(), (_Elem *)0, _Cvt);
		} catch (...) {
		_Tidy();
		throw;
		}

		if (_Isdef)
			{	

			_Dp = _Maklocchr('.', (_Elem *)0, _Cvt);
			_Kseparator = _Maklocchr(',', (_Elem *)0, _Cvt);
			}
		else
			_Getvals((_Elem)0, _Ptr, _Cvt);
		}

	virtual _Elem  do_decimal_point() const
		{	
		return (_Dp);
		}

	virtual _Elem  do_thousands_sep() const
		{	
		return (_Kseparator);
		}

	virtual string  do_grouping() const
		{	
		return (string(_Grouping));
		}

	virtual string_type  do_falsename() const
		{	
		return (string_type(_Falsename));
		}

	virtual string_type  do_truename() const
		{	
		return (string_type(_Truename));
		}

private:
	void _Tidy()
		{	
		:: free((void *)_Grouping);
		:: free((void *)_Falsename);
		:: free((void *)_Truename);
		}

	const char *_Grouping;	
	_Elem _Dp;	
	_Elem _Kseparator;	
	const _Elem *_Falsename;	
	const _Elem *_Truename;	
	};

		
template<class _Elem>
	class numpunct_byname
		: public numpunct<_Elem>
	{	
public:
	explicit numpunct_byname(const char *_Locname, size_t _Refs = 0)
		: numpunct<_Elem>(_Locname, _Refs)
		{	
		}

	explicit numpunct_byname(const string& _Str, size_t _Refs = 0)
		: numpunct<_Elem>(_Str.c_str(), _Refs)
		{	
		}

protected:
	virtual  ~numpunct_byname() noexcept
		{	
		}
	};

		
template<class _Elem>
	 locale::id numpunct<_Elem>::id;

		
template<class _Elem,
	class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_get
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_get<_Elem, _InIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_get() noexcept
		{	
		}

	void _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_get(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_get(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _InIt iter_type;

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			bool& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase,	ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long long& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

	_InIt  get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		return (do_get(_First, _Last, _Iosbase, _State, _Val));
		}

protected:
	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			bool& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 427);
		int _Ans = -1;	

		if (_Iosbase.flags() & ios_base::boolalpha)
			{	
			typedef typename _Mystr::size_type _Mystrsize;
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str((_Mystrsize)1, (char_type)0);
			_Str += _Punct_fac.falsename();
			_Str += (char_type)0;
			_Str += _Punct_fac.truename();	
			_Ans = _Getloctxt(_First, _Last, (size_t)2, _Str.c_str());
			}
		else
			{	
			char _Ac[32], *_Ep;
			int _Errno = 0;
			const unsigned long _Ulo = :: _Stoulx(_Ac, &_Ep,
				_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
					_Iosbase.getloc()), &_Errno);
			if (_Ep != _Ac && _Errno == 0 && _Ulo <= 1)
				_Ans = _Ulo;
			}

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ans < 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans != 0;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned short& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 464);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = (unsigned short)(_Ac[0] == '-'
				? 0 -_Ans : _Ans);	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned int& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 487);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(),
			_Iosbase.getloc());	
		char *_Ptr = _Ac[0] == '-' ? _Ac + 1 : _Ac;	
		const unsigned long _Ans =
			:: _Stoulx(_Ptr, &_Ep, _Base, &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ptr || _Errno != 0 || 0xffffffff < _Ans)
			_State |= ios_base::failbit;
		else
			_Val = _Ac[0] == '-' ? 0 -_Ans : _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 509);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const long _Ans = :: _Stolx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 529);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned long _Ans = :: _Stoulx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 549);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const long long _Ans = :: _Stollx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			unsigned long long& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 569);
		char _Ac[32], *_Ep;
		int _Errno = 0;
		const unsigned long long _Ans = :: _Stoullx(_Ac, &_Ep,
			_Getifld(_Ac, _First, _Last, _Iosbase.flags(),
				_Iosbase.getloc()), &_Errno);	

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}







	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			float& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 595);
		char _Ac[(8 + 768 + 16)], *_Ep;
		int _Errno = 0;
		int _Hexexp = 1000000000;
		float _Ans = _Stofx_v2(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 1000000000 && _Hexexp != 0)
			_Ans = :: ldexpf(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			double& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 619);
		char _Ac[(8 + 768 + 16)], *_Ep;
		int _Errno = 0;
		int _Hexexp = 1000000000;
		double _Ans = _Stodx_v2(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 1000000000 && _Hexexp != 0)
			_Ans = :: ldexp(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}

	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			long double& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 643);
		char _Ac[(8 + 768 + 16)], *_Ep;
		int _Errno = 0;
		int _Hexexp = 1000000000;
		long double _Ans = _Stodx_v2(_Ac, &_Ep,
			_Getffld(_Ac, _First, _Last,
				_Iosbase, &_Hexexp), &_Errno);	

		if (_Hexexp != 1000000000 && _Hexexp != 0)
			_Ans = :: ldexpl(_Ans, 4 * _Hexexp);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = _Ans;	
		return (_First);
		}



	virtual _InIt  do_get(_InIt _First, _InIt _Last,
		ios_base& _Iosbase, ios_base::iostate& _State,
			void *& _Val) const
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 669);
		char _Ac[32], *_Ep;
		int _Errno = 0;

		int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex,
			_Iosbase.getloc());	
		const unsigned long long _Ans =
			(sizeof (void *) == sizeof (unsigned long))
				? (unsigned long long):: _Stoulx(_Ac, &_Ep, _Base, &_Errno)
				: :: _Stoullx(_Ac, &_Ep, _Base, &_Errno);

		if (_First == _Last)
			_State |= ios_base::eofbit;
		if (_Ep == _Ac || _Errno != 0)
			_State |= ios_base::failbit;
		else
			_Val = (void *)((char *)0 + _Ans);	
		return (_First);
		}

private:
	int __cdecl _Getifld(char *_Ac,
		_InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield,
			const locale& _Loc) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Loc);
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Grouping.size() == 0
			? (_Elem)0 : _Punct_fac.thousands_sep();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+Xx"};	
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Loc);
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		_Basefield &= ios_base::basefield;
		int _Base = _Basefield == ios_base::oct ? 8
			: _Basefield == ios_base::hex ? 16
			: _Basefield == ios_base::_Fmtzero ? 0 : 10;

		bool _Seendigit = false;	
		bool _Nonzero = false;	

		if (_First != _Last && *_First == _Atoms[0])
			{	
			_Seendigit = true, ++_First;
			if (_First != _Last && (*_First == _Atoms[_NUMGET_XOFF + 1]
					|| *_First == _Atoms[_NUMGET_XOFF])
				&& (_Base == 0 || _Base == 16))
				_Base = 16, _Seendigit = false, ++_First;
			else if (_Base == 0)
				_Base = 8;
			}

		size_t _Dlen = _Base == 0 || _Base == 10 ? 10
			: _Base == 8 ? 8 : 16 + 6;
		string _Groups((size_t)1, (char)_Seendigit);
		size_t _Group = 0;

		for (char *const _Pe = &_Ac[32 - 1];
			_First != _Last; ++_First)
			{	
			size_t _Idx = _Find_elem(_Atoms, *_First);
			if (_Idx < _Dlen)
				{	
				*_Ptr = _Src[_Idx];
				if ((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
					++_Ptr, _Nonzero = true;
				_Seendigit = true;
				if (_Groups[_Group] != 127)
					++_Groups[_Group];
				}
			else if (_Groups[_Group] == '\0'
				|| _Kseparator == (_Elem)0
				|| *_First != _Kseparator)
				break;	
			else
				{	
				_Groups.append((string::size_type)1, '\0');
				++_Group;
				}
			}

		if (_Group == 0)
			;	
		else if ('\0' < _Groups[_Group])
			++_Group;	
		else
			_Seendigit = false;	

		for (const char *_Pg = &_Grouping[0]; _Seendigit && 0 < _Group; )
			if (*_Pg == 127)
				break;	
			else if ((0 < --_Group && *_Pg != _Groups[_Group])
				|| (0 == _Group && *_Pg < _Groups[_Group]))
				_Seendigit = false;	
			else if ('\0' < _Pg[1])
				++_Pg;	

		if (_Seendigit && !_Nonzero)
			*_Ptr++ = '0';	
		else if (!_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Base);
		}

	int __cdecl _Getffld(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		if ((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
			return (_Getffldx(_Ac, _First, _Last,
				_Iosbase, _Phexexp));	

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		char *_Ptr = _Ac;
		bool _Bad = false;
		bool _Sticky = false;

		enum {
			_NUMGET_SIGNOFF = 10,
			_NUMGET_EOFF = 12};
		static const char _Src[] = {"0123456789-+Ee"};	
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		char *_Leading = _Ptr;	
		*_Ptr++ = '0';	

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Pten = 0;	
		size_t _Idx;

		const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
					_Seendigit = true, ++_First)
				if (_Max_sig_dig <= _Significant)
					{	
					++_Pten;
					if (0 < _Idx)
						_Sticky = true;
					}
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < 10)
					{	
					_Seendigit = true;
					if (_Max_sig_dig <= _Significant)
						{	
						++_Pten;
						if (0 < _Idx)
							_Sticky = true;
						}
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (*_Phexexp != 1000000000 && _Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Pten;	
			if (_Pten < 0)
				*_Ptr++ = '0', ++_Pten;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
			if (_Significant < _Max_sig_dig)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}
			else if (0 < _Idx)
				_Sticky = true;	

		if (_Sticky)
			{	
			char *_Px = _Ptr;
			for (; --_Px != _Leading; )
				{	
				if (*_Px == localeconv()->decimal_point[0])
					;	
				else if (*_Px != '9')
					{	
					++*_Px;
					break;
					}
				else
					*_Px = '0';	
				}

			if (_Px == _Leading)
				{	
				*_Px = '1';
				++_Pten;
				}
			}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_EOFF + 1]
				|| *_First == _Atoms[_NUMGET_EOFF]))
			{	
			*_Ptr++ = 'e', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < 10;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		return (_Pten);
		}

	int __cdecl _Getffldx(char *_Ac,
		_InIt& _First, _InIt &_Last,
		ios_base& _Iosbase, int *_Phexexp) const
		{	
		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();

		enum {
			_NUMGET_SIGNOFF = 22,
			_NUMGET_XOFF = 24,
			_NUMGET_POFF = 26};
		static const char _Src[] = {"0123456789ABCDEFabcdef-+XxPp"};	
		_Elem _Atoms[sizeof (_Src)];
		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Ctype_fac.widen(&_Src[0], &_Src[sizeof (_Src)], _Atoms);

		char *_Ptr = _Ac;
		bool _Bad = false;
		size_t _Idx;

		if (_First == _Last)
			;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
			*_Ptr++ = '+', ++_First;	
		else if (*_First == _Atoms[_NUMGET_SIGNOFF])
			*_Ptr++ = '-', ++_First;	

		*_Ptr++ = '0';
		*_Ptr++ = 'x';

		bool _Seendigit = false;	
		int _Significant = 0;	
		int _Phex = 0;	

		if (_First == _Last || *_First != _Atoms[0])
			;
		else if (++_First != _Last
			&& (*_First == _Atoms[_NUMGET_XOFF + 1]
				|| *_First == _Atoms[_NUMGET_XOFF]))
			++_First;	
		else
			_Seendigit = true;	

		const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

		const char *_Pg = &_Grouping[0];
		if (*_Pg == 127 || *_Pg <= '\0')
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
					_Seendigit = true, ++_First)
				if (_Max_sig_dig <= _Significant)
					++_Phex;	
				else if (_Idx == 0 && _Significant == 0)
					;	
				else
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
		else
			{	
			const _Elem _Kseparator = _Grouping.size() == 0
				? (_Elem)0 : _Punct_fac.thousands_sep();
			string _Groups((size_t)1, '\0');
			size_t _Group = 0;

			for (; _First != _Last; ++_First)
				if ((_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF)
					{	
					_Seendigit = true;
					if (_Max_sig_dig <= _Significant)
						++_Phex;	
					else if (_Idx == 0 && _Significant == 0)
						;	
					else
						{	
						*_Ptr++ = _Src[_Idx];
						++_Significant;
						}
					if (_Groups[_Group] != 127)
						++_Groups[_Group];
					}
				else if (_Groups[_Group] == '\0'
					|| _Kseparator == (_Elem)0
					|| *_First != _Kseparator)
					break;	
				else
					{	
					_Groups.append((size_t)1, '\0');
					++_Group;
					}
			if (_Group == 0)
				;	
			else if ('\0' < _Groups[_Group])
				++_Group;	
			else
				_Bad = true;	

			while (!_Bad && 0 < _Group)
				if (*_Pg == 127)
					break;	
				else if ((0 < --_Group && *_Pg != _Groups[_Group])
					|| (0 == _Group && *_Pg < _Groups[_Group]))
					_Bad = true;	
				else if ('\0' < _Pg[1])
					++_Pg;	
			}

		if (_Seendigit && _Significant == 0)
			*_Ptr++ = '0';	

		if (_First != _Last && *_First == _Punct_fac.decimal_point())
			*_Ptr++ = localeconv()->decimal_point[0], ++_First;	

		if (_Significant == 0)
			{	
			for (; _First != _Last && *_First == _Atoms[0];
				_Seendigit = true, ++_First)
				--_Phex;	
			if (_Phex < 0)
				*_Ptr++ = '0', ++_Phex;	
			}

		for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
			if (_Significant < _Max_sig_dig)
				{	
				*_Ptr++ = _Src[_Idx];
				++_Significant;
				}

		if (_Seendigit && _First != _Last
			&& (*_First == _Atoms[_NUMGET_POFF + 1]
				|| *_First == _Atoms[_NUMGET_POFF]))
			{	
			*_Ptr++ = 'p', ++_First;
			_Seendigit = false, _Significant = 0;

			if (_First == _Last)
				;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF + 1])
				*_Ptr++ = '+', ++_First;	
			else if (*_First == _Atoms[_NUMGET_SIGNOFF])
				*_Ptr++ = '-', ++_First;	
			for (; _First != _Last && *_First == _Atoms[0]; )
				_Seendigit = true, ++_First;	
			if (_Seendigit)
				*_Ptr++ = '0';	
			for (; _First != _Last
				&& (_Idx = _Find_elem(_Atoms, *_First)) < _NUMGET_SIGNOFF;
				_Seendigit = true, ++_First)
				if (_Significant < 8)
					{	
					*_Ptr++ = _Src[_Idx];
					++_Significant;
					}
			}

		if (_Bad || !_Seendigit)
			_Ptr = _Ac;	
		*_Ptr = '\0';
		*_Phexexp = _Phex;	
		return (0);	
		}



	};

		
template<class _Elem,
	class _InIt>
	 locale::id num_get<_Elem, _InIt>::id;

		
template<class _Elem,
	class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem> > >
	class num_put
		: public locale::facet
	{	
public:
	typedef numpunct<_Elem> _Mypunct;
	typedef basic_string<_Elem, char_traits<_Elem>, allocator<_Elem> >
		_Mystr;

	static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0,
		const locale *_Ploc = 0)
		{	
		if (_Ppf != 0 && *_Ppf == 0)
			*_Ppf = new num_put<_Elem, _OutIt>(
				_Locinfo(_Ploc->c_str()));
		return (4);
		}

	 static locale::id id;	

protected:
	virtual  ~num_put() noexcept
		{	
		}

	void  _Init(const _Locinfo&)
		{	
		}

public:
	explicit  num_put(size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		{ _Locinfo _Lobj;
			_Init(_Lobj);
		}
		}

	 num_put(const _Locinfo& _Lobj, size_t _Refs = 0)
		: locale::facet(_Refs)
		{	
		_Init(_Lobj);
		}

	typedef _Elem char_type;
	typedef _OutIt iter_type;

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

	_OutIt  put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		return (do_put(_Dest, _Iosbase, _Fill, _Val));
		}

protected:
	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, bool _Val) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 1256);
		if (!(_Iosbase.flags() & ios_base::boolalpha))
			return (do_put(_Dest, _Iosbase, _Fill, (long)_Val));
		else
			{	
			const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
			_Mystr _Str;
			if (_Val)
				_Str.assign(_Punct_fac.truename());
			else
				_Str.assign(_Punct_fac.falsename());

			size_t _Fillcount = _Iosbase.width() <= 0
				|| (size_t)_Iosbase.width() <= _Str.size()
					? 0 : (size_t)_Iosbase.width() - _Str.size();

			if ((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
				{	
				_Dest = _Rep(_Dest, _Fill, _Fillcount);
				_Fillcount = 0;
				}
			_Dest = _Put(_Dest, _Str.c_str(), _Str.size());	
			_Iosbase.width(0);
			return (_Rep(_Dest, _Fill, _Fillcount));	
			}
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[6];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "lu",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Ld",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
		{	
		char _Buf[2 * 32], _Fmt[8];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), _Ifmt(_Fmt, "Lu",
				_Iosbase.flags()), _Val)));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, double _Val) const
		{	
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabs(_Val))
			{	
			int _Ptwo;
			(void):: frexp(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	

		int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 0, _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, long double _Val) const
		{	
		string _Buf;
		char _Fmt[8];
		bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield)
			== ios_base::fixed;
		streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed
			? 6 : _Iosbase.precision();	
		size_t _Bufsize = (size_t)_Precision;
		if (_Isfixed && 1e10 < :: fabsl(_Val))
			{	
			int _Ptwo;
			(void):: frexpl(_Val, &_Ptwo);
			_Bufsize += :: abs(_Ptwo) * 30103L / 100000L;
			}
		_Buf.resize(_Bufsize + 50);	

		int _Ngen = :: sprintf_s((char *)_Buf.c_str(), _Buf.size(),
			_Ffmt(_Fmt, 'L', _Iosbase.flags()), (int)_Precision, _Val);

		return (_Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen));
		}

	virtual _OutIt  do_put(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const void *_Val) const
		{	
		char _Buf[2 * 32];

		return (_Iput(_Dest, _Iosbase, _Fill, _Buf,
			:: sprintf_s(_Buf, sizeof (_Buf), "%p", _Val)));
		}

private:
	char *__cdecl _Ffmt(char *_Fmt,
		char _Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showpoint)
			*_Ptr++ = '#';
		*_Ptr++ = '.';
		*_Ptr++ = '*';	
		if (_Spec != '\0')
			*_Ptr++ = _Spec;	

		ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
		if (_Flags & ios_base::uppercase)
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'A'	
				: _Ffl == ios_base::scientific ? 'E' : 'G';	
		else
			*_Ptr++ = _Ffl == ios_base::fixed ? 'f'
				: _Ffl == ios_base::hexfloat ? 'a'	
				: _Ffl == ios_base::scientific ? 'e' : 'g';	

		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Fput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, const char *_Buf,
			size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 1414);
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;

		const char *_Exps;
		if ((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
			_Exps = "eE";
		else
			{	
			_Exps = "pP";
			if (_Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
				&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
				_Prefix += 2;
			}
		const size_t _Eoff =
			:: strcspn(&_Buf[0], _Exps);	
		char _Dp[2] = {"."};
		_Dp[0] = :: localeconv()->decimal_point[0];
		const size_t _Poff =
			:: strcspn(&_Buf[0], &_Dp[0]);	

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const _Elem _Kseparator = _Punct_fac.thousands_sep();

		if (_Poff != _Count)
			_Groupstring[_Poff] = _Punct_fac.decimal_point();

		size_t _Off = _Poff == _Count ? _Eoff : _Poff;
		const char *_Pg = &_Grouping[0];
		while (*_Pg != 127 && '\0' < *_Pg
			&& (size_t)*_Pg < _Off - _Prefix)
			{	
			_Groupstring.insert(_Off -= *_Pg, (size_t)1, _Kseparator);
			if ('\0' < _Pg[1])
				++_Pg;	
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	char *__cdecl _Ifmt(char *_Fmt,
		const char *_Spec, ios_base::fmtflags _Flags) const
		{	
		char *_Ptr = _Fmt;
		*_Ptr++ = '%';

		if (_Flags & ios_base::showpos)
			*_Ptr++ = '+';
		if (_Flags & ios_base::showbase)
			*_Ptr++ = '#';
		if (_Spec[0] != 'L')
			*_Ptr++ = _Spec[0];	
		else

			{	
			*_Ptr++ = 'I';
			*_Ptr++ = '6';
			*_Ptr++ = '4';
			}

		ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
		*_Ptr++ = _Basefield == ios_base::oct ? 'o'
			: _Basefield != ios_base::hex ? _Spec[1]	
			: _Flags & ios_base::uppercase ? 'X' : 'x';
		*_Ptr = '\0';
		return (_Fmt);
		}

	_OutIt __cdecl _Iput(_OutIt _Dest,
		ios_base& _Iosbase, _Elem _Fill, char *_Buf, size_t _Count) const
		{	
		_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum", 1516);
		size_t _Prefix = 0 < _Count && (*_Buf == '+' || *_Buf == '-')
			? 1 : 0;
		if ((_Iosbase.flags() & ios_base::basefield) == ios_base::hex
			&& _Prefix + 2 <= _Count && _Buf[_Prefix] == '0'
			&& (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
			_Prefix += 2;

		const ctype<_Elem>& _Ctype_fac =
			use_facet< ctype<_Elem> >(_Iosbase.getloc());
		_Mystr _Groupstring(_Count, _Elem(0));	
		_Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

		const _Mypunct& _Punct_fac = use_facet< _Mypunct >(_Iosbase.getloc());
		const string _Grouping = _Punct_fac.grouping();
		const char *_Pg = &_Grouping[0];
		if (*_Pg != 127 && '\0' < *_Pg)
			{	
			const _Elem _Kseparator = _Punct_fac.thousands_sep();
			while (*_Pg != 127 && '\0' < *_Pg
				&& (size_t)*_Pg < _Count - _Prefix)
				{	
				_Count -= *_Pg;
				_Groupstring.insert(_Count, 1, _Kseparator);
				if ('\0' < _Pg[1])
					++_Pg;	
				}
			}

		_Count = _Groupstring.size();
		size_t _Fillcount = _Iosbase.width() <= 0
			|| (size_t)_Iosbase.width() <= _Count
				? 0 : (size_t)_Iosbase.width() - _Count;

		ios_base::fmtflags _Adjustfield =
			_Iosbase.flags() & ios_base::adjustfield;
		if (_Adjustfield != ios_base::left
			&& _Adjustfield != ios_base::internal)
			{	
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			}
		else if (_Adjustfield == ios_base::internal)
			{	
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
			_Dest = _Rep(_Dest, _Fill, _Fillcount);
			_Fillcount = 0;
			}
		else
			_Dest = _Put(_Dest, &_Groupstring[0], _Prefix);

		_Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
		_Iosbase.width(0);
		return (_Rep(_Dest, _Fill, _Fillcount));	
		}

	_OutIt __cdecl _Put(_OutIt _Dest,
		const _Elem *_Ptr, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)
			*_Dest = *_Ptr;
		return (_Dest);
		}

	_OutIt __cdecl _Rep(_OutIt _Dest,
		_Elem _Ch, size_t _Count) const
		{	
		for (; 0 < _Count; --_Count, (void)++_Dest)
			*_Dest = _Ch;
		return (_Dest);
		}
	};

		
template<class _Elem,
	class _OutIt>
	 locale::id num_put<_Elem, _OutIt>::id;

 

  
template  locale::id numpunct<char>::id;
template class __declspec(dllimport) num_get<char,
	istreambuf_iterator<char, char_traits<char> > >;
template class __declspec(dllimport) num_put<char,
	ostreambuf_iterator<char, char_traits<char> > >;

template  locale::id numpunct<wchar_t>::id;
template class __declspec(dllimport) num_get<wchar_t,
	istreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
template class __declspec(dllimport) num_put<wchar_t,
	ostreambuf_iterator<wchar_t, char_traits<wchar_t> > >;
  #line 1610 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"

  






 #line 1619 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1624 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"
#line 1625 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xlocnum"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
		
template<class _Elem,
	class _Traits>
	class basic_ios
		: public ios_base
	{	
public:
	typedef basic_ios<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ctype<_Elem> _Ctype;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_ios(_Mysb *_Strbuf)
		{	
		init(_Strbuf);
		}

	virtual  ~basic_ios() noexcept
		{	
		}

	void  clear(iostate _State = goodbit,
		bool _Reraise = false)
		{	
		ios_base::clear((iostate)(_Mystrbuf == 0
			? (int)_State | (int)badbit : (int)_State), _Reraise);
		}

 
	void  clear(io_state _State)
		{	
		clear((iostate)_State);
		}
 #line 55 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

	void  setstate(iostate _State,
		bool _Reraise = false)
		{	
		if (_State != goodbit)
			clear((iostate)((int)rdstate() | (int)_State), _Reraise);
		}

 
	void  setstate(io_state _State)
		{	
		setstate((iostate)_State);
		}
 #line 69 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

	_Myt&  copyfmt(const _Myt& _Right)
		{	
		_Tiestr = _Right.tie();
		_Fillch = _Right.fill();
		ios_base::copyfmt(_Right);
		return (*this);
		}

	_Myos * tie() const
		{	
		return (_Tiestr);
		}

	_Myos * tie(_Myos *_Newtie)
		{	
		_Myos *_Oldtie = _Tiestr;
		_Tiestr = _Newtie;
		return (_Oldtie);
		}

	_Mysb * rdbuf() const
		{	
		return (_Mystrbuf);
		}

	_Mysb * rdbuf(_Mysb *_Strbuf)
		{	
		_Mysb *_Oldstrbuf = _Mystrbuf;
		_Mystrbuf = _Strbuf;
		clear();
		return (_Oldstrbuf);
		}

	locale  imbue(const locale& _Loc)
		{	
		locale _Oldlocale = ios_base::imbue(_Loc);
		if (rdbuf() != 0)
			rdbuf()->pubimbue(_Loc);
		return (_Oldlocale);
		}

	_Elem  fill() const
		{	
		return (_Fillch);
		}

	_Elem  fill(_Elem _Newfill)
		{	
		_Elem _Oldfill = _Fillch;
		_Fillch = _Newfill;
		return (_Oldfill);
		}

	char  narrow(_Elem _Ch, char _Dflt = '\0') const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.narrow(_Ch, _Dflt));
		}

	_Elem  widen(char _Byte) const
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(getloc());
		return (_Ctype_fac.widen(_Byte));
		}

	void  move(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  move(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Mystrbuf = 0;
			_Tiestr = 0;
			this->swap(_Right);
			}
		}

	void  swap(_Myt& _Right) noexcept
		{	
		ios_base::swap(_Right);
		::std:: swap(_Fillch, _Right._Fillch);
		::std:: swap(_Tiestr, _Right._Tiestr);
		}

	void  set_rdbuf(_Mysb *_Strbuf)
		{	
		_Mystrbuf = _Strbuf;
		}

protected:
	void  init(_Mysb *_Strbuf = 0,
		bool _Isstd = false)
		{	
		_Init();	
		_Mystrbuf = _Strbuf;
		_Tiestr = 0;
		_Fillch = widen(' ');

		if (_Mystrbuf == 0)
			setstate(badbit);

		if (_Isstd)
			_Addstd(this);	
		}

	 basic_ios()
		{	
		}

private:
	_Mysb *_Mystrbuf;	
	_Myos *_Tiestr;	
	_Elem _Fillch;	

public:
	 basic_ios(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;
	};

 

  
template class __declspec(dllimport) basic_ios<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ios<wchar_t,
	char_traits<wchar_t> >;
  #line 205 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

  



 #line 211 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

		
inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl dec(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::dec, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl fixed(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::fixed, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hex(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hex, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
	return (_Iosbase);
	}


namespace tr1 {	
using ::std:: hexfloat;
}	
#line 254 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"

inline ios_base& __cdecl internal(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::internal, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl left(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::left, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::boolalpha);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
	{	
	_Iosbase.unsetf(ios_base::uppercase);
	return (_Iosbase);
	}

inline ios_base& __cdecl oct(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::oct, ios_base::basefield);
	return (_Iosbase);
	}

inline ios_base& __cdecl right(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::right, ios_base::adjustfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl scientific(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::scientific, ios_base::floatfield);
	return (_Iosbase);
	}

inline ios_base& __cdecl showbase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showbase);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpoint);
	return (_Iosbase);
	}

inline ios_base& __cdecl showpos(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::showpos);
	return (_Iosbase);
	}

inline ios_base& __cdecl skipws(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::skipws);
	return (_Iosbase);
	}

inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::unitbuf);
	return (_Iosbase);
	}

inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
	{	
	_Iosbase.setf(ios_base::uppercase);
	return (_Iosbase);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 368 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"
#line 369 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ios"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189 4390)

namespace std {
		

 
 

 



 



 



#line 34 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_ostream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_ostream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef ostreambuf_iterator<_Elem, _Traits> _Iter;
	typedef num_put<_Elem, _Iter> _Nput;

	explicit  basic_ostream(
		basic_streambuf<_Elem, _Traits> *_Strbuf,

		bool _Isstd = false)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_ostream(_Uninitialized, bool _Addit = true)
		{	
		if (_Addit)
			this->_Addstd(this);	
		}

protected:
	 basic_ostream(_Myt&& _Right)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_ostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_ostream() noexcept
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Ostr)
			: _Myostr(_Ostr)
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	
			if (_Myostr.rdbuf() != 0)
				_Myostr.rdbuf()->_Unlock();
			}

		_Myt& _Myostr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Ostr)
			: _Sentry_base(_Ostr)
			{	
			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)
				_Ostr.tie()->flush();
			_Ok = _Ostr.good();	
			}

		 ~sentry() noexcept
			{	
 
			if (!::std:: uncaught_exception())
				this->_Myostr._Osfx();

 

#line 138 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	
		};

	bool  opfx()
		{	
		if (this->good() && _Myios::tie() != 0 && _Myios::tie() != this)
			_Myios::tie()->flush();
		return (this->good());
		}

	void  osfx()
		{	
		_Osfx();
		}

	void  _Osfx()
		{	
		try {
		if (this->good() && this->flags() & ios_base::unitbuf)
			if (_Myios::rdbuf()->pubsync() == -1)	
				_Myios::setstate(ios_base::badbit);
		} catch (...) {
		}
		}

  





















	_Myt&  operator<<(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 198);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator<<(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 204);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator<<(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 211);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator<<(bool _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned short)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator<<(unsigned short _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());
			ios_base::fmtflags _Bfl =
				this->flags() & ios_base::basefield;
			long _Tmp = (_Bfl == ios_base::oct
				|| _Bfl == ios_base::hex)
				? (long)(unsigned int)_Val : (long)_Val;

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Tmp).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned int _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (unsigned long)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(unsigned long long _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(float _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), (double)_Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(long double _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(const void *_Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nput& _Nput_fac = use_facet< _Nput >(this->getloc());

			try {
			if (_Nput_fac.put(_Iter(_Myios::rdbuf()), *this,
				_Myios::fill(), _Val).failed())
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator<<(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			for (int_type _Meta = _Traits::eof(); ; _Copied = true)
				{	
				try {
				_Meta = _Traits::eq_int_type(_Traits::eof(), _Meta)
					? _Strbuf->sgetc() : _Strbuf->snextc();
				} catch (...) {
					_Myios::setstate(ios_base::failbit);
					throw;
				}

				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					break;	

				try {
					if (_Traits::eq_int_type(_Traits::eof(),
						_Myios::rdbuf()->sputc(
							_Traits::to_char_type(_Meta))))
						{	
						_State |= ios_base::badbit;
						break;
						}
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

		this->width(0);
		_Myios::setstate(_Strbuf == 0 ? ios_base::badbit
			: !_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  put(_Elem _Ch)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputc(_Ch)))
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  write(const _Elem *_Str,
		streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (!_Ok)
			_State |= ios_base::badbit;
		else if (0 < _Count)
			{	
			_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream", 562);
			try {
			if (_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
				_State |= ios_base::badbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  flush()
		{	
		if (_Myios::rdbuf() != 0)
			{	
			const sentry _Ok(*this);

			if (_Ok && _Myios::rdbuf()->pubsync() == -1)
				_Myios::setstate(ios_base::badbit);	
			}
		return (*this);
		}

	_Myt&  seekp(pos_type _Pos)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	_Myt&  seekp(off_type _Off, ios_base::seekdir _Way)
		{	
		const sentry _Ok(*this);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::out) == _BADOFF)
			_Myios::setstate(ios_base::failbit);
		return (*this);
		}

	pos_type  tellp()
		{	
		const sentry _Ok(*this);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::out));
		else
			return (pos_type(_BADOFF));
		}
	};

 #pragma vtordisp(pop)	

	

  

















































 

  
template class __declspec(dllimport) basic_ostream<char,
	char_traits<char> >;
template class __declspec(dllimport) basic_ostream<wchar_t,
	char_traits<wchar_t> >;
  #line 681 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

  



 #line 687 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"

		

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const char *_Val)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize):: strlen(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		for (; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
	{	
	ios_base::iostate _State = ios_base::goodbit;
	const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		const ctype<_Elem>& _Ctype_fac = use_facet< ctype<_Elem> >(_Ostr.getloc());
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr,
		const char *_Val)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, char _Ch)
	{	
	typedef char _Elem;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, const _Elem *_Val)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	streamsize _Count = (streamsize)_Traits::length(_Val);	
	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count
		? 0 : _Ostr.width() - _Count;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
			_State |= ios_base::badbit;

		if (_State == ios_base::goodbit)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;

	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myos::sentry _Ok(_Ostr);

	if (_Ok)
		{	
		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

		try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; _State == ios_base::goodbit && 0 < _Pad;
				--_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					_State |= ios_base::badbit;

		if (_State == ios_base::goodbit
			&& _Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ch)))
			_State |= ios_base::badbit;

		for (; _State == ios_base::goodbit && 0 < _Pad;
			--_Pad)	
			if (_Traits::eq_int_type(_Traits::eof(),
				_Ostr.rdbuf()->sputc(_Ostr.fill())))
				_State |= ios_base::badbit;
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.width(0);
	_Ostr.setstate(_State);
	return (_Ostr);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const signed char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, const unsigned char *_Val)
	{	
	return (_Ostr << (const char *)_Val);
	}

template<class _Traits> inline
	basic_ostream<char, _Traits>& operator<<(
		basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
	{	
	return (_Ostr << (char)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>&& _Ostr, const _Ty& _Val)
	{	
	return (_Ostr << _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Ostr.widen('\n'));
	_Ostr.flush();
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.put(_Elem());
	return (_Ostr);
	}

template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		__cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
	{	
	_Ostr.flush();
	return (_Ostr);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_ostream<_Elem, _Traits>&
		operator<<(basic_ostream<_Elem, _Traits>& _Ostr,
			const error_code& _Errcode)
	{	
	return (_Ostr << _Errcode.category().name() << ':' << _Errcode.value());
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1030 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"
#line 1031 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\ostream"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)

namespace std {
 #pragma vtordisp(push, 2)	

		
template<class _Elem,
	class _Traits>
	class basic_istream
		: virtual public basic_ios<_Elem, _Traits>
	{	
public:
	typedef basic_istream<_Elem, _Traits> _Myt;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef istreambuf_iterator<_Elem, _Traits> _Iter;
	typedef ctype<_Elem> _Ctype;
	typedef num_get<_Elem, _Iter> _Nget;

  







#line 41 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

	explicit  basic_istream(_Mysb *_Strbuf,
		bool _Isstd = false)

		: _Chcount(0)
		{	
		_Myios::init(_Strbuf, _Isstd);
		}

	 basic_istream(_Uninitialized)
		{	
		this->_Addstd(this);
		}

protected:
	 basic_istream(_Myt&& _Right)
		: _Chcount(_Right._Chcount)
		{	
		_Myios::init();
		_Myios::move(::std:: move(_Right));
		_Right._Chcount = 0;
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		_Myios::swap(_Right);
		::std:: swap(_Chcount, _Right._Chcount);
		}

public:
	 basic_istream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_istream() noexcept
		{	
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

		
	class _Sentry_base
		{	
	public:
		 _Sentry_base(_Myt& _Istr)
			: _Myistr(_Istr)
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Lock();
			}

		 ~_Sentry_base() noexcept
			{	
			if (_Myistr.rdbuf() != 0)
				_Myistr.rdbuf()->_Unlock();
			}

		_Myt& _Myistr;	

	private:
		_Sentry_base& operator=(const _Sentry_base&);
		};

	class sentry
		: public _Sentry_base
		{	
	public:
		explicit  sentry(_Myt& _Istr, bool _Noskip = false)
			: _Sentry_base(_Istr)
			{	
			_Ok = this->_Myistr._Ipfx(_Noskip);
			}

		explicit  operator bool() const
			{	
			return (_Ok);
			}

		 sentry(const sentry&) = delete;
		sentry&  operator=(const sentry&) = delete;

	private:
		bool _Ok;	
		};

	bool  _Ipfx(bool _Noskip = false)
		{	
		if (this->good())
			{	
			if (_Myios::tie() != 0)
				_Myios::tie()->flush();

			if (!_Noskip && this->flags() & ios_base::skipws)
				{	
				const _Ctype& _Ctype_fac = use_facet< _Ctype >(this->getloc());

				try {
				int_type _Meta = _Myios::rdbuf()->sgetc();

				for (; ; _Meta = _Myios::rdbuf()->snextc())
					if (_Traits::eq_int_type(_Traits::eof(), _Meta))
						{	
						_Myios::setstate(ios_base::eofbit);
						break;
						}
					else if (!_Ctype_fac.is(_Ctype::space,
						_Traits::to_char_type(_Meta)))
						break;	
				} catch (...) { _Myios::setstate(ios_base::badbit, true); }
				}

			if (this->good())
				return (true);
			}
		_Myios::setstate(ios_base::failbit);
		return (false);
		}

	bool  ipfx(bool _Noskip = false)
		{	
		return (_Ipfx(_Noskip));
		}

	void  isfx()
		{	
		}

  





















	_Myt&  operator>>(_Myt& (__cdecl *_Pfn)(_Myt&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 199);
		return ((*_Pfn)(*this));
		}

	_Myt&  operator>>(_Myios& (__cdecl *_Pfn)(_Myios&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 205);
		(*_Pfn)(*(_Myios *)this);
		return (*this);
		}

	_Myt&  operator>>(ios_base& (__cdecl *_Pfn)(ios_base&))
		{	
		_Debug_pointer(_Pfn, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 212);
		(*_Pfn)(*(ios_base *)this);
		return (*this);
		}

	_Myt&  operator>>(bool& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-32768) || 32767 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = (short)_Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}










	_Myt&  operator>>(unsigned short& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			long _Tmp = 0;
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Tmp);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }

			if (_State & ios_base::failbit
				|| _Tmp < (-2147483647 - 1) || 2147483647 < _Tmp)
				_State |= ios_base::failbit;
			else
				_Val = _Tmp;
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned int& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(unsigned long long& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(float& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);
		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(long double& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());
			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(void *& _Val)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const sentry _Ok(*this);

		if (_Ok)
			{	
			const _Nget& _Nget_fac = use_facet< _Nget >(this->getloc());

			try {
			_Nget_fac.get(_Iter(_Myios::rdbuf()), _Iter(0),
				*this, _State, _Val);
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  operator>>(_Mysb *_Strbuf)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		bool _Copied = false;
		const sentry _Ok(*this);

		if (_Ok && _Strbuf != 0)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						if (_Traits::eq_int_type(_Traits::eof(),
							_Strbuf->sputc(_Traits::to_char_type(_Meta))))
							break;
					} catch (...) {
						break;
					}
					_Copied = true;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(!_Copied ? _State | ios_base::failbit : _State);
		return (*this);
		}

	int_type  get()
		{	
		int_type _Meta = 0;
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			_Meta = _Myios::rdbuf()->sgetc();

			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				_State |= ios_base::eofbit | ios_base::failbit;	
			else
				{	
				_Myios::rdbuf()->sbumpc();
				++_Chcount;
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  get(_Elem *_Str, streamsize _Count)
		{	
		return (get(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  get(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Traits::to_char_type(_Meta) == _Delim)
					break;	
				else
					{	
					_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 572);
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_Chcount == 0
			? _State | ios_base::failbit : _State);
		*_Str = _Elem();	
		return (*this);
		}

	_Myt&  get(_Elem& _Ch)
		{	
		int_type _Meta = get();
		if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
			_Ch = _Traits::to_char_type(_Meta);
		return (*this);
		}

	_Myt&  get(_Mysb& _Strbuf)
		{	
		return (get(_Strbuf, _Myios::widen('\n')));
		}

	_Myt&  get(_Mysb& _Strbuf, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					try {
						_Elem _Ch = _Traits::to_char_type(_Meta);
						if (_Ch == _Delim
							|| _Traits::eq_int_type(_Traits::eof(),
								_Strbuf.sputc(_Ch)))
							break;
					} catch (...) {
						break;
					}
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		if (_Chcount == 0)
			_State |= ios_base::failbit;
		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  getline(_Elem *_Str, streamsize _Count)
		{	
		return (getline(_Str, _Count, _Myios::widen('\n')));
		}

	_Myt&  getline(_Elem *_Str,
		streamsize _Count, _Elem _Delim)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			int_type _Metadelim = _Traits::to_int_type(_Delim);

			try {
			int_type _Meta = _Myios::rdbuf()->sgetc();

			for (; ; _Meta = _Myios::rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (_Meta == _Metadelim)
					{	
					++_Chcount;
					_Myios::rdbuf()->sbumpc();
					break;
					}
				else if (--_Count <= 0)
					{	
					_State |= ios_base::failbit;
					break;
					}
				else
					{	
					_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 675);
					*_Str++ = _Traits::to_char_type(_Meta);
					++_Chcount;
					}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		*_Str = _Elem();	
		_Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
		return (*this);
		}

	_Myt&  ignore(streamsize _Count = 1,
		int_type _Metadelim = _Traits::eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			for (; ; )
				{	
				int_type _Meta;
				if (_Count != (numeric_limits<streamsize>::max)()
					&& --_Count < 0)
					break;	
				else if (_Traits::eq_int_type(_Traits::eof(),
					_Meta = _Myios::rdbuf()->sbumpc()))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else
					{	
					++_Chcount;
					if (_Meta == _Metadelim)
						break;	
					}
				}
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  read(_Elem *_Str, streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);

		if (_Ok && 0 < _Count)
			{	
			try {
			_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 732);
			const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
			_Chcount += _Num;
			if (_Num != _Count)
				_State |= ios_base::eofbit | ios_base::failbit;	
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  readsome(_Elem *_Str,
		streamsize _Count)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		const sentry _Ok(*this, true);
		streamsize _Num;

		if (!_Ok)
			_State |= ios_base::failbit;	
		else if ((_Num = _Myios::rdbuf()->in_avail()) < 0)
			_State |= ios_base::eofbit;	
		else if (0 < _Count && 0 < _Num)
			{	
			_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 758);
			read(_Str, _Num < _Count ? _Num : _Count);	
			}

		_Myios::setstate(_State);
		return (gcount());
		}

	int_type  peek()
		{	
		ios_base::iostate _State = ios_base::goodbit;
		_Chcount = 0;
		int_type _Meta = 0;
		const sentry _Ok(*this, true);

		if (!_Ok)
			_Meta = _Traits::eof();	
		else
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Meta = _Myios::rdbuf()->sgetc()))
				_State |= ios_base::eofbit;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (_Meta);
		}

	_Myt&  putback(_Elem _Ch)
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sputbackc(_Ch)))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	_Myt&  unget()
		{	
		_Chcount = 0;
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (_Ok)
			{	
			try {
			if (_Traits::eq_int_type(_Traits::eof(),
				_Myios::rdbuf()->sungetc()))
				_State |= ios_base::badbit | _Oldstate;
			} catch (...) { _Myios::setstate(ios_base::badbit, true); }
			}

		_Myios::setstate(_State);
		return (*this);
		}

	streamsize  gcount() const
		{	
		return (_Chcount);
		}

	int  sync()
		{	
		const sentry _Ok(*this, true);

		if (_Myios::rdbuf() == 0)
			return (-1);
		else if (_Myios::rdbuf()->pubsync() == -1)
			{	
			_Myios::setstate(ios_base::badbit);
			return (-1);
			}
		else
			return (0);
		}

	_Myt&  seekg(pos_type _Pos)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekpos(_Pos,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	_Myt&  seekg(off_type _Off, ios_base::seekdir _Way)
		{	
		ios_base::iostate _State = ios_base::goodbit;
		ios_base::iostate _Oldstate = _Myios::rdstate();
		_Myios::clear(_Oldstate & ~ios_base::eofbit);
		const sentry _Ok(*this, true);

		if (!this->fail()
			&& (off_type)_Myios::rdbuf()->pubseekoff(_Off, _Way,
				ios_base::in) == _BADOFF)
			_Myios::setstate(_State | ios_base::failbit);
		return (*this);
		}

	pos_type  tellg()
		{	
		const sentry _Ok(*this, true);

		if (!this->fail())
			return (_Myios::rdbuf()->pubseekoff(0,
				ios_base::cur, ios_base::in));
		else
			return (pos_type(_BADOFF));
		}

private:
	streamsize _Chcount;	
	};

	

 #pragma vtordisp(pop)	

  






















 

  
template class __declspec(dllimport) basic_istream<char, char_traits<char> >;
template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t> >;
  #line 926 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

  



 #line 932 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

		
template<class _Elem,
	class _Traits>
	class basic_iostream
	: public basic_istream<_Elem, _Traits>,
		public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_iostream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	explicit  basic_iostream(basic_streambuf<_Elem, _Traits> *_Strbuf)
		: _Myis(_Strbuf, false),
			_Myos(_Noinit, false)
		{	
		}

protected:
	 basic_iostream(_Myt&& _Right)
		: _Myis(_Right.rdbuf(), false),
			_Myos(_Noinit, false)
		{	
		_Myios::init();
		_Myios::move(::std:: forward<_Myt>(_Right));
		}

	_Myt&  operator=(_Myt&& _Right)
		{	
		this->swap(_Right);
		return (*this);
		}

	void  swap(_Myt& _Right)
		{	
		if (this != &_Right)
			_Myios::swap(_Right);
		}

public:
	 basic_iostream(const _Myt&) = delete;
	_Myt&  operator=(const _Myt&) = delete;

	virtual  ~basic_iostream() noexcept
		{	
		}
	};

	

 

  
template class __declspec(dllimport) basic_iostream<char, char_traits<char> >;
template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t> >;
  #line 995 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

  



 #line 1001 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"

		

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem *_Str)
	{	
	_Debug_pointer(_Str, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream", 1009);
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;
	ios_base::iostate _State = ios_base::goodbit;
	_Elem *_Str0 = _Str;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

		try {
		streamsize _Count = 0 < _Istr.width() ? _Istr.width()
			: (numeric_limits<streamsize>::max)();
		typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
		_Elem _Ch;
		for (; 0 < --_Count; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Ch = _Traits::to_char_type(_Meta))
					|| _Ch == _Elem())
				break;	
			else
				*_Str++ = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	*_Str = _Elem();	
	_Istr.width(0);
	_Istr.setstate(_Str == _Str0 ? _State | ios_base::failbit : _State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	typename _Myis::int_type _Meta;
	ios_base::iostate _State = ios_base::goodbit;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		try {
		_Meta = _Istr.rdbuf()->sbumpc();
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			_State |= ios_base::eofbit | ios_base::failbit;	
		else
			_Ch = _Traits::to_char_type(_Meta);	
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, signed char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char *_Str)
	{	
	return (_Istr >> (char *)_Str);
	}

template<class _Traits> inline
	basic_istream<char, _Traits>& operator>>(
		basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
	{	
	return (_Istr >> (char&)_Ch);
	}

template<class _Elem,
	class _Traits,
	class _Ty> inline
	basic_istream<_Elem, _Traits>&
		operator>>(basic_istream<_Elem, _Traits>&& _Istr, _Ty& _Val)
	{	
	return (_Istr >> _Val);
	}

		
template<class _Elem,
	class _Traits> inline
	basic_istream<_Elem, _Traits>&
		__cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef ctype<_Elem> _Ctype;

	if (!_Istr.eof())
		{	
		ios_base::iostate _State = ios_base::goodbit;
		const typename _Myis::sentry _Ok(_Istr, true);

		if (_Ok)
			{	
			const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());

			try {
			for (typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc(); ;
				_Meta = _Istr.rdbuf()->snextc())
				if (_Traits::eq_int_type(_Traits::eof(), _Meta))
					{	
					_State |= ios_base::eofbit;
					break;
					}
				else if (!_Ctype_fac.is(_Ctype::space,
					_Traits::to_char_type(_Meta)))
					break;	
			} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
			}

		_Istr.setstate(_State);
		}
	return (_Istr);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1151 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"
#line 1152 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\istream"






#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4189)
 #pragma warning(disable: 4172)
 #pragma warning(disable: 4455)

namespace std {
		
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef ctype<_Elem> _Ctype;
	typedef basic_istream<_Elem, _Traits> _Myis;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr);

	if (_Ok)
		{	
		const _Ctype& _Ctype_fac = use_facet< _Ctype >(_Istr.getloc());
		_Str.erase();

		try {
		_Mysizt _Size = 0 < _Istr.width()
			&& (_Mysizt)_Istr.width() < _Str.max_size()
				? (_Mysizt)_Istr.width() : _Str.max_size();
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Ctype_fac.is(_Ctype::space,
				_Traits::to_char_type(_Meta)))
				break;	
			else
				{	
				_Str.append(1, _Traits::to_char_type(_Meta));
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	_Istr.width(0);
	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	typedef basic_istream<_Elem, _Traits> _Myis;

	ios_base::iostate _State = ios_base::goodbit;
	bool _Changed = false;
	const typename _Myis::sentry _Ok(_Istr, true);

	if (_Ok)
		{	
		try {
		_Str.erase();
		const typename _Traits::int_type _Metadelim =
			_Traits::to_int_type(_Delim);
		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

		for (; ; _Meta = _Istr.rdbuf()->snextc())
			if (_Traits::eq_int_type(_Traits::eof(), _Meta))
				{	
				_State |= ios_base::eofbit;
				break;
				}
			else if (_Traits::eq_int_type(_Meta, _Metadelim))
				{	
				_Changed = true;
				_Istr.rdbuf()->sbumpc();
				break;
				}
			else if (_Str.max_size() <= _Str.size())
				{	
				_State |= ios_base::failbit;
				break;
				}
			else
				{	
				_Str += _Traits::to_char_type(_Meta);
				_Changed = true;
				}
		} catch (...) { (_Istr).setstate(ios_base::badbit, true); }
		}

	if (!_Changed)
		_State |= ios_base::failbit;
	_Istr.setstate(_State);
	return (_Istr);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>&& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(_Istr, _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& operator>>(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (::std:: move(_Istr) >> _Str);
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str,
		const _Elem _Delim)
	{	
	return (getline(::std:: move(_Istr), _Str, _Delim));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_istream<_Elem, _Traits>& getline(
		basic_istream<_Elem, _Traits>& _Istr,
		basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	return (getline(::std:: move(_Istr), _Str, _Istr.widen('\n')));
	}

template<class _Elem,
	class _Traits,
	class _Alloc> inline
	basic_ostream<_Elem, _Traits>& operator<<(
		basic_ostream<_Elem, _Traits>& _Ostr,
		const basic_string<_Elem, _Traits, _Alloc>& _Str)
	{	
	typedef basic_ostream<_Elem, _Traits> _Myos;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
	typedef typename _Mystr::size_type _Mysizt;

	ios_base::iostate _State = ios_base::goodbit;
	_Mysizt _Size = _Str.size();
	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size
		? 0 : (_Mysizt)_Ostr.width() - _Size;
	const typename _Myos::sentry _Ok(_Ostr);

	if (!_Ok)
		_State |= ios_base::badbit;
	else
		{	
	try {
		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}

		if (_State == ios_base::goodbit
			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)
				!= (streamsize)_Size)
				_State |= ios_base::badbit;
		else
			for (; 0 < _Pad; --_Pad)	
				if (_Traits::eq_int_type(_Traits::eof(),
					_Ostr.rdbuf()->sputc(_Ostr.fill())))
					{	
					_State |= ios_base::badbit;
					break;
					}
		_Ostr.width(0);
		} catch (...) { (_Ostr).setstate(ios_base::badbit, true); }
		}

	_Ostr.setstate(_State);
	return (_Ostr);
	}

		

inline int stoi(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: strtol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: strtoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long long _Ans = :: strtoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const string& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	unsigned long long _Ans = :: strtoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	float _Ans = :: strtof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	double _Ans = :: strtod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const string& _Str, size_t *_Idx = 0)
	{	
	const char *_Ptr = _Str.c_str();
	char *_Eptr;
	(*_errno()) = 0;
	long double _Ans = :: strtold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		
inline int stoi(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoi argument");
	if ((*_errno()) == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
		_Xout_of_range("stoi argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return ((int)_Ans);
	}

inline long stol(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long _Ans = :: wcstol(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stol argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stol argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long stoul(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long _Ans = :: wcstoul(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoul argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoul argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long long stoll(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long long _Ans = :: wcstoll(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoll argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoll argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline unsigned long long stoull(const wstring& _Str, size_t *_Idx = 0,
	int _Base = 10)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	unsigned long long _Ans = :: wcstoull(_Ptr, &_Eptr, _Base);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stoull argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stoull argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline float stof(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	float _Ans = :: wcstof(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stof argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stof argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline double stod(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	double _Ans = :: wcstod(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stod argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stod argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

inline long double stold(const wstring& _Str, size_t *_Idx = 0)
	{	
	const wchar_t *_Ptr = _Str.c_str();
	wchar_t *_Eptr;
	(*_errno()) = 0;
	long double _Ans = :: wcstold(_Ptr, &_Eptr);

	if (_Ptr == _Eptr)
		_Xinvalid_argument("invalid stold argument");
	if ((*_errno()) == 34)
		_Xout_of_range("stold argument out of range");
	if (_Idx != 0)
		*_Idx = (size_t)(_Eptr - _Ptr);
	return (_Ans);
	}

		
 #pragma warning(push)
 #pragma warning(disable: 4127) 
template<class _Elem,
	class _UTy> inline
	_Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal)
	{	
	static_assert(is_unsigned<_UTy>::value, "_UTy must be unsigned");




	if (sizeof(_UTy) > 4)
		{	
		while (_UVal > 0xFFFFFFFFU)
			{
			auto _UVal_chunk = static_cast<_Uint32t>(_UVal % 1000000000);
			_UVal /= 1000000000;

			for (int _Idx = 0; _Idx != 9; ++_Idx)
				{
				*--_RNext = '0' + _UVal_chunk % 10;
				_UVal_chunk /= 10;
				}
			}
		}

	auto _UVal_trunc = static_cast<_Uint32t>(_UVal);
#line 513 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"

	do
		{
		*--_RNext = '0' + _UVal_trunc % 10;
		_UVal_trunc /= 10;
		}
	while (_UVal_trunc != 0);
	return (_RNext);
	}
 #pragma warning(pop)

template<class _Elem,
	class _Ty> inline
	basic_string<_Elem> _Integral_to_string(const _Ty _Val)
	{	
	static_assert(is_integral<_Ty>::value, "_Ty must be integral");
	using _UTy = make_unsigned_t<_Ty>;
	_Elem _Buff[21]; 
	_Elem* const _Buff_end = ::std:: end(_Buff);
	_Elem* _RNext = _Buff_end;
	auto _UVal = static_cast<_UTy>(_Val);
	if (_Val < 0)
		{
		_RNext = _UIntegral_to_buff(_RNext, 0 - _UVal);
		*--_RNext = '-';
		}
	else
		_RNext = _UIntegral_to_buff(_RNext, _UVal);

	return (basic_string<_Elem>(_RNext, _Buff_end));
	}

template<class _Ty> inline
	string _Floating_to_string(const char *_Fmt, _Ty _Val)
	{	
	static_assert(is_floating_point<_Ty>::value,
		"_Ty must be floating point");

	int _Len = :: _scprintf(_Fmt, _Val);
	string _Str(_Len + 1, '\0');
	:: sprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}

template<class _Ty> inline
	wstring _Floating_to_wstring(const wchar_t *_Fmt, _Ty _Val)
	{	
	static_assert(is_floating_point<_Ty>::value,
		"_Ty must be floating point");

	int _Len = :: _scwprintf(_Fmt, _Val);
	wstring _Str(_Len + 1, L'\0');
	:: swprintf_s(&_Str[0], _Len + 1, _Fmt, _Val);
	_Str.resize(_Len);
	return (_Str);
	}



		
inline string to_string(int _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(unsigned int _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(long _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(unsigned long _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(long long _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(unsigned long long _Val)
	{	
	return (_Integral_to_string<char>(_Val));
	}

inline string to_string(float _Val)
	{	
	return (_Floating_to_string("%f", _Val));
	}

inline string to_string(double _Val)
	{	
	return (_Floating_to_string("%f", _Val));
	}

inline string to_string(long double _Val)
	{	
	return (_Floating_to_string("%Lf", _Val));
	}

		
inline wstring to_wstring(int _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(unsigned int _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(long _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(unsigned long _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(long long _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(unsigned long long _Val)
	{	
	return (_Integral_to_string<wchar_t>(_Val));
	}

inline wstring to_wstring(float _Val)
	{	
	return (_Floating_to_wstring(L"%f", _Val));
	}

inline wstring to_wstring(double _Val)
	{	
	return (_Floating_to_wstring(L"%f", _Val));
	}

inline wstring to_wstring(long double _Val)
	{	
	return (_Floating_to_wstring(L"%Lf", _Val));
	}

	





inline namespace literals {
inline namespace string_literals {
inline string operator "" s(const char *_Str, size_t _Len)
	{	
	return (string(_Str, _Len));
	}

inline wstring operator "" s(const wchar_t *_Str, size_t _Len)
	{	
	return (wstring(_Str, _Len));
	}

inline u16string operator "" s(const char16_t *_Str, size_t _Len)
	{	
	return (u16string(_Str, _Len));
	}

inline u32string operator "" s(const char32_t *_Str, size_t _Len)
	{	
	return (u32string(_Str, _Len));
	}
}	
}	





}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 705 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"
#line 706 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\string"





#line 3 "d:\\users\\stasw\\documents\\virheimur\\game - client\\text.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"

#pragma once




#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"

#pragma once







 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
	
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_implicit_val0
		: false_type
	{	
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_implicit_val0<true, tuple<_Dests...>, _Srcs...>
		: conjunction<
			is_constructible<_Dests, _Srcs>...,
			is_convertible<_Srcs, _Dests>...
		>::type
	{	
	};

template<class _Dest,
	class... _Srcs>
	struct _Tuple_implicit_val
		: _Tuple_implicit_val0<tuple_size<_Dest>::value == sizeof...(_Srcs), _Dest, _Srcs...>::type
	{	
	};

template<class _Dest,
	class... _Srcs>
	using _Tuple_implicit_t = enable_if_t<_Tuple_implicit_val<_Dest, _Srcs...>::value, int>;

	
template<bool _Same,
	class _Dest,
	class... _Srcs>
	struct _Tuple_explicit_val0
		: false_type
	{	
	};

template<class... _Dests,
	class... _Srcs>
	struct _Tuple_explicit_val0<true, tuple<_Dests...>, _Srcs...>
		: conjunction<
			is_constructible<_Dests, _Srcs>...,
			negation<conjunction<is_convertible<_Srcs, _Dests>...>>
		>::type
	{	
	};

template<class _Dest,
	class... _Srcs>
	struct _Tuple_explicit_val
		: _Tuple_explicit_val0<tuple_size<_Dest>::value == sizeof...(_Srcs), _Dest, _Srcs...>::type
	{	
	};

template<class _Dest,
	class... _Srcs>
	using _Tuple_explicit_t = enable_if_t<_Tuple_explicit_val<_Dest, _Srcs...>::value, int>;

	
template<class _Myt,
	class... _Other>
	struct _Tuple_convert_copy
	{	
	typedef int type;
	};

template<class _This,
	class _Uty>
	struct _Tuple_convert_copy<tuple<_This>, _Uty>
		: enable_if<!is_same<_This, _Uty>::value
			&& !is_constructible<_This, const tuple<_Uty>&>::value
			&& !is_convertible<const tuple<_Uty>&, _This>::value, int>
	{	
	};

template<class _Myt,
	class... _Other>
	using _Tuple_convert_copy_t = typename _Tuple_convert_copy<_Myt, _Other...>::type;

	
template<class _Myt,
	class... _Other>
	struct _Tuple_convert_move
	{	
	typedef int type;
	};

template<class _This,
	class _Uty>
	struct _Tuple_convert_move<tuple<_This>, _Uty>
		: enable_if<!is_same<_This, _Uty>::value
			&& !is_constructible<_This, tuple<_Uty> >::value
			&& !is_convertible<tuple<_Uty>, _This>::value, int>
	{	
	};

template<class _Myt,
	class... _Other>
	using _Tuple_convert_move_t = typename _Tuple_convert_move<_Myt, _Other...>::type;

	
template<class _Myt,
	class _This2,
	class... _Rest2>
	struct _Tuple_perfect_val
		: true_type
	{	
	};

template<class _Myt,
	class _This2>
	struct _Tuple_perfect_val<_Myt, _This2>
		: negation<is_same<_Myt, remove_const_t<remove_reference_t<_This2>>>>::type
	{	
	};

	
struct _Ignore
	{	
	template<class _Ty>
		void operator=(const _Ty&) const
		{	
		}
	};

constexpr _Ignore ignore{};

		
struct _Tuple_alloc_t
	{	
	};

constexpr _Tuple_alloc_t _Tuple_alloc{};

	
template<class _Ty>
	struct _Tuple_val
	{	
	constexpr _Tuple_val()
		: _Val()
		{	
		}

	template<class _Other>
		constexpr _Tuple_val(_Other&& _Arg)
		: _Val(::std:: forward<_Other>(_Arg))
		{	
		}

	template<class _Other>
		_Tuple_val& operator=(_Other&& _Right)
		{	
		_Val = ::std:: forward<_Other>(_Right);
		return (*this);
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc&,
			typename enable_if<!uses_allocator<_Ty, _Alloc>::value,
				_Tuple_alloc_t>::type, _Other&&... _Arg)
		: _Val(::std:: forward<_Other>(_Arg)...)
		{	
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc& _Al,
			typename enable_if<uses_allocator<_Ty, _Alloc>::value
				&& is_constructible<_Ty,
					allocator_arg_t, _Alloc>::value,
				_Tuple_alloc_t>::type, _Other&&... _Arg)
		: _Val(allocator_arg, _Al, ::std:: forward<_Other>(_Arg)...)
		{	
		}

	template<class _Alloc,
		class... _Other>
		_Tuple_val(const _Alloc& _Al,
			typename enable_if<uses_allocator<_Ty, _Alloc>::value
				&& !is_constructible<_Ty,
					allocator_arg_t, _Alloc>::value,
				_Tuple_alloc_t>::type, _Other&&... _Arg)
		: _Val(::std:: forward<_Other>(_Arg)..., _Al)
		{	
		}

	_Ty _Val;
	};

	
struct _Exact_args_t
	{	
	};

struct _Unpack_tuple_t
	{	
	};

struct _Alloc_exact_args_t
	{	
	};

struct _Alloc_unpack_tuple_t
	{	
	};

template<class... _Types>
	class tuple;

template<>
	class tuple<>
	{	
public:
	typedef tuple<> _Myt;

	constexpr tuple() noexcept
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&) noexcept
		{	
		}

	constexpr tuple(const tuple&) noexcept
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc&, const _Myt&) noexcept
		{	
		}

	template<class _Tag,
		enable_if_t<is_same<_Tag, _Exact_args_t>::value, int> = 0>
		constexpr tuple(_Tag) noexcept
		{	
		}

	template<class _Tag,
		enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int> = 0>
		constexpr tuple(_Tag, const _Myt&) noexcept
		{	
		}

	template<class _Tag,
		class _Alloc,
		enable_if_t<is_same<_Tag, _Alloc_exact_args_t>::value, int> = 0>
		tuple(_Tag, const _Alloc&) noexcept
		{	
		}

	void swap(_Myt&) noexcept
		{	
		}

	constexpr bool _Equals(const _Myt&) const noexcept
		{	
		return (true);
		}

	constexpr bool _Less(const _Myt&) const noexcept
		{	
		return (false);
		}
	};

template<class _This,
	class... _Rest>
	class tuple<_This, _Rest...>
		: private tuple<_Rest...>
	{	
public:
	typedef _This _This_type;
	typedef tuple<_This, _Rest...> _Myt;
	typedef tuple<_Rest...> _Mybase;
	static constexpr size_t _Mysize = 1 + sizeof...(_Rest);

	template<class _Tag,
		class _This2,
		class... _Rest2,
		enable_if_t<is_same<_Tag, _Exact_args_t>::value, int> = 0>
		constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(::std:: forward<_This2>(_This_arg))
		{	
		}




















	template<class _Tag,
		class... _Other,
		enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int> = 0>
		constexpr tuple(_Tag, const tuple<_Other...>& _Right)
		: _Mybase(_Unpack_tuple_t{}, _Right._Get_rest()),
			_Myfirst(_Right._Myfirst._Val)
		{	
		}

	template<class _Tag,
		class... _Other,
		enable_if_t<is_same<_Tag, _Unpack_tuple_t>::value, int> = 0>
		constexpr tuple(_Tag, tuple<_Other...>&& _Right)
		: _Mybase(_Unpack_tuple_t{}, (typename tuple<_Other...>::_Mybase&&) _Right),
			_Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val))
		{	
		}

	template<class _Tag,
		class _Alloc,
		class _This2,
		class... _Rest2,
		enable_if_t<is_same<_Tag, _Alloc_exact_args_t>::value, int> = 0>
		tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
		: _Mybase(_Alloc_exact_args_t{}, _Al, ::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(_Al, _Tuple_alloc, ::std:: forward<_This2>(_This_arg))
		{	
		}

	template<class _Tag,
		class _Alloc,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int> = 0> inline
		tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, integer_sequence<size_t, _Indices...>);

	template<class _Tag,
		class _Alloc,
		class _Tpl,
		enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int> = 0>
		tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: forward<_Tpl>(_Right),
			make_integer_sequence<size_t, tuple_size<remove_reference_t<_Tpl>>::value>{})
		{	
		}

	template<class _This2 = _This,
		class = enable_if_t<conjunction<is_default_constructible<_This2>,
										is_default_constructible<_Rest>...>::value> >
		constexpr tuple()
		: _Mybase(), _Myfirst()
		{	
		}

	template<class... _Other,
		_Tuple_implicit_t<_Myt, const _Other&...> = 0,
		_Tuple_convert_copy_t<_Myt, _Other...> = 0>
		constexpr tuple(const tuple<_Other...>& _Right)


		: _Mybase(_Unpack_tuple_t{}, _Right._Get_rest()),
			_Myfirst(_Right._Myfirst._Val)
		{	
		}

	template<class... _Other,
		_Tuple_explicit_t<_Myt, const _Other&...> = 0,
		_Tuple_convert_copy_t<_Myt, _Other...> = 0>
		constexpr explicit tuple(const tuple<_Other...>& _Right)


		: _Mybase(_Unpack_tuple_t{}, _Right._Get_rest()),
			_Myfirst(_Right._Myfirst._Val)
		{	
		}

	template<class _Alloc,
		class... _Other,
		_Tuple_implicit_t<_Myt, const _Other&...> = 0,
		_Tuple_convert_copy_t<_Myt, _Other...> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple<_Other...>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	
		}

	template<class _Alloc,
		class... _Other,
		_Tuple_explicit_t<_Myt, const _Other&...> = 0,
		_Tuple_convert_copy_t<_Myt, _Other...> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const tuple<_Other...>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	
		}

	template<class _This2 = _This,
		_Tuple_implicit_t<_Myt, const _This2&, const _Rest&...> = 0>
		constexpr tuple(const _This& _This_arg, const _Rest&... _Rest_arg)


		: _Mybase(_Exact_args_t{}, _Rest_arg...), _Myfirst(_This_arg)
		{	
		}

	template<class _This2 = _This,
		_Tuple_explicit_t<_Myt, const _This2&, const _Rest&...> = 0>
		constexpr explicit tuple(const _This& _This_arg, const _Rest&... _Rest_arg)


		: _Mybase(_Exact_args_t{}, _Rest_arg...), _Myfirst(_This_arg)
		{	
		}

	template<class _Alloc,
		class _This2 = _This,
		_Tuple_implicit_t<_Myt, const _This2&, const _Rest&...> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
		{	
		}

	template<class _Alloc,
		class _This2 = _This,
		_Tuple_explicit_t<_Myt, const _This2&, const _Rest&...> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const _This& _This_arg, const _Rest&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
		{	
		}

	template<class _This2,
		class... _Rest2,
		enable_if_t<conjunction<
			_Tuple_perfect_val<_Myt, _This2, _Rest2...>,
			_Tuple_implicit_val<_Myt, _This2, _Rest2...>
		>::value, int> = 0>
		constexpr tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)


		: _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(::std:: forward<_This2>(_This_arg))
		{	
		}

	template<class _This2,
		class... _Rest2,
		enable_if_t<conjunction<
			_Tuple_perfect_val<_Myt, _This2, _Rest2...>,
			_Tuple_explicit_val<_Myt, _This2, _Rest2...>
		>::value, int> = 0>
		constexpr explicit tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg)


		: _Mybase(_Exact_args_t{}, ::std:: forward<_Rest2>(_Rest_arg)...),
			_Myfirst(::std:: forward<_This2>(_This_arg))
		{	
		}

	template<class _Alloc,
		class _This2,
		class... _Rest2,
		enable_if_t<conjunction<
			_Tuple_perfect_val<_Myt, _This2, _Rest2...>,
			_Tuple_implicit_val<_Myt, _This2, _Rest2...>
		>::value, int> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
		{	
		}

	template<class _Alloc,
		class _This2,
		class... _Rest2,
		enable_if_t<conjunction<
			_Tuple_perfect_val<_Myt, _This2, _Rest2...>,
			_Tuple_explicit_val<_Myt, _This2, _Rest2...>
		>::value, int> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			_This2&& _This_arg, _Rest2&&... _Rest_arg)
		: tuple(_Alloc_exact_args_t{}, _Al, ::std:: forward<_This2>(_This_arg), ::std:: forward<_Rest2>(_Rest_arg)...)
		{	
		}

	template<class... _Other,
		_Tuple_implicit_t<_Myt, _Other...> = 0,
		_Tuple_convert_move_t<_Myt, _Other...> = 0>
		constexpr tuple(tuple<_Other...>&& _Right)


		: _Mybase(_Unpack_tuple_t{}, (typename tuple<_Other...>::_Mybase&&) _Right),
			_Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val))
		{	
		}

	template<class... _Other,
		_Tuple_explicit_t<_Myt, _Other...> = 0,
		_Tuple_convert_move_t<_Myt, _Other...> = 0>
		constexpr explicit tuple(tuple<_Other...>&& _Right)


		: _Mybase(_Unpack_tuple_t{}, (typename tuple<_Other...>::_Mybase&&) _Right),
			_Myfirst(::std:: forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val))
		{	
		}

	template<class _Alloc,
		class... _Other,
		_Tuple_implicit_t<_Myt, _Other...> = 0,
		_Tuple_convert_move_t<_Myt, _Other...> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			tuple<_Other...>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{	
		}

	template<class _Alloc,
		class... _Other,
		_Tuple_explicit_t<_Myt, _Other...> = 0,
		_Tuple_convert_move_t<_Myt, _Other...> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			tuple<_Other...>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{	
		}

	template<class... _Other>
		_Myt& operator=(const tuple<_Other...>& _Right)
		{	
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class... _Other>
		_Myt& operator=(tuple<_Other...>&& _Right)
		{	
		_Myfirst._Val = ::std:: forward<typename tuple<_Other...>::_This_type>
			(_Right._Myfirst._Val);
		_Get_rest() = ::std:: forward<typename tuple<_Other...>::_Mybase>
			(_Right._Get_rest());
		return (*this);
		}

	template<class... _Other>
		constexpr bool _Equals(const tuple<_Other...>& _Right) const
		{	
		static_assert(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val == _Right._Myfirst._Val
			&& _Mybase::_Equals(_Right._Get_rest()));
		}

	template<class... _Other>
		constexpr bool _Less(const tuple<_Other...>& _Right) const
		{	
		static_assert(_Mysize == sizeof...(_Other),
			"comparing tuple to object with different size");
		return (_Myfirst._Val < _Right._Myfirst._Val
			|| (!(_Right._Myfirst._Val < _Myfirst._Val)
				&& _Mybase::_Less(_Right._Get_rest())));
		}

	template<class _Alloc,
		class _This2 = _This,
		class = enable_if_t<conjunction<is_default_constructible<_This2>,
										is_default_constructible<_Rest>...>::value> >
		tuple(allocator_arg_t, const _Alloc& _Al)
		: _Mybase(allocator_arg, _Al), _Myfirst(_Al, _Tuple_alloc)
		{	
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const _Myt& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	
		}

	tuple(const _Myt&) = default;
	tuple(_Myt&&) = default;

	template<class _First,
		class _Second,
		_Tuple_implicit_t<_Myt, const _First&, const _Second&> = 0>
		constexpr tuple(const pair<_First, _Second>& _Right)


		: _Mybase(_Exact_args_t{}, _Right.second), _Myfirst(_Right.first)
		{	
		}

	template<class _First,
		class _Second,
		_Tuple_explicit_t<_Myt, const _First&, const _Second&> = 0>
		constexpr explicit tuple(const pair<_First, _Second>& _Right)


		: _Mybase(_Exact_args_t{}, _Right.second), _Myfirst(_Right.first)
		{	
		}

	template<class _Alloc,
		class _First,
		class _Second,
		_Tuple_implicit_t<_Myt, const _First&, const _Second&> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			const pair<_First, _Second>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	
		}

	template<class _Alloc,
		class _First,
		class _Second,
		_Tuple_explicit_t<_Myt, const _First&, const _Second&> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			const pair<_First, _Second>& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
		{	
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Myfirst._Val = _Right._Myfirst._Val;
		_Get_rest() = _Right._Get_rest();
		return (*this);
		}

	template<class _First,
		class _Second>
		_Myt& operator=(const pair<_First, _Second>& _Right)
		{	
		static_assert(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = _Right.first;
		_Get_rest()._Myfirst._Val = _Right.second;
		return (*this);
		}

	template<class _Alloc>
		tuple(allocator_arg_t, const _Alloc& _Al,
			_Myt&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{	
		}

	template<class _First,
		class _Second,
		_Tuple_implicit_t<_Myt, _First, _Second> = 0>
		constexpr tuple(pair<_First, _Second>&& _Right)


		: _Mybase(_Exact_args_t{}, ::std:: forward<_Second>(_Right.second)),
			_Myfirst(::std:: forward<_First>(_Right.first))
		{	
		}

	template<class _First,
		class _Second,
		_Tuple_explicit_t<_Myt, _First, _Second> = 0>
		constexpr explicit tuple(pair<_First, _Second>&& _Right)


		: _Mybase(_Exact_args_t{}, ::std:: forward<_Second>(_Right.second)),
			_Myfirst(::std:: forward<_First>(_Right.first))
		{	
		}

	template<class _Alloc,
		class _First,
		class _Second,
		_Tuple_implicit_t<_Myt, _First, _Second> = 0>
		tuple(allocator_arg_t, const _Alloc& _Al,
			pair<_First, _Second>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{	
		}

	template<class _Alloc,
		class _First,
		class _Second,
		_Tuple_explicit_t<_Myt, _First, _Second> = 0>
		explicit tuple(allocator_arg_t, const _Alloc& _Al,
			pair<_First, _Second>&& _Right)
		: tuple(_Alloc_unpack_tuple_t{}, _Al, ::std:: move(_Right))
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(is_nothrow_move_assignable<_This>::value && is_nothrow_move_assignable<_Mybase>::value)
#line 720 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"
		{	
		_Myfirst._Val = ::std:: forward<_This>(_Right._Myfirst._Val);
		_Get_rest() = ::std:: forward<_Mybase>(_Right._Get_rest());
		return (*this);
		}

	template<class _First,
		class _Second>
		_Myt& operator=(pair<_First, _Second>&& _Right)
		{	
		static_assert(_Mysize == 2,
			"assigning to tuple from object with different size");
		_Myfirst._Val = ::std:: forward<_First>(_Right.first);
		_Get_rest()._Myfirst._Val = ::std:: forward<_Second>(_Right.second);
		return (*this);
		}

	_Mybase& _Get_rest() noexcept
		{	
		return (*this);
		}

	constexpr const _Mybase& _Get_rest() const noexcept
		{	
		return (*this);
		}

	_Tuple_val<_This> _Myfirst;	

	void swap(tuple& _Right)
		noexcept((conjunction<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>::value))
#line 752 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"
		{	
		_Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
		_Mybase::swap(_Right._Get_rest());
		}
	};


	

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator==(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (_Left._Equals(_Right));
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator!=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator<(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (_Left._Less(_Right));
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator>=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator>(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (_Right < _Left);
	}

template<class... _Types1,
	class... _Types2> inline
	constexpr bool operator<=(const tuple<_Types1...>& _Left,
		const tuple<_Types2...>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class... _Types,
	class = enable_if_t<conjunction<_Is_swappable<_Types>...>::value>> inline
	void swap(tuple<_Types...>& _Left,
		tuple<_Types...>& _Right)
			noexcept(noexcept(_Left.swap(_Right)))
	{	
	return (_Left.swap(_Right));
	}


	
template<class _Ty,
	class _Tuple>
	struct _Tuple_element;

template<class _This,
	class... _Rest>
	struct _Tuple_element<_This, tuple<_This, _Rest...> >
	{	
	typedef int _Check_type;
	static_assert(is_void<typename _Tuple_element<_This,
		tuple<_Rest...> >::_Check_type>::value,
		"duplicate type T in get<T>(tuple)");

	typedef _This type;
	typedef tuple<_This, _Rest...> _Ttype;
	};

template<class _Ty,
	class _This,
	class... _Rest>
	struct _Tuple_element<_Ty, tuple<_This, _Rest...> >
		: public _Tuple_element<_Ty, tuple<_Rest...> >
	{	
	};

template<class _Ty>
	struct _Tuple_element<_Ty, tuple<> >
	{	
	typedef void _Check_type;	
	};

template<class _Ty,
	class _Tuple>
	struct _Tuple_element<_Ty, const _Tuple>
		: public _Tuple_element<_Ty, _Tuple>
	{	
	typedef _Tuple_element<_Ty, _Tuple> _Mybase;
	typedef typename add_const<typename _Mybase::type>::type type;
	};

template<class _Ty,
	class _Tuple>
	struct _Tuple_element<_Ty, volatile _Tuple>
		: public _Tuple_element<_Ty, _Tuple>
	{	
	typedef _Tuple_element<_Ty, _Tuple> _Mybase;
	typedef typename add_volatile<typename _Mybase::type>::type type;
	};

template<class _Ty,
	class _Tuple>
	struct _Tuple_element<_Ty, const volatile _Tuple>
		: public _Tuple_element<_Ty, _Tuple>
	{	
	typedef _Tuple_element<_Ty, _Tuple> _Mybase;
	typedef typename add_cv<typename _Mybase::type>::type type;
	};

	
template<size_t _Index,
	class... _Types> inline
	constexpr typename tuple_element<_Index, tuple<_Types...> >::type&
		get(tuple<_Types...>& _Tuple) noexcept
	{	
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types> inline
	constexpr const typename tuple_element<_Index, tuple<_Types...> >::type&
		get(const tuple<_Types...>& _Tuple) noexcept
	{	
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<size_t _Index,
	class... _Types> inline
	constexpr typename tuple_element<_Index, tuple<_Types...> >::type&&
		get(tuple<_Types...>&& _Tuple) noexcept
	{	
	typedef typename tuple_element<_Index, tuple<_Types...> >::_Ttype
		_Ttype;
	typedef typename tuple_element<_Index, tuple<_Types...> >::type&&
		_RRtype;
	return (::std:: forward<_RRtype>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	
template<class _Ty,
	class... _Types> inline
	constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept
	{	
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types> inline
	constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept
	{	
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (((_Ttype&)_Tuple)._Myfirst._Val);
	}

template<class _Ty,
	class... _Types> inline
	constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept
	{	
	typedef typename _Tuple_element<_Ty, tuple<_Types...> >::_Ttype _Ttype;
	return (::std:: forward<_Ty&&>(((_Ttype&)_Tuple)._Myfirst._Val));
	}

	













template<class _This,
	class... _Rest>
	template<class _Tag,
		class _Alloc,
		class _Tpl,
		size_t... _Indices,
		enable_if_t<is_same<_Tag, _Alloc_unpack_tuple_t>::value, int>> inline
		tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, integer_sequence<size_t, _Indices...>)
		: tuple(_Alloc_exact_args_t{}, _Al, ::std:: get<_Indices>(::std:: forward<_Tpl>(_Right))...)
		{	
		}

	
template<class... _Types> inline
	constexpr tuple<typename _Unrefwrap<_Types>::type...>
		make_tuple(_Types&&... _Args)
	{	
	typedef tuple<typename _Unrefwrap<_Types>::type...> _Ttype;
	return (_Ttype(::std:: forward<_Types>(_Args)...));
	}

	
template<class... _Types> inline
	constexpr tuple<_Types&...>
		tie(_Types&... _Args) noexcept
	{	
	typedef tuple<_Types&...> _Ttype;
	return (_Ttype(_Args...));
	}


	

template<class... _Types> inline
	constexpr tuple<_Types&&...>
		forward_as_tuple(_Types&&... _Args) noexcept
	{	
	return (tuple<_Types&&...>(::std:: forward<_Types>(_Args)...));
	}


	
template<class _Seq_type1,
	class _Seq_type2>
	struct _Cat_sequences;

template<size_t... _Indexes1,
	size_t... _Indexes2>
	struct _Cat_sequences<integer_sequence<size_t, _Indexes1...>,
		integer_sequence<size_t, _Indexes2...> >
	{	
	typedef integer_sequence<size_t, _Indexes1..., _Indexes2...> type;
	};

	
template<class _Ty,
	size_t _Size>
	class array;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

template<size_t _Idx,
	class _Ty,
	size_t _Size>
	constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

	
template<class _Ty,
	class... _For_array>
	struct _View_as_tuple
	{	
	static_assert(_Always_false<_Ty>::value,
		"Unsupported tuple_cat arguments.");
	};

template<class... _Types>
	struct _View_as_tuple<tuple<_Types...> >
	{	
	typedef tuple<_Types...> type;
	};

template<class _Ty1,
	class _Ty2>
	struct _View_as_tuple<pair<_Ty1, _Ty2> >
	{	
	typedef tuple<_Ty1, _Ty2> type;
	};

template<class _Ty,
	class... _Types>
	struct _View_as_tuple<array<_Ty, 0>, _Types...>
	{	
	typedef tuple<_Types...> type;
	};

template<class _Ty,
	size_t _Size,
	class... _Types>
	struct _View_as_tuple<array<_Ty, _Size>, _Types...>
		: _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
	{	
	};

	
template<size_t _Nx,
	class _Ty>
	struct _Repeat_for
		: integral_constant<size_t, _Nx>
	{	
	};

	
template<class _Ret,
	class _Kx_arg,
	class _Ix_arg,
	size_t _Ix_next,
	class... _Tuples>
	struct _Tuple_cat2
	{	
	static_assert(sizeof...(_Tuples) == 0,
		"Unsupported tuple_cat arguments.");
	typedef _Ret type;
	typedef _Kx_arg _Kx_arg_seq;
	typedef _Ix_arg _Ix_arg_seq;
	};

template<class... _Types1,
	class _Kx_arg,
	size_t... _Ix,
	size_t _Ix_next,
	class... _Types2,
	class... _Rest>
	struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg,
		integer_sequence<size_t, _Ix...>, _Ix_next,
		tuple<_Types2...>, _Rest...>
		: _Tuple_cat2<
			tuple<_Types1..., _Types2...>,
			typename _Cat_sequences<_Kx_arg,
				make_integer_sequence<size_t, sizeof...(_Types2)> >::type,
			integer_sequence<size_t, _Ix...,
				_Repeat_for<_Ix_next, _Types2>::value...>,
			_Ix_next + 1,
			_Rest...>
	{	
	};

template<class... _Tuples>
	struct _Tuple_cat1
		: _Tuple_cat2<tuple<>, integer_sequence<size_t>,
				integer_sequence<size_t>, 0,
			typename _View_as_tuple<typename decay<_Tuples>::type>::type...>
	{	
	};

template<class _Ret,
	size_t... _Kx,
	size_t... _Ix,
	class _Ty> inline
	constexpr _Ret _Tuple_cat(integer_sequence<size_t, _Kx...>,
		integer_sequence<size_t, _Ix...>, _Ty&& _Arg)
	{	
	return (_Ret(::std:: get<_Kx>(::std:: get<_Ix>(::std:: forward<_Ty>(_Arg)))...));
	}

template<class _Ret,
	class _Ty> inline
	constexpr _Ret _Tuple_cat(integer_sequence<size_t>,
		integer_sequence<size_t>, _Ty&&)
	{	
	return (_Ret());
	}

template<class... _Tuples> inline
	constexpr typename _Tuple_cat1<_Tuples...>::type
		tuple_cat(_Tuples&&... _Tpls)
	{	
	typedef _Tuple_cat1<_Tuples...> _Cat1;
	return (_Tuple_cat<typename _Cat1::type>(
		typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
		::std:: forward_as_tuple(::std:: forward<_Tuples>(_Tpls)...)));
	}


	
template<class _Tpl,
	class _Fx,
	size_t... _Indices> inline
	void _For_each_tuple_element_impl(_Tpl&& _Tuple,
		_Fx _Func, integer_sequence<size_t, _Indices...>)
	{	
	int _Ignored[] = { (static_cast<void>(_Func(
		::std:: get<_Indices>(::std:: forward<_Tpl>(_Tuple))
		)), 0)... };
	(void)_Ignored;
	}

template<class _Tpl,
	class _Fx> inline
	void _For_each_tuple_element(_Tpl&& _Tuple, _Fx _Func)
	{	
	_For_each_tuple_element_impl(
		::std:: forward<_Tpl>(_Tuple),
		_Func,
		make_integer_sequence<size_t,
			tuple_size<remove_reference_t<_Tpl>>::value>()
		);
	}


	
template<class _Ty1,
	class _Ty2>
	template<class _Tuple1,
		class _Tuple2,
		size_t... _Indexes1,
		size_t... _Indexes2> inline
		pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1,
			_Tuple2& _Val2,
			integer_sequence<size_t, _Indexes1...>,
			integer_sequence<size_t, _Indexes2...>)
		: first(::std:: get<_Indexes1>(::std:: move(_Val1))...),
			second(::std:: get<_Indexes2>(::std:: move(_Val2))...)
		{	
		(void) _Val1;	
		(void) _Val2;
		}

	
template<class _Ty1,
	class _Ty2>
	template<class... _Types1,
		class... _Types2> inline
		pair<_Ty1, _Ty2>::pair(piecewise_construct_t,
			tuple<_Types1...> _Val1,
			tuple<_Types2...> _Val2)
		: pair(_Val1, _Val2,
			make_integer_sequence<size_t, sizeof...(_Types1)>(),
			make_integer_sequence<size_t, sizeof...(_Types2)>())
		{	
		}

}

namespace std {
	
template<class... _Types,
	class _Alloc>
	struct uses_allocator<tuple<_Types...>, _Alloc>
		: true_type
	{	
	};

}	


namespace std {
namespace tr1 {	
using ::std:: get;
using ::std:: ignore;
using ::std:: make_tuple;
using ::std:: ref;
using ::std:: tie;
using ::std:: tuple;
}	
}
#line 1224 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1229 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"
#line 1230 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\tuple"






#line 8 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

#pragma once



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4700)

namespace std {
		
template<class _Ty> inline
	pair<_Ty *, ptrdiff_t>
		get_temporary_buffer(ptrdiff_t _Count) noexcept
	{	
	_Ty *_Pbuf;

	if (_Count < 0)
		_Count = 0;
	else if (((size_t)(-1) / sizeof (_Ty) < _Count))
		_Xbad_alloc();	
	for (_Pbuf = 0; 0 < _Count; _Count /= 2)
		if ((_Pbuf = (_Ty *)operator new(
			(size_t)_Count * sizeof (_Ty), nothrow)) != 0)
			break;

	return (pair<_Ty *, ptrdiff_t>(_Pbuf, _Count));
	}

		
template<class _Ty> inline
	void return_temporary_buffer(_Ty *_Pbuf)
	{	
	operator delete(_Pbuf);
	}

		
template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _General_ptr_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, (void)++_First)
		_Construct(_Unfancy(_Dest), *_First);
	} catch (...) {
	_Destroy_range(_Next, _Dest);
	throw;
	}

	return (_Dest);
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_unchecked(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy_unchecked1(_First, _Last,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, input_iterator_tag, forward_iterator_tag)
	{	
	return (_Rechecked(_Dest,
		_Uninitialized_copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy1(_InIt _First, _InIt _Last,
		_FwdIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Uninitialized_copy_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _InIt,
	class _FwdIt> inline
	_FwdIt uninitialized_copy(_InIt _First, _InIt _Last,
		_FwdIt _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "uninitialized_copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 103);
	return (_Uninitialized_copy1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_FwdIt>()));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: uninitialized_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 120 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		
template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _General_ptr_iterator_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; 0 < _Count; --_Count, (void)++_Dest, ++_First)
		_Construct(_Unfancy(_Dest), *_First);
	} catch (...) {
	_Destroy_range(_Next, _Dest);
	throw;
	}

	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked1(_InIt _First, _Diff _Count,
		_FwdIt _Dest, _Really_trivial_ptr_iterator_tag)
	{	
	if (0 < _Count)
		return (_Copy_memmove(_First, _First + _Count, _Dest));
	return (_Dest);
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt _Uninitialized_copy_n_unchecked(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
	return (_Uninitialized_copy_n_unchecked1(_First, _Count,
		_Dest, _Ptr_copy_cat(_First, _Dest)));
	}

template<class _InIt,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InIt _First, _Diff _Count,
		_FwdIt _Dest)
	{	
		
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "uninitialized_copy_n" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Rechecked(_Dest,
		_Uninitialized_copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Unchecked_n(_Dest, _Count))));
	}

 
template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _FwdIt> inline
	_FwdIt uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_FwdIt _Dest)
	{	
		
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "uninitialized_copy_n" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_array_size2(_First, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 184);
	return (_Rechecked(_Dest,
		_Uninitialized_copy_n_unchecked(_First, _Count, _Unchecked_n(_Dest, _Count))));
	}

template<class _InIt,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InIt _First, _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	_Debug_array_size2(_Dest, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 196);
	return (_Uninitialized_copy_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Dest));
	}

template<class _InTy,
	size_t _InSize,
	class _Diff,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *uninitialized_copy_n(_InTy (&_First)[_InSize], _Diff _Count,
		_OutTy (&_Dest)[_OutSize])
	{	
	_Debug_array_size2(_First, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 208);
	_Debug_array_size2(_Dest, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 209);
	return (_Uninitialized_copy_n_unchecked(_First, _Count, _Dest));
	}
 #line 213 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy_al_unchecked1(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _General_ptr_iterator_tag, _Any_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, (void)++_First)
		_Al.construct(_Unfancy(_Dest), *_First);
	} catch (...) {
	_Destroy_range(_Next, _Dest, _Al);
	throw;
	}

	return (_Dest);
	}

template<class _Ty1,
	class _Ty2,
	class _Alloc> inline
	_Ty2 *_Uninitialized_copy_al_unchecked1(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<_Alloc>&, _Really_trivial_ptr_iterator_tag, true_type)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al)
	{	
	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,
		_Ptr_copy_cat(_First, _Dest),
		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_copy(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al)
	{	
		
		
	return (_Rechecked(_Dest,
		_Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest), _Al)));
	}

		
template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move_al_unchecked1(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al, _General_ptr_iterator_tag, _Any_tag)
	{	
	_FwdIt _Next = _Dest;

	try {
	for (; _First != _Last; ++_Dest, (void)++_First)
		_Al.construct(_Unfancy(_Dest), ::std:: move(*_First));
	} catch (...) {
	_Destroy_range(_Next, _Dest, _Al);
	throw;
	}

	return (_Dest);
	}

template<class _Ty1,
	class _Ty2,
	class _Alloc> inline
	_Ty2 *_Uninitialized_move_al_unchecked1(_Ty1 *_First, _Ty1 *_Last, _Ty2 *_Dest,
		_Wrap_alloc<_Alloc>&, _Really_trivial_ptr_iterator_tag, true_type)
	{	
	return (_Copy_memmove(_First, _Last, _Dest));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move_al_unchecked(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al)
	{	
	typedef decltype(::std:: move(*_First)) _Src_type; 
	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,
		_Ptr_move_cat(_First, _Dest),
		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
	}

template<class _InIt,
	class _FwdIt,
	class _Alloc> inline
	_FwdIt _Uninitialized_move(_InIt _First, _InIt _Last, _FwdIt _Dest,
		_Wrap_alloc<_Alloc>& _Al)
	{	
		
		
	return (_Rechecked(_Dest,
		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked(_Dest), _Al)));
	}

		
template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, false_type)
	{	
	_FwdIt _Next = _First;

	try {
	for (; _First != _Last; ++_First)
		_Construct(_Unfancy(_First), _Val);
	} catch (...) {
	_Destroy_range(_Next, _First);
	throw;
	}
	}

template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked1(_FwdIt _First, _FwdIt _Last, const _Tval& _Val, true_type)
	{	
	:: memset(_First, _Val, _Last - _First);
	}

template<class _FwdIt,
	class _Tval> inline
	void _Uninitialized_fill_unchecked(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	
	_Uninitialized_fill_unchecked1(_First, _Last, _Val, _Fill_memset_is_safe(_First, _Val));
	}

template<class _FwdIt,
	class _Tval> inline
	void uninitialized_fill(_FwdIt _First, _FwdIt _Last, const _Tval& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 355);
	_Uninitialized_fill_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val);
	}

		
template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked1(_FwdIt _First, _Diff _Count, const _Tval& _Val, false_type)
	{	
	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, (void)++_First)
		_Construct(_Unfancy(_First), _Val);
	} catch (...) {
	_Destroy_range(_Next, _First);
	throw;
	}

	return (_First);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked1(_FwdIt _First, _Diff _Count, const _Tval& _Val, true_type)
	{	
	if (0 < _Count)
		{
		:: memset(_First, _Val, _Count);
		return (_First + _Count);
		}

	return (_First);
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt _Uninitialized_fill_n_unchecked(_FwdIt _First, _Diff _Count, const _Tval& _Val)
	{	
	return (_Uninitialized_fill_n_unchecked1(_First, _Count, _Val, _Fill_memset_is_safe(_First, _Val)));
	}

template<class _FwdIt,
	class _Diff,
	class _Tval> inline
	_FwdIt uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Tval& _Val)
	{	
	return (_Rechecked(_First,
		_Uninitialized_fill_n_unchecked(_Unchecked_n(_First, _Count), _Count, _Val)));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt> * _Pval,
		_Wrap_alloc<_Alloc>& _Al, false_type)
	{	
	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, (void)++_First)
		_Al.construct(_Unfancy(_First), *_Pval);
	} catch (...) {
	_Destroy_range(_Next, _First, _Al);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninit_alloc_fill_n1(_FwdIt _First, _Diff _Count, const _Iter_value_t<_FwdIt> * _Pval,
		_Wrap_alloc<_Alloc>&, true_type)
	{	
	:: memset(_First, *_Pval, _Count);
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_fill_n(_FwdIt _First, _Diff _Count,
		const _Iter_value_t<_FwdIt> * _Pval, _Wrap_alloc<_Alloc>& _Al)
	{	
	_Uninit_alloc_fill_n1(_First, _Count, _Pval, _Al,
		typename conjunction<decltype(_Fill_memset_is_safe(_First, *_Pval)),
			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First)), decltype(*_Pval)>>::type());
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_default_fill_n1(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al, false_type)
	{	
	_FwdIt _Next = _First;

	try {
	for (; 0 < _Count; --_Count, (void)++_First)
		_Al.construct(_Unfancy(_First));
	} catch (...) {
	_Destroy_range(_Next, _First, _Al);
	throw;
	}
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_default_fill_n1(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>&, true_type)
	{	
	:: memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));
	}

template<class _FwdIt,
	class _Diff,
	class _Alloc> inline
	void _Uninitialized_default_fill_n(_FwdIt _First, _Diff _Count,
		_Wrap_alloc<_Alloc>& _Al)
	{	
	typedef _Iter_value_t<_FwdIt> _Ty;
	_Uninitialized_default_fill_n1(_First, _Count, _Al,
		typename conjunction<
			is_pointer<_FwdIt>,
			is_scalar<_Ty>,
			negation<is_volatile<_Ty>>,
			negation<is_member_pointer<_Ty>>,
			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
	}

		
template<class _OutIt,
	class _Ty>
	class raw_storage_iterator
		: public _Outit
	{	
public:
	explicit raw_storage_iterator(_OutIt _First)
		: _Next(_First)
		{	
		}

	raw_storage_iterator& operator*()
		{	
		return (*this);
		}

	raw_storage_iterator& operator=(const _Ty& _Val)
		{	
		_Construct(_Unfancy(_Next), _Val);
		return (*this);
		}

	raw_storage_iterator& operator=(_Ty&& _Val)
		{	
		_Construct(_Unfancy(_Next), ::std:: move(_Val));
		return (*this);
		}

	raw_storage_iterator& operator++()
		{	
		++_Next;
		return (*this);
		}

	raw_storage_iterator operator++(int)
		{	
		raw_storage_iterator _Ans = *this;
		++_Next;
		return (_Ans);
		}

	_OutIt base() const
		{	
		return (_Next);
		}

private:
	_OutIt _Next;	
	};

		
template<class _Ty>
	class _Temp_iterator
		: public _Outit
	{	
public:
	typedef _Ty *_Pty;

	_Temp_iterator(ptrdiff_t _Count = 0)
		{	
		_Buf._Begin = 0;
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = _Count;	
		_Pbuf = &_Buf;
		}

	_Temp_iterator(const _Temp_iterator& _Right)
		{	
		_Buf._Begin = 0;	
		_Buf._Current = 0;
		_Buf._Hiwater = 0;
		_Buf._Size = 0;
		*this = _Right;
		}

	~_Temp_iterator() noexcept
		{	
		if (_Buf._Begin != 0)
			{	
			for (_Pty _Next = _Buf._Begin;
				_Next != _Buf._Hiwater; ++_Next)
				_Destroy(_Next);
			::std:: return_temporary_buffer(_Buf._Begin);
			}
		}

	_Temp_iterator& operator=(const _Temp_iterator& _Right)
		{	
		_Pbuf = _Right._Pbuf;
		return (*this);
		}

	_Temp_iterator& operator=(const _Ty& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ = _Val;	
		else
			{	
			_Pty _Ptr = _Pbuf->_Current;
			_Construct(_Ptr, _Val);
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}

		return (*this);
		}

	_Temp_iterator& operator=(_Ty&& _Val)
		{	
		if (_Pbuf->_Current < _Pbuf->_Hiwater)
			*_Pbuf->_Current++ =
				::std:: forward<_Ty>(_Val);	
		else
			{	
			_Pty _Ptr = _Pbuf->_Current;
			_Construct(_Ptr, ::std:: forward<_Ty>(_Val));
			_Pbuf->_Hiwater = ++_Pbuf->_Current;
			}

		return (*this);
		}

	_Temp_iterator& operator*()
		{	
		return (*this);
		}

	_Temp_iterator& operator++()
		{	
		return (*this);
		}

	_Temp_iterator& operator++(int)
		{	
		return (*this);
		}

	_Temp_iterator& _Init()
		{	
		_Pbuf->_Current = _Pbuf->_Begin;
		return (*this);
		}

	_Pty _First() const
		{	
		return (_Pbuf->_Begin);
		}

	_Pty _Last() const
		{	
		return (_Pbuf->_Current);
		}

	ptrdiff_t _Maxlen()
		{	
		if (_Pbuf->_Begin == 0 && 0 < _Pbuf->_Size)
			{	
			pair<_Pty, ptrdiff_t> _Pair =

				::std:: get_temporary_buffer<_Ty>(_Pbuf->_Size);

			_Pbuf->_Begin = _Pair.first;
			_Pbuf->_Current = _Pair.first;
			_Pbuf->_Hiwater = _Pair.first;
			_Pbuf->_Size = _Pair.second;
			}

		return (_Pbuf->_Size);
		}

private:
	struct _Bufpar
		{	
		_Pty _Begin;	
		_Pty _Current;	
		_Pty _Hiwater;	
		ptrdiff_t _Size;	
		};
	_Bufpar _Buf;	
	_Bufpar *_Pbuf;	
	};

 
		
template<class _Ty>
	class auto_ptr;

template<class _Ty>
	struct auto_ptr_ref
		{	
	explicit auto_ptr_ref(_Ty *_Right)
		: _Ref(_Right)
		{	
		}

	_Ty *_Ref;	
	};

template<class _Ty>
	class auto_ptr
		{	
public:
	typedef auto_ptr<_Ty> _Myt;
	typedef _Ty element_type;

	explicit auto_ptr(_Ty *_Ptr = 0) noexcept
		: _Myptr(_Ptr)
		{	
		}

	auto_ptr(_Myt& _Right) noexcept
		: _Myptr(_Right.release())
		{	
		}

	auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		_Myptr = _Ptr;	
		}

	template<class _Other>
		operator auto_ptr<_Other>() noexcept
		{	
		return (auto_ptr<_Other>(*this));
		}

	template<class _Other>
		operator auto_ptr_ref<_Other>() noexcept
		{	
		_Other *_Cvtptr = _Myptr;	
		auto_ptr_ref<_Other> _Ans(_Cvtptr);
		_Myptr = 0;	
		return (_Ans);
		}

	template<class _Other>
		_Myt& operator=(auto_ptr<_Other>& _Right) noexcept
		{	
		reset(_Right.release());
		return (*this);
		}

	template<class _Other>
		auto_ptr(auto_ptr<_Other>& _Right) noexcept
		: _Myptr(_Right.release())
		{	
		}

	_Myt& operator=(_Myt& _Right) noexcept
		{	
		reset(_Right.release());
		return (*this);
		}

	_Myt& operator=(auto_ptr_ref<_Ty> _Right) noexcept
		{	
		_Ty *_Ptr = _Right._Ref;
		_Right._Ref = 0;	
		reset(_Ptr);	
		return (*this);
		}

	~auto_ptr() noexcept
		{	
		delete _Myptr;
		}

	_Ty& operator*() const noexcept
		{	
 
		if (_Myptr == 0)
			_Debug_message(L"auto_ptr not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 764);
 #line 766 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		return (*get());
		}

	_Ty *operator->() const noexcept
		{	
 
		if (_Myptr == 0)
			_Debug_message(L"auto_ptr not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory", 774);
 #line 776 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"

		return (get());
		}

	_Ty *get() const noexcept
		{	
		return (_Myptr);
		}

	_Ty *release() noexcept
		{	
		_Ty *_Tmp = _Myptr;
		_Myptr = 0;
		return (_Tmp);
		}

	void reset(_Ty *_Ptr = 0)
		{	
		if (_Ptr != _Myptr)
			delete _Myptr;
		_Myptr = _Ptr;
		}

private:
	_Ty *_Myptr;	
	};
 #line 803 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 809 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"
#line 810 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xmemory"





#line 7 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"


 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4127)
namespace std {
		
template<class _Mytree,
	class _Base = _Iterator_base0>
	class _Tree_unchecked_const_iterator
		: public _Iterator012<bidirectional_iterator_tag,
			typename _Mytree::value_type,
			typename _Mytree::difference_type,
			typename _Mytree::const_pointer,
			typename _Mytree::const_reference,
			_Base>
	{	
public:
	typedef _Tree_unchecked_const_iterator<_Mytree, _Base> _Myiter;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;
	typedef typename _Mytree::const_pointer pointer;
	typedef typename _Mytree::const_reference reference;

	_Tree_unchecked_const_iterator()
		: _Ptr()
		{	
		}

	_Tree_unchecked_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Ptr(_Pnode)
		{	
		this->_Adopt(_Plist);
		}

	reference operator*() const
		{	
		return (_Mytree::_Myval(_Ptr));
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		if (_Mytree::_Isnil(_Ptr))
			;	
		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))
			_Ptr = _Mytree::_Min(
				_Mytree::_Right(_Ptr));	
		else
			{	
			_Nodeptr _Pnode;
			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
				&& _Ptr == _Mytree::_Right(_Pnode))
				_Ptr = _Pnode;	
			_Ptr = _Pnode;	
			}
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		if (_Mytree::_Isnil(_Ptr))
			_Ptr = _Mytree::_Right(_Ptr);	
		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))
			_Ptr = _Mytree::_Max(
				_Mytree::_Left(_Ptr));	
		else
			{	
			_Nodeptr _Pnode;
			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
				&& _Ptr == _Mytree::_Left(_Pnode))
				_Ptr = _Pnode;	
			if (_Mytree::_Isnil(_Ptr))
				;	
			else
				_Ptr = _Pnode;	
			}
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	bool operator==(const _Myiter& _Right) const
		{	
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	_Nodeptr _Mynode() const
		{	
		return (_Ptr);
		}

	_Nodeptr _Ptr;	
	};

	
template<class _Mytree>
	class _Tree_unchecked_iterator
		: public _Tree_unchecked_const_iterator<_Mytree>
	{	
public:
	typedef _Tree_unchecked_iterator<_Mytree> _Myiter;
	typedef _Tree_unchecked_const_iterator<_Mytree> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;
	typedef typename _Mytree::pointer pointer;
	typedef typename _Mytree::reference reference;

	_Tree_unchecked_iterator()
		{	
		}

	_Tree_unchecked_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}
	};

	
template<class _Mytree>
	class _Tree_const_iterator
		: public _Tree_unchecked_const_iterator<_Mytree, _Iterator_base>
	{	
public:
	typedef _Tree_const_iterator<_Mytree> _Myiter;
	typedef _Tree_unchecked_const_iterator<_Mytree, _Iterator_base> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;
	typedef typename _Mytree::const_pointer pointer;
	typedef typename _Mytree::const_reference reference;

	_Tree_const_iterator()
		: _Mybase()
		{	
		}

	_Tree_const_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	typedef _Tree_unchecked_const_iterator<_Mytree> _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right._Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr, (_Mytree *)this->_Getcont()));
		}

	reference operator*() const
		{	
 
		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
		if (_Mycont == 0
			|| this->_Ptr == nullptr_t{}
			|| this->_Ptr == _Mycont->_Myhead)
			{	
			_Debug_message(L"map/set iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 238);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 239, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 239, 0); };
			}

 




#line 248 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		return (_Mytree::_Myval(this->_Ptr));
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == nullptr_t{}
			|| _Mytree::_Isnil(this->_Ptr))
			{	
			_Debug_message(L"map/set iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 264);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 265, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 265, 0); };
			}

 


#line 272 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		++static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		if (this->_Getcont() == 0
			|| this->_Ptr == nullptr_t{})
			{	
			_Debug_message(L"map/set iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 290);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 291, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 291, 0); };
			}

		_Nodeptr _Ptrsav = this->_Ptr;
		--static_cast<_Mybase&>(*this);
		if (_Ptrsav == this->_Ptr)
			{	
			_Debug_message(L"map/set iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 298);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 299, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 299, 0); };
			}

 








#line 312 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	bool operator==(const _Myiter& _Right) const
		{	
 
		if (this->_Getcont() != _Right._Getcont())
			{	
			_Debug_message(L"map/set iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 328);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 329, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 329, 0); };
			}

 

#line 335 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}
	};

template<class _Mytree> inline
	typename _Tree_const_iterator<_Mytree>::_Unchecked_type
		_Unchecked(_Tree_const_iterator<_Mytree> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mytree> inline
	_Tree_const_iterator<_Mytree>&
		_Rechecked(_Tree_const_iterator<_Mytree>& _Iter,
			typename _Tree_const_iterator<_Mytree>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

	
template<class _Mytree>
	class _Tree_iterator
		: public _Tree_const_iterator<_Mytree>
	{	
public:
	typedef _Tree_iterator<_Mytree> _Myiter;
	typedef _Tree_const_iterator<_Mytree> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mytree::_Nodeptr _Nodeptr;
	typedef typename _Mytree::value_type value_type;
	typedef typename _Mytree::difference_type difference_type;

	typedef typename _Mytree::pointer pointer;
	typedef typename _Mytree::reference reference;

	_Tree_iterator()
		{	
		}

	_Tree_iterator(_Nodeptr _Pnode, const _Mytree *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	typedef _Tree_unchecked_iterator<_Mytree> _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right._Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr, static_cast<const _Mytree *>(this->_Getcont())));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--static_cast<_Mybase&>(*this);
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}
	};

template<class _Mytree> inline
	typename _Tree_iterator<_Mytree>::_Unchecked_type
		_Unchecked(_Tree_iterator<_Mytree> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mytree> inline
	_Tree_iterator<_Mytree>&
		_Rechecked(_Tree_iterator<_Mytree>& _Iter,
			typename _Tree_iterator<_Mytree>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference,
	class _Nodeptr_type>
	struct _Tree_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	typedef _Nodeptr_type _Nodeptr;
	};

template<class _Value_type,
	class _Voidptr>
	struct _Tree_node
		{	
		_Voidptr _Left;	
		_Voidptr _Parent;	
		_Voidptr _Right;	
		char _Color;	
		char _Isnil;	
		_Value_type _Myval;	

	private:
		_Tree_node& operator=(const _Tree_node&);
		};

template<class _Value_type>
	struct _Tree_node<_Value_type, void *>
		{	
		typedef _Tree_node<_Value_type, void *> *_Nodeptr;
		_Nodeptr _Left;	
		_Nodeptr _Parent;	
		_Nodeptr _Right;	
		char _Color;	
		char _Isnil;	
		_Value_type _Myval;	

	private:
		_Tree_node& operator=(const _Tree_node&);
		};

template<class _Ty>
	struct _Tree_simple_types
		: public _Simple_types<_Ty>
	{	
	typedef _Tree_node<_Ty, void *> _Node;
	typedef _Node *_Nodeptr;
	};

template<class _Ty,
	class _Alloc0>
	struct _Tree_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _Tree_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;

	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
		_Voidptr;
	typedef _Tree_node<typename _Alty::value_type,
		_Voidptr> _Node;

	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
	typedef typename _Alnod_type::pointer _Nodeptr;
	typedef _Nodeptr& _Nodepref;

	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Tree_simple_types<typename _Alty::value_type>,
		_Tree_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference,
			_Nodeptr> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _Tree_val
		: public _Container_base
	{	
public:
	typedef _Tree_val<_Val_types> _Myt;

	typedef typename _Val_types::_Nodeptr _Nodeptr;
	typedef _Nodeptr& _Nodepref;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Tree_const_iterator<_Myt> const_iterator;
	typedef _Tree_iterator<_Myt> iterator;

	_Tree_val()
		: _Myhead(),
		_Mysize(0)
		{	
		}

	enum _Redbl
		{	
		_Red, _Black};

	static char& _Color(_Nodeptr _Pnode)
		{	
		return ((char&)_Pnode->_Color);
		}

	static char& _Isnil(_Nodeptr _Pnode)
		{	
		return ((char&)_Pnode->_Isnil);
		}

	static _Nodepref _Left(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Left);
		}

	static _Nodepref _Parent(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Parent);
		}

	static _Nodepref _Right(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Right);
		}

	static reference _Myval(_Nodeptr _Pnode)
		{	
		return ((reference)_Pnode->_Myval);
		}

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{	
		while (!_Isnil(_Right(_Pnode)))
			_Pnode = _Right(_Pnode);
		return (_Pnode);
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{	
		while (!_Isnil(_Left(_Pnode)))
			_Pnode = _Left(_Pnode);
		return (_Pnode);
		}

	_Nodeptr _Myhead;	
	size_type _Mysize;	
	};

		
template<class _Traits>
	class _Tree_comp_alloc
	{	
public:
	typedef _Tree_comp_alloc<_Traits> _Myt;

	typedef typename _Traits::allocator_type allocator_type;
	typedef typename _Traits::key_compare key_compare;

	typedef _Tree_base_types<typename _Traits::value_type,
		allocator_type> _Alloc_types;

	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alnod_type _Alty;
	typedef typename _Alloc_types::_Node _Node;
	typedef typename _Alloc_types::_Nodeptr _Nodeptr;
	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef _Nodeptr& _Nodepref;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Tree_const_iterator<_Tree_val<_Val_types> > const_iterator;
	typedef _Tree_iterator<_Tree_val<_Val_types> > iterator;

	enum _Redbl
		{	
		_Red, _Black
		};

	static char& _Color(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Color(_Pnode));
		}

	static char& _Isnil(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
		}

	static _Nodepref _Left(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Left(_Pnode));
		}

	static _Nodepref _Parent(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Parent(_Pnode));
		}

	static _Nodepref _Right(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Right(_Pnode));
		}

	static reference _Myval(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Myval(_Pnode));
		}

	static _Nodeptr _Max(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Max(_Pnode));
		}

	static _Nodeptr _Min(_Nodeptr _Pnode)
		{	
		return (_Tree_val<_Val_types>::_Min(_Pnode));
		}

	_Tree_comp_alloc(const key_compare& _Parg)
		: _Mypair(_One_then_variadic_args_t(), _Parg,
			_Zero_then_variadic_args_t())
		{	
		_Construct();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
		_Tree_comp_alloc(const key_compare& _Parg, _Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(), _Parg,
			_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	
		_Construct();
		}

 




















#line 740 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
	void _Construct()
		{	
		_Myhead() = _Buyheadnode();
		try {
		_Alloc_proxy();
		} catch (...) {
		_Freeheadnode(_Myhead());
		throw;
		}
		}

	~_Tree_comp_alloc() noexcept
		{	
		_Freeheadnode(_Myhead());
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		_Pocca(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Free_proxy();
		_Pocma(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Myproxy() = _Unfancy(_Alproxy.allocate(1));
		_Alproxy.construct(_Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = &_Get_data();
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Orphan_all();
		_Alproxy.destroy(_Myproxy());
		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	
		return (_Get_data()._Myproxy);
		}
 #line 805 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Nodeptr _Buyheadnode()
		{	
		_Nodeptr _Pnode = _Getal().allocate(1);

		try {
		_Getal().construct(
			::std:: addressof(_Left(_Pnode)), _Pnode);
		_Getal().construct(
			::std:: addressof(_Parent(_Pnode)), _Pnode);
		_Getal().construct(
			::std:: addressof(_Right(_Pnode)), _Pnode);
		} catch (...) {
		_Getal().deallocate(_Pnode, 1);
		throw;
		}

		_Color(_Pnode) = _Black;
		_Isnil(_Pnode) = true;
		return (_Pnode);
		}

	void _Freeheadnode(_Nodeptr _Pnode)
		{	
		_Getal().destroy(
			::std:: addressof(_Left(_Pnode)));
		_Getal().destroy(
			::std:: addressof(_Parent(_Pnode)));
		_Getal().destroy(
			::std:: addressof(_Right(_Pnode)));
		_Getal().deallocate(_Pnode, 1);
		}

	_Nodeptr _Buynode0()
		{	
		_Nodeptr _Pnode = _Getal().allocate(1);

		try {
		_Getal().construct(
			::std:: addressof(_Left(_Pnode)), _Myhead());
		_Getal().construct(
			::std:: addressof(_Parent(_Pnode)), _Myhead());
		_Getal().construct(
			::std:: addressof(_Right(_Pnode)), _Myhead());
		} catch (...) {
		_Getal().deallocate(_Pnode, 1);
		throw;
		}

		return (_Pnode);
		}

	void _Freenode0(_Nodeptr _Pnode)
		{	
		_Getal().destroy(
			::std:: addressof(_Left(_Pnode)));
		_Getal().destroy(
			::std:: addressof(_Parent(_Pnode)));
		_Getal().destroy(
			::std:: addressof(_Right(_Pnode)));
		_Getal().deallocate(_Pnode, 1);
		}

	template<class... _Valty>
		_Nodeptr _Buynode(_Valty&&... _Val)
		{	
		_Nodeptr _Pnode = _Buynode0();

		this->_Color(_Pnode) = _Red;
		this->_Isnil(_Pnode) = false;

		try {
		this->_Getal().construct(
			::std:: addressof(_Myval(_Pnode)),
				::std:: forward<_Valty>(_Val)...);
		} catch (...) {
		_Freenode0(_Pnode);
		throw;
		}

		return (_Pnode);
		}

	key_compare& _Getcomp() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const key_compare& _Getcomp() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_second()._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_second()._Get_first());
		}

	_Tree_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second()._Get_second());
		}

	const _Tree_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second()._Get_second());
		}

	_Nodeptr& _Myhead() noexcept
		{	
		return (_Get_data()._Myhead);
		}

	const _Nodeptr& _Myhead() const noexcept
		{	
		return (_Get_data()._Myhead);
		}

	size_type& _Mysize() noexcept
		{	
		return (_Get_data()._Mysize);
		}

	const size_type& _Mysize() const noexcept
		{	
		return (_Get_data()._Mysize);
		}

private:
	_Compressed_pair<key_compare,
		_Compressed_pair<_Alty, _Tree_val<_Val_types> > > _Mypair;
	};

		
template<class _Traits>
	class _Tree
		: public _Tree_comp_alloc<_Traits>
	{	
public:
	typedef _Tree<_Traits> _Myt;
	typedef _Tree_comp_alloc<_Traits> _Mybase;

	typedef typename _Traits::key_type key_type;
	typedef typename _Traits::value_compare value_compare;
	enum
		{	
		_Multi = _Traits::_Multi};

	typedef typename _Mybase::_Node _Node;
	typedef typename _Mybase::_Nodeptr _Nodeptr;
	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::key_compare key_compare;
	typedef typename _Mybase::allocator_type allocator_type;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _If<is_same<key_type, value_type>::value,
		typename _Mybase::const_iterator,
		typename _Mybase::iterator>::type iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	typedef pair<iterator, bool> _Pairib;
	typedef pair<iterator, iterator> _Pairii;
	typedef pair<const_iterator, const_iterator> _Paircc;

	struct _Copy_tag
		{	
		};
	struct _Move_tag
		{	
		};

	_Tree(const key_compare& _Parg)
		: _Mybase(_Parg)
		{	
		}

	_Tree(const key_compare& _Parg,
		const allocator_type& _Al)
		: _Mybase(_Parg, _Al)
		{	
		}

	template<class _Any_alloc>
		_Tree(const _Myt& _Right, _Any_alloc&& _Al)
		: _Mybase(_Right.key_comp(), ::std:: forward<_Any_alloc>(_Al))
		{	
		try {
		_Copy(_Right, _Copy_tag());
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	_Tree(_Myt&& _Right)
		: _Mybase(_Right.key_comp(), ::std:: move(_Right._Getal()))
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		}

	_Tree(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(_Right.key_comp(), _Al)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			clear();
			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right, true_type)
		{	
		this->_Swap_all(_Right);
		_Swap_adl(this->_Getcomp(), _Right._Getcomp());
		_Swap_adl(this->_Myhead(), _Right._Myhead());
		::std:: swap(this->_Mysize(), _Right._Mysize());
		}

	void _Assign_rv(_Myt&& _Right, false_type)
		{	
		if (get_allocator() == _Right.get_allocator())
			_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		else
			_Copy(_Right, _Move_tag());
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right),
			typename _Alty::propagate_on_container_move_assignment());
		}

	template<class... _Valty>
		_Pairib emplace(_Valty&&... _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
		return (_Insert_nohint(false,
			this->_Myval(_Newnode), _Newnode));
		}

	template<class... _Valty>
		iterator emplace_hint(const_iterator _Where, _Valty&&... _Val)
		{	
		_Nodeptr _Newnode = this->_Buynode(::std:: forward<_Valty>(_Val)...);
		return (_Insert_hint(_Where,
			this->_Myval(_Newnode), _Newnode));
		}

	~_Tree() noexcept
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			clear();
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				this->_Copy_alloc(_Right._Getal());

			this->_Getcomp() = _Right._Getcomp();
			_Copy(_Right, _Copy_tag());
			}
		return (*this);
		}

	iterator begin() noexcept
		{	
		return (iterator(_Lmost(), &this->_Get_data()));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(_Lmost(), &this->_Get_data()));
		}

	iterator end() noexcept
		{	
		return (iterator(this->_Myhead(), &this->_Get_data()));
		}

	const_iterator end() const noexcept
		{	
		return (const_iterator(this->_Myhead(), &this->_Get_data()));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type max_size() const noexcept
		{	
		return (this->_Getal().max_size());
		}

	bool empty() const noexcept
		{	
		return (size() == 0);
		}

	allocator_type get_allocator() const noexcept
		{	
		allocator_type _Ret(this->_Getal());
		return (_Ret);
		}

	key_compare key_comp() const
		{	
		return (this->_Getcomp());
		}

	value_compare value_comp() const
		{	
		return (value_compare(key_comp()));
		}

	template<bool _Multi2 = _Multi,
		enable_if_t<!_Multi2, int> = 0>
		_Pairib insert(const value_type& _Val)
		{	
		return (_Insert_nohint(false,
			_Val, _Nil()));
		}

	template<bool _Multi2 = _Multi,
		enable_if_t<_Multi2, int> = 0>
		iterator insert(const value_type& _Val)
		{	
		return (_Insert_nohint(false,
			_Val, _Nil()).first);
		}

	template<bool _Multi2 = _Multi,
		enable_if_t<!_Multi2, int> = 0>
		_Pairib insert(value_type&& _Val)
		{	
		return (_Insert_nohint(false,
			::std:: forward<value_type>(_Val), _Nil()));
		}

	template<bool _Multi2 = _Multi,
		enable_if_t<_Multi2, int> = 0>
		iterator insert(value_type&& _Val)
		{	
		return (_Insert_nohint(false,
			::std:: forward<value_type>(_Val), _Nil()).first);
		}

	iterator insert(const_iterator _Where,
		const value_type& _Val)
		{	
		return (_Insert_hint(_Where,
			_Val, _Nil()));
		}

	iterator insert(const_iterator _Where, value_type&& _Val)
		{	
		return (_Insert_hint(_Where,
			::std:: forward<value_type>(_Val), _Nil()));
		}

	template<class _Iter>
		void insert(_Iter _First, _Iter _Last)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1248);
		for (; _First != _Last; ++_First)
			emplace_hint(end(), *_First);
		}

	void insert(::std:: initializer_list<value_type> _Ilist)
		{	
		insert(_Ilist.begin(), _Ilist.end());
		}

	iterator erase(const_iterator _Where)
		{	
 
		if (_Where._Getcont() != &this->_Get_data()
			|| this->_Isnil(_Where._Mynode()))
			_Debug_message(L"map/set erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1263);
		_Nodeptr _Erasednode = _Where._Mynode();	
		++_Where;	
		_Orphan_ptr(_Erasednode);

 


#line 1272 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		_Nodeptr _Fixnode;	
		_Nodeptr _Fixnodeparent;	
		_Nodeptr _Pnode = _Erasednode;

		if (this->_Isnil(this->_Left(_Pnode)))
			_Fixnode = this->_Right(_Pnode);	
		else if (this->_Isnil(this->_Right(_Pnode)))
			_Fixnode = this->_Left(_Pnode);	
		else
			{	
			_Pnode = _Where._Mynode();	
			_Fixnode = this->_Right(_Pnode);	
			}

		if (_Pnode == _Erasednode)
			{	
			_Fixnodeparent = this->_Parent(_Erasednode);
			if (!this->_Isnil(_Fixnode))
				this->_Parent(_Fixnode) = _Fixnodeparent;	

			if (_Root() == _Erasednode)
				_Root() = _Fixnode;	
			else if (this->_Left(_Fixnodeparent) == _Erasednode)
				this->_Left(_Fixnodeparent) = _Fixnode;	
			else
				this->_Right(_Fixnodeparent) =
					_Fixnode;	

			if (_Lmost() == _Erasednode)
				_Lmost() = this->_Isnil(_Fixnode)
					? _Fixnodeparent	
					: this->_Min(_Fixnode);	

			if (_Rmost() == _Erasednode)
				_Rmost() = this->_Isnil(_Fixnode)
					? _Fixnodeparent	
					: this->_Max(_Fixnode);	
			}
		else
			{	
			this->_Parent(this->_Left(_Erasednode)) =
				_Pnode;	
			this->_Left(_Pnode) =
				this->_Left(_Erasednode);	

			if (_Pnode == this->_Right(_Erasednode))
				_Fixnodeparent = _Pnode;	
			else
				{	
				_Fixnodeparent =
					this->_Parent(_Pnode);	
				if (!this->_Isnil(_Fixnode))
					this->_Parent(_Fixnode) = _Fixnodeparent;	
				this->_Left(_Fixnodeparent) = _Fixnode;	
				this->_Right(_Pnode) =
					this->_Right(_Erasednode);	
				this->_Parent(this->_Right(_Erasednode)) =
					_Pnode;	
				}

			if (_Root() == _Erasednode)
				_Root() = _Pnode;	
			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)
				this->_Left(this->_Parent(_Erasednode)) =
					_Pnode;	
			else
				this->_Right(this->_Parent(_Erasednode)) =
					_Pnode;	

			this->_Parent(_Pnode) =
				this->_Parent(_Erasednode);	
			::std:: swap(this->_Color(_Pnode),
				this->_Color(_Erasednode));	
			}

		if (this->_Color(_Erasednode) == this->_Black)
			{	
			for (; _Fixnode != _Root()
				&& this->_Color(_Fixnode) == this->_Black;
				_Fixnodeparent = this->_Parent(_Fixnode))
				if (_Fixnode == this->_Left(_Fixnodeparent))
					{	
					_Pnode = this->_Right(_Fixnodeparent);
					if (this->_Color(_Pnode) == this->_Red)
						{	
						this->_Color(_Pnode) = this->_Black;
						this->_Color(_Fixnodeparent) = this->_Red;
						_Lrotate(_Fixnodeparent);
						_Pnode = this->_Right(_Fixnodeparent);
						}

					if (this->_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	
					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
						&& this->_Color(this->_Right(_Pnode)) == this->_Black)
						{	
						this->_Color(_Pnode) = this->_Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	
						if (this->_Color(this->_Right(_Pnode))
							== this->_Black)
							{	
							this->_Color(this->_Left(_Pnode)) = this->_Black;
							this->_Color(_Pnode) = this->_Red;
							_Rrotate(_Pnode);
							_Pnode = this->_Right(_Fixnodeparent);
							}

						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
						this->_Color(_Fixnodeparent) = this->_Black;
						this->_Color(this->_Right(_Pnode)) = this->_Black;
						_Lrotate(_Fixnodeparent);
						break;	
						}
					}
				else
					{	
					_Pnode = this->_Left(_Fixnodeparent);
					if (this->_Color(_Pnode) == this->_Red)
						{	
						this->_Color(_Pnode) = this->_Black;
						this->_Color(_Fixnodeparent) = this->_Red;
						_Rrotate(_Fixnodeparent);
						_Pnode = this->_Left(_Fixnodeparent);
						}

					if (this->_Isnil(_Pnode))
						_Fixnode = _Fixnodeparent;	
					else if (this->_Color(this->_Right(_Pnode)) ==
						this->_Black
						&& this->_Color(this->_Left(_Pnode)) == this->_Black)
						{	
						this->_Color(_Pnode) = this->_Red;
						_Fixnode = _Fixnodeparent;
						}
					else
						{	
						if (this->_Color(this->_Left(_Pnode)) == this->_Black)
							{	
							this->_Color(this->_Right(_Pnode)) = this->_Black;
							this->_Color(_Pnode) = this->_Red;
							_Lrotate(_Pnode);
							_Pnode = this->_Left(_Fixnodeparent);
							}

						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);
						this->_Color(_Fixnodeparent) = this->_Black;
						this->_Color(this->_Left(_Pnode)) = this->_Black;
						_Rrotate(_Fixnodeparent);
						break;	
						}
					}

			this->_Color(_Fixnode) = this->_Black;	
			}

		this->_Getal().destroy(
			::std:: addressof(this->_Myval(_Erasednode)));	

		this->_Getal().deallocate(_Erasednode, 1);

		if (0 < this->_Mysize())
			--this->_Mysize();

		return (iterator(_Where._Ptr,
			&this->_Get_data()));	
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		if (_First == begin() && _Last == end())
			{	
			clear();
			return (begin());
			}
		else
			{	
			while (_First != _Last)
				erase(_First++);
			return (iterator(_First._Ptr, &this->_Get_data()));
			}
		}

	size_type erase(const key_type& _Keyval)
		{	
		_Pairii _Where = equal_range(_Keyval);
		size_type _Num = ::std:: distance(_Where.first, _Where.second);
		erase(_Where.first, _Where.second);
		return (_Num);
		}

	void clear() noexcept
		{	
 
		this->_Orphan_ptr(nullptr_t{});
 #line 1471 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		_Erase(_Root());
		_Root() = this->_Myhead();
		_Lmost() = this->_Myhead();
		_Rmost() = this->_Myhead();
		this->_Mysize() = 0;
		}

	iterator find(const key_type& _Keyval)
		{	
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1484)
#line 1485 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					? end() : _Where);
		}

	const_iterator find(const key_type& _Keyval) const
		{	
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1493)
#line 1494 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					? end() : _Where);
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		iterator find(const _Other& _Keyval)
		{	
		iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1505)
#line 1506 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					? end() : _Where);
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		const_iterator find(const _Other& _Keyval) const
		{	
		const_iterator _Where = lower_bound(_Keyval);
		return (_Where == end()
			|| _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1517)
#line 1518 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					? end() : _Where);
		}

	size_type count(const key_type& _Keyval) const
		{	
		_Paircc _Ans = equal_range(_Keyval);
		return (::std:: distance(_Ans.first, _Ans.second));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		size_type count(const _Other& _Keyval) const
		{	
		_Paircc _Ans = equal_range(_Keyval);
		return (::std:: distance(_Ans.first, _Ans.second));
		}

	iterator lower_bound(const key_type& _Keyval)
		{	
		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
		}

	const_iterator lower_bound(const key_type& _Keyval) const
		{	
		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		iterator lower_bound(const _Other& _Keyval)
		{	
		return (iterator(_Lbound(_Keyval), &this->_Get_data()));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		const_iterator lower_bound(const _Other& _Keyval) const
		{	
		return (const_iterator(_Lbound(_Keyval), &this->_Get_data()));
		}

	iterator upper_bound(const key_type& _Keyval)
		{	
		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
		}

	const_iterator upper_bound(const key_type& _Keyval) const
		{	
		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		iterator upper_bound(const _Other& _Keyval)
		{	
		return (iterator(_Ubound(_Keyval), &this->_Get_data()));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		const_iterator upper_bound(const _Other& _Keyval) const
		{	
		return (const_iterator(_Ubound(_Keyval), &this->_Get_data()));
		}

	_Pairii equal_range(const key_type& _Keyval)
		{	
		return (_Eqrange(_Keyval));
		}

	_Paircc equal_range(const key_type& _Keyval) const
		{	
		return (_Eqrange(_Keyval));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		_Pairii equal_range(const _Other& _Keyval)
		{	
		return (_Eqrange(_Keyval));
		}

	template<class _Other,
		class _Mycomp = key_compare,
		class = typename _Mycomp::is_transparent>
		_Paircc equal_range(const _Other& _Keyval) const
		{	
		return (_Eqrange(_Keyval));
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			_Swap_adl(this->_Getcomp(), _Right._Getcomp());
			_Swap_adl(this->_Myhead(), _Right._Myhead());
			::std:: swap(this->_Mysize(), _Right._Mysize());
			}
		}

protected:
	template<class _Valty>
		_Nodeptr _Buynode_if_nil(_Nodeptr _Node, _Valty&&)
		{	
		return (_Node);
		}

	template<class _Valty>
		_Nodeptr _Buynode_if_nil(_Nil, _Valty&& _Val)
		{	
		return (this->_Buynode(::std:: forward<_Valty>(_Val)));
		}

	void _Destroy_if_not_nil(_Nodeptr _Newnode)
		{	
		this->_Getal().destroy(
			::std:: addressof(this->_Myval(_Newnode)));

		this->_Getal().deallocate(_Newnode, 1);
		}

	void _Destroy_if_not_nil(_Nil)
		{	
		}

	template<class _Valty,
		class _Nodety>
		iterator _Insert_hint(const_iterator _Where,
			_Valty&& _Val, _Nodety _Newnode)
		{	
		const_iterator _Next;
		bool _Leftish = false;	

		try {

 
		if (_Where._Getcont() != &this->_Get_data())
			_Debug_message(L"map/set insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1663);
 #line 1665 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

		if (size() == 0)
			return (_Insert_at(true, this->_Myhead(),
				::std:: forward<_Valty>(_Val), _Newnode));	
		else if (this->_Multi)
			{	
			if (_Where == begin())
				{	
				if (!_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1674))
#line 1675 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				_Leftish = true;	
				}
			else if (_Where == end())
				{	
				if (!_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Rmost()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1682))
#line 1683 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					return (_Insert_at(false, _Rmost(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (!_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1687)
#line 1688 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				&& !_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key((--(_Next = _Where))._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1690))
#line 1691 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Next._Mynode())))
					return (_Insert_at(false, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (!_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1700)
#line 1701 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				&& (++(_Next = _Where) == end()
					|| !_Debug_lt_pred(this->_Getcomp(), this->_Key(_Next._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1703)))
#line 1704 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Where._Mynode())))
					return (_Insert_at(false, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else
				_Leftish = true;	
			}
		else
			{	
			if (_Where == begin())
				{	
				if (_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1720))
#line 1721 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (_Where == end())
				{	
				if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Rmost()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1727))
#line 1728 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					return (_Insert_at(false, _Rmost(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (_Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1732)
#line 1733 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				&& _Debug_lt_pred(this->_Getcomp(), this->_Key((--(_Next = _Where))._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1735))
#line 1736 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Next._Mynode())))
					return (_Insert_at(false, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			else if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1745)
#line 1746 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				&& (++(_Next = _Where) == end()
					|| _Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Next._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1748)))
#line 1749 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				{	
				if (this->_Isnil(this->_Right(_Where._Mynode())))
					return (_Insert_at(false, _Where._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				else
					return (_Insert_at(true, _Next._Mynode(),
						::std:: forward<_Valty>(_Val), _Newnode));
				}
			}
		} catch (...) {
		_Destroy_if_not_nil(_Newnode);
		throw;
		}

		return (_Insert_nohint(_Leftish,
			::std:: forward<_Valty>(_Val), _Newnode).first);
		}

	template<class _Valty,
		class _Nodety>
		_Pairib _Insert_nohint(bool _Leftish,
			_Valty&& _Val, _Nodety _Newnode)
		{	
		try {
		_Nodeptr _Trynode = _Root();
		_Nodeptr _Wherenode = this->_Myhead();
		bool _Addleft = true;	

		while (!this->_Isnil(_Trynode))
			{	
			_Wherenode = _Trynode;
			if (_Leftish)
				_Addleft = !_Debug_lt_pred(this->_Getcomp(), this->_Key(_Trynode), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1783);	
#line 1784 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
			else
				_Addleft = _Debug_lt_pred(this->_Getcomp(), this->_Kfn(_Val), this->_Key(_Trynode), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1787);	
#line 1788 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
			_Trynode = _Addleft ? this->_Left(_Trynode)
				: this->_Right(_Trynode);
			}

		if (this->_Multi)
			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
				::std:: forward<_Valty>(_Val), _Newnode), true));
		else
			{	
			iterator _Where = iterator(_Wherenode, &this->_Get_data());
			if (!_Addleft)
				;	
			else if (_Where == begin())
				return (_Pairib(_Insert_at(true, _Wherenode,
					::std:: forward<_Valty>(_Val), _Newnode), true));
			else
				--_Where;	

			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Where._Mynode()), this->_Kfn(_Val), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1808))
#line 1809 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
				return (_Pairib(_Insert_at(_Addleft, _Wherenode,
					::std:: forward<_Valty>(_Val), _Newnode), true));
			else
				{	
				_Destroy_if_not_nil(_Newnode);
				return (_Pairib(_Where, false));
				}
			}
		} catch (...) {
		_Destroy_if_not_nil(_Newnode);
		throw;
		}
		}

	template<class _Valty,
		class _Nodety>
		iterator _Insert_at(bool _Addleft, _Nodeptr _Wherenode,
		_Valty&& _Val, _Nodety _Node)
		{	
		if (max_size() - 1 <= this->_Mysize())
			{	
			_Destroy_if_not_nil(_Node);
			_Xlength_error("map/set<T> too long");
			}
		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
			::std:: forward<_Valty>(_Val));

		++this->_Mysize();
		_Newnode->_Parent = _Wherenode;

		if (_Wherenode == this->_Myhead())
			{	
			_Root() = _Newnode;
			_Lmost() = _Newnode;
			_Rmost() = _Newnode;
			}
		else if (_Addleft)
			{	
			this->_Left(_Wherenode) = _Newnode;
			if (_Wherenode == _Lmost())
				_Lmost() = _Newnode;
			}
		else
			{	
			this->_Right(_Wherenode) = _Newnode;
			if (_Wherenode == _Rmost())
				_Rmost() = _Newnode;
			}

		for (_Nodeptr _Pnode = _Newnode;
			this->_Color(this->_Parent(_Pnode)) == this->_Red; )
			if (this->_Parent(_Pnode)
				== this->_Left(this->_Parent(this->_Parent(_Pnode))))
				{	
				_Wherenode =
					this->_Right(this->_Parent(this->_Parent(_Pnode)));
				if (this->_Color(_Wherenode) == this->_Red)
					{	
					this->_Color(this->_Parent(_Pnode)) = this->_Black;
					this->_Color(_Wherenode) = this->_Black;
					this->_Color(this->_Parent(this->_Parent(_Pnode)))
						= this->_Red;
					_Pnode = this->_Parent(this->_Parent(_Pnode));
					}
				else
					{	
					if (_Pnode == this->_Right(this->_Parent(_Pnode)))
						{	
						_Pnode = this->_Parent(_Pnode);
						_Lrotate(_Pnode);
						}
					this->_Color(this->_Parent(_Pnode)) =
						this->_Black;	
					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
						this->_Red;
					_Rrotate(this->_Parent(this->_Parent(_Pnode)));
					}
				}
			else
				{	
				_Wherenode =
					this->_Left(this->_Parent(this->_Parent(_Pnode)));
				if (this->_Color(_Wherenode) == this->_Red)
					{	
					this->_Color(this->_Parent(_Pnode)) = this->_Black;
					this->_Color(_Wherenode) = this->_Black;
					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
						this->_Red;
					_Pnode = this->_Parent(this->_Parent(_Pnode));
					}
				else
					{	
					if (_Pnode == this->_Left(this->_Parent(_Pnode)))
						{	
						_Pnode = this->_Parent(_Pnode);
						_Rrotate(_Pnode);
						}
					this->_Color(this->_Parent(_Pnode)) =
						this->_Black;	
					this->_Color(this->_Parent(this->_Parent(_Pnode))) =
						this->_Red;
					_Lrotate(this->_Parent(this->_Parent(_Pnode)));
					}
				}

		this->_Color(_Root()) = this->_Black;	
		return (iterator(_Newnode, &this->_Get_data()));
		}

	template<class _Moveit>
		void _Copy(const _Myt& _Right, _Moveit _Movefl)
		{	
		_Root() = _Copy_nodes(_Right._Root(), this->_Myhead(), _Movefl);
		this->_Mysize() = _Right.size();
		if (!this->_Isnil(_Root()))
			{	
			_Lmost() = this->_Min(_Root());
			_Rmost() = this->_Max(_Root());
			}
		else
			{	
			_Lmost() = this->_Myhead();
			_Rmost() = this->_Myhead();
			}
		}

	template<class _Ty,
		class _Is_set>
		_Nodeptr _Copy_or_move(_Ty& _Val, _Copy_tag, _Is_set)
		{	
		return (this->_Buynode(_Val));
		}

	template<class _Ty>
		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, true_type)
		{	
		return (this->_Buynode(::std:: move(_Val)));
		}

	template<class _Ty>
		_Nodeptr _Copy_or_move(_Ty& _Val, _Move_tag, false_type)
		{	
		return (this->_Buynode(
			::std:: move(const_cast<key_type&>(_Val.first)),
			::std:: move(_Val.second)));
		}

	template<class _Moveit>
		_Nodeptr _Copy_nodes(_Nodeptr _Rootnode, _Nodeptr _Wherenode,
			_Moveit _Movefl)
		{	
		_Nodeptr _Newroot = this->_Myhead();	

		if (!this->_Isnil(_Rootnode))
			{	
			typename is_same<key_type, value_type>::type _Is_set;
			_Nodeptr _Pnode = _Copy_or_move(
				this->_Myval(_Rootnode), _Movefl, _Is_set);
			_Pnode->_Parent = _Wherenode;
			_Pnode->_Color = this->_Color(_Rootnode);
			if (this->_Isnil(_Newroot))
				_Newroot = _Pnode;	

			try {
			this->_Left(_Pnode) =
				_Copy_nodes(this->_Left(_Rootnode), _Pnode, _Movefl);
			this->_Right(_Pnode) =
				_Copy_nodes(this->_Right(_Rootnode), _Pnode, _Movefl);
			} catch (...) {
			_Erase(_Newroot);	
			throw;
			}
			}

		return (_Newroot);	
		}

	template<class _Other>
		_Paircc _Eqrange(const _Other& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Lonode = this->_Myhead();	
		_Nodeptr _Hinode = this->_Myhead();	

		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), this->_Key(_Pnode), _Keyval, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 1994))
				_Pnode = this->_Right(_Pnode);	
			else
				{	
				if (this->_Isnil(_Hinode)
						&& _Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 2000))
#line 2001 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
					_Hinode = _Pnode;	
				_Lonode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}

		_Pnode = this->_Isnil(_Hinode) ? _Root()
			: this->_Left(_Hinode);	
		while (!this->_Isnil(_Pnode))
			if (_Debug_lt_pred(this->_Getcomp(), _Keyval, this->_Key(_Pnode), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 2009))
				{	
				_Hinode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}
			else
				_Pnode = this->_Right(_Pnode);	

		const_iterator _First = const_iterator(_Lonode, &this->_Get_data());
		const_iterator _Last = const_iterator(_Hinode, &this->_Get_data());
		return (_Paircc(_First, _Last));
		}

	template<class _Other>
		_Pairii _Eqrange(const _Other& _Keyval)
		{	
		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));
		iterator _First = iterator(_Ans.first._Ptr, &this->_Get_data());
		iterator _Last = iterator(_Ans.second._Ptr, &this->_Get_data());
		return (_Pairii(_First, _Last));
		}

	void _Erase(_Nodeptr _Rootnode)
		{	
		for (_Nodeptr _Pnode = _Rootnode;
			!this->_Isnil(_Pnode); _Rootnode = _Pnode)
			{	
			_Erase(this->_Right(_Pnode));
			_Pnode = this->_Left(_Pnode);
			this->_Getal().destroy(
				::std:: addressof(this->_Myval(_Rootnode)));

			this->_Getal().deallocate(_Rootnode, 1);
			}
		}

	bool _Compare(const key_type& _Left, const key_type& _Right) const
		{	
		return (_Debug_lt_pred(this->_Getcomp(), _Left, _Right, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree", 2047));
		}

	template<class _Ty1,
		class _Ty2>
		bool _Compare(const _Ty1& _Left, const _Ty2& _Right) const
		{	
		return (this->_Getcomp()(_Left, _Right));
		}

	template<class _Other>
		_Nodeptr _Lbound(const _Other& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = this->_Myhead();	

		while (!this->_Isnil(_Pnode))
			if (_Compare(this->_Key(_Pnode), _Keyval))
				_Pnode = this->_Right(_Pnode);	
			else
				{	
				_Wherenode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}

		return (_Wherenode);	
		}

	_Nodeptr& _Lmost() const
		{	
		return (this->_Left(this->_Myhead()));
		}

	void _Lrotate(_Nodeptr _Wherenode)
		{	
		_Nodeptr _Pnode = this->_Right(_Wherenode);
		this->_Right(_Wherenode) = this->_Left(_Pnode);

		if (!this->_Isnil(this->_Left(_Pnode)))
			this->_Parent(this->_Left(_Pnode)) = _Wherenode;
		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))
			this->_Left(this->_Parent(_Wherenode)) = _Pnode;
		else
			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

		this->_Left(_Pnode) = _Wherenode;
		this->_Parent(_Wherenode) = _Pnode;
		}

	_Nodeptr& _Rmost() const
		{	
		return (this->_Right(this->_Myhead()));
		}

	_Nodeptr& _Root() const
		{	
		return (this->_Parent(this->_Myhead()));
		}

	void _Rrotate(_Nodeptr _Wherenode)
		{	
		_Nodeptr _Pnode = this->_Left(_Wherenode);
		this->_Left(_Wherenode) = this->_Right(_Pnode);

		if (!this->_Isnil(this->_Right(_Pnode)))
			this->_Parent(this->_Right(_Pnode)) = _Wherenode;
		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

		if (_Wherenode == _Root())
			_Root() = _Pnode;
		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))
			this->_Right(this->_Parent(_Wherenode)) = _Pnode;
		else
			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

		this->_Right(_Pnode) = _Wherenode;
		this->_Parent(_Wherenode) = _Pnode;
		}

	template<class _Other>
		_Nodeptr _Ubound(const _Other& _Keyval) const
		{	
		_Nodeptr _Pnode = _Root();
		_Nodeptr _Wherenode = this->_Myhead();	

		while (!this->_Isnil(_Pnode))
			if (_Compare(_Keyval, this->_Key(_Pnode)))
				{	
				_Wherenode = _Pnode;
				_Pnode = this->_Left(_Pnode);	
				}
			else
				_Pnode = this->_Right(_Pnode);	

		return (_Wherenode);	
		}

 
	void _Orphan_ptr(_Nodeptr _Ptr)
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				if ((*_Pnext)->_Ptr == this->_Myhead()
					|| _Ptr != nullptr_t{} && (*_Pnext)->_Ptr != _Ptr)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
		}
 #line 2165 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"

	void _Tidy()
		{	
		erase(begin(), end());
		}

	const key_type& _Kfn(const value_type& _Val) const
		{	
		return (_Traits::_Kfn(_Val));
		}

	const key_type& _Key(_Nodeptr _Pnode) const
		{	
		return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));
		}
	};

		
template<class _Traits> inline
	bool operator==(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Traits> inline
	bool operator!=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Traits> inline
	bool operator<(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Traits> inline
	bool operator>(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Traits> inline
	bool operator<=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Traits> inline
	bool operator>=(const _Tree<_Traits>& _Left, const _Tree<_Traits>& _Right)
	{	
	return (!(_Left < _Right));
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2226 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"
#line 2227 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\xtree"






#line 10 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
		
template<class _Kty,	
	class _Ty,	
	class _Pr,	
	class _Alloc,	
	bool _Mfl>	
	class _Tmap_traits
	{	
public:
	typedef _Kty key_type;
	typedef pair<const _Kty, _Ty> value_type;
	typedef _Pr key_compare;
	typedef _Alloc allocator_type;

	enum
		{	
		_Multi = _Mfl};

	class value_compare
		{	
		friend class _Tmap_traits<_Kty, _Ty, _Pr, _Alloc, _Mfl>;

	public:
		typedef value_type first_argument_type;
		typedef value_type second_argument_type;
		typedef bool result_type;

		bool operator()(const value_type& _Left,
			const value_type& _Right) const
			{	
			return (comp(_Left.first, _Right.first));
			}

		value_compare(key_compare _Pred)
			: comp(_Pred)
			{	
			}

	protected:
		key_compare comp;	
		};

	template<class _Ty1,
		class _Ty2>
		static const _Kty& _Kfn(const pair<_Ty1, _Ty2>& _Val)
		{	
		return (_Val.first);
		}
	};

		
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class map
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> >
	{	
public:
	typedef map<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, false> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	typedef typename _Mybase::_Alty _Alty;
	typedef typename _Mybase::_Pairib _Pairib;

	map()
		: _Mybase(key_compare())
		{	
		}

	explicit map(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	
		}

	map(const _Myt& _Right)
		: _Mybase(_Right,
			_Right._Getal().select_on_container_copy_construction())
		{	
		}

	map(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	explicit map(const key_compare& _Pred)
		: _Mybase(_Pred)
		{	
		}

	map(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last)
		: _Mybase(key_compare())
		{	
		insert(_First, _Last);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred)
		{	
		insert(_First, _Last);
		}

	template<class _Iter>
		map(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		insert(_First, _Last);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	map(_Myt&& _Right)
		: _Mybase(::std:: move(_Right))
		{	
		}

	map(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::is_always_equal::value && is_nothrow_move_assignable<_Pr>::value)
#line 171 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	mapped_type& operator[](key_type&& _Keyval)
		{	
		return (try_emplace(::std:: move(_Keyval)).first->second);
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::is_always_equal::value && _Is_nothrow_swappable<_Pr>::value)
#line 184 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
		{	
		_Mybase::swap(_Right);
		}

	using _Mybase::insert;

	template<class _Valty,
		class = enable_if_t<is_constructible<value_type, _Valty>::value> >
		_Pairib insert(_Valty&& _Val)
		{	
		return (this->emplace(::std:: forward<_Valty>(_Val)));
		}

	template<class _Valty,
		class = enable_if_t<is_constructible<value_type, _Valty>::value> >
		iterator insert(const_iterator _Where, _Valty&& _Val)
		{	
		return (this->emplace_hint(_Where, ::std:: forward<_Valty>(_Val)));
		}

	template<class _Keyty,
		class... _Mappedty>
		_Pairib _Try_emplace(_Keyty&& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Debug_lt_pred(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map", 212))
#line 213 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
			return (_Pairib(
				_Mybase::emplace_hint(_Where,
					piecewise_construct,
					::std:: forward_as_tuple(
						::std:: forward<_Keyty>(_Keyval)),
					::std:: forward_as_tuple(
						::std:: forward<_Mappedty>(_Mapval)...)),
				true));
		else
			return (_Pairib(_Where, false));
		}

	template<class... _Mappedty>
		_Pairib try_emplace(const key_type& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		return (_Try_emplace(_Keyval, ::std:: forward<_Mappedty>(_Mapval)...));
		}

	template<class... _Mappedty>
		iterator try_emplace(const_iterator, const key_type& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		return (_Try_emplace(_Keyval,
			::std:: forward<_Mappedty>(_Mapval)...).first);
		}

	template<class... _Mappedty>
		_Pairib try_emplace(key_type&& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		return (_Try_emplace(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)...));
		}

	template<class... _Mappedty>
		iterator try_emplace(const_iterator, key_type&& _Keyval,
			_Mappedty&&... _Mapval)
		{	
		return (_Try_emplace(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)...).first);
		}

	template<class _Keyty,
		class _Mappedty>
		_Pairib _Insert_or_assign(_Keyty&& _Keyval,
			_Mappedty&& _Mapval)
		{	
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Debug_lt_pred(_Mybase::_Getcomp(), _Keyval, _Mybase::_Key(_Where._Mynode()), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map", 264))
#line 265 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
			return (_Pairib(
				_Mybase::emplace_hint(_Where,
					::std:: forward<_Keyty>(_Keyval),
					::std:: forward<_Mappedty>(_Mapval)),
				true));
		else
			{	
			_Where->second = ::std:: forward<_Mappedty>(_Mapval);
			return (_Pairib(_Where, false));
			}
		}

	template<class _Mappedty>
		_Pairib insert_or_assign(const key_type& _Keyval,
			_Mappedty&& _Mapval)
		{	
		return (_Insert_or_assign(_Keyval,
			::std:: forward<_Mappedty>(_Mapval)));
		}

	template<class _Mappedty>
		iterator insert_or_assign(const_iterator, const key_type& _Keyval,
			_Mappedty&& _Mapval)
		{	
		return (_Insert_or_assign(_Keyval,
			::std:: forward<_Mappedty>(_Mapval)).first);
		}

	template<class _Mappedty>
		_Pairib insert_or_assign(key_type&& _Keyval,
			_Mappedty&& _Mapval)
		{	
		return (_Insert_or_assign(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)));
		}

	template<class _Mappedty>
		iterator insert_or_assign(const_iterator, key_type&& _Keyval,
			_Mappedty&& _Mapval)
		{	
		return (_Insert_or_assign(::std:: move(_Keyval),
			::std:: forward<_Mappedty>(_Mapval)).first);
		}

	map(::std:: initializer_list<value_type> _Ilist)
		: _Mybase(key_compare())
		{	
		insert(_Ilist);
		}

	map(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred)
		: _Mybase(_Pred)
		{	
		insert(_Ilist);
		}

	map(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		insert(_Ilist);
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		_Mybase::clear();
		insert(_Ilist);
		return (*this);
		}

	mapped_type& operator[](const key_type& _Keyval)
		{	
		return (try_emplace(_Keyval).first->second);
		}

	mapped_type& at(const key_type& _Keyval)
		{	
		iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
			_Xout_of_range("invalid map<K, T> key");
		return (_Where->second);
		}

	const mapped_type& at(const key_type& _Keyval) const
		{	
		const_iterator _Where = _Mybase::lower_bound(_Keyval);
		if (_Where == _Mybase::end()
			|| _Mybase::_Getcomp()(_Keyval, _Mybase::_Key(_Where._Mynode())))
			_Xout_of_range("invalid map<K, T> key");
		return (_Where->second);
		}
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(map<_Kty, _Ty, _Pr, _Alloc>& _Left,
		map<_Kty, _Ty, _Pr, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

		
template<class _Kty,
	class _Ty,
	class _Pr = less<_Kty>,
	class _Alloc = allocator<pair<const _Kty, _Ty> > >
	class multimap
		: public _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> >
	{	
public:
	typedef multimap<_Kty, _Ty, _Pr, _Alloc> _Myt;
	typedef _Tree<_Tmap_traits<_Kty, _Ty, _Pr, _Alloc, true> > _Mybase;
	typedef _Kty key_type;
	typedef _Ty mapped_type;
	typedef _Pr key_compare;
	typedef typename _Mybase::value_compare value_compare;
	typedef typename _Mybase::allocator_type allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::reverse_iterator reverse_iterator;
	typedef typename _Mybase::const_reverse_iterator
		const_reverse_iterator;
	typedef typename _Mybase::value_type value_type;

	typedef typename _Mybase::_Alty _Alty;

	multimap()
		: _Mybase(key_compare())
		{	
		}

	explicit multimap(const allocator_type& _Al)
		: _Mybase(key_compare(), _Al)
		{	
		}

	multimap(const _Myt& _Right)
		: _Mybase(_Right,
			_Right._Getal().select_on_container_copy_construction())
		{	
		}

	multimap(const _Myt& _Right, const allocator_type& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	explicit multimap(const key_compare& _Pred)
		: _Mybase(_Pred)
		{	
		}

	multimap(const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last)
		: _Mybase(key_compare())
		{	
		insert(_First, _Last);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred)
		: _Mybase(_Pred)
		{	
		insert(_First, _Last);
		}

	template<class _Iter>
		multimap(_Iter _First, _Iter _Last,
			const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		insert(_First, _Last);
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		_Mybase::operator=(_Right);
		return (*this);
		}

	multimap(_Myt&& _Right)
		: _Mybase(::std:: move(_Right))
		{	
		}

	multimap(_Myt&& _Right, const allocator_type& _Al)
		: _Mybase(::std:: move(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::is_always_equal::value && is_nothrow_move_assignable<_Pr>::value)
#line 475 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
		{	
		_Mybase::operator=(::std:: move(_Right));
		return (*this);
		}

	template<class... _Valty>
		iterator emplace(_Valty&&... _Val)
		{	
		return (_Mybase::emplace(::std:: forward<_Valty>(_Val)...).first);
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::is_always_equal::value && _Is_nothrow_swappable<_Pr>::value)
#line 489 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
		{	
		_Mybase::swap(_Right);
		}

	using _Mybase::insert;

	template<class _Valty,
		class = enable_if_t<is_constructible<value_type, _Valty>::value> >
		iterator insert(_Valty&& _Val)
		{	
		return (this->emplace(::std:: forward<_Valty>(_Val)));
		}

	template<class _Valty,
		class = enable_if_t<is_constructible<value_type, _Valty>::value> >
		iterator insert(const_iterator _Where, _Valty&& _Val)
		{	
		return (this->emplace_hint(_Where, ::std:: forward<_Valty>(_Val)));
		}

	multimap(::std:: initializer_list<value_type> _Ilist)
		: _Mybase(key_compare())
		{	
		insert(_Ilist);
		}

	multimap(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred)
		: _Mybase(_Pred)
		{	
		insert(_Ilist);
		}

	multimap(::std:: initializer_list<value_type> _Ilist,
		const key_compare& _Pred, const allocator_type& _Al)
		: _Mybase(_Pred, _Al)
		{	
		insert(_Ilist);
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		_Mybase::clear();
		insert(_Ilist);
		return (*this);
		}
	};

template<class _Kty,
	class _Ty,
	class _Pr,
	class _Alloc> inline
	void swap(multimap<_Kty, _Ty, _Pr, _Alloc>& _Left,
		multimap<_Kty, _Ty, _Pr, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 552 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"
#line 553 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\map"





#line 4 "d:\\users\\stasw\\documents\\virheimur\\game - client\\text.h"

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#pragma once

#line 1 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





















































































#line 87 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


#line 90 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


#line 93 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


#line 96 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


#line 99 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


#line 102 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
































#line 135 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


#line 138 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


#line 141 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
#line 142 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



#line 146 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
#line 147 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





#line 153 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



#line 157 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
#line 158 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




#line 163 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




#line 168 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"







#line 176 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 185 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




#line 190 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

#line 192 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
#line 193 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 207 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
#line 208 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















































#line 256 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










extern "C" {
#line 268 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef unsigned int GLenum;
typedef unsigned int GLbitfield;
typedef unsigned int GLuint;
typedef int GLint;
typedef int GLsizei;
typedef unsigned char GLboolean;
typedef signed char GLbyte;
typedef short GLshort;
typedef unsigned char GLubyte;
typedef unsigned short GLushort;
typedef unsigned long GLulong;
typedef float GLfloat;
typedef float GLclampf;
typedef double GLdouble;
typedef double GLclampd;
typedef void GLvoid;



#line 294 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
typedef signed long long GLint64EXT;
typedef unsigned long long GLuint64EXT;






#line 303 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
typedef GLint64EXT  GLint64;
typedef GLuint64EXT GLuint64;
typedef struct __GLsync *GLsync;

typedef char GLchar;
























































































































































































































































































































































































































































































































































__declspec(dllimport) void __stdcall glAccum (GLenum op, GLfloat value);
__declspec(dllimport) void __stdcall glAlphaFunc (GLenum func, GLclampf ref);
__declspec(dllimport) GLboolean __stdcall glAreTexturesResident (GLsizei n, const GLuint *textures, GLboolean *residences);
__declspec(dllimport) void __stdcall glArrayElement (GLint i);
__declspec(dllimport) void __stdcall glBegin (GLenum mode);
__declspec(dllimport) void __stdcall glBindTexture (GLenum target, GLuint texture);
__declspec(dllimport) void __stdcall glBitmap (GLsizei width, GLsizei height, GLfloat xorig, GLfloat yorig, GLfloat xmove, GLfloat ymove, const GLubyte *bitmap);
__declspec(dllimport) void __stdcall glBlendFunc (GLenum sfactor, GLenum dfactor);
__declspec(dllimport) void __stdcall glCallList (GLuint list);
__declspec(dllimport) void __stdcall glCallLists (GLsizei n, GLenum type, const void *lists);
__declspec(dllimport) void __stdcall glClear (GLbitfield mask);
__declspec(dllimport) void __stdcall glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
__declspec(dllimport) void __stdcall glClearDepth (GLclampd depth);
__declspec(dllimport) void __stdcall glClearIndex (GLfloat c);
__declspec(dllimport) void __stdcall glClearStencil (GLint s);
__declspec(dllimport) void __stdcall glClipPlane (GLenum plane, const GLdouble *equation);
__declspec(dllimport) void __stdcall glColor3b (GLbyte red, GLbyte green, GLbyte blue);
__declspec(dllimport) void __stdcall glColor3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor3d (GLdouble red, GLdouble green, GLdouble blue);
__declspec(dllimport) void __stdcall glColor3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor3f (GLfloat red, GLfloat green, GLfloat blue);
__declspec(dllimport) void __stdcall glColor3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor3i (GLint red, GLint green, GLint blue);
__declspec(dllimport) void __stdcall glColor3iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor3s (GLshort red, GLshort green, GLshort blue);
__declspec(dllimport) void __stdcall glColor3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor3ub (GLubyte red, GLubyte green, GLubyte blue);
__declspec(dllimport) void __stdcall glColor3ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor3ui (GLuint red, GLuint green, GLuint blue);
__declspec(dllimport) void __stdcall glColor3uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor3us (GLushort red, GLushort green, GLushort blue);
__declspec(dllimport) void __stdcall glColor3usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha);
__declspec(dllimport) void __stdcall glColor4bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha);
__declspec(dllimport) void __stdcall glColor4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__declspec(dllimport) void __stdcall glColor4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glColor4i (GLint red, GLint green, GLint blue, GLint alpha);
__declspec(dllimport) void __stdcall glColor4iv (const GLint *v);
__declspec(dllimport) void __stdcall glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha);
__declspec(dllimport) void __stdcall glColor4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
__declspec(dllimport) void __stdcall glColor4ubv (const GLubyte *v);
__declspec(dllimport) void __stdcall glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha);
__declspec(dllimport) void __stdcall glColor4uiv (const GLuint *v);
__declspec(dllimport) void __stdcall glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha);
__declspec(dllimport) void __stdcall glColor4usv (const GLushort *v);
__declspec(dllimport) void __stdcall glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
__declspec(dllimport) void __stdcall glColorMaterial (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glColorPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type);
__declspec(dllimport) void __stdcall glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border);
__declspec(dllimport) void __stdcall glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
__declspec(dllimport) void __stdcall glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
__declspec(dllimport) void __stdcall glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glCullFace (GLenum mode);
__declspec(dllimport) void __stdcall glDeleteLists (GLuint list, GLsizei range);
__declspec(dllimport) void __stdcall glDeleteTextures (GLsizei n, const GLuint *textures);
__declspec(dllimport) void __stdcall glDepthFunc (GLenum func);
__declspec(dllimport) void __stdcall glDepthMask (GLboolean flag);
__declspec(dllimport) void __stdcall glDepthRange (GLclampd zNear, GLclampd zFar);
__declspec(dllimport) void __stdcall glDisable (GLenum cap);
__declspec(dllimport) void __stdcall glDisableClientState (GLenum array);
__declspec(dllimport) void __stdcall glDrawArrays (GLenum mode, GLint first, GLsizei count);
__declspec(dllimport) void __stdcall glDrawBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glDrawElements (GLenum mode, GLsizei count, GLenum type, const void *indices);
__declspec(dllimport) void __stdcall glDrawPixels (GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glEdgeFlag (GLboolean flag);
__declspec(dllimport) void __stdcall glEdgeFlagPointer (GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glEdgeFlagv (const GLboolean *flag);
__declspec(dllimport) void __stdcall glEnable (GLenum cap);
__declspec(dllimport) void __stdcall glEnableClientState (GLenum array);
__declspec(dllimport) void __stdcall glEnd (void);
__declspec(dllimport) void __stdcall glEndList (void);
__declspec(dllimport) void __stdcall glEvalCoord1d (GLdouble u);
__declspec(dllimport) void __stdcall glEvalCoord1dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord1f (GLfloat u);
__declspec(dllimport) void __stdcall glEvalCoord1fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalCoord2d (GLdouble u, GLdouble v);
__declspec(dllimport) void __stdcall glEvalCoord2dv (const GLdouble *u);
__declspec(dllimport) void __stdcall glEvalCoord2f (GLfloat u, GLfloat v);
__declspec(dllimport) void __stdcall glEvalCoord2fv (const GLfloat *u);
__declspec(dllimport) void __stdcall glEvalMesh1 (GLenum mode, GLint i1, GLint i2);
__declspec(dllimport) void __stdcall glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2);
__declspec(dllimport) void __stdcall glEvalPoint1 (GLint i);
__declspec(dllimport) void __stdcall glEvalPoint2 (GLint i, GLint j);
__declspec(dllimport) void __stdcall glFeedbackBuffer (GLsizei size, GLenum type, GLfloat *buffer);
__declspec(dllimport) void __stdcall glFinish (void);
__declspec(dllimport) void __stdcall glFlush (void);
__declspec(dllimport) void __stdcall glFogf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glFogfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glFogi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glFogiv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glFrontFace (GLenum mode);
__declspec(dllimport) void __stdcall glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) GLuint __stdcall glGenLists (GLsizei range);
__declspec(dllimport) void __stdcall glGenTextures (GLsizei n, GLuint *textures);
__declspec(dllimport) void __stdcall glGetBooleanv (GLenum pname, GLboolean *params);
__declspec(dllimport) void __stdcall glGetClipPlane (GLenum plane, GLdouble *equation);
__declspec(dllimport) void __stdcall glGetDoublev (GLenum pname, GLdouble *params);
__declspec(dllimport) GLenum __stdcall glGetError (void);
__declspec(dllimport) void __stdcall glGetFloatv (GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetIntegerv (GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetLightiv (GLenum light, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetMapdv (GLenum target, GLenum query, GLdouble *v);
__declspec(dllimport) void __stdcall glGetMapfv (GLenum target, GLenum query, GLfloat *v);
__declspec(dllimport) void __stdcall glGetMapiv (GLenum target, GLenum query, GLint *v);
__declspec(dllimport) void __stdcall glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetMaterialiv (GLenum face, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetPixelMapfv (GLenum map, GLfloat *values);
__declspec(dllimport) void __stdcall glGetPixelMapuiv (GLenum map, GLuint *values);
__declspec(dllimport) void __stdcall glGetPixelMapusv (GLenum map, GLushort *values);
__declspec(dllimport) void __stdcall glGetPointerv (GLenum pname, void* *params);
__declspec(dllimport) void __stdcall glGetPolygonStipple (GLubyte *mask);
__declspec(dllimport) const GLubyte * __stdcall glGetString (GLenum name);
__declspec(dllimport) void __stdcall glGetTexEnvfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexEnviv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexGendv (GLenum coord, GLenum pname, GLdouble *params);
__declspec(dllimport) void __stdcall glGetTexGenfv (GLenum coord, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexGeniv (GLenum coord, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexImage (GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
__declspec(dllimport) void __stdcall glGetTexLevelParameterfv (GLenum target, GLint level, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexLevelParameteriv (GLenum target, GLint level, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
__declspec(dllimport) void __stdcall glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
__declspec(dllimport) void __stdcall glHint (GLenum target, GLenum mode);
__declspec(dllimport) void __stdcall glIndexMask (GLuint mask);
__declspec(dllimport) void __stdcall glIndexPointer (GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glIndexd (GLdouble c);
__declspec(dllimport) void __stdcall glIndexdv (const GLdouble *c);
__declspec(dllimport) void __stdcall glIndexf (GLfloat c);
__declspec(dllimport) void __stdcall glIndexfv (const GLfloat *c);
__declspec(dllimport) void __stdcall glIndexi (GLint c);
__declspec(dllimport) void __stdcall glIndexiv (const GLint *c);
__declspec(dllimport) void __stdcall glIndexs (GLshort c);
__declspec(dllimport) void __stdcall glIndexsv (const GLshort *c);
__declspec(dllimport) void __stdcall glIndexub (GLubyte c);
__declspec(dllimport) void __stdcall glIndexubv (const GLubyte *c);
__declspec(dllimport) void __stdcall glInitNames (void);
__declspec(dllimport) void __stdcall glInterleavedArrays (GLenum format, GLsizei stride, const void *pointer);
__declspec(dllimport) GLboolean __stdcall glIsEnabled (GLenum cap);
__declspec(dllimport) GLboolean __stdcall glIsList (GLuint list);
__declspec(dllimport) GLboolean __stdcall glIsTexture (GLuint texture);
__declspec(dllimport) void __stdcall glLightModelf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightModelfv (GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLightModeli (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightModeliv (GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLightf (GLenum light, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glLightfv (GLenum light, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glLighti (GLenum light, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glLightiv (GLenum light, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glLineStipple (GLint factor, GLushort pattern);
__declspec(dllimport) void __stdcall glLineWidth (GLfloat width);
__declspec(dllimport) void __stdcall glListBase (GLuint base);
__declspec(dllimport) void __stdcall glLoadIdentity (void);
__declspec(dllimport) void __stdcall glLoadMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glLoadMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glLoadName (GLuint name);
__declspec(dllimport) void __stdcall glLogicOp (GLenum opcode);
__declspec(dllimport) void __stdcall glMap1d (GLenum target, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap1f (GLenum target, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat *points);
__declspec(dllimport) void __stdcall glMap2d (GLenum target, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble *points);
__declspec(dllimport) void __stdcall glMap2f (GLenum target, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat *points);
__declspec(dllimport) void __stdcall glMapGrid1d (GLint un, GLdouble u1, GLdouble u2);
__declspec(dllimport) void __stdcall glMapGrid1f (GLint un, GLfloat u1, GLfloat u2);
__declspec(dllimport) void __stdcall glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2);
__declspec(dllimport) void __stdcall glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2);
__declspec(dllimport) void __stdcall glMaterialf (GLenum face, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glMateriali (GLenum face, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glMaterialiv (GLenum face, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glMatrixMode (GLenum mode);
__declspec(dllimport) void __stdcall glMultMatrixd (const GLdouble *m);
__declspec(dllimport) void __stdcall glMultMatrixf (const GLfloat *m);
__declspec(dllimport) void __stdcall glNewList (GLuint list, GLenum mode);
__declspec(dllimport) void __stdcall glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz);
__declspec(dllimport) void __stdcall glNormal3bv (const GLbyte *v);
__declspec(dllimport) void __stdcall glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz);
__declspec(dllimport) void __stdcall glNormal3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
__declspec(dllimport) void __stdcall glNormal3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glNormal3i (GLint nx, GLint ny, GLint nz);
__declspec(dllimport) void __stdcall glNormal3iv (const GLint *v);
__declspec(dllimport) void __stdcall glNormal3s (GLshort nx, GLshort ny, GLshort nz);
__declspec(dllimport) void __stdcall glNormal3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glNormalPointer (GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar);
__declspec(dllimport) void __stdcall glPassThrough (GLfloat token);
__declspec(dllimport) void __stdcall glPixelMapfv (GLenum map, GLsizei mapsize, const GLfloat *values);
__declspec(dllimport) void __stdcall glPixelMapuiv (GLenum map, GLsizei mapsize, const GLuint *values);
__declspec(dllimport) void __stdcall glPixelMapusv (GLenum map, GLsizei mapsize, const GLushort *values);
__declspec(dllimport) void __stdcall glPixelStoref (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelStorei (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelTransferf (GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glPixelTransferi (GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glPixelZoom (GLfloat xfactor, GLfloat yfactor);
__declspec(dllimport) void __stdcall glPointSize (GLfloat size);
__declspec(dllimport) void __stdcall glPolygonMode (GLenum face, GLenum mode);
__declspec(dllimport) void __stdcall glPolygonOffset (GLfloat factor, GLfloat units);
__declspec(dllimport) void __stdcall glPolygonStipple (const GLubyte *mask);
__declspec(dllimport) void __stdcall glPopAttrib (void);
__declspec(dllimport) void __stdcall glPopClientAttrib (void);
__declspec(dllimport) void __stdcall glPopMatrix (void);
__declspec(dllimport) void __stdcall glPopName (void);
__declspec(dllimport) void __stdcall glPrioritizeTextures (GLsizei n, const GLuint *textures, const GLclampf *priorities);
__declspec(dllimport) void __stdcall glPushAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushClientAttrib (GLbitfield mask);
__declspec(dllimport) void __stdcall glPushMatrix (void);
__declspec(dllimport) void __stdcall glPushName (GLuint name);
__declspec(dllimport) void __stdcall glRasterPos2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glRasterPos2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glRasterPos2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glRasterPos2iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glRasterPos2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRasterPos3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glRasterPos3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glRasterPos3iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glRasterPos3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glRasterPos4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glRasterPos4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glRasterPos4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glRasterPos4iv (const GLint *v);
__declspec(dllimport) void __stdcall glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glRasterPos4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glReadBuffer (GLenum mode);
__declspec(dllimport) void __stdcall glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void *pixels);
__declspec(dllimport) void __stdcall glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2);
__declspec(dllimport) void __stdcall glRectdv (const GLdouble *v1, const GLdouble *v2);
__declspec(dllimport) void __stdcall glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2);
__declspec(dllimport) void __stdcall glRectfv (const GLfloat *v1, const GLfloat *v2);
__declspec(dllimport) void __stdcall glRecti (GLint x1, GLint y1, GLint x2, GLint y2);
__declspec(dllimport) void __stdcall glRectiv (const GLint *v1, const GLint *v2);
__declspec(dllimport) void __stdcall glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2);
__declspec(dllimport) void __stdcall glRectsv (const GLshort *v1, const GLshort *v2);
__declspec(dllimport) GLint __stdcall glRenderMode (GLenum mode);
__declspec(dllimport) void __stdcall glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScaled (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glScalef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
__declspec(dllimport) void __stdcall glSelectBuffer (GLsizei size, GLuint *buffer);
__declspec(dllimport) void __stdcall glShadeModel (GLenum mode);
__declspec(dllimport) void __stdcall glStencilFunc (GLenum func, GLint ref, GLuint mask);
__declspec(dllimport) void __stdcall glStencilMask (GLuint mask);
__declspec(dllimport) void __stdcall glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
__declspec(dllimport) void __stdcall glTexCoord1d (GLdouble s);
__declspec(dllimport) void __stdcall glTexCoord1dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord1f (GLfloat s);
__declspec(dllimport) void __stdcall glTexCoord1fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord1i (GLint s);
__declspec(dllimport) void __stdcall glTexCoord1iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord1s (GLshort s);
__declspec(dllimport) void __stdcall glTexCoord1sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord2d (GLdouble s, GLdouble t);
__declspec(dllimport) void __stdcall glTexCoord2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord2f (GLfloat s, GLfloat t);
__declspec(dllimport) void __stdcall glTexCoord2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord2i (GLint s, GLint t);
__declspec(dllimport) void __stdcall glTexCoord2iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord2s (GLshort s, GLshort t);
__declspec(dllimport) void __stdcall glTexCoord2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord3d (GLdouble s, GLdouble t, GLdouble r);
__declspec(dllimport) void __stdcall glTexCoord3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord3f (GLfloat s, GLfloat t, GLfloat r);
__declspec(dllimport) void __stdcall glTexCoord3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord3i (GLint s, GLint t, GLint r);
__declspec(dllimport) void __stdcall glTexCoord3iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord3s (GLshort s, GLshort t, GLshort r);
__declspec(dllimport) void __stdcall glTexCoord3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q);
__declspec(dllimport) void __stdcall glTexCoord4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__declspec(dllimport) void __stdcall glTexCoord4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glTexCoord4i (GLint s, GLint t, GLint r, GLint q);
__declspec(dllimport) void __stdcall glTexCoord4iv (const GLint *v);
__declspec(dllimport) void __stdcall glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q);
__declspec(dllimport) void __stdcall glTexCoord4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glTexEnvf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexEnvi (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexEnviv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexGend (GLenum coord, GLenum pname, GLdouble param);
__declspec(dllimport) void __stdcall glTexGendv (GLenum coord, GLenum pname, const GLdouble *params);
__declspec(dllimport) void __stdcall glTexGenf (GLenum coord, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexGenfv (GLenum coord, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexGeni (GLenum coord, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexGeniv (GLenum coord, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexImage1D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTexParameterf (GLenum target, GLenum pname, GLfloat param);
__declspec(dllimport) void __stdcall glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
__declspec(dllimport) void __stdcall glTexParameteri (GLenum target, GLenum pname, GLint param);
__declspec(dllimport) void __stdcall glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
__declspec(dllimport) void __stdcall glTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
__declspec(dllimport) void __stdcall glTranslated (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glTranslatef (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex2d (GLdouble x, GLdouble y);
__declspec(dllimport) void __stdcall glVertex2dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex2f (GLfloat x, GLfloat y);
__declspec(dllimport) void __stdcall glVertex2fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex2i (GLint x, GLint y);
__declspec(dllimport) void __stdcall glVertex2iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex2s (GLshort x, GLshort y);
__declspec(dllimport) void __stdcall glVertex2sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex3d (GLdouble x, GLdouble y, GLdouble z);
__declspec(dllimport) void __stdcall glVertex3dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex3f (GLfloat x, GLfloat y, GLfloat z);
__declspec(dllimport) void __stdcall glVertex3fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex3i (GLint x, GLint y, GLint z);
__declspec(dllimport) void __stdcall glVertex3iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex3s (GLshort x, GLshort y, GLshort z);
__declspec(dllimport) void __stdcall glVertex3sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w);
__declspec(dllimport) void __stdcall glVertex4dv (const GLdouble *v);
__declspec(dllimport) void __stdcall glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
__declspec(dllimport) void __stdcall glVertex4fv (const GLfloat *v);
__declspec(dllimport) void __stdcall glVertex4i (GLint x, GLint y, GLint z, GLint w);
__declspec(dllimport) void __stdcall glVertex4iv (const GLint *v);
__declspec(dllimport) void __stdcall glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w);
__declspec(dllimport) void __stdcall glVertex4sv (const GLshort *v);
__declspec(dllimport) void __stdcall glVertexPointer (GLint size, GLenum type, GLsizei stride, const void *pointer);
__declspec(dllimport) void __stdcall glViewport (GLint x, GLint y, GLsizei width, GLsizei height);



#line 1184 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 1195 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





#line 1201 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"





















#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"


















#pragma once
#line 21 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"





































#line 59 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"


























































#line 118 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"










































 

















#line 179 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"

#line 181 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winapifamily.h"
#line 23 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\gl.h"































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 24 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"


extern "C" {
#line 28 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"


















#pragma region Desktop Family















#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"

const GLubyte* __stdcall gluErrorString (
    GLenum   errCode);

const wchar_t* __stdcall gluErrorUnicodeStringEXT (
    GLenum   errCode);

const GLubyte* __stdcall gluGetString (
    GLenum   name);

void __stdcall gluOrtho2D (
    GLdouble left, 
    GLdouble right, 
    GLdouble bottom, 
    GLdouble top);

void __stdcall gluPerspective (
    GLdouble fovy, 
    GLdouble aspect, 
    GLdouble zNear, 
    GLdouble zFar);

void __stdcall gluPickMatrix (
    GLdouble x, 
    GLdouble y, 
    GLdouble width, 
    GLdouble height, 
    GLint    viewport[4]);

void __stdcall gluLookAt (
    GLdouble eyex, 
    GLdouble eyey, 
    GLdouble eyez, 
    GLdouble centerx, 
    GLdouble centery, 
    GLdouble centerz, 
    GLdouble upx, 
    GLdouble upy, 
    GLdouble upz);

int __stdcall gluProject (
    GLdouble        objx, 
    GLdouble        objy, 
    GLdouble        objz,  
    const GLdouble  modelMatrix[16], 
    const GLdouble  projMatrix[16], 
    const GLint     viewport[4], 
    GLdouble        *winx, 
    GLdouble        *winy, 
    GLdouble        *winz);

int __stdcall gluUnProject (
    GLdouble       winx, 
    GLdouble       winy, 
    GLdouble       winz, 
    const GLdouble modelMatrix[16], 
    const GLdouble projMatrix[16], 
    const GLint    viewport[4], 
    GLdouble       *objx, 
    GLdouble       *objy, 
    GLdouble       *objz);


int __stdcall gluScaleImage (
    GLenum      format, 
    GLint       widthin, 
    GLint       heightin, 
    GLenum      typein, 
    const void  *datain, 
    GLint       widthout, 
    GLint       heightout, 
    GLenum      typeout, 
    void        *dataout);


int __stdcall gluBuild1DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);

int __stdcall gluBuild2DMipmaps (
    GLenum      target, 
    GLint       components, 
    GLint       width, 
    GLint       height, 
    GLenum      format, 
    GLenum      type, 
    const void  *data);



class GLUnurbs;
class GLUquadric;
class GLUtesselator;


typedef class GLUnurbs GLUnurbsObj;
typedef class GLUquadric GLUquadricObj;
typedef class GLUtesselator GLUtesselatorObj;
typedef class GLUtesselator GLUtriangulatorObj;













#line 180 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"


GLUquadric* __stdcall gluNewQuadric (void);
void __stdcall gluDeleteQuadric (
    GLUquadric          *state);

void __stdcall gluQuadricNormals (
    GLUquadric          *quadObject, 
    GLenum              normals);

void __stdcall gluQuadricTexture (
    GLUquadric          *quadObject, 
    GLboolean           textureCoords);

void __stdcall gluQuadricOrientation (
    GLUquadric          *quadObject, 
    GLenum              orientation);

void __stdcall gluQuadricDrawStyle (
    GLUquadric          *quadObject, 
    GLenum              drawStyle);

void __stdcall gluCylinder (
    GLUquadric          *qobj, 
    GLdouble            baseRadius, 
    GLdouble            topRadius, 
    GLdouble            height, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops);

void __stdcall gluPartialDisk (
    GLUquadric          *qobj, 
    GLdouble            innerRadius, 
    GLdouble            outerRadius, 
    GLint               slices, 
    GLint               loops, 
    GLdouble            startAngle, 
    GLdouble            sweepAngle);

void __stdcall gluSphere (
    GLUquadric          *qobj, 
    GLdouble            radius, 
    GLint               slices, 
    GLint               stacks);

void __stdcall gluQuadricCallback (
    GLUquadric          *qobj, 
    GLenum              which, 
    void                (__stdcall* fn)());

GLUtesselator* __stdcall  gluNewTess(          
    void );

void __stdcall  gluDeleteTess(       
    GLUtesselator       *tess );

void __stdcall  gluTessBeginPolygon( 
    GLUtesselator       *tess,
    void                *polygon_data );

void __stdcall  gluTessBeginContour( 
    GLUtesselator       *tess );

void __stdcall  gluTessVertex(       
    GLUtesselator       *tess,
    GLdouble            coords[3], 
    void                *data );

void __stdcall  gluTessEndContour(   
    GLUtesselator       *tess );

void __stdcall  gluTessEndPolygon(   
    GLUtesselator       *tess );

void __stdcall  gluTessProperty(     
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            value );
 
void __stdcall  gluTessNormal(       
    GLUtesselator       *tess, 
    GLdouble            x,
    GLdouble            y, 
    GLdouble            z );

void __stdcall  gluTessCallback(     
    GLUtesselator       *tess,
    GLenum              which, 
    void                (__stdcall *fn)());

void __stdcall  gluGetTessProperty(  
    GLUtesselator       *tess,
    GLenum              which, 
    GLdouble            *value );
 
GLUnurbs* __stdcall gluNewNurbsRenderer (void);

void __stdcall gluDeleteNurbsRenderer (
    GLUnurbs            *nobj);

void __stdcall gluBeginSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndCurve (
    GLUnurbs            *nobj);

void __stdcall gluEndSurface (
    GLUnurbs            *nobj);

void __stdcall gluBeginTrim (
    GLUnurbs            *nobj);

void __stdcall gluEndTrim (
    GLUnurbs            *nobj);

void __stdcall gluPwlCurve (
    GLUnurbs            *nobj, 
    GLint               count, 
    GLfloat             *array, 
    GLint               stride, 
    GLenum              type);

void __stdcall gluNurbsCurve (
    GLUnurbs            *nobj, 
    GLint               nknots, 
    GLfloat             *knot, 
    GLint               stride, 
    GLfloat             *ctlarray, 
    GLint               order, 
    GLenum              type);

void __stdcall 
gluNurbsSurface(     
    GLUnurbs            *nobj, 
    GLint               sknot_count, 
    float               *sknot, 
    GLint               tknot_count, 
    GLfloat             *tknot, 
    GLint               s_stride, 
    GLint               t_stride, 
    GLfloat             *ctlarray, 
    GLint               sorder, 
    GLint               torder, 
    GLenum              type);

void __stdcall 
gluLoadSamplingMatrices (
    GLUnurbs            *nobj, 
    const GLfloat       modelMatrix[16], 
    const GLfloat       projMatrix[16], 
    const GLint         viewport[4] );

void __stdcall 
gluNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             value );

void __stdcall 
gluGetNurbsProperty (
    GLUnurbs            *nobj, 
    GLenum              property, 
    GLfloat             *value );

void __stdcall 
gluNurbsCallback (
    GLUnurbs            *nobj, 
    GLenum              which, 
    void                (__stdcall* fn)() );





typedef void (__stdcall* GLUquadricErrorProc) (GLenum);


typedef void (__stdcall* GLUtessBeginProc)        (GLenum);
typedef void (__stdcall* GLUtessEdgeFlagProc)     (GLboolean);
typedef void (__stdcall* GLUtessVertexProc)       (void *);
typedef void (__stdcall* GLUtessEndProc)          (void);
typedef void (__stdcall* GLUtessErrorProc)        (GLenum);
typedef void (__stdcall* GLUtessCombineProc)      (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void** );
typedef void (__stdcall* GLUtessBeginDataProc)    (GLenum, void *);
typedef void (__stdcall* GLUtessEdgeFlagDataProc) (GLboolean, void *);
typedef void (__stdcall* GLUtessVertexDataProc)   (void *, void *);
typedef void (__stdcall* GLUtessEndDataProc)      (void *);
typedef void (__stdcall* GLUtessErrorDataProc)    (GLenum, void *);
typedef void (__stdcall* GLUtessCombineDataProc)  (GLdouble[3],
                                                  void*[4], 
                                                  GLfloat[4],
                                                  void**,
                                                  void* );


typedef void (__stdcall* GLUnurbsErrorProc)   (GLenum);













































































































































































void __stdcall   gluBeginPolygon( GLUtesselator *tess );

void __stdcall   gluNextContour(  GLUtesselator *tess, 
                                 GLenum        type );

void __stdcall   gluEndPolygon(   GLUtesselator *tess );















#line 584 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"
#pragma endregion


}
#line 589 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"

#line 591 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"
#line 592 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\glu.h"
#line 1202 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
#line 1203 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
#line 1204 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















































typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);
typedef void (__stdcall * PFNGLTEXIMAGE3DPROC) (GLenum target, GLint level, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);








#line 1264 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 1273 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"







































































































typedef void (__stdcall * PFNGLACTIVETEXTUREPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCLIENTACTIVETEXTUREPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE1DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE2DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXIMAGEPROC) (GLenum target, GLint lod, void *img);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXDPROC) (const GLdouble m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXFPROC) (const GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DPROC) (GLenum target, GLdouble s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FPROC) (GLenum target, GLfloat s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IPROC) (GLenum target, GLint s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SPROC) (GLenum target, GLshort s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IPROC) (GLenum target, GLint s, GLint t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SPROC) (GLenum target, GLshort s, GLshort t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DVPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FVPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IVPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SVPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLSAMPLECOVERAGEPROC) (GLclampf value, GLboolean invert);


















































#line 1473 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














































typedef void (__stdcall * PFNGLBLENDCOLORPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONPROC) (GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);
typedef void (__stdcall * PFNGLFOGCOORDPOINTERPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLFOGCOORDDPROC) (GLdouble coord);
typedef void (__stdcall * PFNGLFOGCOORDDVPROC) (const GLdouble *coord);
typedef void (__stdcall * PFNGLFOGCOORDFPROC) (GLfloat coord);
typedef void (__stdcall * PFNGLFOGCOORDFVPROC) (const GLfloat *coord);
typedef void (__stdcall * PFNGLMULTIDRAWARRAYSPROC) (GLenum mode, const GLint *first, const GLsizei *count, GLsizei drawcount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSPROC) (GLenum mode, const GLsizei *count, GLenum type, const void *const* indices, GLsizei drawcount);
typedef void (__stdcall * PFNGLPOINTPARAMETERFPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVPROC) (GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLPOINTPARAMETERIPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPOINTPARAMETERIVPROC) (GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BVPROC) (const GLbyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DVPROC) (const GLdouble *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FVPROC) (const GLfloat *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IPROC) (GLint red, GLint green, GLint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IVPROC) (const GLint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SPROC) (GLshort red, GLshort green, GLshort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SVPROC) (const GLshort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBVPROC) (const GLubyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIPROC) (GLuint red, GLuint green, GLuint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIVPROC) (const GLuint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USPROC) (GLushort red, GLushort green, GLushort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USVPROC) (const GLushort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTERPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLWINDOWPOS2DPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVPROC) (const GLdouble *p);
typedef void (__stdcall * PFNGLWINDOWPOS2FPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVPROC) (const GLfloat *p);
typedef void (__stdcall * PFNGLWINDOWPOS2IPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVPROC) (const GLint *p);
typedef void (__stdcall * PFNGLWINDOWPOS2SPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVPROC) (const GLshort *p);
typedef void (__stdcall * PFNGLWINDOWPOS3DPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVPROC) (const GLdouble *p);
typedef void (__stdcall * PFNGLWINDOWPOS3FPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVPROC) (const GLfloat *p);
typedef void (__stdcall * PFNGLWINDOWPOS3IPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVPROC) (const GLint *p);
typedef void (__stdcall * PFNGLWINDOWPOS3SPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVPROC) (const GLshort *p);



















































#line 1618 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

























































typedef ptrdiff_t GLintptr;
typedef ptrdiff_t GLsizeiptr;

typedef void (__stdcall * PFNGLBEGINQUERYPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLBINDBUFFERPROC) (GLenum target, GLuint buffer);
typedef void (__stdcall * PFNGLBUFFERDATAPROC) (GLenum target, GLsizeiptr size, const void* data, GLenum usage);
typedef void (__stdcall * PFNGLBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, const void* data);
typedef void (__stdcall * PFNGLDELETEBUFFERSPROC) (GLsizei n, const GLuint* buffers);
typedef void (__stdcall * PFNGLDELETEQUERIESPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLGENQUERIESPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETBUFFERPOINTERVPROC) (GLenum target, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETBUFFERSUBDATAPROC) (GLenum target, GLintptr offset, GLsizeiptr size, void* data);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISBUFFERPROC) (GLuint buffer);
typedef GLboolean (__stdcall * PFNGLISQUERYPROC) (GLuint id);
typedef void* (__stdcall * PFNGLMAPBUFFERPROC) (GLenum target, GLenum access);
typedef GLboolean (__stdcall * PFNGLUNMAPBUFFERPROC) (GLenum target);























#line 1721 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



























































































typedef void (__stdcall * PFNGLATTACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (__stdcall * PFNGLBINDATTRIBLOCATIONPROC) (GLuint program, GLuint index, const GLchar* name);
typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEPROC) (GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLCOMPILESHADERPROC) (GLuint shader);
typedef GLuint (__stdcall * PFNGLCREATEPROGRAMPROC) (void);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROC) (GLenum type);
typedef void (__stdcall * PFNGLDELETEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLDELETESHADERPROC) (GLuint shader);
typedef void (__stdcall * PFNGLDETACHSHADERPROC) (GLuint program, GLuint shader);
typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (__stdcall * PFNGLDRAWBUFFERSPROC) (GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBARRAYPROC) (GLuint index);
typedef void (__stdcall * PFNGLGETACTIVEATTRIBPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMPROC) (GLuint program, GLuint index, GLsizei maxLength, GLsizei* length, GLint* size, GLenum* type, GLchar* name);
typedef void (__stdcall * PFNGLGETATTACHEDSHADERSPROC) (GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders);
typedef GLint (__stdcall * PFNGLGETATTRIBLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void (__stdcall * PFNGLGETPROGRAMINFOLOGPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void (__stdcall * PFNGLGETPROGRAMIVPROC) (GLuint program, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETSHADERINFOLOGPROC) (GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog);
typedef void (__stdcall * PFNGLGETSHADERSOURCEPROC) (GLuint obj, GLsizei maxLength, GLsizei* length, GLchar* source);
typedef void (__stdcall * PFNGLGETSHADERIVPROC) (GLuint shader, GLenum pname, GLint* param);
typedef GLint (__stdcall * PFNGLGETUNIFORMLOCATIONPROC) (GLuint program, const GLchar* name);
typedef void (__stdcall * PFNGLGETUNIFORMFVPROC) (GLuint program, GLint location, GLfloat* params);
typedef void (__stdcall * PFNGLGETUNIFORMIVPROC) (GLuint program, GLint location, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMPROC) (GLuint program);
typedef GLboolean (__stdcall * PFNGLISSHADERPROC) (GLuint shader);
typedef void (__stdcall * PFNGLLINKPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLSHADERSOURCEPROC) (GLuint shader, GLsizei count, const GLchar *const* string, const GLint* length);
typedef void (__stdcall * PFNGLSTENCILFUNCSEPARATEPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILMASKSEPARATEPROC) (GLenum face, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILOPSEPARATEPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);
typedef void (__stdcall * PFNGLUNIFORM1FPROC) (GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLUNIFORM1FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM1IPROC) (GLint location, GLint v0);
typedef void (__stdcall * PFNGLUNIFORM1IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM2FPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLUNIFORM2FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM2IPROC) (GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLUNIFORM2IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM3FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLUNIFORM3FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM3IPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLUNIFORM3IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM4FPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLUNIFORM4FVPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM4IPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLUNIFORM4IVPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMPROC) (GLuint program);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NBVPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NIVPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NSVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUIVPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUSVPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4BVPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4IVPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UIVPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4USVPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer);

































































































#line 2003 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






























typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3FVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat *value);










#line 2050 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















































































































typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERPROC) (GLuint id, GLenum mode);
typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONPROC) (GLuint program, GLuint colorNumber, const GLchar* name);
typedef void (__stdcall * PFNGLCLAMPCOLORPROC) (GLenum target, GLenum clamp);
typedef void (__stdcall * PFNGLCLEARBUFFERFIPROC) (GLenum buffer, GLint drawBuffer, GLfloat depth, GLint stencil);
typedef void (__stdcall * PFNGLCLEARBUFFERFVPROC) (GLenum buffer, GLint drawBuffer, const GLfloat* value);
typedef void (__stdcall * PFNGLCLEARBUFFERIVPROC) (GLenum buffer, GLint drawBuffer, const GLint* value);
typedef void (__stdcall * PFNGLCLEARBUFFERUIVPROC) (GLenum buffer, GLint drawBuffer, const GLuint* value);
typedef void (__stdcall * PFNGLCOLORMASKIPROC) (GLuint buf, GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
typedef void (__stdcall * PFNGLDISABLEIPROC) (GLenum cap, GLuint index);
typedef void (__stdcall * PFNGLENABLEIPROC) (GLenum cap, GLuint index);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERPROC) (void);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKPROC) (void);
typedef void (__stdcall * PFNGLGETBOOLEANI_VPROC) (GLenum pname, GLuint index, GLboolean* data);
typedef GLint (__stdcall * PFNGLGETFRAGDATALOCATIONPROC) (GLuint program, const GLchar* name);
typedef const GLubyte* (__stdcall * PFNGLGETSTRINGIPROC) (GLenum name, GLuint index);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei * length, GLsizei * size, GLenum * type, GLchar * name);
typedef void (__stdcall * PFNGLGETUNIFORMUIVPROC) (GLuint program, GLint location, GLuint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIIVPROC) (GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIUIVPROC) (GLuint index, GLenum pname, GLuint* params);
typedef GLboolean (__stdcall * PFNGLISENABLEDIPROC) (GLenum cap, GLuint index);
typedef void (__stdcall * PFNGLTEXPARAMETERIIVPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXPARAMETERIUIVPROC) (GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSPROC) (GLuint program, GLsizei count, const GLchar *const* varyings, GLenum bufferMode);
typedef void (__stdcall * PFNGLUNIFORM1UIPROC) (GLint location, GLuint v0);
typedef void (__stdcall * PFNGLUNIFORM1UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLUNIFORM2UIPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLUNIFORM2UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLUNIFORM3UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLUNIFORM3UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLUNIFORM4UIPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLUNIFORM4UIVPROC) (GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IPROC) (GLuint index, GLint v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIPROC) (GLuint index, GLuint v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IPROC) (GLuint index, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIPROC) (GLuint index, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IPROC) (GLuint index, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4BVPROC) (GLuint index, const GLbyte* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IPROC) (GLuint index, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IVPROC) (GLuint index, const GLint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4SVPROC) (GLuint index, const GLshort* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UBVPROC) (GLuint index, const GLubyte* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIPROC) (GLuint index, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIVPROC) (GLuint index, const GLuint* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4USVPROC) (GLuint index, const GLushort* v0);
typedef void (__stdcall * PFNGLVERTEXATTRIBIPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void*pointer);



























































#line 2277 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









































typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void (__stdcall * PFNGLPRIMITIVERESTARTINDEXPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLTEXBUFFERPROC) (GLenum target, GLenum internalFormat, GLuint buffer);








#line 2331 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERI64VPROC) (GLenum target, GLenum value, GLint64 * data);
typedef void (__stdcall * PFNGLGETINTEGER64I_VPROC) (GLenum pname, GLuint index, GLint64 * data);







#line 2371 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORPROC) (GLuint index, GLuint divisor);





#line 2387 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLMINSAMPLESHADINGPROC) (GLclampf value);









#line 2421 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2430 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 2444 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 2456 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 2469 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2478 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 2492 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTBUFFERMASK3DFXPROC) (GLuint mask);





#line 2505 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 2517 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 2529 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2538 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





















typedef void (__stdcall *GLDEBUGPROCAMD)(GLuint id, GLenum category, GLenum severity, GLsizei length, const GLchar* message, void* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKAMDPROC) (GLDEBUGPROCAMD callback, void *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGEENABLEAMDPROC) (GLenum category, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTAMDPROC) (GLenum category, GLenum severity, GLuint id, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGAMDPROC) (GLuint count, GLsizei bufsize, GLenum* categories, GLuint* severities, GLuint* ids, GLsizei* lengths, GLchar* message);








#line 2574 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 2586 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBLENDEQUATIONINDEXEDAMDPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCINDEXEDAMDPROC) (GLuint buf, GLenum src, GLenum dst);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);








#line 2605 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2614 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2623 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLVERTEXATTRIBPARAMETERIAMDPROC) (GLuint index, GLenum pname, GLint param);





#line 2646 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);






#line 2661 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLDELETENAMESAMDPROC) (GLenum identifier, GLuint num, const GLuint* names);
typedef void (__stdcall * PFNGLGENNAMESAMDPROC) (GLenum identifier, GLuint num, GLuint* names);
typedef GLboolean (__stdcall * PFNGLISNAMEAMDPROC) (GLenum identifier, GLuint name);







#line 2684 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLQUERYOBJECTPARAMETERUIAMDPROC) (GLenum target, GLuint id, GLenum pname, GLuint param);





#line 2704 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLBEGINPERFMONITORAMDPROC) (GLuint monitor);
typedef void (__stdcall * PFNGLDELETEPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void (__stdcall * PFNGLENDPERFMONITORAMDPROC) (GLuint monitor);
typedef void (__stdcall * PFNGLGENPERFMONITORSAMDPROC) (GLsizei n, GLuint* monitors);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERDATAAMDPROC) (GLuint monitor, GLenum pname, GLsizei dataSize, GLuint* data, GLint *bytesWritten);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERINFOAMDPROC) (GLuint group, GLuint counter, GLenum pname, void *data);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC) (GLuint group, GLuint counter, GLsizei bufSize, GLsizei* length, GLchar *counterString);
typedef void (__stdcall * PFNGLGETPERFMONITORCOUNTERSAMDPROC) (GLuint group, GLint* numCounters, GLint *maxActiveCounters, GLsizei countersSize, GLuint *counters);
typedef void (__stdcall * PFNGLGETPERFMONITORGROUPSTRINGAMDPROC) (GLuint group, GLsizei bufSize, GLsizei* length, GLchar *groupString);
typedef void (__stdcall * PFNGLGETPERFMONITORGROUPSAMDPROC) (GLint* numGroups, GLsizei groupsSize, GLuint *groups);
typedef void (__stdcall * PFNGLSELECTPERFMONITORCOUNTERSAMDPROC) (GLuint monitor, GLboolean enable, GLuint group, GLint numCounters, GLuint* counterList);















#line 2745 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 2756 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 2769 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLSETMULTISAMPLEFVAMDPROC) (GLenum pname, GLuint index, const GLfloat* val);





#line 2784 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 2795 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2804 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2813 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2822 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2831 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLTEXSTORAGESPARSEAMDPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);
typedef void (__stdcall * PFNGLTEXTURESTORAGESPARSEAMDPROC) (GLuint texture, GLenum target, GLenum internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLsizei layers, GLbitfield flags);






#line 2856 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLSTENCILOPVALUEAMDPROC) (GLenum face, GLuint value);





#line 2874 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2883 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2892 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 2903 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2912 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLTESSELLATIONFACTORAMDPROC) (GLfloat factor);
typedef void (__stdcall * PFNGLTESSELLATIONMODEAMDPROC) (GLenum mode);






#line 2935 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2944 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 2953 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLITFRAMEBUFFERANGLEPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 2971 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 2988 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDANGLEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDANGLEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);
typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORANGLEPROC) (GLuint index, GLuint divisor);







#line 3007 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 3018 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 3029 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 3043 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 3057 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 3071 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 3083 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLBEGINQUERYANGLEPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEQUERIESANGLEPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYANGLEPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENQUERIESANGLEPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VANGLEPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVANGLEPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VANGLEPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVANGLEPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVANGLEPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISQUERYANGLEPROC) (GLuint id);
typedef void (__stdcall * PFNGLQUERYCOUNTERANGLEPROC) (GLuint id, GLenum target);















#line 3123 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC) (GLuint shader, GLsizei bufsize, GLsizei* length, GLchar* source);





#line 3138 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 3149 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 3160 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLELEMENTPOINTERAPPLEPROC) (GLenum type, const void *pointer);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void (__stdcall * PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC) (GLenum mode, GLuint start, GLuint end, const GLint* first, const GLsizei *count, GLsizei primcount);









#line 3185 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDELETEFENCESAPPLEPROC) (GLsizei n, const GLuint* fences);
typedef void (__stdcall * PFNGLFINISHFENCEAPPLEPROC) (GLuint fence);
typedef void (__stdcall * PFNGLFINISHOBJECTAPPLEPROC) (GLenum object, GLint name);
typedef void (__stdcall * PFNGLGENFENCESAPPLEPROC) (GLsizei n, GLuint* fences);
typedef GLboolean (__stdcall * PFNGLISFENCEAPPLEPROC) (GLuint fence);
typedef void (__stdcall * PFNGLSETFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean (__stdcall * PFNGLTESTFENCEAPPLEPROC) (GLuint fence);
typedef GLboolean (__stdcall * PFNGLTESTOBJECTAPPLEPROC) (GLenum object, GLuint name);












#line 3215 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"























#line 3239 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBUFFERPARAMETERIAPPLEPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC) (GLenum target, GLintptr offset, GLsizeiptr size);






#line 3257 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETOBJECTPARAMETERIVAPPLEPROC) (GLenum objectType, GLuint name, GLenum pname, GLint* params);
typedef GLenum (__stdcall * PFNGLOBJECTPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);
typedef GLenum (__stdcall * PFNGLOBJECTUNPURGEABLEAPPLEPROC) (GLenum objectType, GLuint name, GLenum option);







#line 3281 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 3292 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 3306 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 3318 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 3329 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC) (GLenum target, GLenum pname, void **params);
typedef void (__stdcall * PFNGLTEXTURERANGEAPPLEPROC) (GLenum target, GLsizei length, void *pointer);






#line 3351 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 3362 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLBINDVERTEXARRAYAPPLEPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSAPPLEPROC) (GLsizei n, const GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYAPPLEPROC) (GLuint array);








#line 3383 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);
typedef void (__stdcall * PFNGLVERTEXARRAYPARAMETERIAPPLEPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLVERTEXARRAYRANGEAPPLEPROC) (GLsizei length, void *pointer);







#line 3409 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBAPPLEPROC) (GLuint index, GLenum pname);
typedef GLboolean (__stdcall * PFNGLISVERTEXATTRIBENABLEDAPPLEPROC) (GLuint index, GLenum pname);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB1DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint stride, GLint order, const GLdouble* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB1FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint stride, GLint order, const GLfloat* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB2DAPPLEPROC) (GLuint index, GLuint size, GLdouble u1, GLdouble u2, GLint ustride, GLint uorder, GLdouble v1, GLdouble v2, GLint vstride, GLint vorder, const GLdouble* points);
typedef void (__stdcall * PFNGLMAPVERTEXATTRIB2FAPPLEPROC) (GLuint index, GLuint size, GLfloat u1, GLfloat u2, GLint ustride, GLint uorder, GLfloat v1, GLfloat v2, GLint vstride, GLint vorder, const GLfloat* points);











#line 3445 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 3456 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"























typedef int GLfixed;

typedef void (__stdcall * PFNGLCLEARDEPTHFPROC) (GLclampf d);
typedef void (__stdcall * PFNGLDEPTHRANGEFPROC) (GLclampf n, GLclampf f);
typedef void (__stdcall * PFNGLGETSHADERPRECISIONFORMATPROC) (GLenum shadertype, GLenum precisiontype, GLint* range, GLint *precision);
typedef void (__stdcall * PFNGLRELEASESHADERCOMPILERPROC) (void);
typedef void (__stdcall * PFNGLSHADERBINARYPROC) (GLsizei count, const GLuint* shaders, GLenum binaryformat, const void*binary, GLsizei length);









#line 3496 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMEMORYBARRIERBYREGIONPROC) (GLbitfield barriers);





#line 3509 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"























#line 3533 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 3542 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLuint baseinstance);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex, GLuint baseinstance);







#line 3559 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef GLuint64 (__stdcall * PFNGLGETIMAGEHANDLEARBPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (__stdcall * PFNGLGETTEXTUREHANDLEARBPROC) (GLuint texture);
typedef GLuint64 (__stdcall * PFNGLGETTEXTURESAMPLERHANDLEARBPROC) (GLuint texture, GLuint sampler);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBLUI64VARBPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef GLboolean (__stdcall * PFNGLISIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef GLboolean (__stdcall * PFNGLISTEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLERESIDENTARBPROC) (GLuint64 handle, GLenum access);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLERESIDENTARBPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC) (GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64ARBPROC) (GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64VARBPROC) (GLint location, GLsizei count, const GLuint64* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64ARBPROC) (GLuint index, GLuint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64VARBPROC) (GLuint index, const GLuint64EXT* v);




















#line 3604 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONINDEXEDPROC) (GLuint program, GLuint colorNumber, GLuint index, const GLchar * name);
typedef GLint (__stdcall * PFNGLGETFRAGDATAINDEXPROC) (GLuint program, const GLchar * name);






#line 3624 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLBUFFERSTORAGEPROC) (GLenum target, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);






#line 3649 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef struct _cl_context *cl_context;
typedef struct _cl_event *cl_event;

typedef GLsync (__stdcall * PFNGLCREATESYNCFROMCLEVENTARBPROC) (cl_context context, cl_event event, GLbitfield flags);





#line 3668 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCLEARBUFFERDATAPROC) (GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARBUFFERSUBDATAPROC) (GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);








#line 3687 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLCLEARTEXIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARTEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data);






#line 3704 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLCLIPCONTROLPROC) (GLenum origin, GLenum depth);





#line 3724 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLCLAMPCOLORARBPROC) (GLenum target, GLenum clamp);





#line 3743 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 3752 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

















#line 3770 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

























typedef void (__stdcall * PFNGLDISPATCHCOMPUTEPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z);
typedef void (__stdcall * PFNGLDISPATCHCOMPUTEINDIRECTPROC) (GLintptr indirect);






#line 3804 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC) (GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z, GLuint group_size_x, GLuint group_size_y, GLuint group_size_z);





#line 3822 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 3836 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 3845 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLCOPYBUFFERSUBDATAPROC) (GLenum readtarget, GLenum writetarget, GLintptr readoffset, GLintptr writeoffset, GLsizeiptr size);





#line 3861 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYIMAGESUBDATAPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth);





#line 3874 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 3886 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





























typedef void (__stdcall *GLDEBUGPROCARB)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKARBPROC) (GLDEBUGPROCARB callback, const void *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGECONTROLARBPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTARBPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGARBPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);








#line 3930 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 3943 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 3954 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 3969 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 3978 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLBINDTEXTUREUNITPROC) (GLuint unit, GLuint texture);
typedef void (__stdcall * PFNGLBLITNAMEDFRAMEBUFFERPROC) (GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum (__stdcall * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC) (GLuint framebuffer, GLenum target);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERDATAPROC) (GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERFIPROC) (GLuint framebuffer, GLenum buffer, GLfloat depth, GLint stencil);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERFVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat* value);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint* value);
typedef void (__stdcall * PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC) (GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint* value);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOPYNAMEDBUFFERSUBDATAPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCREATEBUFFERSPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLCREATEFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLCREATEPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void (__stdcall * PFNGLCREATEQUERIESPROC) (GLenum target, GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLCREATERENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLCREATESAMPLERSPROC) (GLsizei n, GLuint* samplers);
typedef void (__stdcall * PFNGLCREATETEXTURESPROC) (GLenum target, GLsizei n, GLuint* textures);
typedef void (__stdcall * PFNGLCREATETRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLCREATEVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYATTRIBPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLGENERATETEXTUREMIPMAPPROC) (GLuint texture);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLsizei bufSize, void *pixels);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERI64VPROC) (GLuint buffer, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERIVPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPOINTERVPROC) (GLuint buffer, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREIMAGEPROC) (GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERFVPROC) (GLuint texture, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERIVPROC) (GLuint texture, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKI64_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint64* param);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKI_VPROC) (GLuint xfb, GLenum pname, GLuint index, GLint* param);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKIVPROC) (GLuint xfb, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINDEXED64IVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint64* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINDEXEDIVPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYIVPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments);
typedef void (__stdcall * PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC) (GLuint framebuffer, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFERPROC) (GLuint buffer, GLenum access);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFERRANGEPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (__stdcall * PFNGLNAMEDBUFFERDATAPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void (__stdcall * PFNGLNAMEDBUFFERSTORAGEPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags);
typedef void (__stdcall * PFNGLNAMEDBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC) (GLuint framebuffer, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTUREBUFFERPROC) (GLuint texture, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLTEXTUREBUFFERRANGEPROC) (GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIIVPROC) (GLuint texture, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIUIVPROC) (GLuint texture, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFPROC) (GLuint texture, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFVPROC) (GLuint texture, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIPROC) (GLuint texture, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIVPROC) (GLuint texture, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLTEXTURESTORAGE1DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DPROC) (GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC) (GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE1DPROC) (GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE2DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE3DPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC) (GLuint xfb, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC) (GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef GLboolean (__stdcall * PFNGLUNMAPNAMEDBUFFERPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBBINDINGPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBIFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYATTRIBLFORMATPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYBINDINGDIVISORPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (__stdcall * PFNGLVERTEXARRAYELEMENTBUFFERPROC) (GLuint vaobj, GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXBUFFERPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXBUFFERSPROC) (GLuint vaobj, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);

































































































#line 4179 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLDRAWBUFFERSARBPROC) (GLsizei n, const GLenum* bufs);





#line 4210 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEIARBPROC) (GLuint buf, GLenum modeRGB, GLenum modeAlpha);
typedef void (__stdcall * PFNGLBLENDEQUATIONIARBPROC) (GLuint buf, GLenum mode);
typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEIARBPROC) (GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha);
typedef void (__stdcall * PFNGLBLENDFUNCIARBPROC) (GLuint buf, GLenum src, GLenum dst);








#line 4229 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount, GLint basevertex);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices, GLint basevertex);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC) (GLenum mode, const GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount, const GLint *basevertex);








#line 4248 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect);
typedef void (__stdcall * PFNGLDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect);






#line 4266 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 4275 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 4288 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 4297 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 4308 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 4317 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 4326 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
























#line 4351 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 4360 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 4373 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLFRAMEBUFFERPARAMETERIPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC) (GLuint framebuffer, GLenum pname, GLint param);








#line 4402 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

















































































typedef void (__stdcall * PFNGLBINDFRAMEBUFFERPROC) (GLenum target, GLuint framebuffer);
typedef void (__stdcall * PFNGLBINDRENDERBUFFERPROC) (GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLBLITFRAMEBUFFERPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);
typedef GLenum (__stdcall * PFNGLCHECKFRAMEBUFFERSTATUSPROC) (GLenum target);
typedef void (__stdcall * PFNGLDELETEFRAMEBUFFERSPROC) (GLsizei n, const GLuint* framebuffers);
typedef void (__stdcall * PFNGLDELETERENDERBUFFERSPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void (__stdcall * PFNGLFRAMEBUFFERRENDERBUFFERPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE1DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE3DPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERPROC) (GLenum target,GLenum attachment, GLuint texture,GLint level,GLint layer);
typedef void (__stdcall * PFNGLGENFRAMEBUFFERSPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLGENRENDERBUFFERSPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLGENERATEMIPMAPPROC) (GLenum target);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETRENDERBUFFERPARAMETERIVPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFRAMEBUFFERPROC) (GLuint framebuffer);
typedef GLboolean (__stdcall * PFNGLISRENDERBUFFERPROC) (GLuint renderbuffer);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
























#line 4528 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 4539 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREFACEARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYERARBPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIARBPROC) (GLuint program, GLenum pname, GLint value);








#line 4578 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLGETPROGRAMBINARYPROC) (GLuint program, GLsizei bufSize, GLsizei* length, GLenum *binaryFormat, void*binary);
typedef void (__stdcall * PFNGLPROGRAMBINARYPROC) (GLuint program, GLenum binaryFormat, const void *binary, GLsizei length);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIPROC) (GLuint program, GLenum pname, GLint value);







#line 4600 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels);
typedef void (__stdcall * PFNGLGETTEXTURESUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels);






#line 4615 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















#line 4631 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLGETUNIFORMDVPROC) (GLuint program, GLint location, GLdouble* params);
typedef void (__stdcall * PFNGLUNIFORM1DPROC) (GLint location, GLdouble x);
typedef void (__stdcall * PFNGLUNIFORM1DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM2DPROC) (GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLUNIFORM2DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM3DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLUNIFORM3DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORM4DPROC) (GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLUNIFORM4DVPROC) (GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3X4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X2DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4X3DVPROC) (GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);






















#line 4691 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 4702 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 4713 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




















































































typedef void (__stdcall * PFNGLCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFPROC) (GLenum target, GLenum pname, GLfloat params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, const GLfloat *params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIPROC) (GLenum target, GLenum pname, GLint params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLCOPYCOLORSUBTABLEPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCOLORTABLEPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER1DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER2DPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLGETCOLORTABLEPROC) (GLenum target, GLenum format, GLenum type, void *table);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONFILTERPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETMINMAXPROC) (GLenum target, GLboolean reset, GLenum format, GLenum types, void *values);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERFVPROC) (GLenum target, GLenum pname, GLfloat *params);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERIVPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETSEPARABLEFILTERPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void (__stdcall * PFNGLHISTOGRAMPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLMINMAXPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLRESETHISTOGRAMPROC) (GLenum target);
typedef void (__stdcall * PFNGLRESETMINMAXPROC) (GLenum target);
typedef void (__stdcall * PFNGLSEPARABLEFILTER2DPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);




































#line 4866 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC) (GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride);






#line 4884 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDARBPROC) (GLenum mode, GLint first, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDARBPROC) (GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei primcount);
typedef void (__stdcall * PFNGLVERTEXATTRIBDIVISORARBPROC) (GLuint index, GLuint divisor);







#line 4903 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLGETINTERNALFORMATIVPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint* params);





#line 4918 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










































































































typedef void (__stdcall * PFNGLGETINTERNALFORMATI64VPROC) (GLenum target, GLenum internalformat, GLenum pname, GLsizei bufSize, GLint64* params);





#line 5031 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINVALIDATEBUFFERDATAPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLINVALIDATEBUFFERSUBDATAPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLINVALIDATEFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments);
typedef void (__stdcall * PFNGLINVALIDATESUBFRAMEBUFFERPROC) (GLenum target, GLsizei numAttachments, const GLenum* attachments, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLINVALIDATETEXIMAGEPROC) (GLuint texture, GLint level);
typedef void (__stdcall * PFNGLINVALIDATETEXSUBIMAGEPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth);










#line 5054 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 5065 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLFLUSHMAPPEDBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length);
typedef void * (__stdcall * PFNGLMAPBUFFERRANGEPROC) (GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access);






#line 5087 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLCURRENTPALETTEMATRIXARBPROC) (GLint index);
typedef void (__stdcall * PFNGLMATRIXINDEXPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLMATRIXINDEXUBVARBPROC) (GLint size, GLubyte *indices);
typedef void (__stdcall * PFNGLMATRIXINDEXUIVARBPROC) (GLint size, GLuint *indices);
typedef void (__stdcall * PFNGLMATRIXINDEXUSVARBPROC) (GLint size, GLushort *indices);









#line 5119 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBINDBUFFERSBASEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers);
typedef void (__stdcall * PFNGLBINDBUFFERSRANGEPROC) (GLenum target, GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizeiptr *sizes);
typedef void (__stdcall * PFNGLBINDIMAGETEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void (__stdcall * PFNGLBINDSAMPLERSPROC) (GLuint first, GLsizei count, const GLuint* samplers);
typedef void (__stdcall * PFNGLBINDTEXTURESPROC) (GLuint first, GLsizei count, const GLuint* textures);
typedef void (__stdcall * PFNGLBINDVERTEXBUFFERSPROC) (GLuint first, GLsizei count, const GLuint* buffers, const GLintptr *offsets, const GLsizei *strides);










#line 5142 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTPROC) (GLenum mode, const void *indirect, GLsizei primcount, GLsizei stride);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei primcount, GLsizei stride);






#line 5157 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLSAMPLECOVERAGEARBPROC) (GLclampf value, GLboolean invert);





#line 5180 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










































typedef void (__stdcall * PFNGLACTIVETEXTUREARBPROC) (GLenum texture);
typedef void (__stdcall * PFNGLCLIENTACTIVETEXTUREARBPROC) (GLenum texture);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DARBPROC) (GLenum target, GLdouble s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FARBPROC) (GLenum target, GLfloat s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IARBPROC) (GLenum target, GLint s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SARBPROC) (GLenum target, GLshort s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DARBPROC) (GLenum target, GLdouble s, GLdouble t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FARBPROC) (GLenum target, GLfloat s, GLfloat t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IARBPROC) (GLenum target, GLint s, GLint t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SARBPROC) (GLenum target, GLshort s, GLshort t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IARBPROC) (GLenum target, GLint s, GLint t, GLint r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3SVARBPROC) (GLenum target, const GLshort *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DARBPROC) (GLenum target, GLdouble s, GLdouble t, GLdouble r, GLdouble q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4DVARBPROC) (GLenum target, const GLdouble *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FARBPROC) (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4FVARBPROC) (GLenum target, const GLfloat *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IARBPROC) (GLenum target, GLint s, GLint t, GLint r, GLint q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4IVARBPROC) (GLenum target, const GLint *v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SARBPROC) (GLenum target, GLshort s, GLshort t, GLshort r, GLshort q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4SVARBPROC) (GLenum target, const GLshort *v);






































#line 5295 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLBEGINQUERYARBPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEQUERIESARBPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDQUERYARBPROC) (GLenum target);
typedef void (__stdcall * PFNGLGENQUERIESARBPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETQUERYOBJECTIVARBPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUIVARBPROC) (GLuint id, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETQUERYIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISQUERYARBPROC) (GLuint id);












#line 5328 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 5339 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




















#line 5360 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 5374 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPOINTPARAMETERFARBPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVARBPROC) (GLenum pname, const GLfloat* params);






#line 5394 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 5406 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






















































typedef void (__stdcall * PFNGLGETPROGRAMINTERFACEIVPROC) (GLuint program, GLenum programInterface, GLenum pname, GLint* params);
typedef GLuint (__stdcall * PFNGLGETPROGRAMRESOURCEINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC) (GLuint program, GLenum programInterface, const GLchar* name);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCENAMEPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETPROGRAMRESOURCEIVPROC) (GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum* props, GLsizei bufSize, GLsizei *length, GLint *params);










#line 5477 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPROVOKINGVERTEXPROC) (GLenum mode);





#line 5495 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 5509 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 5518 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














typedef GLenum (__stdcall * PFNGLGETGRAPHICSRESETSTATUSARBPROC) (void);
typedef void (__stdcall * PFNGLGETNCOLORTABLEARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* table);
typedef void (__stdcall * PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, GLsizei bufSize, void* img);
typedef void (__stdcall * PFNGLGETNCONVOLUTIONFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei bufSize, void* image);
typedef void (__stdcall * PFNGLGETNHISTOGRAMARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void (__stdcall * PFNGLGETNMAPDVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLdouble* v);
typedef void (__stdcall * PFNGLGETNMAPFVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLfloat* v);
typedef void (__stdcall * PFNGLGETNMAPIVARBPROC) (GLenum target, GLenum query, GLsizei bufSize, GLint* v);
typedef void (__stdcall * PFNGLGETNMINMAXARBPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPFVARBPROC) (GLenum map, GLsizei bufSize, GLfloat* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPUIVARBPROC) (GLenum map, GLsizei bufSize, GLuint* values);
typedef void (__stdcall * PFNGLGETNPIXELMAPUSVARBPROC) (GLenum map, GLsizei bufSize, GLushort* values);
typedef void (__stdcall * PFNGLGETNPOLYGONSTIPPLEARBPROC) (GLsizei bufSize, GLubyte* pattern);
typedef void (__stdcall * PFNGLGETNSEPARABLEFILTERARBPROC) (GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void* row, GLsizei columnBufSize, void*column, void*span);
typedef void (__stdcall * PFNGLGETNTEXIMAGEARBPROC) (GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void* img);
typedef void (__stdcall * PFNGLGETNUNIFORMDVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLdouble* params);
typedef void (__stdcall * PFNGLGETNUNIFORMFVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void (__stdcall * PFNGLGETNUNIFORMIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void (__stdcall * PFNGLGETNUNIFORMUIVARBPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void (__stdcall * PFNGLREADNPIXELSARBPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void* data);
























#line 5577 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 5586 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 5595 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLMINSAMPLESHADINGARBPROC) (GLclampf value);





#line 5611 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLBINDSAMPLERPROC) (GLuint unit, GLuint sampler);
typedef void (__stdcall * PFNGLDELETESAMPLERSPROC) (GLsizei count, const GLuint * samplers);
typedef void (__stdcall * PFNGLGENSAMPLERSPROC) (GLsizei count, GLuint* samplers);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISSAMPLERPROC) (GLuint sampler);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIIVPROC) (GLuint sampler, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIUIVPROC) (GLuint sampler, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERFPROC) (GLuint sampler, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERFVPROC) (GLuint sampler, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIPROC) (GLuint sampler, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLSAMPLERPARAMETERIVPROC) (GLuint sampler, GLenum pname, const GLint* params);


















#line 5652 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 5663 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 5674 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLACTIVESHADERPROGRAMPROC) (GLuint pipeline, GLuint program);
typedef void (__stdcall * PFNGLBINDPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROGRAMVPROC) (GLenum type, GLsizei count, const GLchar * const * strings);
typedef void (__stdcall * PFNGLDELETEPROGRAMPIPELINESPROC) (GLsizei n, const GLuint* pipelines);
typedef void (__stdcall * PFNGLGENPROGRAMPIPELINESPROC) (GLsizei n, GLuint* pipelines);
typedef void (__stdcall * PFNGLGETPROGRAMPIPELINEINFOLOGPROC) (GLuint pipeline, GLsizei bufSize, GLsizei* length, GLchar *infoLog);
typedef void (__stdcall * PFNGLGETPROGRAMPIPELINEIVPROC) (GLuint pipeline, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMPIPELINEPROC) (GLuint pipeline);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1DPROC) (GLuint program, GLint location, GLdouble x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FPROC) (GLuint program, GLint location, GLfloat x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IPROC) (GLuint program, GLint location, GLint x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIPROC) (GLuint program, GLint location, GLuint x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IPROC) (GLuint program, GLint location, GLint x, GLint y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIPROC) (GLuint program, GLint location, GLuint x, GLuint y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4DPROC) (GLuint program, GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4DVPROC) (GLuint program, GLint location, GLsizei count, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FPROC) (GLuint program, GLint location, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FVPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IPROC) (GLuint program, GLint location, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IVPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIPROC) (GLuint program, GLint location, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIVPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMSTAGESPROC) (GLuint pipeline, GLbitfield stages, GLuint program);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMPIPELINEPROC) (GLuint pipeline);
































































#line 5815 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




































typedef void (__stdcall * PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC) (GLuint program, GLuint bufferIndex, GLenum pname, GLint* params);





#line 5858 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 5867 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 5876 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 5885 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"







































































typedef void (__stdcall * PFNGLBINDIMAGETEXTUREPROC) (GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format);
typedef void (__stdcall * PFNGLMEMORYBARRIERPROC) (GLbitfield barriers);






#line 5965 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 5974 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









































typedef char GLcharARB;
typedef unsigned int GLhandleARB;

typedef void (__stdcall * PFNGLATTACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB obj);
typedef void (__stdcall * PFNGLCOMPILESHADERARBPROC) (GLhandleARB shaderObj);
typedef GLhandleARB (__stdcall * PFNGLCREATEPROGRAMOBJECTARBPROC) (void);
typedef GLhandleARB (__stdcall * PFNGLCREATESHADEROBJECTARBPROC) (GLenum shaderType);
typedef void (__stdcall * PFNGLDELETEOBJECTARBPROC) (GLhandleARB obj);
typedef void (__stdcall * PFNGLDETACHOBJECTARBPROC) (GLhandleARB containerObj, GLhandleARB attachedObj);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef void (__stdcall * PFNGLGETATTACHEDOBJECTSARBPROC) (GLhandleARB containerObj, GLsizei maxCount, GLsizei* count, GLhandleARB *obj);
typedef GLhandleARB (__stdcall * PFNGLGETHANDLEARBPROC) (GLenum pname);
typedef void (__stdcall * PFNGLGETINFOLOGARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *infoLog);
typedef void (__stdcall * PFNGLGETOBJECTPARAMETERFVARBPROC) (GLhandleARB obj, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETOBJECTPARAMETERIVARBPROC) (GLhandleARB obj, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSHADERSOURCEARBPROC) (GLhandleARB obj, GLsizei maxLength, GLsizei* length, GLcharARB *source);
typedef GLint (__stdcall * PFNGLGETUNIFORMLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);
typedef void (__stdcall * PFNGLGETUNIFORMFVARBPROC) (GLhandleARB programObj, GLint location, GLfloat* params);
typedef void (__stdcall * PFNGLGETUNIFORMIVARBPROC) (GLhandleARB programObj, GLint location, GLint* params);
typedef void (__stdcall * PFNGLLINKPROGRAMARBPROC) (GLhandleARB programObj);
typedef void (__stdcall * PFNGLSHADERSOURCEARBPROC) (GLhandleARB shaderObj, GLsizei count, const GLcharARB ** string, const GLint *length);
typedef void (__stdcall * PFNGLUNIFORM1FARBPROC) (GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLUNIFORM1FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM1IARBPROC) (GLint location, GLint v0);
typedef void (__stdcall * PFNGLUNIFORM1IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM2FARBPROC) (GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLUNIFORM2FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM2IARBPROC) (GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLUNIFORM2IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM3FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLUNIFORM3FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM3IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLUNIFORM3IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORM4FARBPROC) (GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLUNIFORM4FVARBPROC) (GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORM4IARBPROC) (GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLUNIFORM4IVARBPROC) (GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX2FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX3FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUNIFORMMATRIX4FVARBPROC) (GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLUSEPROGRAMOBJECTARBPROC) (GLhandleARB programObj);
typedef void (__stdcall * PFNGLVALIDATEPROGRAMARBPROC) (GLhandleARB programObj);











































#line 6101 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6110 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6119 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLSHADERSTORAGEBLOCKBINDINGPROC) (GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding);





#line 6149 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLGETACTIVESUBROUTINENAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC) (GLuint program, GLenum shadertype, GLuint index, GLsizei bufsize, GLsizei* length, GLchar *name);
typedef void (__stdcall * PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC) (GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint* values);
typedef void (__stdcall * PFNGLGETPROGRAMSTAGEIVPROC) (GLuint program, GLenum shadertype, GLenum pname, GLint* values);
typedef GLuint (__stdcall * PFNGLGETSUBROUTINEINDEXPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef GLint (__stdcall * PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC) (GLuint program, GLenum shadertype, const GLchar* name);
typedef void (__stdcall * PFNGLGETUNIFORMSUBROUTINEUIVPROC) (GLenum shadertype, GLint location, GLuint* params);
typedef void (__stdcall * PFNGLUNIFORMSUBROUTINESUIVPROC) (GLenum shadertype, GLsizei count, const GLuint* indices);












#line 6186 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6195 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6204 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 6215 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6224 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLCOMPILESHADERINCLUDEARBPROC) (GLuint shader, GLsizei count, const GLchar* const *path, const GLint *length);
typedef void (__stdcall * PFNGLDELETENAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void (__stdcall * PFNGLGETNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name, GLsizei bufSize, GLint *stringlen, GLchar *string);
typedef void (__stdcall * PFNGLGETNAMEDSTRINGIVARBPROC) (GLint namelen, const GLchar* name, GLenum pname, GLint *params);
typedef GLboolean (__stdcall * PFNGLISNAMEDSTRINGARBPROC) (GLint namelen, const GLchar* name);
typedef void (__stdcall * PFNGLNAMEDSTRINGARBPROC) (GLenum type, GLint namelen, const GLchar* name, GLint stringlen, const GLchar *string);










#line 6251 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6260 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 6273 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 6284 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBUFFERPAGECOMMITMENTARBPROC) (GLenum target, GLintptr offset, GLsizeiptr size, GLboolean commit);





#line 6300 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


















typedef void (__stdcall * PFNGLTEXPAGECOMMITMENTARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);
typedef void (__stdcall * PFNGLTEXTUREPAGECOMMITMENTEXTPROC) (GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLboolean commit);






#line 6327 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 6338 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






















typedef GLenum (__stdcall * PFNGLCLIENTWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);
typedef void (__stdcall * PFNGLDELETESYNCPROC) (GLsync GLsync);
typedef GLsync (__stdcall * PFNGLFENCESYNCPROC) (GLenum condition,GLbitfield flags);
typedef void (__stdcall * PFNGLGETINTEGER64VPROC) (GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETSYNCIVPROC) (GLsync GLsync,GLenum pname,GLsizei bufSize,GLsizei* length, GLint *values);
typedef GLboolean (__stdcall * PFNGLISSYNCPROC) (GLsync GLsync);
typedef void (__stdcall * PFNGLWAITSYNCPROC) (GLsync GLsync,GLbitfield flags,GLuint64 timeout);











#line 6379 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"







































typedef void (__stdcall * PFNGLPATCHPARAMETERFVPROC) (GLenum pname, const GLfloat* values);
typedef void (__stdcall * PFNGLPATCHPARAMETERIPROC) (GLenum pname, GLint value);






#line 6427 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXTUREBARRIERPROC) (void);





#line 6440 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 6451 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXBUFFERARBPROC) (GLenum target, GLenum internalformat, GLuint buffer);





#line 6470 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6479 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLTEXBUFFERRANGEPROC) (GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLTEXTUREBUFFERRANGEEXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size);






#line 6498 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


















typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE1DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE2DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXIMAGE3DARBPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXIMAGEARBPROC) (GLenum target, GLint lod, void *img);











#line 6535 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 6549 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 6563 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





















#line 6585 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















#line 6602 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6611 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"































#line 6643 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6652 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 6664 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





























#line 6694 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 6707 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 6718 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 6729 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




























typedef void (__stdcall * PFNGLGETMULTISAMPLEFVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void (__stdcall * PFNGLSAMPLEMASKIPROC) (GLuint index, GLbitfield mask);
typedef void (__stdcall * PFNGLTEXIMAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXIMAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);








#line 6770 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6779 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6788 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 6797 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















#line 6813 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

































#line 6847 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 6858 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 6870 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLTEXSTORAGE1DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXSTORAGE2DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXSTORAGE3DPROC) (GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);
typedef void (__stdcall * PFNGLTEXTURESTORAGE1DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DEXTPROC) (GLuint texture, GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth);










#line 6895 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXSTORAGE2DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXSTORAGE3DMULTISAMPLEPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations);
typedef void (__stdcall * PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC) (GLuint texture, GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations);








#line 6914 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 6929 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXTUREVIEWPROC) (GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers);





#line 6948 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VPROC) (GLuint id, GLenum pname, GLint64* params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VPROC) (GLuint id, GLenum pname, GLuint64* params);
typedef void (__stdcall * PFNGLQUERYCOUNTERPROC) (GLuint id, GLenum target);







#line 6968 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBINDTRANSFORMFEEDBACKPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETETRANSFORMFEEDBACKSPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKPROC) (GLenum mode, GLuint id);
typedef void (__stdcall * PFNGLGENTRANSFORMFEEDBACKSPROC) (GLsizei n, GLuint* ids);
typedef GLboolean (__stdcall * PFNGLISTRANSFORMFEEDBACKPROC) (GLuint id);
typedef void (__stdcall * PFNGLPAUSETRANSFORMFEEDBACKPROC) (void);
typedef void (__stdcall * PFNGLRESUMETRANSFORMFEEDBACKPROC) (void);











#line 6998 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBEGINQUERYINDEXEDPROC) (GLenum target, GLuint index, GLuint id);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC) (GLenum mode, GLuint id, GLuint stream);
typedef void (__stdcall * PFNGLENDQUERYINDEXEDPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETQUERYINDEXEDIVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);








#line 7020 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC) (GLenum mode, GLuint id, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC) (GLenum mode, GLuint id, GLuint stream, GLsizei primcount);






#line 7035 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 7047 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void (__stdcall * PFNGLLOADTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXDARBPROC) (GLdouble m[16]);
typedef void (__stdcall * PFNGLMULTTRANSPOSEMATRIXFARBPROC) (GLfloat m[16]);








#line 7071 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








































typedef void (__stdcall * PFNGLBINDBUFFERBASEPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFERRANGEPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC) (GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMBLOCKIVPROC) (GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMNAMEPROC) (GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName);
typedef void (__stdcall * PFNGLGETACTIVEUNIFORMSIVPROC) (GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETINTEGERI_VPROC) (GLenum target, GLuint index, GLint* data);
typedef GLuint (__stdcall * PFNGLGETUNIFORMBLOCKINDEXPROC) (GLuint program, const GLchar* uniformBlockName);
typedef void (__stdcall * PFNGLGETUNIFORMINDICESPROC) (GLuint program, GLsizei uniformCount, const GLchar* const * uniformNames, GLuint* uniformIndices);
typedef void (__stdcall * PFNGLUNIFORMBLOCKBINDINGPROC) (GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding);














#line 7136 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 7147 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLBINDVERTEXARRAYPROC) (GLuint array);
typedef void (__stdcall * PFNGLDELETEVERTEXARRAYSPROC) (GLsizei n, const GLuint* arrays);
typedef void (__stdcall * PFNGLGENVERTEXARRAYSPROC) (GLsizei n, GLuint* arrays);
typedef GLboolean (__stdcall * PFNGLISVERTEXARRAYPROC) (GLuint array);








#line 7168 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETVERTEXATTRIBLDVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLPOINTERPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer);














#line 7199 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLBINDVERTEXBUFFERPROC) (GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC) (GLuint vaobj, GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC) (GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC) (GLuint vaobj, GLuint bindingindex, GLuint divisor);
typedef void (__stdcall * PFNGLVERTEXATTRIBBINDINGPROC) (GLuint attribindex, GLuint bindingindex);
typedef void (__stdcall * PFNGLVERTEXATTRIBFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXATTRIBIFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXATTRIBLFORMATPROC) (GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset);
typedef void (__stdcall * PFNGLVERTEXBINDINGDIVISORPROC) (GLuint bindingindex, GLuint divisor);
















#line 7243 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

















































typedef void (__stdcall * PFNGLVERTEXBLENDARBPROC) (GLint count);
typedef void (__stdcall * PFNGLWEIGHTPOINTERARBPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLWEIGHTBVARBPROC) (GLint size, GLbyte *weights);
typedef void (__stdcall * PFNGLWEIGHTDVARBPROC) (GLint size, GLdouble *weights);
typedef void (__stdcall * PFNGLWEIGHTFVARBPROC) (GLint size, GLfloat *weights);
typedef void (__stdcall * PFNGLWEIGHTIVARBPROC) (GLint size, GLint *weights);
typedef void (__stdcall * PFNGLWEIGHTSVARBPROC) (GLint size, GLshort *weights);
typedef void (__stdcall * PFNGLWEIGHTUBVARBPROC) (GLint size, GLubyte *weights);
typedef void (__stdcall * PFNGLWEIGHTUIVARBPROC) (GLint size, GLuint *weights);
typedef void (__stdcall * PFNGLWEIGHTUSVARBPROC) (GLint size, GLushort *weights);














#line 7317 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






































typedef ptrdiff_t GLintptrARB;
typedef ptrdiff_t GLsizeiptrARB;

typedef void (__stdcall * PFNGLBINDBUFFERARBPROC) (GLenum target, GLuint buffer);
typedef void (__stdcall * PFNGLBUFFERDATAARBPROC) (GLenum target, GLsizeiptrARB size, const void *data, GLenum usage);
typedef void (__stdcall * PFNGLBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, const void *data);
typedef void (__stdcall * PFNGLDELETEBUFFERSARBPROC) (GLsizei n, const GLuint* buffers);
typedef void (__stdcall * PFNGLGENBUFFERSARBPROC) (GLsizei n, GLuint* buffers);
typedef void (__stdcall * PFNGLGETBUFFERPARAMETERIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETBUFFERPOINTERVARBPROC) (GLenum target, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETBUFFERSUBDATAARBPROC) (GLenum target, GLintptrARB offset, GLsizeiptrARB size, void *data);
typedef GLboolean (__stdcall * PFNGLISBUFFERARBPROC) (GLuint buffer);
typedef void * (__stdcall * PFNGLMAPBUFFERARBPROC) (GLenum target, GLenum access);
typedef GLboolean (__stdcall * PFNGLUNMAPBUFFERARBPROC) (GLenum target);















#line 7385 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






















































































typedef void (__stdcall * PFNGLBINDPROGRAMARBPROC) (GLenum target, GLuint program);
typedef void (__stdcall * PFNGLDELETEPROGRAMSARBPROC) (GLsizei n, const GLuint* programs);
typedef void (__stdcall * PFNGLDISABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXATTRIBARRAYARBPROC) (GLuint index);
typedef void (__stdcall * PFNGLGENPROGRAMSARBPROC) (GLsizei n, GLuint* programs);
typedef void (__stdcall * PFNGLGETPROGRAMENVPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMENVPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMSTRINGARBPROC) (GLenum target, GLenum pname, void *string);
typedef void (__stdcall * PFNGLGETPROGRAMIVARBPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVARBPROC) (GLuint index, GLenum pname, void** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVARBPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVARBPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVARBPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMARBPROC) (GLuint program);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4DARBPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4DVARBPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4FARBPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETER4FVARBPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMSTRINGARBPROC) (GLenum target, GLenum format, GLsizei len, const void *string);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DARBPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FARBPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SARBPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DARBPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FARBPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SARBPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NBVARBPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NIVARBPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NSVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBARBPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUBVARBPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUIVARBPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4NUSVARBPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4BVARBPROC) (GLuint index, const GLbyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DARBPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVARBPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FARBPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVARBPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4IVARBPROC) (GLuint index, const GLint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SARBPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVARBPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVARBPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UIVARBPROC) (GLuint index, const GLuint* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4USVARBPROC) (GLuint index, const GLushort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERARBPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void *pointer);


































































#line 7600 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLBINDATTRIBLOCATIONARBPROC) (GLhandleARB programObj, GLuint index, const GLcharARB* name);
typedef void (__stdcall * PFNGLGETACTIVEATTRIBARBPROC) (GLhandleARB programObj, GLuint index, GLsizei maxLength, GLsizei* length, GLint *size, GLenum *type, GLcharARB *name);
typedef GLint (__stdcall * PFNGLGETATTRIBLOCATIONARBPROC) (GLhandleARB programObj, const GLcharARB* name);







#line 7625 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 7636 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLCOLORP4UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLCOLORP4UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP1UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP2UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP3UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIPROC) (GLenum texture, GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLMULTITEXCOORDP4UIVPROC) (GLenum texture, GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLNORMALP3UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLNORMALP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIPROC) (GLenum type, GLuint color);
typedef void (__stdcall * PFNGLSECONDARYCOLORP3UIVPROC) (GLenum type, const GLuint* color);
typedef void (__stdcall * PFNGLTEXCOORDP1UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP1UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP2UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP2UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP3UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP3UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLTEXCOORDP4UIPROC) (GLenum type, GLuint coords);
typedef void (__stdcall * PFNGLTEXCOORDP4UIVPROC) (GLenum type, const GLuint* coords);
typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP1UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP2UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP3UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIPROC) (GLuint index, GLenum type, GLboolean normalized, GLuint value);
typedef void (__stdcall * PFNGLVERTEXATTRIBP4UIVPROC) (GLuint index, GLenum type, GLboolean normalized, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP2UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP2UIVPROC) (GLenum type, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP3UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP3UIVPROC) (GLenum type, const GLuint* value);
typedef void (__stdcall * PFNGLVERTEXP4UIPROC) (GLenum type, GLuint value);
typedef void (__stdcall * PFNGLVERTEXP4UIVPROC) (GLenum type, const GLuint* value);










































#line 7726 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




















typedef void (__stdcall * PFNGLDEPTHRANGEARRAYVPROC) (GLuint first, GLsizei count, const GLclampd * v);
typedef void (__stdcall * PFNGLDEPTHRANGEINDEXEDPROC) (GLuint index, GLclampd n, GLclampd f);
typedef void (__stdcall * PFNGLGETDOUBLEI_VPROC) (GLenum target, GLuint index, GLdouble* data);
typedef void (__stdcall * PFNGLGETFLOATI_VPROC) (GLenum target, GLuint index, GLfloat* data);
typedef void (__stdcall * PFNGLSCISSORARRAYVPROC) (GLuint first, GLsizei count, const GLint * v);
typedef void (__stdcall * PFNGLSCISSORINDEXEDPROC) (GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLSCISSORINDEXEDVPROC) (GLuint index, const GLint * v);
typedef void (__stdcall * PFNGLVIEWPORTARRAYVPROC) (GLuint first, GLsizei count, const GLfloat * v);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h);
typedef void (__stdcall * PFNGLVIEWPORTINDEXEDFVPROC) (GLuint index, const GLfloat * v);














#line 7771 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLWINDOWPOS2DARBPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVARBPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS2FARBPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVARBPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS2IARBPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVARBPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS2SARBPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVARBPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS3DARBPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVARBPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS3FARBPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVARBPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS3IARBPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVARBPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS3SARBPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVARBPROC) (const GLshort* p);




















#line 7814 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















#line 7830 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 7843 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 7856 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 7867 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLDRAWBUFFERSATIPROC) (GLsizei n, const GLenum* bufs);





#line 7898 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDRAWELEMENTARRAYATIPROC) (GLenum mode, GLsizei count);
typedef void (__stdcall * PFNGLDRAWRANGEELEMENTARRAYATIPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count);
typedef void (__stdcall * PFNGLELEMENTPOINTERATIPROC) (GLenum type, const void *pointer);







#line 7919 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLGETTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void (__stdcall * PFNGLGETTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);
typedef void (__stdcall * PFNGLTEXBUMPPARAMETERFVATIPROC) (GLenum pname, GLfloat *param);
typedef void (__stdcall * PFNGLTEXBUMPPARAMETERIVATIPROC) (GLenum pname, GLint *param);








#line 7947 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





























































typedef void (__stdcall * PFNGLALPHAFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall * PFNGLALPHAFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall * PFNGLALPHAFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall * PFNGLBEGINFRAGMENTSHADERATIPROC) (void);
typedef void (__stdcall * PFNGLBINDFRAGMENTSHADERATIPROC) (GLuint id);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP1ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP2ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod);
typedef void (__stdcall * PFNGLCOLORFRAGMENTOP3ATIPROC) (GLenum op, GLuint dst, GLuint dstMask, GLuint dstMod, GLuint arg1, GLuint arg1Rep, GLuint arg1Mod, GLuint arg2, GLuint arg2Rep, GLuint arg2Mod, GLuint arg3, GLuint arg3Rep, GLuint arg3Mod);
typedef void (__stdcall * PFNGLDELETEFRAGMENTSHADERATIPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDFRAGMENTSHADERATIPROC) (void);
typedef GLuint (__stdcall * PFNGLGENFRAGMENTSHADERSATIPROC) (GLuint range);
typedef void (__stdcall * PFNGLPASSTEXCOORDATIPROC) (GLuint dst, GLuint coord, GLenum swizzle);
typedef void (__stdcall * PFNGLSAMPLEMAPATIPROC) (GLuint dst, GLuint interp, GLenum swizzle);
typedef void (__stdcall * PFNGLSETFRAGMENTSHADERCONSTANTATIPROC) (GLuint dst, const GLfloat* value);


















#line 8041 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void * (__stdcall * PFNGLMAPOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLUNMAPOBJECTBUFFERATIPROC) (GLuint buffer);






#line 8056 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 8069 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLPNTRIANGLESFATIPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPNTRIANGLESIATIPROC) (GLenum pname, GLint param);






#line 8094 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLSTENCILFUNCSEPARATEATIPROC) (GLenum frontfunc, GLenum backfunc, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILOPSEPARATEATIPROC) (GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass);






#line 8114 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 8123 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 8134 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 8145 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 8158 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





















#line 8180 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 8192 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLARRAYOBJECTATIPROC) (GLenum array, GLint size, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
typedef void (__stdcall * PFNGLFREEOBJECTBUFFERATIPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLGETARRAYOBJECTFVATIPROC) (GLenum array, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETARRAYOBJECTIVATIPROC) (GLenum array, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETOBJECTBUFFERFVATIPROC) (GLuint buffer, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETOBJECTBUFFERIVATIPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVARIANTARRAYOBJECTFVATIPROC) (GLuint id, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVARIANTARRAYOBJECTIVATIPROC) (GLuint id, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISOBJECTBUFFERATIPROC) (GLuint buffer);
typedef GLuint (__stdcall * PFNGLNEWOBJECTBUFFERATIPROC) (GLsizei size, const void *pointer, GLenum usage);
typedef void (__stdcall * PFNGLUPDATEOBJECTBUFFERATIPROC) (GLuint buffer, GLuint offset, GLsizei size, const void *pointer, GLenum preserve);
typedef void (__stdcall * PFNGLVARIANTARRAYOBJECTATIPROC) (GLuint id, GLenum type, GLsizei stride, GLuint buffer, GLuint offset);
















#line 8236 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC) (GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBARRAYOBJECTATIPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLuint buffer, GLuint offset);







#line 8253 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC) (GLenum stream);
typedef void (__stdcall * PFNGLNORMALSTREAM3BATIPROC) (GLenum stream, GLbyte x, GLbyte y, GLbyte z);
typedef void (__stdcall * PFNGLNORMALSTREAM3BVATIPROC) (GLenum stream, const GLbyte *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLNORMALSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLNORMALSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLNORMALSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLNORMALSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLNORMALSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXBLENDENVFATIPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLVERTEXBLENDENVIATIPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLVERTEXSTREAM1DATIPROC) (GLenum stream, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1FATIPROC) (GLenum stream, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1IATIPROC) (GLenum stream, GLint x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM1SATIPROC) (GLenum stream, GLshort x);
typedef void (__stdcall * PFNGLVERTEXSTREAM1SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2DATIPROC) (GLenum stream, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2FATIPROC) (GLenum stream, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2IATIPROC) (GLenum stream, GLint x, GLint y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM2SATIPROC) (GLenum stream, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXSTREAM2SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3IATIPROC) (GLenum stream, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM3SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXSTREAM3SVATIPROC) (GLenum stream, const GLshort *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4DATIPROC) (GLenum stream, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4DVATIPROC) (GLenum stream, const GLdouble *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4FATIPROC) (GLenum stream, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4FVATIPROC) (GLenum stream, const GLfloat *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4IATIPROC) (GLenum stream, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4IVATIPROC) (GLenum stream, const GLint *coords);
typedef void (__stdcall * PFNGLVERTEXSTREAM4SATIPROC) (GLenum stream, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXSTREAM4SVATIPROC) (GLenum stream, const GLshort *coords);

















































#line 8365 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 8379 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 8391 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 8402 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 8414 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef GLint (__stdcall * PFNGLGETUNIFORMBUFFERSIZEEXTPROC) (GLuint program, GLint location);
typedef GLintptr (__stdcall * PFNGLGETUNIFORMOFFSETEXTPROC) (GLuint program, GLint location);
typedef void (__stdcall * PFNGLUNIFORMBUFFEREXTPROC) (GLuint program, GLint location, GLuint buffer);







#line 8438 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLBLENDCOLOREXTPROC) (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);





#line 8457 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLBLENDEQUATIONSEPARATEEXTPROC) (GLenum modeRGB, GLenum modeAlpha);





#line 8473 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLENDFUNCSEPARATEEXTPROC) (GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha);





#line 8491 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 8500 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLENDEQUATIONEXTPROC) (GLenum mode);





#line 8518 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 8530 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 8541 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 8555 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLsizei count, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLCOPYCOLORSUBTABLEEXTPROC) (GLenum target, GLsizei start, GLint x, GLint y, GLsizei width);






#line 8570 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLLOCKARRAYSEXTPROC) (GLint first, GLsizei count);
typedef void (__stdcall * PFNGLUNLOCKARRAYSEXTPROC) (void);






#line 8588 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



























typedef void (__stdcall * PFNGLCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *image);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFEXTPROC) (GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIEXTPROC) (GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLGETCONVOLUTIONFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *image);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETSEPARABLEFILTEREXTPROC) (GLenum target, GLenum format, GLenum type, void *row, void *column, void *span);
typedef void (__stdcall * PFNGLSEPARABLEFILTER2DEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *row, const void *column);

















#line 8646 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





















typedef void (__stdcall * PFNGLBINORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLTANGENTPOINTEREXTPROC) (GLenum type, GLsizei stride, void *pointer);






#line 8676 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYTEXIMAGE1DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXIMAGE2DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);









#line 8697 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLCULLPARAMETERDVEXTPROC) (GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLCULLPARAMETERFVEXTPROC) (GLenum pname, GLfloat* params);






#line 8716 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETOBJECTLABELEXTPROC) (GLenum type, GLuint object, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLLABELOBJECTEXTPROC) (GLenum type, GLuint object, GLsizei length, const GLchar* label);






#line 8738 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINSERTEVENTMARKEREXTPROC) (GLsizei length, const GLchar* marker);
typedef void (__stdcall * PFNGLPOPGROUPMARKEREXTPROC) (void);
typedef void (__stdcall * PFNGLPUSHGROUPMARKEREXTPROC) (GLsizei length, const GLchar* marker);







#line 8755 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDEPTHBOUNDSEXTPROC) (GLclampd zmin, GLclampd zmax);





#line 8771 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLBINDMULTITEXTUREEXTPROC) (GLenum texunit, GLenum target, GLuint texture);
typedef GLenum (__stdcall * PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC) (GLuint framebuffer, GLenum target);
typedef void (__stdcall * PFNGLCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data);
typedef void (__stdcall * PFNGLCOPYMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLDISABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLDISABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void (__stdcall * PFNGLENABLECLIENTSTATEINDEXEDEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLENABLECLIENTSTATEIEXTPROC) (GLenum array, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYATTRIBEXTPROC) (GLuint vaobj, GLuint index);
typedef void (__stdcall * PFNGLENABLEVERTEXARRAYEXTPROC) (GLuint vaobj, GLenum array);
typedef void (__stdcall * PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length);
typedef void (__stdcall * PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC) (GLuint framebuffer, GLsizei n, const GLenum* bufs);
typedef void (__stdcall * PFNGLFRAMEBUFFERREADBUFFEREXTPROC) (GLuint framebuffer, GLenum mode);
typedef void (__stdcall * PFNGLGENERATEMULTITEXMIPMAPEXTPROC) (GLenum texunit, GLenum target);
typedef void (__stdcall * PFNGLGENERATETEXTUREMIPMAPEXTPROC) (GLuint texture, GLenum target);
typedef void (__stdcall * PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, void *img);
typedef void (__stdcall * PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, void *img);
typedef void (__stdcall * PFNGLGETDOUBLEINDEXEDVEXTPROC) (GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETDOUBLEI_VEXTPROC) (GLenum pname, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETFLOATINDEXEDVEXTPROC) (GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETFLOATI_VEXTPROC) (GLenum pname, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXIMAGEEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC) (GLuint buffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPOINTERVEXTPROC) (GLuint buffer, GLenum pname, void** params);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, void *data);
typedef void (__stdcall * PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat* params);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum pname, void *string);
typedef void (__stdcall * PFNGLGETNAMEDPROGRAMIVEXTPROC) (GLuint program, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC) (GLuint renderbuffer, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETPOINTERINDEXEDVEXTPROC) (GLenum target, GLuint index, void** params);
typedef void (__stdcall * PFNGLGETPOINTERI_VEXTPROC) (GLenum pname, GLuint index, void** params);
typedef void (__stdcall * PFNGLGETTEXTUREIMAGEEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum format, GLenum type, void *pixels);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLint level, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYINTEGERVEXTPROC) (GLuint vaobj, GLenum pname, GLint* param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC) (GLuint vaobj, GLuint index, GLenum pname, void** param);
typedef void (__stdcall * PFNGLGETVERTEXARRAYPOINTERVEXTPROC) (GLuint vaobj, GLenum pname, void** param);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFEREXTPROC) (GLuint buffer, GLenum access);
typedef void * (__stdcall * PFNGLMAPNAMEDBUFFERRANGEEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access);
typedef void (__stdcall * PFNGLMATRIXFRUSTUMEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void (__stdcall * PFNGLMATRIXLOADIDENTITYEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXLOADTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXLOADDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXLOADFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSEDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXMULTTRANSPOSEFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXMULTDEXTPROC) (GLenum matrixMode, const GLdouble* m);
typedef void (__stdcall * PFNGLMATRIXMULTFEXTPROC) (GLenum matrixMode, const GLfloat* m);
typedef void (__stdcall * PFNGLMATRIXORTHOEXTPROC) (GLenum matrixMode, GLdouble l, GLdouble r, GLdouble b, GLdouble t, GLdouble n, GLdouble f);
typedef void (__stdcall * PFNGLMATRIXPOPEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXPUSHEXTPROC) (GLenum matrixMode);
typedef void (__stdcall * PFNGLMATRIXROTATEDEXTPROC) (GLenum matrixMode, GLdouble angle, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXROTATEFEXTPROC) (GLenum matrixMode, GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMATRIXSCALEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXSCALEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMATRIXTRANSLATEDEXTPROC) (GLenum matrixMode, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLMATRIXTRANSLATEFEXTPROC) (GLenum matrixMode, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLMULTITEXBUFFEREXTPROC) (GLenum texunit, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLMULTITEXCOORDPOINTEREXTPROC) (GLenum texunit, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLMULTITEXENVFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXENVFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMULTITEXENVIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXENVIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXGENDEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLdouble param);
typedef void (__stdcall * PFNGLMULTITEXGENDVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLdouble* params);
typedef void (__stdcall * PFNGLMULTITEXGENFEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXGENFVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMULTITEXGENIEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXGENIVEXTPROC) (GLenum texunit, GLenum coord, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIUIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERFEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERFVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIEXTPROC) (GLenum texunit, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLMULTITEXPARAMETERIVEXTPROC) (GLenum texunit, GLenum target, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLMULTITEXRENDERBUFFEREXTPROC) (GLenum texunit, GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE1DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE2DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLMULTITEXSUBIMAGE3DEXTPROC) (GLenum texunit, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLNAMEDBUFFERDATAEXTPROC) (GLuint buffer, GLsizeiptr size, const void *data, GLenum usage);
typedef void (__stdcall * PFNGLNAMEDBUFFERSUBDATAEXTPROC) (GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data);
typedef void (__stdcall * PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC) (GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC) (GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC) (GLuint framebuffer, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC) (GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC) (GLuint program, GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC) (GLuint program, GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC) (GLuint program, GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC) (GLuint program, GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, const GLuint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC) (GLuint program, GLenum target, GLuint index, GLsizei count, const GLuint* params);
typedef void (__stdcall * PFNGLNAMEDPROGRAMSTRINGEXTPROC) (GLuint program, GLenum target, GLenum format, GLsizei len, const void *string);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC) (GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC) (GLuint renderbuffer, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FEXTPROC) (GLuint program, GLint location, GLfloat v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IEXTPROC) (GLuint program, GLint location, GLint v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIEXTPROC) (GLuint program, GLint location, GLuint v0);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FEXTPROC) (GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4FVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IEXTPROC) (GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4IVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIEXTPROC) (GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UIVEXTPROC) (GLuint program, GLint location, GLsizei count, const GLuint* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC) (GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat* value);
typedef void (__stdcall * PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC) (GLbitfield mask);
typedef void (__stdcall * PFNGLTEXTUREBUFFEREXTPROC) (GLuint texture, GLenum target, GLenum internalformat, GLuint buffer);
typedef void (__stdcall * PFNGLTEXTUREIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIUIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLuint* params);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERFVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLfloat* param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIEXTPROC) (GLuint texture, GLenum target, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLTEXTUREPARAMETERIVEXTPROC) (GLuint texture, GLenum target, GLenum pname, const GLint* param);
typedef void (__stdcall * PFNGLTEXTURERENDERBUFFEREXTPROC) (GLuint texture, GLenum target, GLuint renderbuffer);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE1DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE2DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXTURESUBIMAGE3DEXTPROC) (GLuint texture, GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);
typedef GLboolean (__stdcall * PFNGLUNMAPNAMEDBUFFEREXTPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLVERTEXARRAYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYINDEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum texunit, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYNORMALOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC) (GLuint vaobj, GLuint index, GLuint divisor);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLint size, GLenum type, GLsizei stride, GLintptr offset);


























































































































































































































#line 9214 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOLORMASKINDEXEDEXTPROC) (GLuint buf, GLboolean r, GLboolean g, GLboolean b, GLboolean a);
typedef void (__stdcall * PFNGLDISABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLENABLEINDEXEDEXTPROC) (GLenum target, GLuint index);
typedef void (__stdcall * PFNGLGETBOOLEANINDEXEDVEXTPROC) (GLenum value, GLuint index, GLboolean* data);
typedef void (__stdcall * PFNGLGETINTEGERINDEXEDVEXTPROC) (GLenum value, GLuint index, GLint* data);
typedef GLboolean (__stdcall * PFNGLISENABLEDINDEXEDEXTPROC) (GLenum target, GLuint index);










#line 9237 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWARRAYSINSTANCEDEXTPROC) (GLenum mode, GLint start, GLsizei count, GLsizei primcount);
typedef void (__stdcall * PFNGLDRAWELEMENTSINSTANCEDEXTPROC) (GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei primcount);






#line 9252 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLDRAWRANGEELEMENTSEXTPROC) (GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void *indices);





#line 9268 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFOGCOORDPOINTEREXTPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLFOGCOORDDEXTPROC) (GLdouble coord);
typedef void (__stdcall * PFNGLFOGCOORDDVEXTPROC) (const GLdouble *coord);
typedef void (__stdcall * PFNGLFOGCOORDFEXTPROC) (GLfloat coord);
typedef void (__stdcall * PFNGLFOGCOORDFVEXTPROC) (const GLfloat *coord);









#line 9298 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





















typedef void (__stdcall * PFNGLFRAGMENTCOLORMATERIALEXTPROC) (GLenum face, GLenum mode);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFEXTPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFVEXTPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIEXTPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIVEXTPROC) (GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFEXTPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIEXTPROC) (GLenum light, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFEXTPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIEXTPROC) (GLenum face, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTFVEXTPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTIVEXTPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALFVEXTPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALIVEXTPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLLIGHTENVIEXTPROC) (GLenum pname, GLint param);






















#line 9360 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBLITFRAMEBUFFEREXTPROC) (GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter);





#line 9378 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC) (GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height);





#line 9395 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 9407 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


























































typedef void (__stdcall * PFNGLBINDFRAMEBUFFEREXTPROC) (GLenum target, GLuint framebuffer);
typedef void (__stdcall * PFNGLBINDRENDERBUFFEREXTPROC) (GLenum target, GLuint renderbuffer);
typedef GLenum (__stdcall * PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLDELETEFRAMEBUFFERSEXTPROC) (GLsizei n, const GLuint* framebuffers);
typedef void (__stdcall * PFNGLDELETERENDERBUFFERSEXTPROC) (GLsizei n, const GLuint* renderbuffers);
typedef void (__stdcall * PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC) (GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE1DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE2DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURE3DEXTPROC) (GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset);
typedef void (__stdcall * PFNGLGENFRAMEBUFFERSEXTPROC) (GLsizei n, GLuint* framebuffers);
typedef void (__stdcall * PFNGLGENRENDERBUFFERSEXTPROC) (GLsizei n, GLuint* renderbuffers);
typedef void (__stdcall * PFNGLGENERATEMIPMAPEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC) (GLenum target, GLenum attachment, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFRAMEBUFFEREXTPROC) (GLuint framebuffer);
typedef GLboolean (__stdcall * PFNGLISRENDERBUFFEREXTPROC) (GLuint renderbuffer);
typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEEXTPROC) (GLenum target, GLenum internalformat, GLsizei width, GLsizei height);





















#line 9504 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 9516 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



























typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level);
typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLenum face);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERIEXTPROC) (GLuint program, GLenum pname, GLint value);







#line 9554 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC) (GLenum target, GLuint index, GLsizei count, const GLfloat* params);






#line 9569 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

































typedef void (__stdcall * PFNGLBINDFRAGDATALOCATIONEXTPROC) (GLuint program, GLuint color, const GLchar *name);
typedef GLint (__stdcall * PFNGLGETFRAGDATALOCATIONEXTPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLGETUNIFORMUIVEXTPROC) (GLuint program, GLint location, GLuint *params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIIVEXTPROC) (GLuint index, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIUIVEXTPROC) (GLuint index, GLenum pname, GLuint *params);
typedef void (__stdcall * PFNGLUNIFORM1UIEXTPROC) (GLint location, GLuint v0);
typedef void (__stdcall * PFNGLUNIFORM1UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM2UIEXTPROC) (GLint location, GLuint v0, GLuint v1);
typedef void (__stdcall * PFNGLUNIFORM2UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM3UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2);
typedef void (__stdcall * PFNGLUNIFORM3UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLUNIFORM4UIEXTPROC) (GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3);
typedef void (__stdcall * PFNGLUNIFORM4UIVEXTPROC) (GLint location, GLsizei count, const GLuint *value);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IEXTPROC) (GLuint index, GLint x);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIEXTPROC) (GLuint index, GLuint x);
typedef void (__stdcall * PFNGLVERTEXATTRIBI1UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IEXTPROC) (GLuint index, GLint x, GLint y);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIEXTPROC) (GLuint index, GLuint x, GLuint y);
typedef void (__stdcall * PFNGLVERTEXATTRIBI2UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IEXTPROC) (GLuint index, GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z);
typedef void (__stdcall * PFNGLVERTEXATTRIBI3UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4BVEXTPROC) (GLuint index, const GLbyte *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IEXTPROC) (GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4IVEXTPROC) (GLuint index, const GLint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4SVEXTPROC) (GLuint index, const GLshort *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UBVEXTPROC) (GLuint index, const GLubyte *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIEXTPROC) (GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4UIVEXTPROC) (GLuint index, const GLuint *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBI4USVEXTPROC) (GLuint index, const GLushort *v);
typedef void (__stdcall * PFNGLVERTEXATTRIBIPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);






































#line 9675 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




















typedef void (__stdcall * PFNGLGETHISTOGRAMEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETHISTOGRAMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMINMAXEXTPROC) (GLenum target, GLboolean reset, GLenum format, GLenum type, void *values);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMINMAXPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLHISTOGRAMEXTPROC) (GLenum target, GLsizei width, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLMINMAXEXTPROC) (GLenum target, GLenum internalformat, GLboolean sink);
typedef void (__stdcall * PFNGLRESETHISTOGRAMEXTPROC) (GLenum target);
typedef void (__stdcall * PFNGLRESETMINMAXEXTPROC) (GLenum target);














#line 9720 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 9729 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINDEXFUNCEXTPROC) (GLenum func, GLfloat ref);





#line 9742 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLINDEXMATERIALEXTPROC) (GLenum face, GLenum mode);





#line 9755 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 9764 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLAPPLYTEXTUREEXTPROC) (GLenum mode);
typedef void (__stdcall * PFNGLTEXTURELIGHTEXTPROC) (GLenum pname);
typedef void (__stdcall * PFNGLTEXTUREMATERIALEXTPROC) (GLenum face, GLenum mode);







#line 9791 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 9800 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSEXTPROC) (GLenum mode, const GLint* first, const GLsizei *count, GLsizei primcount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSEXTPROC) (GLenum mode, GLsizei* count, GLenum type, const void *const *indices, GLsizei primcount);






#line 9815 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLSAMPLEMASKEXTPROC) (GLclampf value, GLboolean invert);
typedef void (__stdcall * PFNGLSAMPLEPATTERNEXTPROC) (GLenum pattern);






#line 9848 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 9862 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 9875 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 9890 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




























typedef void (__stdcall * PFNGLCOLORTABLEEXTPROC) (GLenum target, GLenum internalFormat, GLsizei width, GLenum format, GLenum type, const void *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEEXTPROC) (GLenum target, GLenum format, GLenum type, void *data);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVEXTPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVEXTPROC) (GLenum target, GLenum pname, GLint* params);








#line 9931 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 9945 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFEXTPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIEXTPROC) (GLenum target, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC) (GLenum target, GLenum pname, const GLint* params);










#line 9978 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 9987 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPOINTPARAMETERFEXTPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLPOINTPARAMETERFVEXTPROC) (GLenum pname, const GLfloat* params);






#line 10007 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPOLYGONOFFSETEXTPROC) (GLfloat factor, GLfloat bias);





#line 10024 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLPROVOKINGVERTEXEXTPROC) (GLenum mode);





#line 10042 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 10053 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBEGINSCENEEXTPROC) (void);
typedef void (__stdcall * PFNGLENDSCENEEXTPROC) (void);






#line 10068 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














typedef void (__stdcall * PFNGLSECONDARYCOLOR3BEXTPROC) (GLbyte red, GLbyte green, GLbyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3BVEXTPROC) (const GLbyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DEXTPROC) (GLdouble red, GLdouble green, GLdouble blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3DVEXTPROC) (const GLdouble *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FEXTPROC) (GLfloat red, GLfloat green, GLfloat blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3FVEXTPROC) (const GLfloat *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IEXTPROC) (GLint red, GLint green, GLint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3IVEXTPROC) (const GLint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SEXTPROC) (GLshort red, GLshort green, GLshort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3SVEXTPROC) (const GLshort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBEXTPROC) (GLubyte red, GLubyte green, GLubyte blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UBVEXTPROC) (const GLubyte *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIEXTPROC) (GLuint red, GLuint green, GLuint blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3UIVEXTPROC) (const GLuint *v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USEXTPROC) (GLushort red, GLushort green, GLushort blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3USVEXTPROC) (const GLushort *v);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, const void *pointer);





















#line 10121 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLACTIVEPROGRAMEXTPROC) (GLuint program);
typedef GLuint (__stdcall * PFNGLCREATESHADERPROGRAMEXTPROC) (GLenum type, const GLchar* string);
typedef void (__stdcall * PFNGLUSESHADERPROGRAMEXTPROC) (GLenum type, GLuint program);







#line 10140 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 10153 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 10162 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






























































typedef void (__stdcall * PFNGLBINDIMAGETEXTUREEXTPROC) (GLuint index, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLint format);
typedef void (__stdcall * PFNGLMEMORYBARRIEREXTPROC) (GLbitfield barriers);






#line 10233 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 10242 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 10251 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 10262 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 10274 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLACTIVESTENCILFACEEXTPROC) (GLenum face);





#line 10290 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 10302 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXSUBIMAGE1DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE2DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE3DEXTPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels);







#line 10319 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



















































#line 10371 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall * PFNGLTEXIMAGE3DEXTPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void *pixels);





#line 10394 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC) (GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer);





#line 10416 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLTEXBUFFEREXTPROC) (GLenum target, GLenum internalformat, GLuint buffer);





#line 10435 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 10444 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 10458 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 10472 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 10486 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





















#line 10508 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 10519 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 10528 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 10537 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






























#line 10568 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 10580 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 10592 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






















































typedef void (__stdcall * PFNGLCLEARCOLORIIEXTPROC) (GLint red, GLint green, GLint blue, GLint alpha);
typedef void (__stdcall * PFNGLCLEARCOLORIUIEXTPROC) (GLuint red, GLuint green, GLuint blue, GLuint alpha);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, GLint *params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, GLuint *params);
typedef void (__stdcall * PFNGLTEXPARAMETERIIVEXTPROC) (GLenum target, GLenum pname, const GLint *params);
typedef void (__stdcall * PFNGLTEXPARAMETERIUIVEXTPROC) (GLenum target, GLenum pname, const GLuint *params);










#line 10663 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 10676 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 10689 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef GLboolean (__stdcall * PFNGLARETEXTURESRESIDENTEXTPROC) (GLsizei n, const GLuint* textures, GLboolean* residences);
typedef void (__stdcall * PFNGLBINDTEXTUREEXTPROC) (GLenum target, GLuint texture);
typedef void (__stdcall * PFNGLDELETETEXTURESEXTPROC) (GLsizei n, const GLuint* textures);
typedef void (__stdcall * PFNGLGENTEXTURESEXTPROC) (GLsizei n, GLuint* textures);
typedef GLboolean (__stdcall * PFNGLISTEXTUREEXTPROC) (GLuint texture);
typedef void (__stdcall * PFNGLPRIORITIZETEXTURESEXTPROC) (GLsizei n, const GLuint* textures, const GLclampf* priorities);










#line 10718 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLTEXTURENORMALEXTPROC) (GLenum mode);





#line 10734 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 10748 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

























#line 10774 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 10787 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 10800 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


































#line 10835 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 10850 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLGETQUERYOBJECTI64VEXTPROC) (GLuint id, GLenum pname, GLint64EXT *params);
typedef void (__stdcall * PFNGLGETQUERYOBJECTUI64VEXTPROC) (GLuint id, GLenum pname, GLuint64EXT *params);






#line 10867 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






















typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKEXTPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDBUFFERBASEEXTPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFEROFFSETEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall * PFNGLBINDBUFFERRANGEEXTPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKEXTPROC) (void);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC) (GLuint program, GLsizei count, const GLchar * const* varyings, GLenum bufferMode);











#line 10908 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








































typedef void (__stdcall * PFNGLARRAYELEMENTEXTPROC) (GLint i);
typedef void (__stdcall * PFNGLCOLORPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLDRAWARRAYSEXTPROC) (GLenum mode, GLint first, GLsizei count);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTEREXTPROC) (GLsizei stride, GLsizei count, const GLboolean* pointer);
typedef void (__stdcall * PFNGLINDEXPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLNORMALPOINTEREXTPROC) (GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);
typedef void (__stdcall * PFNGLVERTEXPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, GLsizei count, const void *pointer);












#line 10969 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 10980 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



















typedef void (__stdcall * PFNGLGETVERTEXATTRIBLDVEXTPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC) (GLuint vaobj, GLuint buffer, GLuint index, GLint size, GLenum type, GLsizei stride, GLintptr offset);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DEXTPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DEXTPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DEXTPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4DVEXTPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLPOINTEREXTPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);















#line 11026 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





















































































































typedef void (__stdcall * PFNGLBEGINVERTEXSHADEREXTPROC) (void);
typedef GLuint (__stdcall * PFNGLBINDLIGHTPARAMETEREXTPROC) (GLenum light, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDMATERIALPARAMETEREXTPROC) (GLenum face, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDPARAMETEREXTPROC) (GLenum value);
typedef GLuint (__stdcall * PFNGLBINDTEXGENPARAMETEREXTPROC) (GLenum unit, GLenum coord, GLenum value);
typedef GLuint (__stdcall * PFNGLBINDTEXTUREUNITPARAMETEREXTPROC) (GLenum unit, GLenum value);
typedef void (__stdcall * PFNGLBINDVERTEXSHADEREXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLDELETEVERTEXSHADEREXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLENABLEVARIANTCLIENTSTATEEXTPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDVERTEXSHADEREXTPROC) (void);
typedef void (__stdcall * PFNGLEXTRACTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLuint (__stdcall * PFNGLGENSYMBOLSEXTPROC) (GLenum dataType, GLenum storageType, GLenum range, GLuint components);
typedef GLuint (__stdcall * PFNGLGENVERTEXSHADERSEXTPROC) (GLuint range);
typedef void (__stdcall * PFNGLGETINVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETINVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETINVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETLOCALCONSTANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETVARIANTBOOLEANVEXTPROC) (GLuint id, GLenum value, GLboolean *data);
typedef void (__stdcall * PFNGLGETVARIANTFLOATVEXTPROC) (GLuint id, GLenum value, GLfloat *data);
typedef void (__stdcall * PFNGLGETVARIANTINTEGERVEXTPROC) (GLuint id, GLenum value, GLint *data);
typedef void (__stdcall * PFNGLGETVARIANTPOINTERVEXTPROC) (GLuint id, GLenum value, void **data);
typedef void (__stdcall * PFNGLINSERTCOMPONENTEXTPROC) (GLuint res, GLuint src, GLuint num);
typedef GLboolean (__stdcall * PFNGLISVARIANTENABLEDEXTPROC) (GLuint id, GLenum cap);
typedef void (__stdcall * PFNGLSETINVARIANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void (__stdcall * PFNGLSETLOCALCONSTANTEXTPROC) (GLuint id, GLenum type, void *addr);
typedef void (__stdcall * PFNGLSHADEROP1EXTPROC) (GLenum op, GLuint res, GLuint arg1);
typedef void (__stdcall * PFNGLSHADEROP2EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2);
typedef void (__stdcall * PFNGLSHADEROP3EXTPROC) (GLenum op, GLuint res, GLuint arg1, GLuint arg2, GLuint arg3);
typedef void (__stdcall * PFNGLSWIZZLEEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);
typedef void (__stdcall * PFNGLVARIANTPOINTEREXTPROC) (GLuint id, GLenum type, GLuint stride, void *addr);
typedef void (__stdcall * PFNGLVARIANTBVEXTPROC) (GLuint id, GLbyte *addr);
typedef void (__stdcall * PFNGLVARIANTDVEXTPROC) (GLuint id, GLdouble *addr);
typedef void (__stdcall * PFNGLVARIANTFVEXTPROC) (GLuint id, GLfloat *addr);
typedef void (__stdcall * PFNGLVARIANTIVEXTPROC) (GLuint id, GLint *addr);
typedef void (__stdcall * PFNGLVARIANTSVEXTPROC) (GLuint id, GLshort *addr);
typedef void (__stdcall * PFNGLVARIANTUBVEXTPROC) (GLuint id, GLubyte *addr);
typedef void (__stdcall * PFNGLVARIANTUIVEXTPROC) (GLuint id, GLuint *addr);
typedef void (__stdcall * PFNGLVARIANTUSVEXTPROC) (GLuint id, GLushort *addr);
typedef void (__stdcall * PFNGLWRITEMASKEXTPROC) (GLuint res, GLuint in, GLenum outX, GLenum outY, GLenum outZ, GLenum outW);














































#line 11232 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




















typedef void (__stdcall * PFNGLVERTEXWEIGHTPOINTEREXTPROC) (GLint size, GLenum type, GLsizei stride, void *pointer);
typedef void (__stdcall * PFNGLVERTEXWEIGHTFEXTPROC) (GLfloat weight);
typedef void (__stdcall * PFNGLVERTEXWEIGHTFVEXTPROC) (GLfloat* weight);







#line 11263 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef GLsync (__stdcall * PFNGLIMPORTSYNCEXTPROC) (GLenum external_sync_type, GLintptr external_sync, GLbitfield flags);





#line 11278 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAMETERMINATORGREMEDYPROC) (void);





#line 11291 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLSTRINGMARKERGREMEDYPROC) (GLsizei len, const void *string);





#line 11304 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 11313 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERFHPPROC) (GLenum target, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERFVHPPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERIHPPROC) (GLenum target, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLIMAGETRANSFORMPARAMETERIVHPPROC) (GLenum target, GLenum pname, const GLint* params);










#line 11336 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 11345 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 11354 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 11365 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIMODEDRAWARRAYSIBMPROC) (const GLenum* mode, const GLint *first, const GLsizei *count, GLsizei primcount, GLint modestride);
typedef void (__stdcall * PFNGLMULTIMODEDRAWELEMENTSIBMPROC) (const GLenum* mode, const GLsizei *count, GLenum type, const void *const *indices, GLsizei primcount, GLint modestride);






#line 11380 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 11391 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 11403 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 11414 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLEDGEFLAGPOINTERLISTIBMPROC) (GLint stride, const GLboolean ** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLFOGCOORDPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLINDEXPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLNORMALPOINTERLISTIBMPROC) (GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLSECONDARYCOLORPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLTEXCOORDPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);
typedef void (__stdcall * PFNGLVERTEXPOINTERLISTIBMPROC) (GLint size, GLenum type, GLint stride, const void** pointer, GLint ptrstride);












#line 11458 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

















#line 11476 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 11487 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 11496 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void * (__stdcall * PFNGLMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level, GLbitfield access, GLint* stride, GLenum *layout);
typedef void (__stdcall * PFNGLSYNCTEXTUREINTELPROC) (GLuint texture);
typedef void (__stdcall * PFNGLUNMAPTEXTURE2DINTELPROC) (GLuint texture, GLint level);







#line 11518 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLCOLORPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLNORMALPOINTERVINTELPROC) (GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLTEXCOORDPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);
typedef void (__stdcall * PFNGLVERTEXPOINTERVINTELPROC) (GLint size, GLenum type, const void** pointer);








#line 11543 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



























typedef void (__stdcall * PFNGLBEGINPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void (__stdcall * PFNGLCREATEPERFQUERYINTELPROC) (GLuint queryId, GLuint* queryHandle);
typedef void (__stdcall * PFNGLDELETEPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void (__stdcall * PFNGLENDPERFQUERYINTELPROC) (GLuint queryHandle);
typedef void (__stdcall * PFNGLGETFIRSTPERFQUERYIDINTELPROC) (GLuint* queryId);
typedef void (__stdcall * PFNGLGETNEXTPERFQUERYIDINTELPROC) (GLuint queryId, GLuint* nextQueryId);
typedef void (__stdcall * PFNGLGETPERFCOUNTERINFOINTELPROC) (GLuint queryId, GLuint counterId, GLuint counterNameLength, GLchar* counterName, GLuint counterDescLength, GLchar *counterDesc, GLuint *counterOffset, GLuint *counterDataSize, GLuint *counterTypeEnum, GLuint *counterDataTypeEnum, GLuint64 *rawCounterMaxValue);
typedef void (__stdcall * PFNGLGETPERFQUERYDATAINTELPROC) (GLuint queryHandle, GLuint flags, GLsizei dataSize, void *data, GLuint *bytesWritten);
typedef void (__stdcall * PFNGLGETPERFQUERYIDBYNAMEINTELPROC) (GLchar* queryName, GLuint *queryId);
typedef void (__stdcall * PFNGLGETPERFQUERYINFOINTELPROC) (GLuint queryId, GLuint queryNameLength, GLchar* queryName, GLuint *dataSize, GLuint *noCounters, GLuint *noInstances, GLuint *capsMask);














#line 11595 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXSCISSORFUNCINTELPROC) (GLenum target, GLenum lfunc, GLenum hfunc);
typedef void (__stdcall * PFNGLTEXSCISSORINTELPROC) (GLenum target, GLclampf tlow, GLclampf thigh);






#line 11610 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLBLENDBARRIERKHRPROC) (void);





#line 11640 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 11649 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 11658 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















































typedef void (__stdcall *GLDEBUGPROC)(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* message, const void* userParam);

typedef void (__stdcall * PFNGLDEBUGMESSAGECALLBACKPROC) (GLDEBUGPROC callback, const void *userParam);
typedef void (__stdcall * PFNGLDEBUGMESSAGECONTROLPROC) (GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint* ids, GLboolean enabled);
typedef void (__stdcall * PFNGLDEBUGMESSAGEINSERTPROC) (GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar* buf);
typedef GLuint (__stdcall * PFNGLGETDEBUGMESSAGELOGPROC) (GLuint count, GLsizei bufSize, GLenum* sources, GLenum* types, GLuint* ids, GLenum* severities, GLsizei* lengths, GLchar* messageLog);
typedef void (__stdcall * PFNGLGETOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLGETOBJECTPTRLABELPROC) (const void *ptr, GLsizei bufSize, GLsizei* length, GLchar *label);
typedef void (__stdcall * PFNGLOBJECTLABELPROC) (GLenum identifier, GLuint name, GLsizei length, const GLchar* label);
typedef void (__stdcall * PFNGLOBJECTPTRLABELPROC) (const void *ptr, GLsizei length, const GLchar* label);
typedef void (__stdcall * PFNGLPOPDEBUGGROUPPROC) (void);
typedef void (__stdcall * PFNGLPUSHDEBUGGROUPPROC) (GLenum source, GLuint id, GLsizei length, const GLchar * message);














#line 11732 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 11741 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLGETNUNIFORMFVPROC) (GLuint program, GLint location, GLsizei bufSize, GLfloat* params);
typedef void (__stdcall * PFNGLGETNUNIFORMIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLint* params);
typedef void (__stdcall * PFNGLGETNUNIFORMUIVPROC) (GLuint program, GLint location, GLsizei bufSize, GLuint* params);
typedef void (__stdcall * PFNGLREADNPIXELSPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data);








#line 11769 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





































#line 11807 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





































#line 11845 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef GLuint (__stdcall * PFNGLBUFFERREGIONENABLEDPROC) (void);
typedef void (__stdcall * PFNGLDELETEBUFFERREGIONPROC) (GLenum region);
typedef void (__stdcall * PFNGLDRAWBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height, GLint xDest, GLint yDest);
typedef GLuint (__stdcall * PFNGLNEWBUFFERREGIONPROC) (GLenum region);
typedef void (__stdcall * PFNGLREADBUFFERREGIONPROC) (GLuint region, GLint x, GLint y, GLsizei width, GLsizei height);









#line 11871 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















#line 11887 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 11898 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLRESIZEBUFFERSMESAPROC) (void);





#line 11911 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLWINDOWPOS2DMESAPROC) (GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLWINDOWPOS2DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS2FMESAPROC) (GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLWINDOWPOS2FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS2IMESAPROC) (GLint x, GLint y);
typedef void (__stdcall * PFNGLWINDOWPOS2IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS2SMESAPROC) (GLshort x, GLshort y);
typedef void (__stdcall * PFNGLWINDOWPOS2SVMESAPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS3DMESAPROC) (GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLWINDOWPOS3DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS3FMESAPROC) (GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLWINDOWPOS3FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS3IMESAPROC) (GLint x, GLint y, GLint z);
typedef void (__stdcall * PFNGLWINDOWPOS3IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS3SMESAPROC) (GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLWINDOWPOS3SVMESAPROC) (const GLshort* p);
typedef void (__stdcall * PFNGLWINDOWPOS4DMESAPROC) (GLdouble x, GLdouble y, GLdouble z, GLdouble);
typedef void (__stdcall * PFNGLWINDOWPOS4DVMESAPROC) (const GLdouble* p);
typedef void (__stdcall * PFNGLWINDOWPOS4FMESAPROC) (GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLWINDOWPOS4FVMESAPROC) (const GLfloat* p);
typedef void (__stdcall * PFNGLWINDOWPOS4IMESAPROC) (GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLWINDOWPOS4IVMESAPROC) (const GLint* p);
typedef void (__stdcall * PFNGLWINDOWPOS4SMESAPROC) (GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLWINDOWPOS4SVMESAPROC) (const GLshort* p);




























#line 11970 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 11983 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERNVXPROC) (GLuint id);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERNVXPROC) (void);






#line 11998 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 12013 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC) (GLenum mode, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC) (GLenum mode, GLenum type, const void *indirect, GLsizei drawCount, GLsizei stride, GLint vertexBufferCount);






#line 12028 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);
typedef void (__stdcall * PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC) (GLenum mode, GLenum type, const void *indirect, GLintptr drawCount, GLsizei maxDrawCount, GLsizei stride, GLint vertexBufferCount);






#line 12043 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef GLuint64 (__stdcall * PFNGLGETIMAGEHANDLENVPROC) (GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum format);
typedef GLuint64 (__stdcall * PFNGLGETTEXTUREHANDLENVPROC) (GLuint texture);
typedef GLuint64 (__stdcall * PFNGLGETTEXTURESAMPLERHANDLENVPROC) (GLuint texture, GLuint sampler);
typedef GLboolean (__stdcall * PFNGLISIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef GLboolean (__stdcall * PFNGLISTEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKEIMAGEHANDLERESIDENTNVPROC) (GLuint64 handle, GLenum access);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLMAKETEXTUREHANDLERESIDENTNVPROC) (GLuint64 handle);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC) (GLuint program, GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64* values);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64NVPROC) (GLint location, GLuint64 value);
typedef void (__stdcall * PFNGLUNIFORMHANDLEUI64VNVPROC) (GLint location, GLsizei count, const GLuint64* value);

















#line 12080 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

























































typedef void (__stdcall * PFNGLBLENDBARRIERNVPROC) (void);
typedef void (__stdcall * PFNGLBLENDPARAMETERINVPROC) (GLenum pname, GLint value);






#line 12146 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 12155 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 12164 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 12176 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBEGINCONDITIONALRENDERNVPROC) (GLuint id, GLenum mode);
typedef void (__stdcall * PFNGLENDCONDITIONALRENDERNVPROC) (void);






#line 12196 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 12208 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOPYIMAGESUBDATANVPROC) (GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei width, GLsizei height, GLsizei depth);





#line 12221 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 12233 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLCLEARDEPTHDNVPROC) (GLdouble depth);
typedef void (__stdcall * PFNGLDEPTHBOUNDSDNVPROC) (GLdouble zmin, GLdouble zmax);
typedef void (__stdcall * PFNGLDEPTHRANGEDNVPROC) (GLdouble zNear, GLdouble zFar);







#line 12255 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 12266 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 12281 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDRAWTEXTURENVPROC) (GLuint texture, GLuint sampler, GLfloat x0, GLfloat y0, GLfloat x1, GLfloat y1, GLfloat z, GLfloat s0, GLfloat t0, GLfloat s1, GLfloat t1);





#line 12294 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"































typedef void (__stdcall * PFNGLEVALMAPSNVPROC) (GLenum target, GLenum mode);
typedef void (__stdcall * PFNGLGETMAPATTRIBPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMAPATTRIBPARAMETERIVNVPROC) (GLenum target, GLuint index, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLboolean packed, void *points);
typedef void (__stdcall * PFNGLGETMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLMAPCONTROLPOINTSNVPROC) (GLenum target, GLuint index, GLenum type, GLsizei ustride, GLsizei vstride, GLint uorder, GLint vorder, GLboolean packed, const void *points);
typedef void (__stdcall * PFNGLMAPPARAMETERFVNVPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLMAPPARAMETERIVNVPROC) (GLenum target, GLenum pname, const GLint* params);













#line 12348 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

















typedef void (__stdcall * PFNGLGETMULTISAMPLEFVNVPROC) (GLenum pname, GLuint index, GLfloat* val);
typedef void (__stdcall * PFNGLSAMPLEMASKINDEXEDNVPROC) (GLuint index, GLbitfield mask);
typedef void (__stdcall * PFNGLTEXRENDERBUFFERNVPROC) (GLenum target, GLuint renderbuffer);







#line 12376 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLDELETEFENCESNVPROC) (GLsizei n, const GLuint* fences);
typedef void (__stdcall * PFNGLFINISHFENCENVPROC) (GLuint fence);
typedef void (__stdcall * PFNGLGENFENCESNVPROC) (GLsizei n, GLuint* fences);
typedef void (__stdcall * PFNGLGETFENCEIVNVPROC) (GLuint fence, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISFENCENVPROC) (GLuint fence);
typedef void (__stdcall * PFNGLSETFENCENVPROC) (GLuint fence, GLenum condition);
typedef GLboolean (__stdcall * PFNGLTESTFENCENVPROC) (GLuint fence);











#line 12405 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
























#line 12430 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 12443 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble *params);
typedef void (__stdcall * PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat *params);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4DNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLdouble v[]);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4FNVPROC) (GLuint id, GLsizei len, const GLubyte* name, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC) (GLuint id, GLsizei len, const GLubyte* name, const GLfloat v[]);










#line 12473 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 12488 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 12497 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 12506 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLenum internalformat, GLsizei width, GLsizei height);





#line 12524 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPROGRAMVERTEXLIMITNVPROC) (GLenum target, GLint limit);





#line 12541 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 12550 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4INVPROC) (GLenum target, GLuint index, GLint x, GLint y, GLint z, GLint w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC) (GLenum target, GLuint index, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4UINVPROC) (GLenum target, GLuint index, GLuint x, GLuint y, GLuint z, GLuint w);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC) (GLenum target, GLuint index, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC) (GLenum target, GLuint index, GLsizei count, const GLuint *params);
















#line 12594 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















#line 12610 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 12619 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 12628 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



































typedef void (__stdcall * PFNGLGETUNIFORMI64VNVPROC) (GLuint program, GLint location, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLuint64EXT* params);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64NVPROC) (GLuint program, GLint location, GLint64EXT x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM1UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM2UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM3UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64NVPROC) (GLuint program, GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4I64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64NVPROC) (GLuint program, GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLPROGRAMUNIFORM4UI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM1I64NVPROC) (GLint location, GLint64EXT x);
typedef void (__stdcall * PFNGLUNIFORM1I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM1UI64NVPROC) (GLint location, GLuint64EXT x);
typedef void (__stdcall * PFNGLUNIFORM1UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM2I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLUNIFORM2I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM2UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLUNIFORM2UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM3I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLUNIFORM3I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM3UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLUNIFORM3UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM4I64NVPROC) (GLint location, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLUNIFORM4I64VNVPROC) (GLint location, GLsizei count, const GLint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORM4UI64NVPROC) (GLint location, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLUNIFORM4UI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);






































#line 12736 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef unsigned short GLhalf;

typedef void (__stdcall * PFNGLCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void (__stdcall * PFNGLCOLOR3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLCOLOR4HNVPROC) (GLhalf red, GLhalf green, GLhalf blue, GLhalf alpha);
typedef void (__stdcall * PFNGLCOLOR4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLFOGCOORDHNVPROC) (GLhalf fog);
typedef void (__stdcall * PFNGLFOGCOORDHVNVPROC) (const GLhalf* fog);
typedef void (__stdcall * PFNGLMULTITEXCOORD1HNVPROC) (GLenum target, GLhalf s);
typedef void (__stdcall * PFNGLMULTITEXCOORD1HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD2HNVPROC) (GLenum target, GLhalf s, GLhalf t);
typedef void (__stdcall * PFNGLMULTITEXCOORD2HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD3HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r);
typedef void (__stdcall * PFNGLMULTITEXCOORD3HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLMULTITEXCOORD4HNVPROC) (GLenum target, GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void (__stdcall * PFNGLMULTITEXCOORD4HVNVPROC) (GLenum target, const GLhalf* v);
typedef void (__stdcall * PFNGLNORMAL3HNVPROC) (GLhalf nx, GLhalf ny, GLhalf nz);
typedef void (__stdcall * PFNGLNORMAL3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3HNVPROC) (GLhalf red, GLhalf green, GLhalf blue);
typedef void (__stdcall * PFNGLSECONDARYCOLOR3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD1HNVPROC) (GLhalf s);
typedef void (__stdcall * PFNGLTEXCOORD1HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD2HNVPROC) (GLhalf s, GLhalf t);
typedef void (__stdcall * PFNGLTEXCOORD2HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD3HNVPROC) (GLhalf s, GLhalf t, GLhalf r);
typedef void (__stdcall * PFNGLTEXCOORD3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLTEXCOORD4HNVPROC) (GLhalf s, GLhalf t, GLhalf r, GLhalf q);
typedef void (__stdcall * PFNGLTEXCOORD4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX2HNVPROC) (GLhalf x, GLhalf y);
typedef void (__stdcall * PFNGLVERTEX2HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX3HNVPROC) (GLhalf x, GLhalf y, GLhalf z);
typedef void (__stdcall * PFNGLVERTEX3HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEX4HNVPROC) (GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void (__stdcall * PFNGLVERTEX4HVNVPROC) (const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1HNVPROC) (GLuint index, GLhalf x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2HNVPROC) (GLuint index, GLhalf x, GLhalf y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4HNVPROC) (GLuint index, GLhalf x, GLhalf y, GLhalf z, GLhalf w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4HVNVPROC) (GLuint index, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4HVNVPROC) (GLuint index, GLsizei n, const GLhalf* v);
typedef void (__stdcall * PFNGLVERTEXWEIGHTHNVPROC) (GLhalf weight);
typedef void (__stdcall * PFNGLVERTEXWEIGHTHVNVPROC) (const GLhalf* weight);


















































#line 12843 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 12855 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 12866 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 12877 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBEGINOCCLUSIONQUERYNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLDELETEOCCLUSIONQUERIESNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLENDOCCLUSIONQUERYNVPROC) (void);
typedef void (__stdcall * PFNGLGENOCCLUSIONQUERIESNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETOCCLUSIONQUERYIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETOCCLUSIONQUERYUIVNVPROC) (GLuint id, GLenum pname, GLuint* params);
typedef GLboolean (__stdcall * PFNGLISOCCLUSIONQUERYNVPROC) (GLuint id);











#line 12907 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 12919 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLint *params);
typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLuint *params);
typedef void (__stdcall * PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC) (GLenum target, GLuint buffer, GLuint index, GLsizei count, const GLfloat *params);







#line 12942 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 12951 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"







































































































































typedef void (__stdcall * PFNGLCOPYPATHNVPROC) (GLuint resultPath, GLuint srcPath);
typedef void (__stdcall * PFNGLCOVERFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLCOVERFILLPATHNVPROC) (GLuint path, GLenum coverMode);
typedef void (__stdcall * PFNGLCOVERSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum coverMode, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLCOVERSTROKEPATHNVPROC) (GLuint name, GLenum coverMode);
typedef void (__stdcall * PFNGLDELETEPATHSNVPROC) (GLuint path, GLsizei range);
typedef GLuint (__stdcall * PFNGLGENPATHSNVPROC) (GLsizei range);
typedef void (__stdcall * PFNGLGETPATHCOLORGENFVNVPROC) (GLenum color, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHCOLORGENIVNVPROC) (GLenum color, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLGETPATHCOMMANDSNVPROC) (GLuint name, GLubyte* commands);
typedef void (__stdcall * PFNGLGETPATHCOORDSNVPROC) (GLuint name, GLfloat* coords);
typedef void (__stdcall * PFNGLGETPATHDASHARRAYNVPROC) (GLuint name, GLfloat* dashArray);
typedef GLfloat (__stdcall * PFNGLGETPATHLENGTHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments);
typedef void (__stdcall * PFNGLGETPATHMETRICRANGENVPROC) (GLbitfield metricQueryMask, GLuint fistPathName, GLsizei numPaths, GLsizei stride, GLfloat* metrics);
typedef void (__stdcall * PFNGLGETPATHMETRICSNVPROC) (GLbitfield metricQueryMask, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLsizei stride, GLfloat *metrics);
typedef void (__stdcall * PFNGLGETPATHPARAMETERFVNVPROC) (GLuint name, GLenum param, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHPARAMETERIVNVPROC) (GLuint name, GLenum param, GLint* value);
typedef void (__stdcall * PFNGLGETPATHSPACINGNVPROC) (GLenum pathListMode, GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLfloat advanceScale, GLfloat kerningScale, GLenum transformType, GLfloat *returnedSpacing);
typedef void (__stdcall * PFNGLGETPATHTEXGENFVNVPROC) (GLenum texCoordSet, GLenum pname, GLfloat* value);
typedef void (__stdcall * PFNGLGETPATHTEXGENIVNVPROC) (GLenum texCoordSet, GLenum pname, GLint* value);
typedef void (__stdcall * PFNGLINTERPOLATEPATHSNVPROC) (GLuint resultPath, GLuint pathA, GLuint pathB, GLfloat weight);
typedef GLboolean (__stdcall * PFNGLISPATHNVPROC) (GLuint path);
typedef GLboolean (__stdcall * PFNGLISPOINTINFILLPATHNVPROC) (GLuint path, GLuint mask, GLfloat x, GLfloat y);
typedef GLboolean (__stdcall * PFNGLISPOINTINSTROKEPATHNVPROC) (GLuint path, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLPATHCOLORGENNVPROC) (GLenum color, GLenum genMode, GLenum colorFormat, const GLfloat* coeffs);
typedef void (__stdcall * PFNGLPATHCOMMANDSNVPROC) (GLuint path, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void (__stdcall * PFNGLPATHCOORDSNVPROC) (GLuint path, GLsizei numCoords, GLenum coordType, const void* coords);
typedef void (__stdcall * PFNGLPATHCOVERDEPTHFUNCNVPROC) (GLenum zfunc);
typedef void (__stdcall * PFNGLPATHDASHARRAYNVPROC) (GLuint path, GLsizei dashCount, const GLfloat* dashArray);
typedef void (__stdcall * PFNGLPATHFOGGENNVPROC) (GLenum genMode);
typedef void (__stdcall * PFNGLPATHGLYPHRANGENVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLuint firstGlyph, GLsizei numGlyphs, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall * PFNGLPATHGLYPHSNVPROC) (GLuint firstPathName, GLenum fontTarget, const void* fontName, GLbitfield fontStyle, GLsizei numGlyphs, GLenum type, const void*charcodes, GLenum handleMissingGlyphs, GLuint pathParameterTemplate, GLfloat emScale);
typedef void (__stdcall * PFNGLPATHPARAMETERFNVPROC) (GLuint path, GLenum pname, GLfloat value);
typedef void (__stdcall * PFNGLPATHPARAMETERFVNVPROC) (GLuint path, GLenum pname, const GLfloat* value);
typedef void (__stdcall * PFNGLPATHPARAMETERINVPROC) (GLuint path, GLenum pname, GLint value);
typedef void (__stdcall * PFNGLPATHPARAMETERIVNVPROC) (GLuint path, GLenum pname, const GLint* value);
typedef void (__stdcall * PFNGLPATHSTENCILDEPTHOFFSETNVPROC) (GLfloat factor, GLfloat units);
typedef void (__stdcall * PFNGLPATHSTENCILFUNCNVPROC) (GLenum func, GLint ref, GLuint mask);
typedef void (__stdcall * PFNGLPATHSTRINGNVPROC) (GLuint path, GLenum format, GLsizei length, const void* pathString);
typedef void (__stdcall * PFNGLPATHSUBCOMMANDSNVPROC) (GLuint path, GLsizei commandStart, GLsizei commandsToDelete, GLsizei numCommands, const GLubyte* commands, GLsizei numCoords, GLenum coordType, const void*coords);
typedef void (__stdcall * PFNGLPATHSUBCOORDSNVPROC) (GLuint path, GLsizei coordStart, GLsizei numCoords, GLenum coordType, const void* coords);
typedef void (__stdcall * PFNGLPATHTEXGENNVPROC) (GLenum texCoordSet, GLenum genMode, GLint components, const GLfloat* coeffs);
typedef GLboolean (__stdcall * PFNGLPOINTALONGPATHNVPROC) (GLuint path, GLsizei startSegment, GLsizei numSegments, GLfloat distance, GLfloat* x, GLfloat *y, GLfloat *tangentX, GLfloat *tangentY);
typedef void (__stdcall * PFNGLSTENCILFILLPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLenum fillMode, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILFILLPATHNVPROC) (GLuint path, GLenum fillMode, GLuint mask);
typedef void (__stdcall * PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC) (GLsizei numPaths, GLenum pathNameType, const void* paths, GLuint pathBase, GLint reference, GLuint mask, GLenum transformType, const GLfloat *transformValues);
typedef void (__stdcall * PFNGLSTENCILSTROKEPATHNVPROC) (GLuint path, GLint reference, GLuint mask);
typedef void (__stdcall * PFNGLTRANSFORMPATHNVPROC) (GLuint resultPath, GLuint srcPath, GLenum transformType, const GLfloat* transformValues);
typedef void (__stdcall * PFNGLWEIGHTPATHSNVPROC) (GLuint resultPath, GLsizei numPaths, const GLuint paths[], const GLfloat weights[]);





















































#line 13189 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLFLUSHPIXELDATARANGENVPROC) (GLenum target);
typedef void (__stdcall * PFNGLPIXELDATARANGENVPROC) (GLenum target, GLsizei length, void *pointer);






#line 13211 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLPOINTPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLPOINTPARAMETERIVNVPROC) (GLenum pname, const GLint* params);






#line 13230 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













typedef void (__stdcall * PFNGLGETVIDEOI64VNVPROC) (GLuint video_slot, GLenum pname, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETVIDEOIVNVPROC) (GLuint video_slot, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVIDEOUI64VNVPROC) (GLuint video_slot, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLGETVIDEOUIVNVPROC) (GLuint video_slot, GLenum pname, GLuint* params);
typedef void (__stdcall * PFNGLPRESENTFRAMEDUALFILLNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLenum target1, GLuint fill1, GLenum target2, GLuint fill2, GLenum target3, GLuint fill3);
typedef void (__stdcall * PFNGLPRESENTFRAMEKEYEDNVPROC) (GLuint video_slot, GLuint64EXT minPresentTime, GLuint beginPresentTimeId, GLuint presentDurationId, GLenum type, GLenum target0, GLuint fill0, GLuint key0, GLenum target1, GLuint fill1, GLuint key1);










#line 13260 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLPRIMITIVERESTARTINDEXNVPROC) (GLuint index);
typedef void (__stdcall * PFNGLPRIMITIVERESTARTNVPROC) (void);






#line 13278 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


























































typedef void (__stdcall * PFNGLCOMBINERINPUTNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall * PFNGLCOMBINEROUTPUTNVPROC) (GLenum stage, GLenum portion, GLenum abOutput, GLenum cdOutput, GLenum sumOutput, GLenum scale, GLenum bias, GLboolean abDotProduct, GLboolean cdDotProduct, GLboolean muxSum);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERFNVPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERFVNVPROC) (GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERINVPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLCOMBINERPARAMETERIVNVPROC) (GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLFINALCOMBINERINPUTNVPROC) (GLenum variable, GLenum input, GLenum mapping, GLenum componentUsage);
typedef void (__stdcall * PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum variable, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC) (GLenum stage, GLenum portion, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC) (GLenum variable, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC) (GLenum variable, GLenum pname, GLint* params);

















#line 13367 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC) (GLenum stage, GLenum pname, GLfloat* params);






#line 13384 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 13393 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 13402 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 13411 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLGETBUFFERPARAMETERUI64VNVPROC) (GLenum target, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLGETINTEGERUI64VNVPROC) (GLenum value, GLuint64EXT* result);
typedef void (__stdcall * PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC) (GLuint buffer, GLenum pname, GLuint64EXT* params);
typedef GLboolean (__stdcall * PFNGLISBUFFERRESIDENTNVPROC) (GLenum target);
typedef GLboolean (__stdcall * PFNGLISNAMEDBUFFERRESIDENTNVPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLMAKEBUFFERNONRESIDENTNVPROC) (GLenum target);
typedef void (__stdcall * PFNGLMAKEBUFFERRESIDENTNVPROC) (GLenum target, GLenum access);
typedef void (__stdcall * PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC) (GLuint buffer);
typedef void (__stdcall * PFNGLMAKENAMEDBUFFERRESIDENTNVPROC) (GLuint buffer, GLenum access);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMUI64NVPROC) (GLuint program, GLint location, GLuint64EXT value);
typedef void (__stdcall * PFNGLPROGRAMUNIFORMUI64VNVPROC) (GLuint program, GLint location, GLsizei count, const GLuint64EXT* value);
typedef void (__stdcall * PFNGLUNIFORMUI64NVPROC) (GLint location, GLuint64EXT value);
typedef void (__stdcall * PFNGLUNIFORMUI64VNVPROC) (GLint location, GLsizei count, const GLuint64EXT* value);

















#line 13452 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 13461 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 13474 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 13483 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 13498 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 13511 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 13523 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXTUREBARRIERNVPROC) (void);





#line 13536 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 13545 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 13560 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 13571 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC) (GLuint texture, GLenum target, GLsizei coverageSamples, GLsizei colorSamples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);
typedef void (__stdcall * PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC) (GLuint texture, GLenum target, GLsizei samples, GLint internalFormat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedSampleLocations);










#line 13597 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 13611 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


















































































#line 13694 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





































#line 13732 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


























#line 13759 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
































typedef void (__stdcall * PFNGLACTIVEVARYINGNVPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLBEGINTRANSFORMFEEDBACKNVPROC) (GLenum primitiveMode);
typedef void (__stdcall * PFNGLBINDBUFFERBASENVPROC) (GLenum target, GLuint index, GLuint buffer);
typedef void (__stdcall * PFNGLBINDBUFFEROFFSETNVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset);
typedef void (__stdcall * PFNGLBINDBUFFERRANGENVPROC) (GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size);
typedef void (__stdcall * PFNGLENDTRANSFORMFEEDBACKNVPROC) (void);
typedef void (__stdcall * PFNGLGETACTIVEVARYINGNVPROC) (GLuint program, GLuint index, GLsizei bufSize, GLsizei *length, GLsizei *size, GLenum *type, GLchar *name);
typedef void (__stdcall * PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC) (GLuint program, GLuint index, GLint *location);
typedef GLint (__stdcall * PFNGLGETVARYINGLOCATIONNVPROC) (GLuint program, const GLchar *name);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC) (GLuint count, const GLint *attribs, GLenum bufferMode);
typedef void (__stdcall * PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC) (GLuint program, GLsizei count, const GLint *locations, GLenum bufferMode);















#line 13818 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef void (__stdcall * PFNGLBINDTRANSFORMFEEDBACKNVPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETETRANSFORMFEEDBACKSNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLDRAWTRANSFORMFEEDBACKNVPROC) (GLenum mode, GLuint id);
typedef void (__stdcall * PFNGLGENTRANSFORMFEEDBACKSNVPROC) (GLsizei n, GLuint* ids);
typedef GLboolean (__stdcall * PFNGLISTRANSFORMFEEDBACKNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLPAUSETRANSFORMFEEDBACKNVPROC) (void);
typedef void (__stdcall * PFNGLRESUMETRANSFORMFEEDBACKNVPROC) (void);











#line 13848 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











typedef GLintptr GLvdpauSurfaceNV;

typedef void (__stdcall * PFNGLVDPAUFININVPROC) (void);
typedef void (__stdcall * PFNGLVDPAUGETSURFACEIVNVPROC) (GLvdpauSurfaceNV surface, GLenum pname, GLsizei bufSize, GLsizei* length, GLint *values);
typedef void (__stdcall * PFNGLVDPAUINITNVPROC) (const void* vdpDevice, const void*getProcAddress);
typedef void (__stdcall * PFNGLVDPAUISSURFACENVPROC) (GLvdpauSurfaceNV surface);
typedef void (__stdcall * PFNGLVDPAUMAPSURFACESNVPROC) (GLsizei numSurfaces, const GLvdpauSurfaceNV* surfaces);
typedef GLvdpauSurfaceNV (__stdcall * PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef GLvdpauSurfaceNV (__stdcall * PFNGLVDPAUREGISTERVIDEOSURFACENVPROC) (const void* vdpSurface, GLenum target, GLsizei numTextureNames, const GLuint *textureNames);
typedef void (__stdcall * PFNGLVDPAUSURFACEACCESSNVPROC) (GLvdpauSurfaceNV surface, GLenum access);
typedef void (__stdcall * PFNGLVDPAUUNMAPSURFACESNVPROC) (GLsizei numSurface, const GLvdpauSurfaceNV* surfaces);
typedef void (__stdcall * PFNGLVDPAUUNREGISTERSURFACENVPROC) (GLvdpauSurfaceNV surface);














#line 13886 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












typedef void (__stdcall * PFNGLFLUSHVERTEXARRAYRANGENVPROC) (void);
typedef void (__stdcall * PFNGLVERTEXARRAYRANGENVPROC) (GLsizei length, void *pointer);






#line 13907 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 13918 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLGETVERTEXATTRIBLI64VNVPROC) (GLuint index, GLenum pname, GLint64EXT* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBLUI64VNVPROC) (GLuint index, GLenum pname, GLuint64EXT* params);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1I64NVPROC) (GLuint index, GLint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64NVPROC) (GLuint index, GLuint64EXT x);
typedef void (__stdcall * PFNGLVERTEXATTRIBL1UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y);
typedef void (__stdcall * PFNGLVERTEXATTRIBL2UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z);
typedef void (__stdcall * PFNGLVERTEXATTRIBL3UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4I64NVPROC) (GLuint index, GLint64EXT x, GLint64EXT y, GLint64EXT z, GLint64EXT w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4I64VNVPROC) (GLuint index, const GLint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4UI64NVPROC) (GLuint index, GLuint64EXT x, GLuint64EXT y, GLuint64EXT z, GLuint64EXT w);
typedef void (__stdcall * PFNGLVERTEXATTRIBL4UI64VNVPROC) (GLuint index, const GLuint64EXT* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBLFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);























#line 13970 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
































typedef void (__stdcall * PFNGLBUFFERADDRESSRANGENVPROC) (GLenum pname, GLuint index, GLuint64EXT address, GLsizeiptr length);
typedef void (__stdcall * PFNGLCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLEDGEFLAGFORMATNVPROC) (GLsizei stride);
typedef void (__stdcall * PFNGLFOGCOORDFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLGETINTEGERUI64I_VNVPROC) (GLenum value, GLuint index, GLuint64EXT result[]);
typedef void (__stdcall * PFNGLINDEXFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLNORMALFORMATNVPROC) (GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLSECONDARYCOLORFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLTEXCOORDFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXATTRIBFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXATTRIBIFORMATNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride);
typedef void (__stdcall * PFNGLVERTEXFORMATNVPROC) (GLint size, GLenum type, GLsizei stride);
















#line 14031 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


























































































typedef GLboolean (__stdcall * PFNGLAREPROGRAMSRESIDENTNVPROC) (GLsizei n, const GLuint* ids, GLboolean *residences);
typedef void (__stdcall * PFNGLBINDPROGRAMNVPROC) (GLenum target, GLuint id);
typedef void (__stdcall * PFNGLDELETEPROGRAMSNVPROC) (GLsizei n, const GLuint* ids);
typedef void (__stdcall * PFNGLEXECUTEPROGRAMNVPROC) (GLenum target, GLuint id, const GLfloat* params);
typedef void (__stdcall * PFNGLGENPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLGETPROGRAMPARAMETERDVNVPROC) (GLenum target, GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETPROGRAMPARAMETERFVNVPROC) (GLenum target, GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETPROGRAMSTRINGNVPROC) (GLuint id, GLenum pname, GLubyte* program);
typedef void (__stdcall * PFNGLGETPROGRAMIVNVPROC) (GLuint id, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETTRACKMATRIXIVNVPROC) (GLenum target, GLuint address, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBPOINTERVNVPROC) (GLuint index, GLenum pname, void** pointer);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBDVNVPROC) (GLuint index, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBFVNVPROC) (GLuint index, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVERTEXATTRIBIVNVPROC) (GLuint index, GLenum pname, GLint* params);
typedef GLboolean (__stdcall * PFNGLISPROGRAMNVPROC) (GLuint id);
typedef void (__stdcall * PFNGLLOADPROGRAMNVPROC) (GLenum target, GLuint id, GLsizei len, const GLubyte* program);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4DNVPROC) (GLenum target, GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4DVNVPROC) (GLenum target, GLuint index, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4FNVPROC) (GLenum target, GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLPROGRAMPARAMETER4FVNVPROC) (GLenum target, GLuint index, const GLfloat* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERS4DVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLdouble* params);
typedef void (__stdcall * PFNGLPROGRAMPARAMETERS4FVNVPROC) (GLenum target, GLuint index, GLsizei num, const GLfloat* params);
typedef void (__stdcall * PFNGLREQUESTRESIDENTPROGRAMSNVPROC) (GLsizei n, GLuint* ids);
typedef void (__stdcall * PFNGLTRACKMATRIXNVPROC) (GLenum target, GLuint address, GLenum matrix, GLenum transform);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DNVPROC) (GLuint index, GLdouble x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FNVPROC) (GLuint index, GLfloat x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SNVPROC) (GLuint index, GLshort x);
typedef void (__stdcall * PFNGLVERTEXATTRIB1SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DNVPROC) (GLuint index, GLdouble x, GLdouble y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FNVPROC) (GLuint index, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SNVPROC) (GLuint index, GLshort x, GLshort y);
typedef void (__stdcall * PFNGLVERTEXATTRIB2SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z);
typedef void (__stdcall * PFNGLVERTEXATTRIB3SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DNVPROC) (GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4DVNVPROC) (GLuint index, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FNVPROC) (GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4FVNVPROC) (GLuint index, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SNVPROC) (GLuint index, GLshort x, GLshort y, GLshort z, GLshort w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4SVNVPROC) (GLuint index, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBNVPROC) (GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w);
typedef void (__stdcall * PFNGLVERTEXATTRIB4UBVNVPROC) (GLuint index, const GLubyte* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBPOINTERNVPROC) (GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS1SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS2SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS3SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4DVNVPROC) (GLuint index, GLsizei n, const GLdouble* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4FVNVPROC) (GLuint index, GLsizei n, const GLfloat* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4SVNVPROC) (GLuint index, GLsizei n, const GLshort* v);
typedef void (__stdcall * PFNGLVERTEXATTRIBS4UBVNVPROC) (GLuint index, GLsizei n, const GLubyte* v);




































































#line 14254 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 14263 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 14272 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 14284 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 14295 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 14306 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




































typedef void (__stdcall * PFNGLBEGINVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void (__stdcall * PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLintptrARB offset);
typedef void (__stdcall * PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC) (GLuint video_capture_slot, GLuint stream, GLenum frame_region, GLenum target, GLuint texture);
typedef void (__stdcall * PFNGLENDVIDEOCAPTURENVPROC) (GLuint video_capture_slot);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLdouble* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTURESTREAMIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETVIDEOCAPTUREIVNVPROC) (GLuint video_capture_slot, GLenum pname, GLint* params);
typedef GLenum (__stdcall * PFNGLVIDEOCAPTURENVPROC) (GLuint video_capture_slot, GLuint* sequence_num, GLuint64EXT *capture_time);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLdouble* params);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC) (GLuint video_capture_slot, GLuint stream, GLenum pname, const GLint* params);
















#line 14371 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 14380 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



















#line 14400 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 14412 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCLEARDEPTHFOESPROC) (GLclampd depth);
typedef void (__stdcall * PFNGLCLIPPLANEFOESPROC) (GLenum plane, const GLfloat* equation);
typedef void (__stdcall * PFNGLDEPTHRANGEFOESPROC) (GLclampf n, GLclampf f);
typedef void (__stdcall * PFNGLFRUSTUMFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);
typedef void (__stdcall * PFNGLGETCLIPPLANEFOESPROC) (GLenum plane, GLfloat* equation);
typedef void (__stdcall * PFNGLORTHOFOESPROC) (GLfloat l, GLfloat r, GLfloat b, GLfloat t, GLfloat n, GLfloat f);










#line 14435 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 14447 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















#line 14463 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 14475 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





























#line 14505 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"































#line 14537 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef int GLclampx;

typedef void (__stdcall * PFNGLALPHAFUNCXPROC) (GLenum func, GLclampx ref);
typedef void (__stdcall * PFNGLCLEARCOLORXPROC) (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
typedef void (__stdcall * PFNGLCLEARDEPTHXPROC) (GLclampx depth);
typedef void (__stdcall * PFNGLCOLOR4XPROC) (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
typedef void (__stdcall * PFNGLDEPTHRANGEXPROC) (GLclampx zNear, GLclampx zFar);
typedef void (__stdcall * PFNGLFOGXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLFOGXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLFRUSTUMFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void (__stdcall * PFNGLFRUSTUMXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void (__stdcall * PFNGLLIGHTMODELXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLLIGHTMODELXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLLIGHTXPROC) (GLenum light, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLLIGHTXVPROC) (GLenum light, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLLINEWIDTHXPROC) (GLfixed width);
typedef void (__stdcall * PFNGLLOADMATRIXXPROC) (const GLfixed* m);
typedef void (__stdcall * PFNGLMATERIALXPROC) (GLenum face, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLMATERIALXVPROC) (GLenum face, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLMULTMATRIXXPROC) (const GLfixed* m);
typedef void (__stdcall * PFNGLMULTITEXCOORD4XPROC) (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
typedef void (__stdcall * PFNGLNORMAL3XPROC) (GLfixed nx, GLfixed ny, GLfixed nz);
typedef void (__stdcall * PFNGLORTHOFPROC) (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
typedef void (__stdcall * PFNGLORTHOXPROC) (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
typedef void (__stdcall * PFNGLPOINTSIZEXPROC) (GLfixed size);
typedef void (__stdcall * PFNGLPOLYGONOFFSETXPROC) (GLfixed factor, GLfixed units);
typedef void (__stdcall * PFNGLROTATEXPROC) (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall * PFNGLSAMPLECOVERAGEXPROC) (GLclampx value, GLboolean invert);
typedef void (__stdcall * PFNGLSCALEXPROC) (GLfixed x, GLfixed y, GLfixed z);
typedef void (__stdcall * PFNGLTEXENVXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLTEXENVXVPROC) (GLenum target, GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLTEXPARAMETERXPROC) (GLenum target, GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLTRANSLATEXPROC) (GLfixed x, GLfixed y, GLfixed z);



































#line 14612 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCLIPPLANEFPROC) (GLenum plane, const GLfloat* equation);
typedef void (__stdcall * PFNGLCLIPPLANEXPROC) (GLenum plane, const GLfixed* equation);
typedef void (__stdcall * PFNGLGETCLIPPLANEFPROC) (GLenum pname, GLfloat eqn[4]);
typedef void (__stdcall * PFNGLGETCLIPPLANEXPROC) (GLenum pname, GLfixed eqn[4]);
typedef void (__stdcall * PFNGLGETFIXEDVPROC) (GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETLIGHTXVPROC) (GLenum light, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETMATERIALXVPROC) (GLenum face, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETTEXENVXVPROC) (GLenum env, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLGETTEXPARAMETERXVPROC) (GLenum target, GLenum pname, GLfixed* params);
typedef void (__stdcall * PFNGLPOINTPARAMETERXPROC) (GLenum pname, GLfixed param);
typedef void (__stdcall * PFNGLPOINTPARAMETERXVPROC) (GLenum pname, const GLfixed* params);
typedef void (__stdcall * PFNGLPOINTSIZEPOINTEROESPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLTEXPARAMETERXVPROC) (GLenum target, GLenum pname, const GLfixed* params);

















#line 14649 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



















#line 14669 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef const GLchar* (__stdcall * PFNGLERRORSTRINGREGALPROC) (GLenum error);





#line 14682 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef GLboolean (__stdcall * PFNGLGETEXTENSIONREGALPROC) (const GLchar* ext);
typedef GLboolean (__stdcall * PFNGLISSUPPORTEDREGALPROC) (const GLchar* ext);






#line 14697 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
















typedef void (__stdcall *GLLOGPROCREGAL)(GLenum stream, GLsizei length, const GLchar *message, void *context);

typedef void (__stdcall * PFNGLLOGMESSAGECALLBACKREGALPROC) (GLLOGPROCREGAL callback);





#line 14722 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void * (__stdcall * PFNGLGETPROCADDRESSREGALPROC) (const GLchar *name);





#line 14735 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 14747 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















#line 14763 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"


















#line 14782 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLDETAILTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETDETAILTEXFUNCSGISPROC) (GLenum target, GLfloat* points);






#line 14797 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFOGFUNCSGISPROC) (GLsizei n, const GLfloat* points);
typedef void (__stdcall * PFNGLGETFOGFUNCSGISPROC) (GLfloat* points);






#line 14812 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 14824 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLSAMPLEMASKSGISPROC) (GLclampf value, GLboolean invert);
typedef void (__stdcall * PFNGLSAMPLEPATTERNSGISPROC) (GLenum pattern);






#line 14856 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 14865 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

















#line 14883 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETSHARPENTEXFUNCSGISPROC) (GLenum target, GLfloat* points);
typedef void (__stdcall * PFNGLSHARPENTEXFUNCSGISPROC) (GLenum target, GLsizei n, const GLfloat* points);






#line 14898 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTEXIMAGE4DSGISPROC) (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLint border, GLenum format, GLenum type, const void *pixels);
typedef void (__stdcall * PFNGLTEXSUBIMAGE4DSGISPROC) (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint woffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei extent, GLenum format, GLenum type, const void *pixels);






#line 14913 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 14924 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 14935 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLGETTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLfloat* weights);
typedef void (__stdcall * PFNGLTEXFILTERFUNCSGISPROC) (GLenum target, GLenum filter, GLsizei n, const GLfloat* weights);






#line 14950 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 14964 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 14973 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








typedef void (__stdcall * PFNGLASYNCMARKERSGIXPROC) (GLuint marker);
typedef void (__stdcall * PFNGLDELETEASYNCMARKERSSGIXPROC) (GLuint marker, GLsizei range);
typedef GLint (__stdcall * PFNGLFINISHASYNCSGIXPROC) (GLuint* markerp);
typedef GLuint (__stdcall * PFNGLGENASYNCMARKERSSGIXPROC) (GLsizei range);
typedef GLboolean (__stdcall * PFNGLISASYNCMARKERSGIXPROC) (GLuint marker);
typedef GLint (__stdcall * PFNGLPOLLASYNCSGIXPROC) (GLuint* markerp);










#line 14998 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 15010 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"















#line 15026 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 15038 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 15047 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 15058 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 15071 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFLUSHRASTERSGIXPROC) (void);





#line 15084 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 15096 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










typedef void (__stdcall * PFNGLTEXTUREFOGSGIXPROC) (GLenum pname);





#line 15113 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAGMENTCOLORMATERIALSGIXPROC) (GLenum face, GLenum mode);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELISGIXPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTMODELIVSGIXPROC) (GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFSGIXPROC) (GLenum light, GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTISGIXPROC) (GLenum light, GLenum pname, GLint param);
typedef void (__stdcall * PFNGLFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFSGIXPROC) (GLenum face, GLenum pname, const GLfloat param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALISGIXPROC) (GLenum face, GLenum pname, const GLint param);
typedef void (__stdcall * PFNGLFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTFVSGIXPROC) (GLenum light, GLenum value, GLfloat* data);
typedef void (__stdcall * PFNGLGETFRAGMENTLIGHTIVSGIXPROC) (GLenum light, GLenum value, GLint* data);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALFVSGIXPROC) (GLenum face, GLenum pname, const GLfloat* data);
typedef void (__stdcall * PFNGLGETFRAGMENTMATERIALIVSGIXPROC) (GLenum face, GLenum pname, const GLint* data);





















#line 15158 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLFRAMEZOOMSGIXPROC) (GLint factor);





#line 15171 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 15182 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 15191 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 15200 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLPIXELTEXGENSGIXPROC) (GLenum mode);





#line 15213 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 15222 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLREFERENCEPLANESGIXPROC) (const GLdouble* equation);





#line 15235 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"














#line 15250 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 15264 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 15275 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLSPRITEPARAMETERFSGIXPROC) (GLenum pname, GLfloat param);
typedef void (__stdcall * PFNGLSPRITEPARAMETERFVSGIXPROC) (GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLSPRITEPARAMETERISGIXPROC) (GLenum pname, GLint param);
typedef void (__stdcall * PFNGLSPRITEPARAMETERIVSGIXPROC) (GLenum pname, GLint* params);








#line 15294 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLTAGSAMPLEBUFFERSGIXPROC) (void);





#line 15307 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 15316 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"












#line 15329 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 15338 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 15349 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





































#line 15387 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"













#line 15401 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 15413 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 15425 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"








#line 15434 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




















#line 15455 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"























typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, const GLfloat* params);
typedef void (__stdcall * PFNGLCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, const GLint* params);
typedef void (__stdcall * PFNGLCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLsizei width, GLenum format, GLenum type, const void *table);
typedef void (__stdcall * PFNGLCOPYCOLORTABLESGIPROC) (GLenum target, GLenum internalformat, GLint x, GLint y, GLsizei width);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERFVSGIPROC) (GLenum target, GLenum pname, GLfloat* params);
typedef void (__stdcall * PFNGLGETCOLORTABLEPARAMETERIVSGIPROC) (GLenum target, GLenum pname, GLint* params);
typedef void (__stdcall * PFNGLGETCOLORTABLESGIPROC) (GLenum target, GLenum format, GLenum type, void *table);











#line 15497 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 15509 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLFINISHTEXTURESUNXPROC) (void);





#line 15525 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 15536 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"









typedef void (__stdcall * PFNGLGLOBALALPHAFACTORBSUNPROC) (GLbyte factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORDSUNPROC) (GLdouble factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORFSUNPROC) (GLfloat factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORISUNPROC) (GLint factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORSSUNPROC) (GLshort factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUBSUNPROC) (GLubyte factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUISUNPROC) (GLuint factor);
typedef void (__stdcall * PFNGLGLOBALALPHAFACTORUSSUNPROC) (GLushort factor);












#line 15566 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 15578 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLREADVIDEOPIXELSSUNPROC) (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels);





#line 15591 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 15602 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"
























typedef void (__stdcall * PFNGLREPLACEMENTCODEPOINTERSUNPROC) (GLenum type, GLsizei stride, const void *pointer);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUBSUNPROC) (GLubyte code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUBVSUNPROC) (const GLubyte* code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUISUNPROC) (GLuint code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVSUNPROC) (const GLuint* code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUSSUNPROC) (GLushort code);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUSVSUNPROC) (const GLushort* code);











#line 15645 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLCOLOR3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX2FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX2FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX3FSUNPROC) (GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLCOLOR4UBVERTEX3FVSUNPROC) (const GLubyte* c, const GLfloat *v);
typedef void (__stdcall * PFNGLNORMAL3FVERTEX3FSUNPROC) (GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC) (GLuint rc, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC) (const GLuint* rc, const GLubyte *c, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC) (GLuint rc, GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *tc, const GLfloat *v);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC) (GLuint rc, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC) (const GLuint* rc, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLubyte r, GLubyte g, GLubyte b, GLubyte a, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC) (const GLfloat* tc, const GLubyte *c, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD2FVERTEX3FSUNPROC) (GLfloat s, GLfloat t, GLfloat x, GLfloat y, GLfloat z);
typedef void (__stdcall * PFNGLTEXCOORD2FVERTEX3FVSUNPROC) (const GLfloat* tc, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat r, GLfloat g, GLfloat b, GLfloat a, GLfloat nx, GLfloat ny, GLfloat nz, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *c, const GLfloat *n, const GLfloat *v);
typedef void (__stdcall * PFNGLTEXCOORD4FVERTEX4FSUNPROC) (GLfloat s, GLfloat t, GLfloat p, GLfloat q, GLfloat x, GLfloat y, GLfloat z, GLfloat w);
typedef void (__stdcall * PFNGLTEXCOORD4FVERTEX4FVSUNPROC) (const GLfloat* tc, const GLfloat *v);












































#line 15736 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"











#line 15748 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"










#line 15759 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"






typedef void (__stdcall * PFNGLADDSWAPHINTRECTWINPROC) (GLint x, GLint y, GLsizei width, GLsizei height);





#line 15772 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"





#line 15778 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

#line 15780 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"



#line 15784 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

#line 15786 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




#line 15791 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE3DPROC __glewCopyTexSubImage3D;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSPROC __glewDrawRangeElements;
extern __declspec(dllimport) PFNGLTEXIMAGE3DPROC __glewTexImage3D;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE3DPROC __glewTexSubImage3D;

extern __declspec(dllimport) PFNGLACTIVETEXTUREPROC __glewActiveTexture;
extern __declspec(dllimport) PFNGLCLIENTACTIVETEXTUREPROC __glewClientActiveTexture;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE1DPROC __glewCompressedTexImage1D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE2DPROC __glewCompressedTexImage2D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE3DPROC __glewCompressedTexImage3D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC __glewCompressedTexSubImage1D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC __glewCompressedTexSubImage2D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC __glewCompressedTexSubImage3D;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXIMAGEPROC __glewGetCompressedTexImage;
extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXDPROC __glewLoadTransposeMatrixd;
extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXFPROC __glewLoadTransposeMatrixf;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXDPROC __glewMultTransposeMatrixd;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXFPROC __glewMultTransposeMatrixf;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DPROC __glewMultiTexCoord1d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DVPROC __glewMultiTexCoord1dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FPROC __glewMultiTexCoord1f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FVPROC __glewMultiTexCoord1fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IPROC __glewMultiTexCoord1i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IVPROC __glewMultiTexCoord1iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SPROC __glewMultiTexCoord1s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SVPROC __glewMultiTexCoord1sv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DPROC __glewMultiTexCoord2d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DVPROC __glewMultiTexCoord2dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FPROC __glewMultiTexCoord2f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FVPROC __glewMultiTexCoord2fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IPROC __glewMultiTexCoord2i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IVPROC __glewMultiTexCoord2iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SPROC __glewMultiTexCoord2s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SVPROC __glewMultiTexCoord2sv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DPROC __glewMultiTexCoord3d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DVPROC __glewMultiTexCoord3dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FPROC __glewMultiTexCoord3f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FVPROC __glewMultiTexCoord3fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IPROC __glewMultiTexCoord3i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IVPROC __glewMultiTexCoord3iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SPROC __glewMultiTexCoord3s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SVPROC __glewMultiTexCoord3sv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DPROC __glewMultiTexCoord4d;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DVPROC __glewMultiTexCoord4dv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FPROC __glewMultiTexCoord4f;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FVPROC __glewMultiTexCoord4fv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IPROC __glewMultiTexCoord4i;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IVPROC __glewMultiTexCoord4iv;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SPROC __glewMultiTexCoord4s;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SVPROC __glewMultiTexCoord4sv;
extern __declspec(dllimport) PFNGLSAMPLECOVERAGEPROC __glewSampleCoverage;

extern __declspec(dllimport) PFNGLBLENDCOLORPROC __glewBlendColor;
extern __declspec(dllimport) PFNGLBLENDEQUATIONPROC __glewBlendEquation;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEPROC __glewBlendFuncSeparate;
extern __declspec(dllimport) PFNGLFOGCOORDPOINTERPROC __glewFogCoordPointer;
extern __declspec(dllimport) PFNGLFOGCOORDDPROC __glewFogCoordd;
extern __declspec(dllimport) PFNGLFOGCOORDDVPROC __glewFogCoorddv;
extern __declspec(dllimport) PFNGLFOGCOORDFPROC __glewFogCoordf;
extern __declspec(dllimport) PFNGLFOGCOORDFVPROC __glewFogCoordfv;
extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSPROC __glewMultiDrawArrays;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSPROC __glewMultiDrawElements;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFPROC __glewPointParameterf;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFVPROC __glewPointParameterfv;
extern __declspec(dllimport) PFNGLPOINTPARAMETERIPROC __glewPointParameteri;
extern __declspec(dllimport) PFNGLPOINTPARAMETERIVPROC __glewPointParameteriv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BPROC __glewSecondaryColor3b;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BVPROC __glewSecondaryColor3bv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DPROC __glewSecondaryColor3d;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DVPROC __glewSecondaryColor3dv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FPROC __glewSecondaryColor3f;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FVPROC __glewSecondaryColor3fv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IPROC __glewSecondaryColor3i;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IVPROC __glewSecondaryColor3iv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SPROC __glewSecondaryColor3s;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SVPROC __glewSecondaryColor3sv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBPROC __glewSecondaryColor3ub;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBVPROC __glewSecondaryColor3ubv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIPROC __glewSecondaryColor3ui;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIVPROC __glewSecondaryColor3uiv;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USPROC __glewSecondaryColor3us;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USVPROC __glewSecondaryColor3usv;
extern __declspec(dllimport) PFNGLSECONDARYCOLORPOINTERPROC __glewSecondaryColorPointer;
extern __declspec(dllimport) PFNGLWINDOWPOS2DPROC __glewWindowPos2d;
extern __declspec(dllimport) PFNGLWINDOWPOS2DVPROC __glewWindowPos2dv;
extern __declspec(dllimport) PFNGLWINDOWPOS2FPROC __glewWindowPos2f;
extern __declspec(dllimport) PFNGLWINDOWPOS2FVPROC __glewWindowPos2fv;
extern __declspec(dllimport) PFNGLWINDOWPOS2IPROC __glewWindowPos2i;
extern __declspec(dllimport) PFNGLWINDOWPOS2IVPROC __glewWindowPos2iv;
extern __declspec(dllimport) PFNGLWINDOWPOS2SPROC __glewWindowPos2s;
extern __declspec(dllimport) PFNGLWINDOWPOS2SVPROC __glewWindowPos2sv;
extern __declspec(dllimport) PFNGLWINDOWPOS3DPROC __glewWindowPos3d;
extern __declspec(dllimport) PFNGLWINDOWPOS3DVPROC __glewWindowPos3dv;
extern __declspec(dllimport) PFNGLWINDOWPOS3FPROC __glewWindowPos3f;
extern __declspec(dllimport) PFNGLWINDOWPOS3FVPROC __glewWindowPos3fv;
extern __declspec(dllimport) PFNGLWINDOWPOS3IPROC __glewWindowPos3i;
extern __declspec(dllimport) PFNGLWINDOWPOS3IVPROC __glewWindowPos3iv;
extern __declspec(dllimport) PFNGLWINDOWPOS3SPROC __glewWindowPos3s;
extern __declspec(dllimport) PFNGLWINDOWPOS3SVPROC __glewWindowPos3sv;

extern __declspec(dllimport) PFNGLBEGINQUERYPROC __glewBeginQuery;
extern __declspec(dllimport) PFNGLBINDBUFFERPROC __glewBindBuffer;
extern __declspec(dllimport) PFNGLBUFFERDATAPROC __glewBufferData;
extern __declspec(dllimport) PFNGLBUFFERSUBDATAPROC __glewBufferSubData;
extern __declspec(dllimport) PFNGLDELETEBUFFERSPROC __glewDeleteBuffers;
extern __declspec(dllimport) PFNGLDELETEQUERIESPROC __glewDeleteQueries;
extern __declspec(dllimport) PFNGLENDQUERYPROC __glewEndQuery;
extern __declspec(dllimport) PFNGLGENBUFFERSPROC __glewGenBuffers;
extern __declspec(dllimport) PFNGLGENQUERIESPROC __glewGenQueries;
extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERIVPROC __glewGetBufferParameteriv;
extern __declspec(dllimport) PFNGLGETBUFFERPOINTERVPROC __glewGetBufferPointerv;
extern __declspec(dllimport) PFNGLGETBUFFERSUBDATAPROC __glewGetBufferSubData;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTIVPROC __glewGetQueryObjectiv;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUIVPROC __glewGetQueryObjectuiv;
extern __declspec(dllimport) PFNGLGETQUERYIVPROC __glewGetQueryiv;
extern __declspec(dllimport) PFNGLISBUFFERPROC __glewIsBuffer;
extern __declspec(dllimport) PFNGLISQUERYPROC __glewIsQuery;
extern __declspec(dllimport) PFNGLMAPBUFFERPROC __glewMapBuffer;
extern __declspec(dllimport) PFNGLUNMAPBUFFERPROC __glewUnmapBuffer;

extern __declspec(dllimport) PFNGLATTACHSHADERPROC __glewAttachShader;
extern __declspec(dllimport) PFNGLBINDATTRIBLOCATIONPROC __glewBindAttribLocation;
extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEPROC __glewBlendEquationSeparate;
extern __declspec(dllimport) PFNGLCOMPILESHADERPROC __glewCompileShader;
extern __declspec(dllimport) PFNGLCREATEPROGRAMPROC __glewCreateProgram;
extern __declspec(dllimport) PFNGLCREATESHADERPROC __glewCreateShader;
extern __declspec(dllimport) PFNGLDELETEPROGRAMPROC __glewDeleteProgram;
extern __declspec(dllimport) PFNGLDELETESHADERPROC __glewDeleteShader;
extern __declspec(dllimport) PFNGLDETACHSHADERPROC __glewDetachShader;
extern __declspec(dllimport) PFNGLDISABLEVERTEXATTRIBARRAYPROC __glewDisableVertexAttribArray;
extern __declspec(dllimport) PFNGLDRAWBUFFERSPROC __glewDrawBuffers;
extern __declspec(dllimport) PFNGLENABLEVERTEXATTRIBARRAYPROC __glewEnableVertexAttribArray;
extern __declspec(dllimport) PFNGLGETACTIVEATTRIBPROC __glewGetActiveAttrib;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMPROC __glewGetActiveUniform;
extern __declspec(dllimport) PFNGLGETATTACHEDSHADERSPROC __glewGetAttachedShaders;
extern __declspec(dllimport) PFNGLGETATTRIBLOCATIONPROC __glewGetAttribLocation;
extern __declspec(dllimport) PFNGLGETPROGRAMINFOLOGPROC __glewGetProgramInfoLog;
extern __declspec(dllimport) PFNGLGETPROGRAMIVPROC __glewGetProgramiv;
extern __declspec(dllimport) PFNGLGETSHADERINFOLOGPROC __glewGetShaderInfoLog;
extern __declspec(dllimport) PFNGLGETSHADERSOURCEPROC __glewGetShaderSource;
extern __declspec(dllimport) PFNGLGETSHADERIVPROC __glewGetShaderiv;
extern __declspec(dllimport) PFNGLGETUNIFORMLOCATIONPROC __glewGetUniformLocation;
extern __declspec(dllimport) PFNGLGETUNIFORMFVPROC __glewGetUniformfv;
extern __declspec(dllimport) PFNGLGETUNIFORMIVPROC __glewGetUniformiv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBPOINTERVPROC __glewGetVertexAttribPointerv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBDVPROC __glewGetVertexAttribdv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBFVPROC __glewGetVertexAttribfv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIVPROC __glewGetVertexAttribiv;
extern __declspec(dllimport) PFNGLISPROGRAMPROC __glewIsProgram;
extern __declspec(dllimport) PFNGLISSHADERPROC __glewIsShader;
extern __declspec(dllimport) PFNGLLINKPROGRAMPROC __glewLinkProgram;
extern __declspec(dllimport) PFNGLSHADERSOURCEPROC __glewShaderSource;
extern __declspec(dllimport) PFNGLSTENCILFUNCSEPARATEPROC __glewStencilFuncSeparate;
extern __declspec(dllimport) PFNGLSTENCILMASKSEPARATEPROC __glewStencilMaskSeparate;
extern __declspec(dllimport) PFNGLSTENCILOPSEPARATEPROC __glewStencilOpSeparate;
extern __declspec(dllimport) PFNGLUNIFORM1FPROC __glewUniform1f;
extern __declspec(dllimport) PFNGLUNIFORM1FVPROC __glewUniform1fv;
extern __declspec(dllimport) PFNGLUNIFORM1IPROC __glewUniform1i;
extern __declspec(dllimport) PFNGLUNIFORM1IVPROC __glewUniform1iv;
extern __declspec(dllimport) PFNGLUNIFORM2FPROC __glewUniform2f;
extern __declspec(dllimport) PFNGLUNIFORM2FVPROC __glewUniform2fv;
extern __declspec(dllimport) PFNGLUNIFORM2IPROC __glewUniform2i;
extern __declspec(dllimport) PFNGLUNIFORM2IVPROC __glewUniform2iv;
extern __declspec(dllimport) PFNGLUNIFORM3FPROC __glewUniform3f;
extern __declspec(dllimport) PFNGLUNIFORM3FVPROC __glewUniform3fv;
extern __declspec(dllimport) PFNGLUNIFORM3IPROC __glewUniform3i;
extern __declspec(dllimport) PFNGLUNIFORM3IVPROC __glewUniform3iv;
extern __declspec(dllimport) PFNGLUNIFORM4FPROC __glewUniform4f;
extern __declspec(dllimport) PFNGLUNIFORM4FVPROC __glewUniform4fv;
extern __declspec(dllimport) PFNGLUNIFORM4IPROC __glewUniform4i;
extern __declspec(dllimport) PFNGLUNIFORM4IVPROC __glewUniform4iv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2FVPROC __glewUniformMatrix2fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3FVPROC __glewUniformMatrix3fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4FVPROC __glewUniformMatrix4fv;
extern __declspec(dllimport) PFNGLUSEPROGRAMPROC __glewUseProgram;
extern __declspec(dllimport) PFNGLVALIDATEPROGRAMPROC __glewValidateProgram;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DPROC __glewVertexAttrib1d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DVPROC __glewVertexAttrib1dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FPROC __glewVertexAttrib1f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FVPROC __glewVertexAttrib1fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SPROC __glewVertexAttrib1s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SVPROC __glewVertexAttrib1sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DPROC __glewVertexAttrib2d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DVPROC __glewVertexAttrib2dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FPROC __glewVertexAttrib2f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FVPROC __glewVertexAttrib2fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SPROC __glewVertexAttrib2s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SVPROC __glewVertexAttrib2sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DPROC __glewVertexAttrib3d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DVPROC __glewVertexAttrib3dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FPROC __glewVertexAttrib3f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FVPROC __glewVertexAttrib3fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SPROC __glewVertexAttrib3s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SVPROC __glewVertexAttrib3sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NBVPROC __glewVertexAttrib4Nbv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NIVPROC __glewVertexAttrib4Niv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NSVPROC __glewVertexAttrib4Nsv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBPROC __glewVertexAttrib4Nub;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBVPROC __glewVertexAttrib4Nubv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUIVPROC __glewVertexAttrib4Nuiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUSVPROC __glewVertexAttrib4Nusv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4BVPROC __glewVertexAttrib4bv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DPROC __glewVertexAttrib4d;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DVPROC __glewVertexAttrib4dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FPROC __glewVertexAttrib4f;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FVPROC __glewVertexAttrib4fv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4IVPROC __glewVertexAttrib4iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SPROC __glewVertexAttrib4s;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SVPROC __glewVertexAttrib4sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBVPROC __glewVertexAttrib4ubv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UIVPROC __glewVertexAttrib4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4USVPROC __glewVertexAttrib4usv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBPOINTERPROC __glewVertexAttribPointer;

extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X3FVPROC __glewUniformMatrix2x3fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X4FVPROC __glewUniformMatrix2x4fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X2FVPROC __glewUniformMatrix3x2fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X4FVPROC __glewUniformMatrix3x4fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X2FVPROC __glewUniformMatrix4x2fv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X3FVPROC __glewUniformMatrix4x3fv;

extern __declspec(dllimport) PFNGLBEGINCONDITIONALRENDERPROC __glewBeginConditionalRender;
extern __declspec(dllimport) PFNGLBEGINTRANSFORMFEEDBACKPROC __glewBeginTransformFeedback;
extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONPROC __glewBindFragDataLocation;
extern __declspec(dllimport) PFNGLCLAMPCOLORPROC __glewClampColor;
extern __declspec(dllimport) PFNGLCLEARBUFFERFIPROC __glewClearBufferfi;
extern __declspec(dllimport) PFNGLCLEARBUFFERFVPROC __glewClearBufferfv;
extern __declspec(dllimport) PFNGLCLEARBUFFERIVPROC __glewClearBufferiv;
extern __declspec(dllimport) PFNGLCLEARBUFFERUIVPROC __glewClearBufferuiv;
extern __declspec(dllimport) PFNGLCOLORMASKIPROC __glewColorMaski;
extern __declspec(dllimport) PFNGLDISABLEIPROC __glewDisablei;
extern __declspec(dllimport) PFNGLENABLEIPROC __glewEnablei;
extern __declspec(dllimport) PFNGLENDCONDITIONALRENDERPROC __glewEndConditionalRender;
extern __declspec(dllimport) PFNGLENDTRANSFORMFEEDBACKPROC __glewEndTransformFeedback;
extern __declspec(dllimport) PFNGLGETBOOLEANI_VPROC __glewGetBooleani_v;
extern __declspec(dllimport) PFNGLGETFRAGDATALOCATIONPROC __glewGetFragDataLocation;
extern __declspec(dllimport) PFNGLGETSTRINGIPROC __glewGetStringi;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIIVPROC __glewGetTexParameterIiv;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIUIVPROC __glewGetTexParameterIuiv;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKVARYINGPROC __glewGetTransformFeedbackVarying;
extern __declspec(dllimport) PFNGLGETUNIFORMUIVPROC __glewGetUniformuiv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIIVPROC __glewGetVertexAttribIiv;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIUIVPROC __glewGetVertexAttribIuiv;
extern __declspec(dllimport) PFNGLISENABLEDIPROC __glewIsEnabledi;
extern __declspec(dllimport) PFNGLTEXPARAMETERIIVPROC __glewTexParameterIiv;
extern __declspec(dllimport) PFNGLTEXPARAMETERIUIVPROC __glewTexParameterIuiv;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKVARYINGSPROC __glewTransformFeedbackVaryings;
extern __declspec(dllimport) PFNGLUNIFORM1UIPROC __glewUniform1ui;
extern __declspec(dllimport) PFNGLUNIFORM1UIVPROC __glewUniform1uiv;
extern __declspec(dllimport) PFNGLUNIFORM2UIPROC __glewUniform2ui;
extern __declspec(dllimport) PFNGLUNIFORM2UIVPROC __glewUniform2uiv;
extern __declspec(dllimport) PFNGLUNIFORM3UIPROC __glewUniform3ui;
extern __declspec(dllimport) PFNGLUNIFORM3UIVPROC __glewUniform3uiv;
extern __declspec(dllimport) PFNGLUNIFORM4UIPROC __glewUniform4ui;
extern __declspec(dllimport) PFNGLUNIFORM4UIVPROC __glewUniform4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IPROC __glewVertexAttribI1i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IVPROC __glewVertexAttribI1iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIPROC __glewVertexAttribI1ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIVPROC __glewVertexAttribI1uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IPROC __glewVertexAttribI2i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IVPROC __glewVertexAttribI2iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIPROC __glewVertexAttribI2ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIVPROC __glewVertexAttribI2uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IPROC __glewVertexAttribI3i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IVPROC __glewVertexAttribI3iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIPROC __glewVertexAttribI3ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIVPROC __glewVertexAttribI3uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4BVPROC __glewVertexAttribI4bv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IPROC __glewVertexAttribI4i;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IVPROC __glewVertexAttribI4iv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4SVPROC __glewVertexAttribI4sv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UBVPROC __glewVertexAttribI4ubv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIPROC __glewVertexAttribI4ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIVPROC __glewVertexAttribI4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4USVPROC __glewVertexAttribI4usv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIPOINTERPROC __glewVertexAttribIPointer;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDPROC __glewDrawArraysInstanced;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDPROC __glewDrawElementsInstanced;
extern __declspec(dllimport) PFNGLPRIMITIVERESTARTINDEXPROC __glewPrimitiveRestartIndex;
extern __declspec(dllimport) PFNGLTEXBUFFERPROC __glewTexBuffer;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREPROC __glewFramebufferTexture;
extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERI64VPROC __glewGetBufferParameteri64v;
extern __declspec(dllimport) PFNGLGETINTEGER64I_VPROC __glewGetInteger64i_v;

extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORPROC __glewVertexAttribDivisor;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEIPROC __glewBlendEquationSeparatei;
extern __declspec(dllimport) PFNGLBLENDEQUATIONIPROC __glewBlendEquationi;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEIPROC __glewBlendFuncSeparatei;
extern __declspec(dllimport) PFNGLBLENDFUNCIPROC __glewBlendFunci;
extern __declspec(dllimport) PFNGLMINSAMPLESHADINGPROC __glewMinSampleShading;

extern __declspec(dllimport) PFNGLTBUFFERMASK3DFXPROC __glewTbufferMask3DFX;

extern __declspec(dllimport) PFNGLDEBUGMESSAGECALLBACKAMDPROC __glewDebugMessageCallbackAMD;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEENABLEAMDPROC __glewDebugMessageEnableAMD;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEINSERTAMDPROC __glewDebugMessageInsertAMD;
extern __declspec(dllimport) PFNGLGETDEBUGMESSAGELOGAMDPROC __glewGetDebugMessageLogAMD;

extern __declspec(dllimport) PFNGLBLENDEQUATIONINDEXEDAMDPROC __glewBlendEquationIndexedAMD;
extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEINDEXEDAMDPROC __glewBlendEquationSeparateIndexedAMD;
extern __declspec(dllimport) PFNGLBLENDFUNCINDEXEDAMDPROC __glewBlendFuncIndexedAMD;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEINDEXEDAMDPROC __glewBlendFuncSeparateIndexedAMD;

extern __declspec(dllimport) PFNGLVERTEXATTRIBPARAMETERIAMDPROC __glewVertexAttribParameteriAMD;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTAMDPROC __glewMultiDrawArraysIndirectAMD;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTAMDPROC __glewMultiDrawElementsIndirectAMD;

extern __declspec(dllimport) PFNGLDELETENAMESAMDPROC __glewDeleteNamesAMD;
extern __declspec(dllimport) PFNGLGENNAMESAMDPROC __glewGenNamesAMD;
extern __declspec(dllimport) PFNGLISNAMEAMDPROC __glewIsNameAMD;

extern __declspec(dllimport) PFNGLQUERYOBJECTPARAMETERUIAMDPROC __glewQueryObjectParameteruiAMD;

extern __declspec(dllimport) PFNGLBEGINPERFMONITORAMDPROC __glewBeginPerfMonitorAMD;
extern __declspec(dllimport) PFNGLDELETEPERFMONITORSAMDPROC __glewDeletePerfMonitorsAMD;
extern __declspec(dllimport) PFNGLENDPERFMONITORAMDPROC __glewEndPerfMonitorAMD;
extern __declspec(dllimport) PFNGLGENPERFMONITORSAMDPROC __glewGenPerfMonitorsAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERDATAAMDPROC __glewGetPerfMonitorCounterDataAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERINFOAMDPROC __glewGetPerfMonitorCounterInfoAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERSTRINGAMDPROC __glewGetPerfMonitorCounterStringAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORCOUNTERSAMDPROC __glewGetPerfMonitorCountersAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORGROUPSTRINGAMDPROC __glewGetPerfMonitorGroupStringAMD;
extern __declspec(dllimport) PFNGLGETPERFMONITORGROUPSAMDPROC __glewGetPerfMonitorGroupsAMD;
extern __declspec(dllimport) PFNGLSELECTPERFMONITORCOUNTERSAMDPROC __glewSelectPerfMonitorCountersAMD;

extern __declspec(dllimport) PFNGLSETMULTISAMPLEFVAMDPROC __glewSetMultisamplefvAMD;

extern __declspec(dllimport) PFNGLTEXSTORAGESPARSEAMDPROC __glewTexStorageSparseAMD;
extern __declspec(dllimport) PFNGLTEXTURESTORAGESPARSEAMDPROC __glewTextureStorageSparseAMD;

extern __declspec(dllimport) PFNGLSTENCILOPVALUEAMDPROC __glewStencilOpValueAMD;

extern __declspec(dllimport) PFNGLTESSELLATIONFACTORAMDPROC __glewTessellationFactorAMD;
extern __declspec(dllimport) PFNGLTESSELLATIONMODEAMDPROC __glewTessellationModeAMD;

extern __declspec(dllimport) PFNGLBLITFRAMEBUFFERANGLEPROC __glewBlitFramebufferANGLE;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEANGLEPROC __glewRenderbufferStorageMultisampleANGLE;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDANGLEPROC __glewDrawArraysInstancedANGLE;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDANGLEPROC __glewDrawElementsInstancedANGLE;
extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORANGLEPROC __glewVertexAttribDivisorANGLE;

extern __declspec(dllimport) PFNGLBEGINQUERYANGLEPROC __glewBeginQueryANGLE;
extern __declspec(dllimport) PFNGLDELETEQUERIESANGLEPROC __glewDeleteQueriesANGLE;
extern __declspec(dllimport) PFNGLENDQUERYANGLEPROC __glewEndQueryANGLE;
extern __declspec(dllimport) PFNGLGENQUERIESANGLEPROC __glewGenQueriesANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTI64VANGLEPROC __glewGetQueryObjecti64vANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTIVANGLEPROC __glewGetQueryObjectivANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUI64VANGLEPROC __glewGetQueryObjectui64vANGLE;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUIVANGLEPROC __glewGetQueryObjectuivANGLE;
extern __declspec(dllimport) PFNGLGETQUERYIVANGLEPROC __glewGetQueryivANGLE;
extern __declspec(dllimport) PFNGLISQUERYANGLEPROC __glewIsQueryANGLE;
extern __declspec(dllimport) PFNGLQUERYCOUNTERANGLEPROC __glewQueryCounterANGLE;

extern __declspec(dllimport) PFNGLGETTRANSLATEDSHADERSOURCEANGLEPROC __glewGetTranslatedShaderSourceANGLE;

extern __declspec(dllimport) PFNGLDRAWELEMENTARRAYAPPLEPROC __glewDrawElementArrayAPPLE;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTARRAYAPPLEPROC __glewDrawRangeElementArrayAPPLE;
extern __declspec(dllimport) PFNGLELEMENTPOINTERAPPLEPROC __glewElementPointerAPPLE;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTARRAYAPPLEPROC __glewMultiDrawElementArrayAPPLE;
extern __declspec(dllimport) PFNGLMULTIDRAWRANGEELEMENTARRAYAPPLEPROC __glewMultiDrawRangeElementArrayAPPLE;

extern __declspec(dllimport) PFNGLDELETEFENCESAPPLEPROC __glewDeleteFencesAPPLE;
extern __declspec(dllimport) PFNGLFINISHFENCEAPPLEPROC __glewFinishFenceAPPLE;
extern __declspec(dllimport) PFNGLFINISHOBJECTAPPLEPROC __glewFinishObjectAPPLE;
extern __declspec(dllimport) PFNGLGENFENCESAPPLEPROC __glewGenFencesAPPLE;
extern __declspec(dllimport) PFNGLISFENCEAPPLEPROC __glewIsFenceAPPLE;
extern __declspec(dllimport) PFNGLSETFENCEAPPLEPROC __glewSetFenceAPPLE;
extern __declspec(dllimport) PFNGLTESTFENCEAPPLEPROC __glewTestFenceAPPLE;
extern __declspec(dllimport) PFNGLTESTOBJECTAPPLEPROC __glewTestObjectAPPLE;

extern __declspec(dllimport) PFNGLBUFFERPARAMETERIAPPLEPROC __glewBufferParameteriAPPLE;
extern __declspec(dllimport) PFNGLFLUSHMAPPEDBUFFERRANGEAPPLEPROC __glewFlushMappedBufferRangeAPPLE;

extern __declspec(dllimport) PFNGLGETOBJECTPARAMETERIVAPPLEPROC __glewGetObjectParameterivAPPLE;
extern __declspec(dllimport) PFNGLOBJECTPURGEABLEAPPLEPROC __glewObjectPurgeableAPPLE;
extern __declspec(dllimport) PFNGLOBJECTUNPURGEABLEAPPLEPROC __glewObjectUnpurgeableAPPLE;

extern __declspec(dllimport) PFNGLGETTEXPARAMETERPOINTERVAPPLEPROC __glewGetTexParameterPointervAPPLE;
extern __declspec(dllimport) PFNGLTEXTURERANGEAPPLEPROC __glewTextureRangeAPPLE;

extern __declspec(dllimport) PFNGLBINDVERTEXARRAYAPPLEPROC __glewBindVertexArrayAPPLE;
extern __declspec(dllimport) PFNGLDELETEVERTEXARRAYSAPPLEPROC __glewDeleteVertexArraysAPPLE;
extern __declspec(dllimport) PFNGLGENVERTEXARRAYSAPPLEPROC __glewGenVertexArraysAPPLE;
extern __declspec(dllimport) PFNGLISVERTEXARRAYAPPLEPROC __glewIsVertexArrayAPPLE;

extern __declspec(dllimport) PFNGLFLUSHVERTEXARRAYRANGEAPPLEPROC __glewFlushVertexArrayRangeAPPLE;
extern __declspec(dllimport) PFNGLVERTEXARRAYPARAMETERIAPPLEPROC __glewVertexArrayParameteriAPPLE;
extern __declspec(dllimport) PFNGLVERTEXARRAYRANGEAPPLEPROC __glewVertexArrayRangeAPPLE;

extern __declspec(dllimport) PFNGLDISABLEVERTEXATTRIBAPPLEPROC __glewDisableVertexAttribAPPLE;
extern __declspec(dllimport) PFNGLENABLEVERTEXATTRIBAPPLEPROC __glewEnableVertexAttribAPPLE;
extern __declspec(dllimport) PFNGLISVERTEXATTRIBENABLEDAPPLEPROC __glewIsVertexAttribEnabledAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB1DAPPLEPROC __glewMapVertexAttrib1dAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB1FAPPLEPROC __glewMapVertexAttrib1fAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB2DAPPLEPROC __glewMapVertexAttrib2dAPPLE;
extern __declspec(dllimport) PFNGLMAPVERTEXATTRIB2FAPPLEPROC __glewMapVertexAttrib2fAPPLE;

extern __declspec(dllimport) PFNGLCLEARDEPTHFPROC __glewClearDepthf;
extern __declspec(dllimport) PFNGLDEPTHRANGEFPROC __glewDepthRangef;
extern __declspec(dllimport) PFNGLGETSHADERPRECISIONFORMATPROC __glewGetShaderPrecisionFormat;
extern __declspec(dllimport) PFNGLRELEASESHADERCOMPILERPROC __glewReleaseShaderCompiler;
extern __declspec(dllimport) PFNGLSHADERBINARYPROC __glewShaderBinary;

extern __declspec(dllimport) PFNGLMEMORYBARRIERBYREGIONPROC __glewMemoryBarrierByRegion;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC __glewDrawArraysInstancedBaseInstance;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC __glewDrawElementsInstancedBaseInstance;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC __glewDrawElementsInstancedBaseVertexBaseInstance;

extern __declspec(dllimport) PFNGLGETIMAGEHANDLEARBPROC __glewGetImageHandleARB;
extern __declspec(dllimport) PFNGLGETTEXTUREHANDLEARBPROC __glewGetTextureHandleARB;
extern __declspec(dllimport) PFNGLGETTEXTURESAMPLERHANDLEARBPROC __glewGetTextureSamplerHandleARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLUI64VARBPROC __glewGetVertexAttribLui64vARB;
extern __declspec(dllimport) PFNGLISIMAGEHANDLERESIDENTARBPROC __glewIsImageHandleResidentARB;
extern __declspec(dllimport) PFNGLISTEXTUREHANDLERESIDENTARBPROC __glewIsTextureHandleResidentARB;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLENONRESIDENTARBPROC __glewMakeImageHandleNonResidentARB;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLERESIDENTARBPROC __glewMakeImageHandleResidentARB;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLENONRESIDENTARBPROC __glewMakeTextureHandleNonResidentARB;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLERESIDENTARBPROC __glewMakeTextureHandleResidentARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64ARBPROC __glewProgramUniformHandleui64ARB;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64VARBPROC __glewProgramUniformHandleui64vARB;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64ARBPROC __glewUniformHandleui64ARB;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64VARBPROC __glewUniformHandleui64vARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64ARBPROC __glewVertexAttribL1ui64ARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64VARBPROC __glewVertexAttribL1ui64vARB;

extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONINDEXEDPROC __glewBindFragDataLocationIndexed;
extern __declspec(dllimport) PFNGLGETFRAGDATAINDEXPROC __glewGetFragDataIndex;

extern __declspec(dllimport) PFNGLBUFFERSTORAGEPROC __glewBufferStorage;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSTORAGEEXTPROC __glewNamedBufferStorageEXT;

extern __declspec(dllimport) PFNGLCREATESYNCFROMCLEVENTARBPROC __glewCreateSyncFromCLeventARB;

extern __declspec(dllimport) PFNGLCLEARBUFFERDATAPROC __glewClearBufferData;
extern __declspec(dllimport) PFNGLCLEARBUFFERSUBDATAPROC __glewClearBufferSubData;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERDATAEXTPROC __glewClearNamedBufferDataEXT;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERSUBDATAEXTPROC __glewClearNamedBufferSubDataEXT;

extern __declspec(dllimport) PFNGLCLEARTEXIMAGEPROC __glewClearTexImage;
extern __declspec(dllimport) PFNGLCLEARTEXSUBIMAGEPROC __glewClearTexSubImage;

extern __declspec(dllimport) PFNGLCLIPCONTROLPROC __glewClipControl;

extern __declspec(dllimport) PFNGLCLAMPCOLORARBPROC __glewClampColorARB;

extern __declspec(dllimport) PFNGLDISPATCHCOMPUTEPROC __glewDispatchCompute;
extern __declspec(dllimport) PFNGLDISPATCHCOMPUTEINDIRECTPROC __glewDispatchComputeIndirect;

extern __declspec(dllimport) PFNGLDISPATCHCOMPUTEGROUPSIZEARBPROC __glewDispatchComputeGroupSizeARB;

extern __declspec(dllimport) PFNGLCOPYBUFFERSUBDATAPROC __glewCopyBufferSubData;

extern __declspec(dllimport) PFNGLCOPYIMAGESUBDATAPROC __glewCopyImageSubData;

extern __declspec(dllimport) PFNGLDEBUGMESSAGECALLBACKARBPROC __glewDebugMessageCallbackARB;
extern __declspec(dllimport) PFNGLDEBUGMESSAGECONTROLARBPROC __glewDebugMessageControlARB;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEINSERTARBPROC __glewDebugMessageInsertARB;
extern __declspec(dllimport) PFNGLGETDEBUGMESSAGELOGARBPROC __glewGetDebugMessageLogARB;

extern __declspec(dllimport) PFNGLBINDTEXTUREUNITPROC __glewBindTextureUnit;
extern __declspec(dllimport) PFNGLBLITNAMEDFRAMEBUFFERPROC __glewBlitNamedFramebuffer;
extern __declspec(dllimport) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC __glewCheckNamedFramebufferStatus;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERDATAPROC __glewClearNamedBufferData;
extern __declspec(dllimport) PFNGLCLEARNAMEDBUFFERSUBDATAPROC __glewClearNamedBufferSubData;
extern __declspec(dllimport) PFNGLCLEARNAMEDFRAMEBUFFERFIPROC __glewClearNamedFramebufferfi;
extern __declspec(dllimport) PFNGLCLEARNAMEDFRAMEBUFFERFVPROC __glewClearNamedFramebufferfv;
extern __declspec(dllimport) PFNGLCLEARNAMEDFRAMEBUFFERIVPROC __glewClearNamedFramebufferiv;
extern __declspec(dllimport) PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC __glewClearNamedFramebufferuiv;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC __glewCompressedTextureSubImage1D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC __glewCompressedTextureSubImage2D;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC __glewCompressedTextureSubImage3D;
extern __declspec(dllimport) PFNGLCOPYNAMEDBUFFERSUBDATAPROC __glewCopyNamedBufferSubData;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE1DPROC __glewCopyTextureSubImage1D;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE2DPROC __glewCopyTextureSubImage2D;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE3DPROC __glewCopyTextureSubImage3D;
extern __declspec(dllimport) PFNGLCREATEBUFFERSPROC __glewCreateBuffers;
extern __declspec(dllimport) PFNGLCREATEFRAMEBUFFERSPROC __glewCreateFramebuffers;
extern __declspec(dllimport) PFNGLCREATEPROGRAMPIPELINESPROC __glewCreateProgramPipelines;
extern __declspec(dllimport) PFNGLCREATEQUERIESPROC __glewCreateQueries;
extern __declspec(dllimport) PFNGLCREATERENDERBUFFERSPROC __glewCreateRenderbuffers;
extern __declspec(dllimport) PFNGLCREATESAMPLERSPROC __glewCreateSamplers;
extern __declspec(dllimport) PFNGLCREATETEXTURESPROC __glewCreateTextures;
extern __declspec(dllimport) PFNGLCREATETRANSFORMFEEDBACKSPROC __glewCreateTransformFeedbacks;
extern __declspec(dllimport) PFNGLCREATEVERTEXARRAYSPROC __glewCreateVertexArrays;
extern __declspec(dllimport) PFNGLDISABLEVERTEXARRAYATTRIBPROC __glewDisableVertexArrayAttrib;
extern __declspec(dllimport) PFNGLENABLEVERTEXARRAYATTRIBPROC __glewEnableVertexArrayAttrib;
extern __declspec(dllimport) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC __glewFlushMappedNamedBufferRange;
extern __declspec(dllimport) PFNGLGENERATETEXTUREMIPMAPPROC __glewGenerateTextureMipmap;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC __glewGetCompressedTextureImage;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERI64VPROC __glewGetNamedBufferParameteri64v;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERIVPROC __glewGetNamedBufferParameteriv;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPOINTERVPROC __glewGetNamedBufferPointerv;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERSUBDATAPROC __glewGetNamedBufferSubData;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetNamedFramebufferAttachmentParameteriv;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC __glewGetNamedFramebufferParameteriv;
extern __declspec(dllimport) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC __glewGetNamedRenderbufferParameteriv;
extern __declspec(dllimport) PFNGLGETTEXTUREIMAGEPROC __glewGetTextureImage;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERFVPROC __glewGetTextureLevelParameterfv;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERIVPROC __glewGetTextureLevelParameteriv;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIIVPROC __glewGetTextureParameterIiv;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIUIVPROC __glewGetTextureParameterIuiv;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERFVPROC __glewGetTextureParameterfv;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIVPROC __glewGetTextureParameteriv;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKI64_VPROC __glewGetTransformFeedbacki64_v;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKI_VPROC __glewGetTransformFeedbacki_v;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKIVPROC __glewGetTransformFeedbackiv;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINDEXED64IVPROC __glewGetVertexArrayIndexed64iv;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINDEXEDIVPROC __glewGetVertexArrayIndexediv;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYIVPROC __glewGetVertexArrayiv;
extern __declspec(dllimport) PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC __glewInvalidateNamedFramebufferData;
extern __declspec(dllimport) PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC __glewInvalidateNamedFramebufferSubData;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFERPROC __glewMapNamedBuffer;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFERRANGEPROC __glewMapNamedBufferRange;
extern __declspec(dllimport) PFNGLNAMEDBUFFERDATAPROC __glewNamedBufferData;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSTORAGEPROC __glewNamedBufferStorage;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSUBDATAPROC __glewNamedBufferSubData;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC __glewNamedFramebufferDrawBuffer;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC __glewNamedFramebufferDrawBuffers;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC __glewNamedFramebufferParameteri;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC __glewNamedFramebufferReadBuffer;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC __glewNamedFramebufferRenderbuffer;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTUREPROC __glewNamedFramebufferTexture;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC __glewNamedFramebufferTextureLayer;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEPROC __glewNamedRenderbufferStorage;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewNamedRenderbufferStorageMultisample;
extern __declspec(dllimport) PFNGLTEXTUREBUFFERPROC __glewTextureBuffer;
extern __declspec(dllimport) PFNGLTEXTUREBUFFERRANGEPROC __glewTextureBufferRange;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIIVPROC __glewTextureParameterIiv;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIUIVPROC __glewTextureParameterIuiv;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFPROC __glewTextureParameterf;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFVPROC __glewTextureParameterfv;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIPROC __glewTextureParameteri;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIVPROC __glewTextureParameteriv;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE1DPROC __glewTextureStorage1D;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DPROC __glewTextureStorage2D;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC __glewTextureStorage2DMultisample;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DPROC __glewTextureStorage3D;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC __glewTextureStorage3DMultisample;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE1DPROC __glewTextureSubImage1D;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE2DPROC __glewTextureSubImage2D;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE3DPROC __glewTextureSubImage3D;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC __glewTransformFeedbackBufferBase;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC __glewTransformFeedbackBufferRange;
extern __declspec(dllimport) PFNGLUNMAPNAMEDBUFFERPROC __glewUnmapNamedBuffer;
extern __declspec(dllimport) PFNGLVERTEXARRAYATTRIBBINDINGPROC __glewVertexArrayAttribBinding;
extern __declspec(dllimport) PFNGLVERTEXARRAYATTRIBFORMATPROC __glewVertexArrayAttribFormat;
extern __declspec(dllimport) PFNGLVERTEXARRAYATTRIBIFORMATPROC __glewVertexArrayAttribIFormat;
extern __declspec(dllimport) PFNGLVERTEXARRAYATTRIBLFORMATPROC __glewVertexArrayAttribLFormat;
extern __declspec(dllimport) PFNGLVERTEXARRAYBINDINGDIVISORPROC __glewVertexArrayBindingDivisor;
extern __declspec(dllimport) PFNGLVERTEXARRAYELEMENTBUFFERPROC __glewVertexArrayElementBuffer;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXBUFFERPROC __glewVertexArrayVertexBuffer;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXBUFFERSPROC __glewVertexArrayVertexBuffers;

extern __declspec(dllimport) PFNGLDRAWBUFFERSARBPROC __glewDrawBuffersARB;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEIARBPROC __glewBlendEquationSeparateiARB;
extern __declspec(dllimport) PFNGLBLENDEQUATIONIARBPROC __glewBlendEquationiARB;
extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEIARBPROC __glewBlendFuncSeparateiARB;
extern __declspec(dllimport) PFNGLBLENDFUNCIARBPROC __glewBlendFunciARB;

extern __declspec(dllimport) PFNGLDRAWELEMENTSBASEVERTEXPROC __glewDrawElementsBaseVertex;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC __glewDrawElementsInstancedBaseVertex;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC __glewDrawRangeElementsBaseVertex;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC __glewMultiDrawElementsBaseVertex;

extern __declspec(dllimport) PFNGLDRAWARRAYSINDIRECTPROC __glewDrawArraysIndirect;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINDIRECTPROC __glewDrawElementsIndirect;

extern __declspec(dllimport) PFNGLFRAMEBUFFERPARAMETERIPROC __glewFramebufferParameteri;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERPARAMETERIVPROC __glewGetFramebufferParameteriv;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVEXTPROC __glewGetNamedFramebufferParameterivEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERPARAMETERIEXTPROC __glewNamedFramebufferParameteriEXT;

extern __declspec(dllimport) PFNGLBINDFRAMEBUFFERPROC __glewBindFramebuffer;
extern __declspec(dllimport) PFNGLBINDRENDERBUFFERPROC __glewBindRenderbuffer;
extern __declspec(dllimport) PFNGLBLITFRAMEBUFFERPROC __glewBlitFramebuffer;
extern __declspec(dllimport) PFNGLCHECKFRAMEBUFFERSTATUSPROC __glewCheckFramebufferStatus;
extern __declspec(dllimport) PFNGLDELETEFRAMEBUFFERSPROC __glewDeleteFramebuffers;
extern __declspec(dllimport) PFNGLDELETERENDERBUFFERSPROC __glewDeleteRenderbuffers;
extern __declspec(dllimport) PFNGLFRAMEBUFFERRENDERBUFFERPROC __glewFramebufferRenderbuffer;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE1DPROC __glewFramebufferTexture1D;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE2DPROC __glewFramebufferTexture2D;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE3DPROC __glewFramebufferTexture3D;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYERPROC __glewFramebufferTextureLayer;
extern __declspec(dllimport) PFNGLGENFRAMEBUFFERSPROC __glewGenFramebuffers;
extern __declspec(dllimport) PFNGLGENRENDERBUFFERSPROC __glewGenRenderbuffers;
extern __declspec(dllimport) PFNGLGENERATEMIPMAPPROC __glewGenerateMipmap;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC __glewGetFramebufferAttachmentParameteriv;
extern __declspec(dllimport) PFNGLGETRENDERBUFFERPARAMETERIVPROC __glewGetRenderbufferParameteriv;
extern __declspec(dllimport) PFNGLISFRAMEBUFFERPROC __glewIsFramebuffer;
extern __declspec(dllimport) PFNGLISRENDERBUFFERPROC __glewIsRenderbuffer;
extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEPROC __glewRenderbufferStorage;
extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC __glewRenderbufferStorageMultisample;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREARBPROC __glewFramebufferTextureARB;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREFACEARBPROC __glewFramebufferTextureFaceARB;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYERARBPROC __glewFramebufferTextureLayerARB;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERIARBPROC __glewProgramParameteriARB;

extern __declspec(dllimport) PFNGLGETPROGRAMBINARYPROC __glewGetProgramBinary;
extern __declspec(dllimport) PFNGLPROGRAMBINARYPROC __glewProgramBinary;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERIPROC __glewProgramParameteri;

extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC __glewGetCompressedTextureSubImage;
extern __declspec(dllimport) PFNGLGETTEXTURESUBIMAGEPROC __glewGetTextureSubImage;

extern __declspec(dllimport) PFNGLGETUNIFORMDVPROC __glewGetUniformdv;
extern __declspec(dllimport) PFNGLUNIFORM1DPROC __glewUniform1d;
extern __declspec(dllimport) PFNGLUNIFORM1DVPROC __glewUniform1dv;
extern __declspec(dllimport) PFNGLUNIFORM2DPROC __glewUniform2d;
extern __declspec(dllimport) PFNGLUNIFORM2DVPROC __glewUniform2dv;
extern __declspec(dllimport) PFNGLUNIFORM3DPROC __glewUniform3d;
extern __declspec(dllimport) PFNGLUNIFORM3DVPROC __glewUniform3dv;
extern __declspec(dllimport) PFNGLUNIFORM4DPROC __glewUniform4d;
extern __declspec(dllimport) PFNGLUNIFORM4DVPROC __glewUniform4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2DVPROC __glewUniformMatrix2dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X3DVPROC __glewUniformMatrix2x3dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2X4DVPROC __glewUniformMatrix2x4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3DVPROC __glewUniformMatrix3dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X2DVPROC __glewUniformMatrix3x2dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3X4DVPROC __glewUniformMatrix3x4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4DVPROC __glewUniformMatrix4dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X2DVPROC __glewUniformMatrix4x2dv;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4X3DVPROC __glewUniformMatrix4x3dv;

extern __declspec(dllimport) PFNGLCOLORSUBTABLEPROC __glewColorSubTable;
extern __declspec(dllimport) PFNGLCOLORTABLEPROC __glewColorTable;
extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERFVPROC __glewColorTableParameterfv;
extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERIVPROC __glewColorTableParameteriv;
extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER1DPROC __glewConvolutionFilter1D;
extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER2DPROC __glewConvolutionFilter2D;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFPROC __glewConvolutionParameterf;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFVPROC __glewConvolutionParameterfv;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIPROC __glewConvolutionParameteri;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIVPROC __glewConvolutionParameteriv;
extern __declspec(dllimport) PFNGLCOPYCOLORSUBTABLEPROC __glewCopyColorSubTable;
extern __declspec(dllimport) PFNGLCOPYCOLORTABLEPROC __glewCopyColorTable;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER1DPROC __glewCopyConvolutionFilter1D;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER2DPROC __glewCopyConvolutionFilter2D;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPROC __glewGetColorTable;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERFVPROC __glewGetColorTableParameterfv;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERIVPROC __glewGetColorTableParameteriv;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONFILTERPROC __glewGetConvolutionFilter;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERFVPROC __glewGetConvolutionParameterfv;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERIVPROC __glewGetConvolutionParameteriv;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPROC __glewGetHistogram;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERFVPROC __glewGetHistogramParameterfv;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERIVPROC __glewGetHistogramParameteriv;
extern __declspec(dllimport) PFNGLGETMINMAXPROC __glewGetMinmax;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERFVPROC __glewGetMinmaxParameterfv;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERIVPROC __glewGetMinmaxParameteriv;
extern __declspec(dllimport) PFNGLGETSEPARABLEFILTERPROC __glewGetSeparableFilter;
extern __declspec(dllimport) PFNGLHISTOGRAMPROC __glewHistogram;
extern __declspec(dllimport) PFNGLMINMAXPROC __glewMinmax;
extern __declspec(dllimport) PFNGLRESETHISTOGRAMPROC __glewResetHistogram;
extern __declspec(dllimport) PFNGLRESETMINMAXPROC __glewResetMinmax;
extern __declspec(dllimport) PFNGLSEPARABLEFILTER2DPROC __glewSeparableFilter2D;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTCOUNTARBPROC __glewMultiDrawArraysIndirectCountARB;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTARBPROC __glewMultiDrawElementsIndirectCountARB;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDARBPROC __glewDrawArraysInstancedARB;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDARBPROC __glewDrawElementsInstancedARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBDIVISORARBPROC __glewVertexAttribDivisorARB;

extern __declspec(dllimport) PFNGLGETINTERNALFORMATIVPROC __glewGetInternalformativ;

extern __declspec(dllimport) PFNGLGETINTERNALFORMATI64VPROC __glewGetInternalformati64v;

extern __declspec(dllimport) PFNGLINVALIDATEBUFFERDATAPROC __glewInvalidateBufferData;
extern __declspec(dllimport) PFNGLINVALIDATEBUFFERSUBDATAPROC __glewInvalidateBufferSubData;
extern __declspec(dllimport) PFNGLINVALIDATEFRAMEBUFFERPROC __glewInvalidateFramebuffer;
extern __declspec(dllimport) PFNGLINVALIDATESUBFRAMEBUFFERPROC __glewInvalidateSubFramebuffer;
extern __declspec(dllimport) PFNGLINVALIDATETEXIMAGEPROC __glewInvalidateTexImage;
extern __declspec(dllimport) PFNGLINVALIDATETEXSUBIMAGEPROC __glewInvalidateTexSubImage;

extern __declspec(dllimport) PFNGLFLUSHMAPPEDBUFFERRANGEPROC __glewFlushMappedBufferRange;
extern __declspec(dllimport) PFNGLMAPBUFFERRANGEPROC __glewMapBufferRange;

extern __declspec(dllimport) PFNGLCURRENTPALETTEMATRIXARBPROC __glewCurrentPaletteMatrixARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXPOINTERARBPROC __glewMatrixIndexPointerARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXUBVARBPROC __glewMatrixIndexubvARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXUIVARBPROC __glewMatrixIndexuivARB;
extern __declspec(dllimport) PFNGLMATRIXINDEXUSVARBPROC __glewMatrixIndexusvARB;

extern __declspec(dllimport) PFNGLBINDBUFFERSBASEPROC __glewBindBuffersBase;
extern __declspec(dllimport) PFNGLBINDBUFFERSRANGEPROC __glewBindBuffersRange;
extern __declspec(dllimport) PFNGLBINDIMAGETEXTURESPROC __glewBindImageTextures;
extern __declspec(dllimport) PFNGLBINDSAMPLERSPROC __glewBindSamplers;
extern __declspec(dllimport) PFNGLBINDTEXTURESPROC __glewBindTextures;
extern __declspec(dllimport) PFNGLBINDVERTEXBUFFERSPROC __glewBindVertexBuffers;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTPROC __glewMultiDrawArraysIndirect;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTPROC __glewMultiDrawElementsIndirect;

extern __declspec(dllimport) PFNGLSAMPLECOVERAGEARBPROC __glewSampleCoverageARB;

extern __declspec(dllimport) PFNGLACTIVETEXTUREARBPROC __glewActiveTextureARB;
extern __declspec(dllimport) PFNGLCLIENTACTIVETEXTUREARBPROC __glewClientActiveTextureARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DARBPROC __glewMultiTexCoord1dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1DVARBPROC __glewMultiTexCoord1dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FARBPROC __glewMultiTexCoord1fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1FVARBPROC __glewMultiTexCoord1fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IARBPROC __glewMultiTexCoord1iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1IVARBPROC __glewMultiTexCoord1ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SARBPROC __glewMultiTexCoord1sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1SVARBPROC __glewMultiTexCoord1svARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DARBPROC __glewMultiTexCoord2dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2DVARBPROC __glewMultiTexCoord2dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FARBPROC __glewMultiTexCoord2fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2FVARBPROC __glewMultiTexCoord2fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IARBPROC __glewMultiTexCoord2iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2IVARBPROC __glewMultiTexCoord2ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SARBPROC __glewMultiTexCoord2sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2SVARBPROC __glewMultiTexCoord2svARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DARBPROC __glewMultiTexCoord3dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3DVARBPROC __glewMultiTexCoord3dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FARBPROC __glewMultiTexCoord3fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3FVARBPROC __glewMultiTexCoord3fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IARBPROC __glewMultiTexCoord3iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3IVARBPROC __glewMultiTexCoord3ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SARBPROC __glewMultiTexCoord3sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3SVARBPROC __glewMultiTexCoord3svARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DARBPROC __glewMultiTexCoord4dARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4DVARBPROC __glewMultiTexCoord4dvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FARBPROC __glewMultiTexCoord4fARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4FVARBPROC __glewMultiTexCoord4fvARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IARBPROC __glewMultiTexCoord4iARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4IVARBPROC __glewMultiTexCoord4ivARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SARBPROC __glewMultiTexCoord4sARB;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4SVARBPROC __glewMultiTexCoord4svARB;

extern __declspec(dllimport) PFNGLBEGINQUERYARBPROC __glewBeginQueryARB;
extern __declspec(dllimport) PFNGLDELETEQUERIESARBPROC __glewDeleteQueriesARB;
extern __declspec(dllimport) PFNGLENDQUERYARBPROC __glewEndQueryARB;
extern __declspec(dllimport) PFNGLGENQUERIESARBPROC __glewGenQueriesARB;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTIVARBPROC __glewGetQueryObjectivARB;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUIVARBPROC __glewGetQueryObjectuivARB;
extern __declspec(dllimport) PFNGLGETQUERYIVARBPROC __glewGetQueryivARB;
extern __declspec(dllimport) PFNGLISQUERYARBPROC __glewIsQueryARB;

extern __declspec(dllimport) PFNGLPOINTPARAMETERFARBPROC __glewPointParameterfARB;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFVARBPROC __glewPointParameterfvARB;

extern __declspec(dllimport) PFNGLGETPROGRAMINTERFACEIVPROC __glewGetProgramInterfaceiv;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCEINDEXPROC __glewGetProgramResourceIndex;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCELOCATIONPROC __glewGetProgramResourceLocation;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC __glewGetProgramResourceLocationIndex;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCENAMEPROC __glewGetProgramResourceName;
extern __declspec(dllimport) PFNGLGETPROGRAMRESOURCEIVPROC __glewGetProgramResourceiv;

extern __declspec(dllimport) PFNGLPROVOKINGVERTEXPROC __glewProvokingVertex;

extern __declspec(dllimport) PFNGLGETGRAPHICSRESETSTATUSARBPROC __glewGetGraphicsResetStatusARB;
extern __declspec(dllimport) PFNGLGETNCOLORTABLEARBPROC __glewGetnColorTableARB;
extern __declspec(dllimport) PFNGLGETNCOMPRESSEDTEXIMAGEARBPROC __glewGetnCompressedTexImageARB;
extern __declspec(dllimport) PFNGLGETNCONVOLUTIONFILTERARBPROC __glewGetnConvolutionFilterARB;
extern __declspec(dllimport) PFNGLGETNHISTOGRAMARBPROC __glewGetnHistogramARB;
extern __declspec(dllimport) PFNGLGETNMAPDVARBPROC __glewGetnMapdvARB;
extern __declspec(dllimport) PFNGLGETNMAPFVARBPROC __glewGetnMapfvARB;
extern __declspec(dllimport) PFNGLGETNMAPIVARBPROC __glewGetnMapivARB;
extern __declspec(dllimport) PFNGLGETNMINMAXARBPROC __glewGetnMinmaxARB;
extern __declspec(dllimport) PFNGLGETNPIXELMAPFVARBPROC __glewGetnPixelMapfvARB;
extern __declspec(dllimport) PFNGLGETNPIXELMAPUIVARBPROC __glewGetnPixelMapuivARB;
extern __declspec(dllimport) PFNGLGETNPIXELMAPUSVARBPROC __glewGetnPixelMapusvARB;
extern __declspec(dllimport) PFNGLGETNPOLYGONSTIPPLEARBPROC __glewGetnPolygonStippleARB;
extern __declspec(dllimport) PFNGLGETNSEPARABLEFILTERARBPROC __glewGetnSeparableFilterARB;
extern __declspec(dllimport) PFNGLGETNTEXIMAGEARBPROC __glewGetnTexImageARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMDVARBPROC __glewGetnUniformdvARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMFVARBPROC __glewGetnUniformfvARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMIVARBPROC __glewGetnUniformivARB;
extern __declspec(dllimport) PFNGLGETNUNIFORMUIVARBPROC __glewGetnUniformuivARB;
extern __declspec(dllimport) PFNGLREADNPIXELSARBPROC __glewReadnPixelsARB;

extern __declspec(dllimport) PFNGLMINSAMPLESHADINGARBPROC __glewMinSampleShadingARB;

extern __declspec(dllimport) PFNGLBINDSAMPLERPROC __glewBindSampler;
extern __declspec(dllimport) PFNGLDELETESAMPLERSPROC __glewDeleteSamplers;
extern __declspec(dllimport) PFNGLGENSAMPLERSPROC __glewGenSamplers;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERIIVPROC __glewGetSamplerParameterIiv;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERIUIVPROC __glewGetSamplerParameterIuiv;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERFVPROC __glewGetSamplerParameterfv;
extern __declspec(dllimport) PFNGLGETSAMPLERPARAMETERIVPROC __glewGetSamplerParameteriv;
extern __declspec(dllimport) PFNGLISSAMPLERPROC __glewIsSampler;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIIVPROC __glewSamplerParameterIiv;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIUIVPROC __glewSamplerParameterIuiv;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERFPROC __glewSamplerParameterf;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERFVPROC __glewSamplerParameterfv;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIPROC __glewSamplerParameteri;
extern __declspec(dllimport) PFNGLSAMPLERPARAMETERIVPROC __glewSamplerParameteriv;

extern __declspec(dllimport) PFNGLACTIVESHADERPROGRAMPROC __glewActiveShaderProgram;
extern __declspec(dllimport) PFNGLBINDPROGRAMPIPELINEPROC __glewBindProgramPipeline;
extern __declspec(dllimport) PFNGLCREATESHADERPROGRAMVPROC __glewCreateShaderProgramv;
extern __declspec(dllimport) PFNGLDELETEPROGRAMPIPELINESPROC __glewDeleteProgramPipelines;
extern __declspec(dllimport) PFNGLGENPROGRAMPIPELINESPROC __glewGenProgramPipelines;
extern __declspec(dllimport) PFNGLGETPROGRAMPIPELINEINFOLOGPROC __glewGetProgramPipelineInfoLog;
extern __declspec(dllimport) PFNGLGETPROGRAMPIPELINEIVPROC __glewGetProgramPipelineiv;
extern __declspec(dllimport) PFNGLISPROGRAMPIPELINEPROC __glewIsProgramPipeline;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1DPROC __glewProgramUniform1d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1DVPROC __glewProgramUniform1dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FPROC __glewProgramUniform1f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FVPROC __glewProgramUniform1fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IPROC __glewProgramUniform1i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IVPROC __glewProgramUniform1iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIPROC __glewProgramUniform1ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIVPROC __glewProgramUniform1uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2DPROC __glewProgramUniform2d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2DVPROC __glewProgramUniform2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FPROC __glewProgramUniform2f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FVPROC __glewProgramUniform2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IPROC __glewProgramUniform2i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IVPROC __glewProgramUniform2iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIPROC __glewProgramUniform2ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIVPROC __glewProgramUniform2uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3DPROC __glewProgramUniform3d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3DVPROC __glewProgramUniform3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FPROC __glewProgramUniform3f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FVPROC __glewProgramUniform3fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IPROC __glewProgramUniform3i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IVPROC __glewProgramUniform3iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIPROC __glewProgramUniform3ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIVPROC __glewProgramUniform3uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4DPROC __glewProgramUniform4d;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4DVPROC __glewProgramUniform4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FPROC __glewProgramUniform4f;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FVPROC __glewProgramUniform4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IPROC __glewProgramUniform4i;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IVPROC __glewProgramUniform4iv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIPROC __glewProgramUniform4ui;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIVPROC __glewProgramUniform4uiv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2DVPROC __glewProgramUniformMatrix2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2FVPROC __glewProgramUniformMatrix2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC __glewProgramUniformMatrix2x3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC __glewProgramUniformMatrix2x3fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC __glewProgramUniformMatrix2x4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC __glewProgramUniformMatrix2x4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3DVPROC __glewProgramUniformMatrix3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3FVPROC __glewProgramUniformMatrix3fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC __glewProgramUniformMatrix3x2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC __glewProgramUniformMatrix3x2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC __glewProgramUniformMatrix3x4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC __glewProgramUniformMatrix3x4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4DVPROC __glewProgramUniformMatrix4dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4FVPROC __glewProgramUniformMatrix4fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC __glewProgramUniformMatrix4x2dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC __glewProgramUniformMatrix4x2fv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC __glewProgramUniformMatrix4x3dv;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC __glewProgramUniformMatrix4x3fv;
extern __declspec(dllimport) PFNGLUSEPROGRAMSTAGESPROC __glewUseProgramStages;
extern __declspec(dllimport) PFNGLVALIDATEPROGRAMPIPELINEPROC __glewValidateProgramPipeline;

extern __declspec(dllimport) PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC __glewGetActiveAtomicCounterBufferiv;

extern __declspec(dllimport) PFNGLBINDIMAGETEXTUREPROC __glewBindImageTexture;
extern __declspec(dllimport) PFNGLMEMORYBARRIERPROC __glewMemoryBarrier;

extern __declspec(dllimport) PFNGLATTACHOBJECTARBPROC __glewAttachObjectARB;
extern __declspec(dllimport) PFNGLCOMPILESHADERARBPROC __glewCompileShaderARB;
extern __declspec(dllimport) PFNGLCREATEPROGRAMOBJECTARBPROC __glewCreateProgramObjectARB;
extern __declspec(dllimport) PFNGLCREATESHADEROBJECTARBPROC __glewCreateShaderObjectARB;
extern __declspec(dllimport) PFNGLDELETEOBJECTARBPROC __glewDeleteObjectARB;
extern __declspec(dllimport) PFNGLDETACHOBJECTARBPROC __glewDetachObjectARB;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMARBPROC __glewGetActiveUniformARB;
extern __declspec(dllimport) PFNGLGETATTACHEDOBJECTSARBPROC __glewGetAttachedObjectsARB;
extern __declspec(dllimport) PFNGLGETHANDLEARBPROC __glewGetHandleARB;
extern __declspec(dllimport) PFNGLGETINFOLOGARBPROC __glewGetInfoLogARB;
extern __declspec(dllimport) PFNGLGETOBJECTPARAMETERFVARBPROC __glewGetObjectParameterfvARB;
extern __declspec(dllimport) PFNGLGETOBJECTPARAMETERIVARBPROC __glewGetObjectParameterivARB;
extern __declspec(dllimport) PFNGLGETSHADERSOURCEARBPROC __glewGetShaderSourceARB;
extern __declspec(dllimport) PFNGLGETUNIFORMLOCATIONARBPROC __glewGetUniformLocationARB;
extern __declspec(dllimport) PFNGLGETUNIFORMFVARBPROC __glewGetUniformfvARB;
extern __declspec(dllimport) PFNGLGETUNIFORMIVARBPROC __glewGetUniformivARB;
extern __declspec(dllimport) PFNGLLINKPROGRAMARBPROC __glewLinkProgramARB;
extern __declspec(dllimport) PFNGLSHADERSOURCEARBPROC __glewShaderSourceARB;
extern __declspec(dllimport) PFNGLUNIFORM1FARBPROC __glewUniform1fARB;
extern __declspec(dllimport) PFNGLUNIFORM1FVARBPROC __glewUniform1fvARB;
extern __declspec(dllimport) PFNGLUNIFORM1IARBPROC __glewUniform1iARB;
extern __declspec(dllimport) PFNGLUNIFORM1IVARBPROC __glewUniform1ivARB;
extern __declspec(dllimport) PFNGLUNIFORM2FARBPROC __glewUniform2fARB;
extern __declspec(dllimport) PFNGLUNIFORM2FVARBPROC __glewUniform2fvARB;
extern __declspec(dllimport) PFNGLUNIFORM2IARBPROC __glewUniform2iARB;
extern __declspec(dllimport) PFNGLUNIFORM2IVARBPROC __glewUniform2ivARB;
extern __declspec(dllimport) PFNGLUNIFORM3FARBPROC __glewUniform3fARB;
extern __declspec(dllimport) PFNGLUNIFORM3FVARBPROC __glewUniform3fvARB;
extern __declspec(dllimport) PFNGLUNIFORM3IARBPROC __glewUniform3iARB;
extern __declspec(dllimport) PFNGLUNIFORM3IVARBPROC __glewUniform3ivARB;
extern __declspec(dllimport) PFNGLUNIFORM4FARBPROC __glewUniform4fARB;
extern __declspec(dllimport) PFNGLUNIFORM4FVARBPROC __glewUniform4fvARB;
extern __declspec(dllimport) PFNGLUNIFORM4IARBPROC __glewUniform4iARB;
extern __declspec(dllimport) PFNGLUNIFORM4IVARBPROC __glewUniform4ivARB;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX2FVARBPROC __glewUniformMatrix2fvARB;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX3FVARBPROC __glewUniformMatrix3fvARB;
extern __declspec(dllimport) PFNGLUNIFORMMATRIX4FVARBPROC __glewUniformMatrix4fvARB;
extern __declspec(dllimport) PFNGLUSEPROGRAMOBJECTARBPROC __glewUseProgramObjectARB;
extern __declspec(dllimport) PFNGLVALIDATEPROGRAMARBPROC __glewValidateProgramARB;

extern __declspec(dllimport) PFNGLSHADERSTORAGEBLOCKBINDINGPROC __glewShaderStorageBlockBinding;

extern __declspec(dllimport) PFNGLGETACTIVESUBROUTINENAMEPROC __glewGetActiveSubroutineName;
extern __declspec(dllimport) PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC __glewGetActiveSubroutineUniformName;
extern __declspec(dllimport) PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC __glewGetActiveSubroutineUniformiv;
extern __declspec(dllimport) PFNGLGETPROGRAMSTAGEIVPROC __glewGetProgramStageiv;
extern __declspec(dllimport) PFNGLGETSUBROUTINEINDEXPROC __glewGetSubroutineIndex;
extern __declspec(dllimport) PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC __glewGetSubroutineUniformLocation;
extern __declspec(dllimport) PFNGLGETUNIFORMSUBROUTINEUIVPROC __glewGetUniformSubroutineuiv;
extern __declspec(dllimport) PFNGLUNIFORMSUBROUTINESUIVPROC __glewUniformSubroutinesuiv;

extern __declspec(dllimport) PFNGLCOMPILESHADERINCLUDEARBPROC __glewCompileShaderIncludeARB;
extern __declspec(dllimport) PFNGLDELETENAMEDSTRINGARBPROC __glewDeleteNamedStringARB;
extern __declspec(dllimport) PFNGLGETNAMEDSTRINGARBPROC __glewGetNamedStringARB;
extern __declspec(dllimport) PFNGLGETNAMEDSTRINGIVARBPROC __glewGetNamedStringivARB;
extern __declspec(dllimport) PFNGLISNAMEDSTRINGARBPROC __glewIsNamedStringARB;
extern __declspec(dllimport) PFNGLNAMEDSTRINGARBPROC __glewNamedStringARB;

extern __declspec(dllimport) PFNGLBUFFERPAGECOMMITMENTARBPROC __glewBufferPageCommitmentARB;

extern __declspec(dllimport) PFNGLTEXPAGECOMMITMENTARBPROC __glewTexPageCommitmentARB;
extern __declspec(dllimport) PFNGLTEXTUREPAGECOMMITMENTEXTPROC __glewTexturePageCommitmentEXT;

extern __declspec(dllimport) PFNGLCLIENTWAITSYNCPROC __glewClientWaitSync;
extern __declspec(dllimport) PFNGLDELETESYNCPROC __glewDeleteSync;
extern __declspec(dllimport) PFNGLFENCESYNCPROC __glewFenceSync;
extern __declspec(dllimport) PFNGLGETINTEGER64VPROC __glewGetInteger64v;
extern __declspec(dllimport) PFNGLGETSYNCIVPROC __glewGetSynciv;
extern __declspec(dllimport) PFNGLISSYNCPROC __glewIsSync;
extern __declspec(dllimport) PFNGLWAITSYNCPROC __glewWaitSync;

extern __declspec(dllimport) PFNGLPATCHPARAMETERFVPROC __glewPatchParameterfv;
extern __declspec(dllimport) PFNGLPATCHPARAMETERIPROC __glewPatchParameteri;

extern __declspec(dllimport) PFNGLTEXTUREBARRIERPROC __glewTextureBarrier;

extern __declspec(dllimport) PFNGLTEXBUFFERARBPROC __glewTexBufferARB;

extern __declspec(dllimport) PFNGLTEXBUFFERRANGEPROC __glewTexBufferRange;
extern __declspec(dllimport) PFNGLTEXTUREBUFFERRANGEEXTPROC __glewTextureBufferRangeEXT;

extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE1DARBPROC __glewCompressedTexImage1DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE2DARBPROC __glewCompressedTexImage2DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXIMAGE3DARBPROC __glewCompressedTexImage3DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE1DARBPROC __glewCompressedTexSubImage1DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE2DARBPROC __glewCompressedTexSubImage2DARB;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXSUBIMAGE3DARBPROC __glewCompressedTexSubImage3DARB;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXIMAGEARBPROC __glewGetCompressedTexImageARB;

extern __declspec(dllimport) PFNGLGETMULTISAMPLEFVPROC __glewGetMultisamplefv;
extern __declspec(dllimport) PFNGLSAMPLEMASKIPROC __glewSampleMaski;
extern __declspec(dllimport) PFNGLTEXIMAGE2DMULTISAMPLEPROC __glewTexImage2DMultisample;
extern __declspec(dllimport) PFNGLTEXIMAGE3DMULTISAMPLEPROC __glewTexImage3DMultisample;

extern __declspec(dllimport) PFNGLTEXSTORAGE1DPROC __glewTexStorage1D;
extern __declspec(dllimport) PFNGLTEXSTORAGE2DPROC __glewTexStorage2D;
extern __declspec(dllimport) PFNGLTEXSTORAGE3DPROC __glewTexStorage3D;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE1DEXTPROC __glewTextureStorage1DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DEXTPROC __glewTextureStorage2DEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DEXTPROC __glewTextureStorage3DEXT;

extern __declspec(dllimport) PFNGLTEXSTORAGE2DMULTISAMPLEPROC __glewTexStorage2DMultisample;
extern __declspec(dllimport) PFNGLTEXSTORAGE3DMULTISAMPLEPROC __glewTexStorage3DMultisample;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE2DMULTISAMPLEEXTPROC __glewTextureStorage2DMultisampleEXT;
extern __declspec(dllimport) PFNGLTEXTURESTORAGE3DMULTISAMPLEEXTPROC __glewTextureStorage3DMultisampleEXT;

extern __declspec(dllimport) PFNGLTEXTUREVIEWPROC __glewTextureView;

extern __declspec(dllimport) PFNGLGETQUERYOBJECTI64VPROC __glewGetQueryObjecti64v;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUI64VPROC __glewGetQueryObjectui64v;
extern __declspec(dllimport) PFNGLQUERYCOUNTERPROC __glewQueryCounter;

extern __declspec(dllimport) PFNGLBINDTRANSFORMFEEDBACKPROC __glewBindTransformFeedback;
extern __declspec(dllimport) PFNGLDELETETRANSFORMFEEDBACKSPROC __glewDeleteTransformFeedbacks;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKPROC __glewDrawTransformFeedback;
extern __declspec(dllimport) PFNGLGENTRANSFORMFEEDBACKSPROC __glewGenTransformFeedbacks;
extern __declspec(dllimport) PFNGLISTRANSFORMFEEDBACKPROC __glewIsTransformFeedback;
extern __declspec(dllimport) PFNGLPAUSETRANSFORMFEEDBACKPROC __glewPauseTransformFeedback;
extern __declspec(dllimport) PFNGLRESUMETRANSFORMFEEDBACKPROC __glewResumeTransformFeedback;

extern __declspec(dllimport) PFNGLBEGINQUERYINDEXEDPROC __glewBeginQueryIndexed;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC __glewDrawTransformFeedbackStream;
extern __declspec(dllimport) PFNGLENDQUERYINDEXEDPROC __glewEndQueryIndexed;
extern __declspec(dllimport) PFNGLGETQUERYINDEXEDIVPROC __glewGetQueryIndexediv;

extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC __glewDrawTransformFeedbackInstanced;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC __glewDrawTransformFeedbackStreamInstanced;

extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXDARBPROC __glewLoadTransposeMatrixdARB;
extern __declspec(dllimport) PFNGLLOADTRANSPOSEMATRIXFARBPROC __glewLoadTransposeMatrixfARB;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXDARBPROC __glewMultTransposeMatrixdARB;
extern __declspec(dllimport) PFNGLMULTTRANSPOSEMATRIXFARBPROC __glewMultTransposeMatrixfARB;

extern __declspec(dllimport) PFNGLBINDBUFFERBASEPROC __glewBindBufferBase;
extern __declspec(dllimport) PFNGLBINDBUFFERRANGEPROC __glewBindBufferRange;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC __glewGetActiveUniformBlockName;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMBLOCKIVPROC __glewGetActiveUniformBlockiv;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMNAMEPROC __glewGetActiveUniformName;
extern __declspec(dllimport) PFNGLGETACTIVEUNIFORMSIVPROC __glewGetActiveUniformsiv;
extern __declspec(dllimport) PFNGLGETINTEGERI_VPROC __glewGetIntegeri_v;
extern __declspec(dllimport) PFNGLGETUNIFORMBLOCKINDEXPROC __glewGetUniformBlockIndex;
extern __declspec(dllimport) PFNGLGETUNIFORMINDICESPROC __glewGetUniformIndices;
extern __declspec(dllimport) PFNGLUNIFORMBLOCKBINDINGPROC __glewUniformBlockBinding;

extern __declspec(dllimport) PFNGLBINDVERTEXARRAYPROC __glewBindVertexArray;
extern __declspec(dllimport) PFNGLDELETEVERTEXARRAYSPROC __glewDeleteVertexArrays;
extern __declspec(dllimport) PFNGLGENVERTEXARRAYSPROC __glewGenVertexArrays;
extern __declspec(dllimport) PFNGLISVERTEXARRAYPROC __glewIsVertexArray;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLDVPROC __glewGetVertexAttribLdv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DPROC __glewVertexAttribL1d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DVPROC __glewVertexAttribL1dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DPROC __glewVertexAttribL2d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DVPROC __glewVertexAttribL2dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DPROC __glewVertexAttribL3d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DVPROC __glewVertexAttribL3dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DPROC __glewVertexAttribL4d;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DVPROC __glewVertexAttribL4dv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLPOINTERPROC __glewVertexAttribLPointer;

extern __declspec(dllimport) PFNGLBINDVERTEXBUFFERPROC __glewBindVertexBuffer;
extern __declspec(dllimport) PFNGLVERTEXARRAYBINDVERTEXBUFFEREXTPROC __glewVertexArrayBindVertexBufferEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBBINDINGEXTPROC __glewVertexArrayVertexAttribBindingEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBFORMATEXTPROC __glewVertexArrayVertexAttribFormatEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBIFORMATEXTPROC __glewVertexArrayVertexAttribIFormatEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBLFORMATEXTPROC __glewVertexArrayVertexAttribLFormatEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXBINDINGDIVISOREXTPROC __glewVertexArrayVertexBindingDivisorEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBBINDINGPROC __glewVertexAttribBinding;
extern __declspec(dllimport) PFNGLVERTEXATTRIBFORMATPROC __glewVertexAttribFormat;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIFORMATPROC __glewVertexAttribIFormat;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLFORMATPROC __glewVertexAttribLFormat;
extern __declspec(dllimport) PFNGLVERTEXBINDINGDIVISORPROC __glewVertexBindingDivisor;

extern __declspec(dllimport) PFNGLVERTEXBLENDARBPROC __glewVertexBlendARB;
extern __declspec(dllimport) PFNGLWEIGHTPOINTERARBPROC __glewWeightPointerARB;
extern __declspec(dllimport) PFNGLWEIGHTBVARBPROC __glewWeightbvARB;
extern __declspec(dllimport) PFNGLWEIGHTDVARBPROC __glewWeightdvARB;
extern __declspec(dllimport) PFNGLWEIGHTFVARBPROC __glewWeightfvARB;
extern __declspec(dllimport) PFNGLWEIGHTIVARBPROC __glewWeightivARB;
extern __declspec(dllimport) PFNGLWEIGHTSVARBPROC __glewWeightsvARB;
extern __declspec(dllimport) PFNGLWEIGHTUBVARBPROC __glewWeightubvARB;
extern __declspec(dllimport) PFNGLWEIGHTUIVARBPROC __glewWeightuivARB;
extern __declspec(dllimport) PFNGLWEIGHTUSVARBPROC __glewWeightusvARB;

extern __declspec(dllimport) PFNGLBINDBUFFERARBPROC __glewBindBufferARB;
extern __declspec(dllimport) PFNGLBUFFERDATAARBPROC __glewBufferDataARB;
extern __declspec(dllimport) PFNGLBUFFERSUBDATAARBPROC __glewBufferSubDataARB;
extern __declspec(dllimport) PFNGLDELETEBUFFERSARBPROC __glewDeleteBuffersARB;
extern __declspec(dllimport) PFNGLGENBUFFERSARBPROC __glewGenBuffersARB;
extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERIVARBPROC __glewGetBufferParameterivARB;
extern __declspec(dllimport) PFNGLGETBUFFERPOINTERVARBPROC __glewGetBufferPointervARB;
extern __declspec(dllimport) PFNGLGETBUFFERSUBDATAARBPROC __glewGetBufferSubDataARB;
extern __declspec(dllimport) PFNGLISBUFFERARBPROC __glewIsBufferARB;
extern __declspec(dllimport) PFNGLMAPBUFFERARBPROC __glewMapBufferARB;
extern __declspec(dllimport) PFNGLUNMAPBUFFERARBPROC __glewUnmapBufferARB;

extern __declspec(dllimport) PFNGLBINDPROGRAMARBPROC __glewBindProgramARB;
extern __declspec(dllimport) PFNGLDELETEPROGRAMSARBPROC __glewDeleteProgramsARB;
extern __declspec(dllimport) PFNGLDISABLEVERTEXATTRIBARRAYARBPROC __glewDisableVertexAttribArrayARB;
extern __declspec(dllimport) PFNGLENABLEVERTEXATTRIBARRAYARBPROC __glewEnableVertexAttribArrayARB;
extern __declspec(dllimport) PFNGLGENPROGRAMSARBPROC __glewGenProgramsARB;
extern __declspec(dllimport) PFNGLGETPROGRAMENVPARAMETERDVARBPROC __glewGetProgramEnvParameterdvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMENVPARAMETERFVARBPROC __glewGetProgramEnvParameterfvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMLOCALPARAMETERDVARBPROC __glewGetProgramLocalParameterdvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMLOCALPARAMETERFVARBPROC __glewGetProgramLocalParameterfvARB;
extern __declspec(dllimport) PFNGLGETPROGRAMSTRINGARBPROC __glewGetProgramStringARB;
extern __declspec(dllimport) PFNGLGETPROGRAMIVARBPROC __glewGetProgramivARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBPOINTERVARBPROC __glewGetVertexAttribPointervARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBDVARBPROC __glewGetVertexAttribdvARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBFVARBPROC __glewGetVertexAttribfvARB;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIVARBPROC __glewGetVertexAttribivARB;
extern __declspec(dllimport) PFNGLISPROGRAMARBPROC __glewIsProgramARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4DARBPROC __glewProgramEnvParameter4dARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4DVARBPROC __glewProgramEnvParameter4dvARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4FARBPROC __glewProgramEnvParameter4fARB;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETER4FVARBPROC __glewProgramEnvParameter4fvARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4DARBPROC __glewProgramLocalParameter4dARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4DVARBPROC __glewProgramLocalParameter4dvARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4FARBPROC __glewProgramLocalParameter4fARB;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETER4FVARBPROC __glewProgramLocalParameter4fvARB;
extern __declspec(dllimport) PFNGLPROGRAMSTRINGARBPROC __glewProgramStringARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DARBPROC __glewVertexAttrib1dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DVARBPROC __glewVertexAttrib1dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FARBPROC __glewVertexAttrib1fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FVARBPROC __glewVertexAttrib1fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SARBPROC __glewVertexAttrib1sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SVARBPROC __glewVertexAttrib1svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DARBPROC __glewVertexAttrib2dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DVARBPROC __glewVertexAttrib2dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FARBPROC __glewVertexAttrib2fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FVARBPROC __glewVertexAttrib2fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SARBPROC __glewVertexAttrib2sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SVARBPROC __glewVertexAttrib2svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DARBPROC __glewVertexAttrib3dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DVARBPROC __glewVertexAttrib3dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FARBPROC __glewVertexAttrib3fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FVARBPROC __glewVertexAttrib3fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SARBPROC __glewVertexAttrib3sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SVARBPROC __glewVertexAttrib3svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NBVARBPROC __glewVertexAttrib4NbvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NIVARBPROC __glewVertexAttrib4NivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NSVARBPROC __glewVertexAttrib4NsvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBARBPROC __glewVertexAttrib4NubARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUBVARBPROC __glewVertexAttrib4NubvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUIVARBPROC __glewVertexAttrib4NuivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4NUSVARBPROC __glewVertexAttrib4NusvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4BVARBPROC __glewVertexAttrib4bvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DARBPROC __glewVertexAttrib4dARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DVARBPROC __glewVertexAttrib4dvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FARBPROC __glewVertexAttrib4fARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FVARBPROC __glewVertexAttrib4fvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4IVARBPROC __glewVertexAttrib4ivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SARBPROC __glewVertexAttrib4sARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SVARBPROC __glewVertexAttrib4svARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBVARBPROC __glewVertexAttrib4ubvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UIVARBPROC __glewVertexAttrib4uivARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4USVARBPROC __glewVertexAttrib4usvARB;
extern __declspec(dllimport) PFNGLVERTEXATTRIBPOINTERARBPROC __glewVertexAttribPointerARB;

extern __declspec(dllimport) PFNGLBINDATTRIBLOCATIONARBPROC __glewBindAttribLocationARB;
extern __declspec(dllimport) PFNGLGETACTIVEATTRIBARBPROC __glewGetActiveAttribARB;
extern __declspec(dllimport) PFNGLGETATTRIBLOCATIONARBPROC __glewGetAttribLocationARB;

extern __declspec(dllimport) PFNGLCOLORP3UIPROC __glewColorP3ui;
extern __declspec(dllimport) PFNGLCOLORP3UIVPROC __glewColorP3uiv;
extern __declspec(dllimport) PFNGLCOLORP4UIPROC __glewColorP4ui;
extern __declspec(dllimport) PFNGLCOLORP4UIVPROC __glewColorP4uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP1UIPROC __glewMultiTexCoordP1ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP1UIVPROC __glewMultiTexCoordP1uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP2UIPROC __glewMultiTexCoordP2ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP2UIVPROC __glewMultiTexCoordP2uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP3UIPROC __glewMultiTexCoordP3ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP3UIVPROC __glewMultiTexCoordP3uiv;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP4UIPROC __glewMultiTexCoordP4ui;
extern __declspec(dllimport) PFNGLMULTITEXCOORDP4UIVPROC __glewMultiTexCoordP4uiv;
extern __declspec(dllimport) PFNGLNORMALP3UIPROC __glewNormalP3ui;
extern __declspec(dllimport) PFNGLNORMALP3UIVPROC __glewNormalP3uiv;
extern __declspec(dllimport) PFNGLSECONDARYCOLORP3UIPROC __glewSecondaryColorP3ui;
extern __declspec(dllimport) PFNGLSECONDARYCOLORP3UIVPROC __glewSecondaryColorP3uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP1UIPROC __glewTexCoordP1ui;
extern __declspec(dllimport) PFNGLTEXCOORDP1UIVPROC __glewTexCoordP1uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP2UIPROC __glewTexCoordP2ui;
extern __declspec(dllimport) PFNGLTEXCOORDP2UIVPROC __glewTexCoordP2uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP3UIPROC __glewTexCoordP3ui;
extern __declspec(dllimport) PFNGLTEXCOORDP3UIVPROC __glewTexCoordP3uiv;
extern __declspec(dllimport) PFNGLTEXCOORDP4UIPROC __glewTexCoordP4ui;
extern __declspec(dllimport) PFNGLTEXCOORDP4UIVPROC __glewTexCoordP4uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP1UIPROC __glewVertexAttribP1ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP1UIVPROC __glewVertexAttribP1uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP2UIPROC __glewVertexAttribP2ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP2UIVPROC __glewVertexAttribP2uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP3UIPROC __glewVertexAttribP3ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP3UIVPROC __glewVertexAttribP3uiv;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP4UIPROC __glewVertexAttribP4ui;
extern __declspec(dllimport) PFNGLVERTEXATTRIBP4UIVPROC __glewVertexAttribP4uiv;
extern __declspec(dllimport) PFNGLVERTEXP2UIPROC __glewVertexP2ui;
extern __declspec(dllimport) PFNGLVERTEXP2UIVPROC __glewVertexP2uiv;
extern __declspec(dllimport) PFNGLVERTEXP3UIPROC __glewVertexP3ui;
extern __declspec(dllimport) PFNGLVERTEXP3UIVPROC __glewVertexP3uiv;
extern __declspec(dllimport) PFNGLVERTEXP4UIPROC __glewVertexP4ui;
extern __declspec(dllimport) PFNGLVERTEXP4UIVPROC __glewVertexP4uiv;

extern __declspec(dllimport) PFNGLDEPTHRANGEARRAYVPROC __glewDepthRangeArrayv;
extern __declspec(dllimport) PFNGLDEPTHRANGEINDEXEDPROC __glewDepthRangeIndexed;
extern __declspec(dllimport) PFNGLGETDOUBLEI_VPROC __glewGetDoublei_v;
extern __declspec(dllimport) PFNGLGETFLOATI_VPROC __glewGetFloati_v;
extern __declspec(dllimport) PFNGLSCISSORARRAYVPROC __glewScissorArrayv;
extern __declspec(dllimport) PFNGLSCISSORINDEXEDPROC __glewScissorIndexed;
extern __declspec(dllimport) PFNGLSCISSORINDEXEDVPROC __glewScissorIndexedv;
extern __declspec(dllimport) PFNGLVIEWPORTARRAYVPROC __glewViewportArrayv;
extern __declspec(dllimport) PFNGLVIEWPORTINDEXEDFPROC __glewViewportIndexedf;
extern __declspec(dllimport) PFNGLVIEWPORTINDEXEDFVPROC __glewViewportIndexedfv;

extern __declspec(dllimport) PFNGLWINDOWPOS2DARBPROC __glewWindowPos2dARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2DVARBPROC __glewWindowPos2dvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2FARBPROC __glewWindowPos2fARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2FVARBPROC __glewWindowPos2fvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2IARBPROC __glewWindowPos2iARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2IVARBPROC __glewWindowPos2ivARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2SARBPROC __glewWindowPos2sARB;
extern __declspec(dllimport) PFNGLWINDOWPOS2SVARBPROC __glewWindowPos2svARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3DARBPROC __glewWindowPos3dARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3DVARBPROC __glewWindowPos3dvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3FARBPROC __glewWindowPos3fARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3FVARBPROC __glewWindowPos3fvARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3IARBPROC __glewWindowPos3iARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3IVARBPROC __glewWindowPos3ivARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3SARBPROC __glewWindowPos3sARB;
extern __declspec(dllimport) PFNGLWINDOWPOS3SVARBPROC __glewWindowPos3svARB;

extern __declspec(dllimport) PFNGLDRAWBUFFERSATIPROC __glewDrawBuffersATI;

extern __declspec(dllimport) PFNGLDRAWELEMENTARRAYATIPROC __glewDrawElementArrayATI;
extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTARRAYATIPROC __glewDrawRangeElementArrayATI;
extern __declspec(dllimport) PFNGLELEMENTPOINTERATIPROC __glewElementPointerATI;

extern __declspec(dllimport) PFNGLGETTEXBUMPPARAMETERFVATIPROC __glewGetTexBumpParameterfvATI;
extern __declspec(dllimport) PFNGLGETTEXBUMPPARAMETERIVATIPROC __glewGetTexBumpParameterivATI;
extern __declspec(dllimport) PFNGLTEXBUMPPARAMETERFVATIPROC __glewTexBumpParameterfvATI;
extern __declspec(dllimport) PFNGLTEXBUMPPARAMETERIVATIPROC __glewTexBumpParameterivATI;

extern __declspec(dllimport) PFNGLALPHAFRAGMENTOP1ATIPROC __glewAlphaFragmentOp1ATI;
extern __declspec(dllimport) PFNGLALPHAFRAGMENTOP2ATIPROC __glewAlphaFragmentOp2ATI;
extern __declspec(dllimport) PFNGLALPHAFRAGMENTOP3ATIPROC __glewAlphaFragmentOp3ATI;
extern __declspec(dllimport) PFNGLBEGINFRAGMENTSHADERATIPROC __glewBeginFragmentShaderATI;
extern __declspec(dllimport) PFNGLBINDFRAGMENTSHADERATIPROC __glewBindFragmentShaderATI;
extern __declspec(dllimport) PFNGLCOLORFRAGMENTOP1ATIPROC __glewColorFragmentOp1ATI;
extern __declspec(dllimport) PFNGLCOLORFRAGMENTOP2ATIPROC __glewColorFragmentOp2ATI;
extern __declspec(dllimport) PFNGLCOLORFRAGMENTOP3ATIPROC __glewColorFragmentOp3ATI;
extern __declspec(dllimport) PFNGLDELETEFRAGMENTSHADERATIPROC __glewDeleteFragmentShaderATI;
extern __declspec(dllimport) PFNGLENDFRAGMENTSHADERATIPROC __glewEndFragmentShaderATI;
extern __declspec(dllimport) PFNGLGENFRAGMENTSHADERSATIPROC __glewGenFragmentShadersATI;
extern __declspec(dllimport) PFNGLPASSTEXCOORDATIPROC __glewPassTexCoordATI;
extern __declspec(dllimport) PFNGLSAMPLEMAPATIPROC __glewSampleMapATI;
extern __declspec(dllimport) PFNGLSETFRAGMENTSHADERCONSTANTATIPROC __glewSetFragmentShaderConstantATI;

extern __declspec(dllimport) PFNGLMAPOBJECTBUFFERATIPROC __glewMapObjectBufferATI;
extern __declspec(dllimport) PFNGLUNMAPOBJECTBUFFERATIPROC __glewUnmapObjectBufferATI;

extern __declspec(dllimport) PFNGLPNTRIANGLESFATIPROC __glewPNTrianglesfATI;
extern __declspec(dllimport) PFNGLPNTRIANGLESIATIPROC __glewPNTrianglesiATI;

extern __declspec(dllimport) PFNGLSTENCILFUNCSEPARATEATIPROC __glewStencilFuncSeparateATI;
extern __declspec(dllimport) PFNGLSTENCILOPSEPARATEATIPROC __glewStencilOpSeparateATI;

extern __declspec(dllimport) PFNGLARRAYOBJECTATIPROC __glewArrayObjectATI;
extern __declspec(dllimport) PFNGLFREEOBJECTBUFFERATIPROC __glewFreeObjectBufferATI;
extern __declspec(dllimport) PFNGLGETARRAYOBJECTFVATIPROC __glewGetArrayObjectfvATI;
extern __declspec(dllimport) PFNGLGETARRAYOBJECTIVATIPROC __glewGetArrayObjectivATI;
extern __declspec(dllimport) PFNGLGETOBJECTBUFFERFVATIPROC __glewGetObjectBufferfvATI;
extern __declspec(dllimport) PFNGLGETOBJECTBUFFERIVATIPROC __glewGetObjectBufferivATI;
extern __declspec(dllimport) PFNGLGETVARIANTARRAYOBJECTFVATIPROC __glewGetVariantArrayObjectfvATI;
extern __declspec(dllimport) PFNGLGETVARIANTARRAYOBJECTIVATIPROC __glewGetVariantArrayObjectivATI;
extern __declspec(dllimport) PFNGLISOBJECTBUFFERATIPROC __glewIsObjectBufferATI;
extern __declspec(dllimport) PFNGLNEWOBJECTBUFFERATIPROC __glewNewObjectBufferATI;
extern __declspec(dllimport) PFNGLUPDATEOBJECTBUFFERATIPROC __glewUpdateObjectBufferATI;
extern __declspec(dllimport) PFNGLVARIANTARRAYOBJECTATIPROC __glewVariantArrayObjectATI;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBARRAYOBJECTFVATIPROC __glewGetVertexAttribArrayObjectfvATI;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBARRAYOBJECTIVATIPROC __glewGetVertexAttribArrayObjectivATI;
extern __declspec(dllimport) PFNGLVERTEXATTRIBARRAYOBJECTATIPROC __glewVertexAttribArrayObjectATI;

extern __declspec(dllimport) PFNGLCLIENTACTIVEVERTEXSTREAMATIPROC __glewClientActiveVertexStreamATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3BATIPROC __glewNormalStream3bATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3BVATIPROC __glewNormalStream3bvATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3DATIPROC __glewNormalStream3dATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3DVATIPROC __glewNormalStream3dvATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3FATIPROC __glewNormalStream3fATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3FVATIPROC __glewNormalStream3fvATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3IATIPROC __glewNormalStream3iATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3IVATIPROC __glewNormalStream3ivATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3SATIPROC __glewNormalStream3sATI;
extern __declspec(dllimport) PFNGLNORMALSTREAM3SVATIPROC __glewNormalStream3svATI;
extern __declspec(dllimport) PFNGLVERTEXBLENDENVFATIPROC __glewVertexBlendEnvfATI;
extern __declspec(dllimport) PFNGLVERTEXBLENDENVIATIPROC __glewVertexBlendEnviATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1DATIPROC __glewVertexStream1dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1DVATIPROC __glewVertexStream1dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1FATIPROC __glewVertexStream1fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1FVATIPROC __glewVertexStream1fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1IATIPROC __glewVertexStream1iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1IVATIPROC __glewVertexStream1ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1SATIPROC __glewVertexStream1sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM1SVATIPROC __glewVertexStream1svATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2DATIPROC __glewVertexStream2dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2DVATIPROC __glewVertexStream2dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2FATIPROC __glewVertexStream2fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2FVATIPROC __glewVertexStream2fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2IATIPROC __glewVertexStream2iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2IVATIPROC __glewVertexStream2ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2SATIPROC __glewVertexStream2sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM2SVATIPROC __glewVertexStream2svATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3DATIPROC __glewVertexStream3dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3DVATIPROC __glewVertexStream3dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3FATIPROC __glewVertexStream3fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3FVATIPROC __glewVertexStream3fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3IATIPROC __glewVertexStream3iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3IVATIPROC __glewVertexStream3ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3SATIPROC __glewVertexStream3sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM3SVATIPROC __glewVertexStream3svATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4DATIPROC __glewVertexStream4dATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4DVATIPROC __glewVertexStream4dvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4FATIPROC __glewVertexStream4fATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4FVATIPROC __glewVertexStream4fvATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4IATIPROC __glewVertexStream4iATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4IVATIPROC __glewVertexStream4ivATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4SATIPROC __glewVertexStream4sATI;
extern __declspec(dllimport) PFNGLVERTEXSTREAM4SVATIPROC __glewVertexStream4svATI;

extern __declspec(dllimport) PFNGLGETUNIFORMBUFFERSIZEEXTPROC __glewGetUniformBufferSizeEXT;
extern __declspec(dllimport) PFNGLGETUNIFORMOFFSETEXTPROC __glewGetUniformOffsetEXT;
extern __declspec(dllimport) PFNGLUNIFORMBUFFEREXTPROC __glewUniformBufferEXT;

extern __declspec(dllimport) PFNGLBLENDCOLOREXTPROC __glewBlendColorEXT;

extern __declspec(dllimport) PFNGLBLENDEQUATIONSEPARATEEXTPROC __glewBlendEquationSeparateEXT;

extern __declspec(dllimport) PFNGLBLENDFUNCSEPARATEEXTPROC __glewBlendFuncSeparateEXT;

extern __declspec(dllimport) PFNGLBLENDEQUATIONEXTPROC __glewBlendEquationEXT;

extern __declspec(dllimport) PFNGLCOLORSUBTABLEEXTPROC __glewColorSubTableEXT;
extern __declspec(dllimport) PFNGLCOPYCOLORSUBTABLEEXTPROC __glewCopyColorSubTableEXT;

extern __declspec(dllimport) PFNGLLOCKARRAYSEXTPROC __glewLockArraysEXT;
extern __declspec(dllimport) PFNGLUNLOCKARRAYSEXTPROC __glewUnlockArraysEXT;

extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER1DEXTPROC __glewConvolutionFilter1DEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONFILTER2DEXTPROC __glewConvolutionFilter2DEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFEXTPROC __glewConvolutionParameterfEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERFVEXTPROC __glewConvolutionParameterfvEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIEXTPROC __glewConvolutionParameteriEXT;
extern __declspec(dllimport) PFNGLCONVOLUTIONPARAMETERIVEXTPROC __glewConvolutionParameterivEXT;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER1DEXTPROC __glewCopyConvolutionFilter1DEXT;
extern __declspec(dllimport) PFNGLCOPYCONVOLUTIONFILTER2DEXTPROC __glewCopyConvolutionFilter2DEXT;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONFILTEREXTPROC __glewGetConvolutionFilterEXT;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERFVEXTPROC __glewGetConvolutionParameterfvEXT;
extern __declspec(dllimport) PFNGLGETCONVOLUTIONPARAMETERIVEXTPROC __glewGetConvolutionParameterivEXT;
extern __declspec(dllimport) PFNGLGETSEPARABLEFILTEREXTPROC __glewGetSeparableFilterEXT;
extern __declspec(dllimport) PFNGLSEPARABLEFILTER2DEXTPROC __glewSeparableFilter2DEXT;

extern __declspec(dllimport) PFNGLBINORMALPOINTEREXTPROC __glewBinormalPointerEXT;
extern __declspec(dllimport) PFNGLTANGENTPOINTEREXTPROC __glewTangentPointerEXT;

extern __declspec(dllimport) PFNGLCOPYTEXIMAGE1DEXTPROC __glewCopyTexImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXIMAGE2DEXTPROC __glewCopyTexImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE1DEXTPROC __glewCopyTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE2DEXTPROC __glewCopyTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXSUBIMAGE3DEXTPROC __glewCopyTexSubImage3DEXT;

extern __declspec(dllimport) PFNGLCULLPARAMETERDVEXTPROC __glewCullParameterdvEXT;
extern __declspec(dllimport) PFNGLCULLPARAMETERFVEXTPROC __glewCullParameterfvEXT;

extern __declspec(dllimport) PFNGLGETOBJECTLABELEXTPROC __glewGetObjectLabelEXT;
extern __declspec(dllimport) PFNGLLABELOBJECTEXTPROC __glewLabelObjectEXT;

extern __declspec(dllimport) PFNGLINSERTEVENTMARKEREXTPROC __glewInsertEventMarkerEXT;
extern __declspec(dllimport) PFNGLPOPGROUPMARKEREXTPROC __glewPopGroupMarkerEXT;
extern __declspec(dllimport) PFNGLPUSHGROUPMARKEREXTPROC __glewPushGroupMarkerEXT;

extern __declspec(dllimport) PFNGLDEPTHBOUNDSEXTPROC __glewDepthBoundsEXT;

extern __declspec(dllimport) PFNGLBINDMULTITEXTUREEXTPROC __glewBindMultiTextureEXT;
extern __declspec(dllimport) PFNGLCHECKNAMEDFRAMEBUFFERSTATUSEXTPROC __glewCheckNamedFramebufferStatusEXT;
extern __declspec(dllimport) PFNGLCLIENTATTRIBDEFAULTEXTPROC __glewClientAttribDefaultEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXIMAGE1DEXTPROC __glewCompressedMultiTexImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXIMAGE2DEXTPROC __glewCompressedMultiTexImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXIMAGE3DEXTPROC __glewCompressedMultiTexImage3DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXSUBIMAGE1DEXTPROC __glewCompressedMultiTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXSUBIMAGE2DEXTPROC __glewCompressedMultiTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDMULTITEXSUBIMAGE3DEXTPROC __glewCompressedMultiTexSubImage3DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTUREIMAGE1DEXTPROC __glewCompressedTextureImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTUREIMAGE2DEXTPROC __glewCompressedTextureImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTUREIMAGE3DEXTPROC __glewCompressedTextureImage3DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE1DEXTPROC __glewCompressedTextureSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE2DEXTPROC __glewCompressedTextureSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOMPRESSEDTEXTURESUBIMAGE3DEXTPROC __glewCompressedTextureSubImage3DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXIMAGE1DEXTPROC __glewCopyMultiTexImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXIMAGE2DEXTPROC __glewCopyMultiTexImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXSUBIMAGE1DEXTPROC __glewCopyMultiTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXSUBIMAGE2DEXTPROC __glewCopyMultiTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYMULTITEXSUBIMAGE3DEXTPROC __glewCopyMultiTexSubImage3DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTUREIMAGE1DEXTPROC __glewCopyTextureImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTUREIMAGE2DEXTPROC __glewCopyTextureImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE1DEXTPROC __glewCopyTextureSubImage1DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE2DEXTPROC __glewCopyTextureSubImage2DEXT;
extern __declspec(dllimport) PFNGLCOPYTEXTURESUBIMAGE3DEXTPROC __glewCopyTextureSubImage3DEXT;
extern __declspec(dllimport) PFNGLDISABLECLIENTSTATEINDEXEDEXTPROC __glewDisableClientStateIndexedEXT;
extern __declspec(dllimport) PFNGLDISABLECLIENTSTATEIEXTPROC __glewDisableClientStateiEXT;
extern __declspec(dllimport) PFNGLDISABLEVERTEXARRAYATTRIBEXTPROC __glewDisableVertexArrayAttribEXT;
extern __declspec(dllimport) PFNGLDISABLEVERTEXARRAYEXTPROC __glewDisableVertexArrayEXT;
extern __declspec(dllimport) PFNGLENABLECLIENTSTATEINDEXEDEXTPROC __glewEnableClientStateIndexedEXT;
extern __declspec(dllimport) PFNGLENABLECLIENTSTATEIEXTPROC __glewEnableClientStateiEXT;
extern __declspec(dllimport) PFNGLENABLEVERTEXARRAYATTRIBEXTPROC __glewEnableVertexArrayAttribEXT;
extern __declspec(dllimport) PFNGLENABLEVERTEXARRAYEXTPROC __glewEnableVertexArrayEXT;
extern __declspec(dllimport) PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEEXTPROC __glewFlushMappedNamedBufferRangeEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERDRAWBUFFEREXTPROC __glewFramebufferDrawBufferEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERDRAWBUFFERSEXTPROC __glewFramebufferDrawBuffersEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERREADBUFFEREXTPROC __glewFramebufferReadBufferEXT;
extern __declspec(dllimport) PFNGLGENERATEMULTITEXMIPMAPEXTPROC __glewGenerateMultiTexMipmapEXT;
extern __declspec(dllimport) PFNGLGENERATETEXTUREMIPMAPEXTPROC __glewGenerateTextureMipmapEXT;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDMULTITEXIMAGEEXTPROC __glewGetCompressedMultiTexImageEXT;
extern __declspec(dllimport) PFNGLGETCOMPRESSEDTEXTUREIMAGEEXTPROC __glewGetCompressedTextureImageEXT;
extern __declspec(dllimport) PFNGLGETDOUBLEINDEXEDVEXTPROC __glewGetDoubleIndexedvEXT;
extern __declspec(dllimport) PFNGLGETDOUBLEI_VEXTPROC __glewGetDoublei_vEXT;
extern __declspec(dllimport) PFNGLGETFLOATINDEXEDVEXTPROC __glewGetFloatIndexedvEXT;
extern __declspec(dllimport) PFNGLGETFLOATI_VEXTPROC __glewGetFloati_vEXT;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERPARAMETERIVEXTPROC __glewGetFramebufferParameterivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXENVFVEXTPROC __glewGetMultiTexEnvfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXENVIVEXTPROC __glewGetMultiTexEnvivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXGENDVEXTPROC __glewGetMultiTexGendvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXGENFVEXTPROC __glewGetMultiTexGenfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXGENIVEXTPROC __glewGetMultiTexGenivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXIMAGEEXTPROC __glewGetMultiTexImageEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXLEVELPARAMETERFVEXTPROC __glewGetMultiTexLevelParameterfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXLEVELPARAMETERIVEXTPROC __glewGetMultiTexLevelParameterivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERIIVEXTPROC __glewGetMultiTexParameterIivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERIUIVEXTPROC __glewGetMultiTexParameterIuivEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERFVEXTPROC __glewGetMultiTexParameterfvEXT;
extern __declspec(dllimport) PFNGLGETMULTITEXPARAMETERIVEXTPROC __glewGetMultiTexParameterivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERIVEXTPROC __glewGetNamedBufferParameterivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPOINTERVEXTPROC __glewGetNamedBufferPointervEXT;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERSUBDATAEXTPROC __glewGetNamedBufferSubDataEXT;
extern __declspec(dllimport) PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetNamedFramebufferAttachmentParameterivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIIVEXTPROC __glewGetNamedProgramLocalParameterIivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERIUIVEXTPROC __glewGetNamedProgramLocalParameterIuivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERDVEXTPROC __glewGetNamedProgramLocalParameterdvEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMLOCALPARAMETERFVEXTPROC __glewGetNamedProgramLocalParameterfvEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMSTRINGEXTPROC __glewGetNamedProgramStringEXT;
extern __declspec(dllimport) PFNGLGETNAMEDPROGRAMIVEXTPROC __glewGetNamedProgramivEXT;
extern __declspec(dllimport) PFNGLGETNAMEDRENDERBUFFERPARAMETERIVEXTPROC __glewGetNamedRenderbufferParameterivEXT;
extern __declspec(dllimport) PFNGLGETPOINTERINDEXEDVEXTPROC __glewGetPointerIndexedvEXT;
extern __declspec(dllimport) PFNGLGETPOINTERI_VEXTPROC __glewGetPointeri_vEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREIMAGEEXTPROC __glewGetTextureImageEXT;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERFVEXTPROC __glewGetTextureLevelParameterfvEXT;
extern __declspec(dllimport) PFNGLGETTEXTURELEVELPARAMETERIVEXTPROC __glewGetTextureLevelParameterivEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIIVEXTPROC __glewGetTextureParameterIivEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIUIVEXTPROC __glewGetTextureParameterIuivEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERFVEXTPROC __glewGetTextureParameterfvEXT;
extern __declspec(dllimport) PFNGLGETTEXTUREPARAMETERIVEXTPROC __glewGetTextureParameterivEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINTEGERI_VEXTPROC __glewGetVertexArrayIntegeri_vEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYINTEGERVEXTPROC __glewGetVertexArrayIntegervEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYPOINTERI_VEXTPROC __glewGetVertexArrayPointeri_vEXT;
extern __declspec(dllimport) PFNGLGETVERTEXARRAYPOINTERVEXTPROC __glewGetVertexArrayPointervEXT;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFEREXTPROC __glewMapNamedBufferEXT;
extern __declspec(dllimport) PFNGLMAPNAMEDBUFFERRANGEEXTPROC __glewMapNamedBufferRangeEXT;
extern __declspec(dllimport) PFNGLMATRIXFRUSTUMEXTPROC __glewMatrixFrustumEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADIDENTITYEXTPROC __glewMatrixLoadIdentityEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADTRANSPOSEDEXTPROC __glewMatrixLoadTransposedEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADTRANSPOSEFEXTPROC __glewMatrixLoadTransposefEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADDEXTPROC __glewMatrixLoaddEXT;
extern __declspec(dllimport) PFNGLMATRIXLOADFEXTPROC __glewMatrixLoadfEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTTRANSPOSEDEXTPROC __glewMatrixMultTransposedEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTTRANSPOSEFEXTPROC __glewMatrixMultTransposefEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTDEXTPROC __glewMatrixMultdEXT;
extern __declspec(dllimport) PFNGLMATRIXMULTFEXTPROC __glewMatrixMultfEXT;
extern __declspec(dllimport) PFNGLMATRIXORTHOEXTPROC __glewMatrixOrthoEXT;
extern __declspec(dllimport) PFNGLMATRIXPOPEXTPROC __glewMatrixPopEXT;
extern __declspec(dllimport) PFNGLMATRIXPUSHEXTPROC __glewMatrixPushEXT;
extern __declspec(dllimport) PFNGLMATRIXROTATEDEXTPROC __glewMatrixRotatedEXT;
extern __declspec(dllimport) PFNGLMATRIXROTATEFEXTPROC __glewMatrixRotatefEXT;
extern __declspec(dllimport) PFNGLMATRIXSCALEDEXTPROC __glewMatrixScaledEXT;
extern __declspec(dllimport) PFNGLMATRIXSCALEFEXTPROC __glewMatrixScalefEXT;
extern __declspec(dllimport) PFNGLMATRIXTRANSLATEDEXTPROC __glewMatrixTranslatedEXT;
extern __declspec(dllimport) PFNGLMATRIXTRANSLATEFEXTPROC __glewMatrixTranslatefEXT;
extern __declspec(dllimport) PFNGLMULTITEXBUFFEREXTPROC __glewMultiTexBufferEXT;
extern __declspec(dllimport) PFNGLMULTITEXCOORDPOINTEREXTPROC __glewMultiTexCoordPointerEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVFEXTPROC __glewMultiTexEnvfEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVFVEXTPROC __glewMultiTexEnvfvEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVIEXTPROC __glewMultiTexEnviEXT;
extern __declspec(dllimport) PFNGLMULTITEXENVIVEXTPROC __glewMultiTexEnvivEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENDEXTPROC __glewMultiTexGendEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENDVEXTPROC __glewMultiTexGendvEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENFEXTPROC __glewMultiTexGenfEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENFVEXTPROC __glewMultiTexGenfvEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENIEXTPROC __glewMultiTexGeniEXT;
extern __declspec(dllimport) PFNGLMULTITEXGENIVEXTPROC __glewMultiTexGenivEXT;
extern __declspec(dllimport) PFNGLMULTITEXIMAGE1DEXTPROC __glewMultiTexImage1DEXT;
extern __declspec(dllimport) PFNGLMULTITEXIMAGE2DEXTPROC __glewMultiTexImage2DEXT;
extern __declspec(dllimport) PFNGLMULTITEXIMAGE3DEXTPROC __glewMultiTexImage3DEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIIVEXTPROC __glewMultiTexParameterIivEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIUIVEXTPROC __glewMultiTexParameterIuivEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERFEXTPROC __glewMultiTexParameterfEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERFVEXTPROC __glewMultiTexParameterfvEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIEXTPROC __glewMultiTexParameteriEXT;
extern __declspec(dllimport) PFNGLMULTITEXPARAMETERIVEXTPROC __glewMultiTexParameterivEXT;
extern __declspec(dllimport) PFNGLMULTITEXRENDERBUFFEREXTPROC __glewMultiTexRenderbufferEXT;
extern __declspec(dllimport) PFNGLMULTITEXSUBIMAGE1DEXTPROC __glewMultiTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLMULTITEXSUBIMAGE2DEXTPROC __glewMultiTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLMULTITEXSUBIMAGE3DEXTPROC __glewMultiTexSubImage3DEXT;
extern __declspec(dllimport) PFNGLNAMEDBUFFERDATAEXTPROC __glewNamedBufferDataEXT;
extern __declspec(dllimport) PFNGLNAMEDBUFFERSUBDATAEXTPROC __glewNamedBufferSubDataEXT;
extern __declspec(dllimport) PFNGLNAMEDCOPYBUFFERSUBDATAEXTPROC __glewNamedCopyBufferSubDataEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERRENDERBUFFEREXTPROC __glewNamedFramebufferRenderbufferEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURE1DEXTPROC __glewNamedFramebufferTexture1DEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURE2DEXTPROC __glewNamedFramebufferTexture2DEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURE3DEXTPROC __glewNamedFramebufferTexture3DEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTUREEXTPROC __glewNamedFramebufferTextureEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTUREFACEEXTPROC __glewNamedFramebufferTextureFaceEXT;
extern __declspec(dllimport) PFNGLNAMEDFRAMEBUFFERTEXTURELAYEREXTPROC __glewNamedFramebufferTextureLayerEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4DEXTPROC __glewNamedProgramLocalParameter4dEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4DVEXTPROC __glewNamedProgramLocalParameter4dvEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4FEXTPROC __glewNamedProgramLocalParameter4fEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETER4FVEXTPROC __glewNamedProgramLocalParameter4fvEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IEXTPROC __glewNamedProgramLocalParameterI4iEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4IVEXTPROC __glewNamedProgramLocalParameterI4ivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIEXTPROC __glewNamedProgramLocalParameterI4uiEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERI4UIVEXTPROC __glewNamedProgramLocalParameterI4uivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERS4FVEXTPROC __glewNamedProgramLocalParameters4fvEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4IVEXTPROC __glewNamedProgramLocalParametersI4ivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMLOCALPARAMETERSI4UIVEXTPROC __glewNamedProgramLocalParametersI4uivEXT;
extern __declspec(dllimport) PFNGLNAMEDPROGRAMSTRINGEXTPROC __glewNamedProgramStringEXT;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEEXTPROC __glewNamedRenderbufferStorageEXT;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLECOVERAGEEXTPROC __glewNamedRenderbufferStorageMultisampleCoverageEXT;
extern __declspec(dllimport) PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewNamedRenderbufferStorageMultisampleEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FEXTPROC __glewProgramUniform1fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1FVEXTPROC __glewProgramUniform1fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IEXTPROC __glewProgramUniform1iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1IVEXTPROC __glewProgramUniform1ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIEXTPROC __glewProgramUniform1uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UIVEXTPROC __glewProgramUniform1uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FEXTPROC __glewProgramUniform2fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2FVEXTPROC __glewProgramUniform2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IEXTPROC __glewProgramUniform2iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2IVEXTPROC __glewProgramUniform2ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIEXTPROC __glewProgramUniform2uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UIVEXTPROC __glewProgramUniform2uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FEXTPROC __glewProgramUniform3fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3FVEXTPROC __glewProgramUniform3fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IEXTPROC __glewProgramUniform3iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3IVEXTPROC __glewProgramUniform3ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIEXTPROC __glewProgramUniform3uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UIVEXTPROC __glewProgramUniform3uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FEXTPROC __glewProgramUniform4fEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4FVEXTPROC __glewProgramUniform4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IEXTPROC __glewProgramUniform4iEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4IVEXTPROC __glewProgramUniform4ivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIEXTPROC __glewProgramUniform4uiEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UIVEXTPROC __glewProgramUniform4uivEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2FVEXTPROC __glewProgramUniformMatrix2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X3FVEXTPROC __glewProgramUniformMatrix2x3fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX2X4FVEXTPROC __glewProgramUniformMatrix2x4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3FVEXTPROC __glewProgramUniformMatrix3fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X2FVEXTPROC __glewProgramUniformMatrix3x2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX3X4FVEXTPROC __glewProgramUniformMatrix3x4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4FVEXTPROC __glewProgramUniformMatrix4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X2FVEXTPROC __glewProgramUniformMatrix4x2fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMMATRIX4X3FVEXTPROC __glewProgramUniformMatrix4x3fvEXT;
extern __declspec(dllimport) PFNGLPUSHCLIENTATTRIBDEFAULTEXTPROC __glewPushClientAttribDefaultEXT;
extern __declspec(dllimport) PFNGLTEXTUREBUFFEREXTPROC __glewTextureBufferEXT;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE1DEXTPROC __glewTextureImage1DEXT;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE2DEXTPROC __glewTextureImage2DEXT;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE3DEXTPROC __glewTextureImage3DEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIIVEXTPROC __glewTextureParameterIivEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIUIVEXTPROC __glewTextureParameterIuivEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFEXTPROC __glewTextureParameterfEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERFVEXTPROC __glewTextureParameterfvEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIEXTPROC __glewTextureParameteriEXT;
extern __declspec(dllimport) PFNGLTEXTUREPARAMETERIVEXTPROC __glewTextureParameterivEXT;
extern __declspec(dllimport) PFNGLTEXTURERENDERBUFFEREXTPROC __glewTextureRenderbufferEXT;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE1DEXTPROC __glewTextureSubImage1DEXT;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE2DEXTPROC __glewTextureSubImage2DEXT;
extern __declspec(dllimport) PFNGLTEXTURESUBIMAGE3DEXTPROC __glewTextureSubImage3DEXT;
extern __declspec(dllimport) PFNGLUNMAPNAMEDBUFFEREXTPROC __glewUnmapNamedBufferEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYCOLOROFFSETEXTPROC __glewVertexArrayColorOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYEDGEFLAGOFFSETEXTPROC __glewVertexArrayEdgeFlagOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYFOGCOORDOFFSETEXTPROC __glewVertexArrayFogCoordOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYINDEXOFFSETEXTPROC __glewVertexArrayIndexOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYMULTITEXCOORDOFFSETEXTPROC __glewVertexArrayMultiTexCoordOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYNORMALOFFSETEXTPROC __glewVertexArrayNormalOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYSECONDARYCOLOROFFSETEXTPROC __glewVertexArraySecondaryColorOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYTEXCOORDOFFSETEXTPROC __glewVertexArrayTexCoordOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBDIVISOREXTPROC __glewVertexArrayVertexAttribDivisorEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBIOFFSETEXTPROC __glewVertexArrayVertexAttribIOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBOFFSETEXTPROC __glewVertexArrayVertexAttribOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXOFFSETEXTPROC __glewVertexArrayVertexOffsetEXT;

extern __declspec(dllimport) PFNGLCOLORMASKINDEXEDEXTPROC __glewColorMaskIndexedEXT;
extern __declspec(dllimport) PFNGLDISABLEINDEXEDEXTPROC __glewDisableIndexedEXT;
extern __declspec(dllimport) PFNGLENABLEINDEXEDEXTPROC __glewEnableIndexedEXT;
extern __declspec(dllimport) PFNGLGETBOOLEANINDEXEDVEXTPROC __glewGetBooleanIndexedvEXT;
extern __declspec(dllimport) PFNGLGETINTEGERINDEXEDVEXTPROC __glewGetIntegerIndexedvEXT;
extern __declspec(dllimport) PFNGLISENABLEDINDEXEDEXTPROC __glewIsEnabledIndexedEXT;

extern __declspec(dllimport) PFNGLDRAWARRAYSINSTANCEDEXTPROC __glewDrawArraysInstancedEXT;
extern __declspec(dllimport) PFNGLDRAWELEMENTSINSTANCEDEXTPROC __glewDrawElementsInstancedEXT;

extern __declspec(dllimport) PFNGLDRAWRANGEELEMENTSEXTPROC __glewDrawRangeElementsEXT;

extern __declspec(dllimport) PFNGLFOGCOORDPOINTEREXTPROC __glewFogCoordPointerEXT;
extern __declspec(dllimport) PFNGLFOGCOORDDEXTPROC __glewFogCoorddEXT;
extern __declspec(dllimport) PFNGLFOGCOORDDVEXTPROC __glewFogCoorddvEXT;
extern __declspec(dllimport) PFNGLFOGCOORDFEXTPROC __glewFogCoordfEXT;
extern __declspec(dllimport) PFNGLFOGCOORDFVEXTPROC __glewFogCoordfvEXT;

extern __declspec(dllimport) PFNGLFRAGMENTCOLORMATERIALEXTPROC __glewFragmentColorMaterialEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFEXTPROC __glewFragmentLightModelfEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFVEXTPROC __glewFragmentLightModelfvEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELIEXTPROC __glewFragmentLightModeliEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELIVEXTPROC __glewFragmentLightModelivEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFEXTPROC __glewFragmentLightfEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFVEXTPROC __glewFragmentLightfvEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTIEXTPROC __glewFragmentLightiEXT;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTIVEXTPROC __glewFragmentLightivEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFEXTPROC __glewFragmentMaterialfEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFVEXTPROC __glewFragmentMaterialfvEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALIEXTPROC __glewFragmentMaterialiEXT;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALIVEXTPROC __glewFragmentMaterialivEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTFVEXTPROC __glewGetFragmentLightfvEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTIVEXTPROC __glewGetFragmentLightivEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALFVEXTPROC __glewGetFragmentMaterialfvEXT;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALIVEXTPROC __glewGetFragmentMaterialivEXT;
extern __declspec(dllimport) PFNGLLIGHTENVIEXTPROC __glewLightEnviEXT;

extern __declspec(dllimport) PFNGLBLITFRAMEBUFFEREXTPROC __glewBlitFramebufferEXT;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLEEXTPROC __glewRenderbufferStorageMultisampleEXT;

extern __declspec(dllimport) PFNGLBINDFRAMEBUFFEREXTPROC __glewBindFramebufferEXT;
extern __declspec(dllimport) PFNGLBINDRENDERBUFFEREXTPROC __glewBindRenderbufferEXT;
extern __declspec(dllimport) PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC __glewCheckFramebufferStatusEXT;
extern __declspec(dllimport) PFNGLDELETEFRAMEBUFFERSEXTPROC __glewDeleteFramebuffersEXT;
extern __declspec(dllimport) PFNGLDELETERENDERBUFFERSEXTPROC __glewDeleteRenderbuffersEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC __glewFramebufferRenderbufferEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE1DEXTPROC __glewFramebufferTexture1DEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE2DEXTPROC __glewFramebufferTexture2DEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURE3DEXTPROC __glewFramebufferTexture3DEXT;
extern __declspec(dllimport) PFNGLGENFRAMEBUFFERSEXTPROC __glewGenFramebuffersEXT;
extern __declspec(dllimport) PFNGLGENRENDERBUFFERSEXTPROC __glewGenRenderbuffersEXT;
extern __declspec(dllimport) PFNGLGENERATEMIPMAPEXTPROC __glewGenerateMipmapEXT;
extern __declspec(dllimport) PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC __glewGetFramebufferAttachmentParameterivEXT;
extern __declspec(dllimport) PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC __glewGetRenderbufferParameterivEXT;
extern __declspec(dllimport) PFNGLISFRAMEBUFFEREXTPROC __glewIsFramebufferEXT;
extern __declspec(dllimport) PFNGLISRENDERBUFFEREXTPROC __glewIsRenderbufferEXT;
extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEEXTPROC __glewRenderbufferStorageEXT;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREEXTPROC __glewFramebufferTextureEXT;
extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTUREFACEEXTPROC __glewFramebufferTextureFaceEXT;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERIEXTPROC __glewProgramParameteriEXT;

extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERS4FVEXTPROC __glewProgramEnvParameters4fvEXT;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERS4FVEXTPROC __glewProgramLocalParameters4fvEXT;

extern __declspec(dllimport) PFNGLBINDFRAGDATALOCATIONEXTPROC __glewBindFragDataLocationEXT;
extern __declspec(dllimport) PFNGLGETFRAGDATALOCATIONEXTPROC __glewGetFragDataLocationEXT;
extern __declspec(dllimport) PFNGLGETUNIFORMUIVEXTPROC __glewGetUniformuivEXT;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIIVEXTPROC __glewGetVertexAttribIivEXT;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIUIVEXTPROC __glewGetVertexAttribIuivEXT;
extern __declspec(dllimport) PFNGLUNIFORM1UIEXTPROC __glewUniform1uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM1UIVEXTPROC __glewUniform1uivEXT;
extern __declspec(dllimport) PFNGLUNIFORM2UIEXTPROC __glewUniform2uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM2UIVEXTPROC __glewUniform2uivEXT;
extern __declspec(dllimport) PFNGLUNIFORM3UIEXTPROC __glewUniform3uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM3UIVEXTPROC __glewUniform3uivEXT;
extern __declspec(dllimport) PFNGLUNIFORM4UIEXTPROC __glewUniform4uiEXT;
extern __declspec(dllimport) PFNGLUNIFORM4UIVEXTPROC __glewUniform4uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IEXTPROC __glewVertexAttribI1iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1IVEXTPROC __glewVertexAttribI1ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIEXTPROC __glewVertexAttribI1uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI1UIVEXTPROC __glewVertexAttribI1uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IEXTPROC __glewVertexAttribI2iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2IVEXTPROC __glewVertexAttribI2ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIEXTPROC __glewVertexAttribI2uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI2UIVEXTPROC __glewVertexAttribI2uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IEXTPROC __glewVertexAttribI3iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3IVEXTPROC __glewVertexAttribI3ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIEXTPROC __glewVertexAttribI3uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI3UIVEXTPROC __glewVertexAttribI3uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4BVEXTPROC __glewVertexAttribI4bvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IEXTPROC __glewVertexAttribI4iEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4IVEXTPROC __glewVertexAttribI4ivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4SVEXTPROC __glewVertexAttribI4svEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UBVEXTPROC __glewVertexAttribI4ubvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIEXTPROC __glewVertexAttribI4uiEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4UIVEXTPROC __glewVertexAttribI4uivEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBI4USVEXTPROC __glewVertexAttribI4usvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIPOINTEREXTPROC __glewVertexAttribIPointerEXT;

extern __declspec(dllimport) PFNGLGETHISTOGRAMEXTPROC __glewGetHistogramEXT;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERFVEXTPROC __glewGetHistogramParameterfvEXT;
extern __declspec(dllimport) PFNGLGETHISTOGRAMPARAMETERIVEXTPROC __glewGetHistogramParameterivEXT;
extern __declspec(dllimport) PFNGLGETMINMAXEXTPROC __glewGetMinmaxEXT;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERFVEXTPROC __glewGetMinmaxParameterfvEXT;
extern __declspec(dllimport) PFNGLGETMINMAXPARAMETERIVEXTPROC __glewGetMinmaxParameterivEXT;
extern __declspec(dllimport) PFNGLHISTOGRAMEXTPROC __glewHistogramEXT;
extern __declspec(dllimport) PFNGLMINMAXEXTPROC __glewMinmaxEXT;
extern __declspec(dllimport) PFNGLRESETHISTOGRAMEXTPROC __glewResetHistogramEXT;
extern __declspec(dllimport) PFNGLRESETMINMAXEXTPROC __glewResetMinmaxEXT;

extern __declspec(dllimport) PFNGLINDEXFUNCEXTPROC __glewIndexFuncEXT;

extern __declspec(dllimport) PFNGLINDEXMATERIALEXTPROC __glewIndexMaterialEXT;

extern __declspec(dllimport) PFNGLAPPLYTEXTUREEXTPROC __glewApplyTextureEXT;
extern __declspec(dllimport) PFNGLTEXTURELIGHTEXTPROC __glewTextureLightEXT;
extern __declspec(dllimport) PFNGLTEXTUREMATERIALEXTPROC __glewTextureMaterialEXT;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSEXTPROC __glewMultiDrawArraysEXT;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSEXTPROC __glewMultiDrawElementsEXT;

extern __declspec(dllimport) PFNGLSAMPLEMASKEXTPROC __glewSampleMaskEXT;
extern __declspec(dllimport) PFNGLSAMPLEPATTERNEXTPROC __glewSamplePatternEXT;

extern __declspec(dllimport) PFNGLCOLORTABLEEXTPROC __glewColorTableEXT;
extern __declspec(dllimport) PFNGLGETCOLORTABLEEXTPROC __glewGetColorTableEXT;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERFVEXTPROC __glewGetColorTableParameterfvEXT;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERIVEXTPROC __glewGetColorTableParameterivEXT;

extern __declspec(dllimport) PFNGLGETPIXELTRANSFORMPARAMETERFVEXTPROC __glewGetPixelTransformParameterfvEXT;
extern __declspec(dllimport) PFNGLGETPIXELTRANSFORMPARAMETERIVEXTPROC __glewGetPixelTransformParameterivEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERFEXTPROC __glewPixelTransformParameterfEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERFVEXTPROC __glewPixelTransformParameterfvEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERIEXTPROC __glewPixelTransformParameteriEXT;
extern __declspec(dllimport) PFNGLPIXELTRANSFORMPARAMETERIVEXTPROC __glewPixelTransformParameterivEXT;

extern __declspec(dllimport) PFNGLPOINTPARAMETERFEXTPROC __glewPointParameterfEXT;
extern __declspec(dllimport) PFNGLPOINTPARAMETERFVEXTPROC __glewPointParameterfvEXT;

extern __declspec(dllimport) PFNGLPOLYGONOFFSETEXTPROC __glewPolygonOffsetEXT;

extern __declspec(dllimport) PFNGLPROVOKINGVERTEXEXTPROC __glewProvokingVertexEXT;

extern __declspec(dllimport) PFNGLBEGINSCENEEXTPROC __glewBeginSceneEXT;
extern __declspec(dllimport) PFNGLENDSCENEEXTPROC __glewEndSceneEXT;

extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BEXTPROC __glewSecondaryColor3bEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3BVEXTPROC __glewSecondaryColor3bvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DEXTPROC __glewSecondaryColor3dEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3DVEXTPROC __glewSecondaryColor3dvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FEXTPROC __glewSecondaryColor3fEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3FVEXTPROC __glewSecondaryColor3fvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IEXTPROC __glewSecondaryColor3iEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3IVEXTPROC __glewSecondaryColor3ivEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SEXTPROC __glewSecondaryColor3sEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3SVEXTPROC __glewSecondaryColor3svEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBEXTPROC __glewSecondaryColor3ubEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UBVEXTPROC __glewSecondaryColor3ubvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIEXTPROC __glewSecondaryColor3uiEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3UIVEXTPROC __glewSecondaryColor3uivEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USEXTPROC __glewSecondaryColor3usEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3USVEXTPROC __glewSecondaryColor3usvEXT;
extern __declspec(dllimport) PFNGLSECONDARYCOLORPOINTEREXTPROC __glewSecondaryColorPointerEXT;

extern __declspec(dllimport) PFNGLACTIVEPROGRAMEXTPROC __glewActiveProgramEXT;
extern __declspec(dllimport) PFNGLCREATESHADERPROGRAMEXTPROC __glewCreateShaderProgramEXT;
extern __declspec(dllimport) PFNGLUSESHADERPROGRAMEXTPROC __glewUseShaderProgramEXT;

extern __declspec(dllimport) PFNGLBINDIMAGETEXTUREEXTPROC __glewBindImageTextureEXT;
extern __declspec(dllimport) PFNGLMEMORYBARRIEREXTPROC __glewMemoryBarrierEXT;

extern __declspec(dllimport) PFNGLACTIVESTENCILFACEEXTPROC __glewActiveStencilFaceEXT;

extern __declspec(dllimport) PFNGLTEXSUBIMAGE1DEXTPROC __glewTexSubImage1DEXT;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE2DEXTPROC __glewTexSubImage2DEXT;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE3DEXTPROC __glewTexSubImage3DEXT;

extern __declspec(dllimport) PFNGLTEXIMAGE3DEXTPROC __glewTexImage3DEXT;

extern __declspec(dllimport) PFNGLFRAMEBUFFERTEXTURELAYEREXTPROC __glewFramebufferTextureLayerEXT;

extern __declspec(dllimport) PFNGLTEXBUFFEREXTPROC __glewTexBufferEXT;

extern __declspec(dllimport) PFNGLCLEARCOLORIIEXTPROC __glewClearColorIiEXT;
extern __declspec(dllimport) PFNGLCLEARCOLORIUIEXTPROC __glewClearColorIuiEXT;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIIVEXTPROC __glewGetTexParameterIivEXT;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERIUIVEXTPROC __glewGetTexParameterIuivEXT;
extern __declspec(dllimport) PFNGLTEXPARAMETERIIVEXTPROC __glewTexParameterIivEXT;
extern __declspec(dllimport) PFNGLTEXPARAMETERIUIVEXTPROC __glewTexParameterIuivEXT;

extern __declspec(dllimport) PFNGLARETEXTURESRESIDENTEXTPROC __glewAreTexturesResidentEXT;
extern __declspec(dllimport) PFNGLBINDTEXTUREEXTPROC __glewBindTextureEXT;
extern __declspec(dllimport) PFNGLDELETETEXTURESEXTPROC __glewDeleteTexturesEXT;
extern __declspec(dllimport) PFNGLGENTEXTURESEXTPROC __glewGenTexturesEXT;
extern __declspec(dllimport) PFNGLISTEXTUREEXTPROC __glewIsTextureEXT;
extern __declspec(dllimport) PFNGLPRIORITIZETEXTURESEXTPROC __glewPrioritizeTexturesEXT;

extern __declspec(dllimport) PFNGLTEXTURENORMALEXTPROC __glewTextureNormalEXT;

extern __declspec(dllimport) PFNGLGETQUERYOBJECTI64VEXTPROC __glewGetQueryObjecti64vEXT;
extern __declspec(dllimport) PFNGLGETQUERYOBJECTUI64VEXTPROC __glewGetQueryObjectui64vEXT;

extern __declspec(dllimport) PFNGLBEGINTRANSFORMFEEDBACKEXTPROC __glewBeginTransformFeedbackEXT;
extern __declspec(dllimport) PFNGLBINDBUFFERBASEEXTPROC __glewBindBufferBaseEXT;
extern __declspec(dllimport) PFNGLBINDBUFFEROFFSETEXTPROC __glewBindBufferOffsetEXT;
extern __declspec(dllimport) PFNGLBINDBUFFERRANGEEXTPROC __glewBindBufferRangeEXT;
extern __declspec(dllimport) PFNGLENDTRANSFORMFEEDBACKEXTPROC __glewEndTransformFeedbackEXT;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKVARYINGEXTPROC __glewGetTransformFeedbackVaryingEXT;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKVARYINGSEXTPROC __glewTransformFeedbackVaryingsEXT;

extern __declspec(dllimport) PFNGLARRAYELEMENTEXTPROC __glewArrayElementEXT;
extern __declspec(dllimport) PFNGLCOLORPOINTEREXTPROC __glewColorPointerEXT;
extern __declspec(dllimport) PFNGLDRAWARRAYSEXTPROC __glewDrawArraysEXT;
extern __declspec(dllimport) PFNGLEDGEFLAGPOINTEREXTPROC __glewEdgeFlagPointerEXT;
extern __declspec(dllimport) PFNGLINDEXPOINTEREXTPROC __glewIndexPointerEXT;
extern __declspec(dllimport) PFNGLNORMALPOINTEREXTPROC __glewNormalPointerEXT;
extern __declspec(dllimport) PFNGLTEXCOORDPOINTEREXTPROC __glewTexCoordPointerEXT;
extern __declspec(dllimport) PFNGLVERTEXPOINTEREXTPROC __glewVertexPointerEXT;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLDVEXTPROC __glewGetVertexAttribLdvEXT;
extern __declspec(dllimport) PFNGLVERTEXARRAYVERTEXATTRIBLOFFSETEXTPROC __glewVertexArrayVertexAttribLOffsetEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DEXTPROC __glewVertexAttribL1dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1DVEXTPROC __glewVertexAttribL1dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DEXTPROC __glewVertexAttribL2dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2DVEXTPROC __glewVertexAttribL2dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DEXTPROC __glewVertexAttribL3dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3DVEXTPROC __glewVertexAttribL3dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DEXTPROC __glewVertexAttribL4dEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4DVEXTPROC __glewVertexAttribL4dvEXT;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLPOINTEREXTPROC __glewVertexAttribLPointerEXT;

extern __declspec(dllimport) PFNGLBEGINVERTEXSHADEREXTPROC __glewBeginVertexShaderEXT;
extern __declspec(dllimport) PFNGLBINDLIGHTPARAMETEREXTPROC __glewBindLightParameterEXT;
extern __declspec(dllimport) PFNGLBINDMATERIALPARAMETEREXTPROC __glewBindMaterialParameterEXT;
extern __declspec(dllimport) PFNGLBINDPARAMETEREXTPROC __glewBindParameterEXT;
extern __declspec(dllimport) PFNGLBINDTEXGENPARAMETEREXTPROC __glewBindTexGenParameterEXT;
extern __declspec(dllimport) PFNGLBINDTEXTUREUNITPARAMETEREXTPROC __glewBindTextureUnitParameterEXT;
extern __declspec(dllimport) PFNGLBINDVERTEXSHADEREXTPROC __glewBindVertexShaderEXT;
extern __declspec(dllimport) PFNGLDELETEVERTEXSHADEREXTPROC __glewDeleteVertexShaderEXT;
extern __declspec(dllimport) PFNGLDISABLEVARIANTCLIENTSTATEEXTPROC __glewDisableVariantClientStateEXT;
extern __declspec(dllimport) PFNGLENABLEVARIANTCLIENTSTATEEXTPROC __glewEnableVariantClientStateEXT;
extern __declspec(dllimport) PFNGLENDVERTEXSHADEREXTPROC __glewEndVertexShaderEXT;
extern __declspec(dllimport) PFNGLEXTRACTCOMPONENTEXTPROC __glewExtractComponentEXT;
extern __declspec(dllimport) PFNGLGENSYMBOLSEXTPROC __glewGenSymbolsEXT;
extern __declspec(dllimport) PFNGLGENVERTEXSHADERSEXTPROC __glewGenVertexShadersEXT;
extern __declspec(dllimport) PFNGLGETINVARIANTBOOLEANVEXTPROC __glewGetInvariantBooleanvEXT;
extern __declspec(dllimport) PFNGLGETINVARIANTFLOATVEXTPROC __glewGetInvariantFloatvEXT;
extern __declspec(dllimport) PFNGLGETINVARIANTINTEGERVEXTPROC __glewGetInvariantIntegervEXT;
extern __declspec(dllimport) PFNGLGETLOCALCONSTANTBOOLEANVEXTPROC __glewGetLocalConstantBooleanvEXT;
extern __declspec(dllimport) PFNGLGETLOCALCONSTANTFLOATVEXTPROC __glewGetLocalConstantFloatvEXT;
extern __declspec(dllimport) PFNGLGETLOCALCONSTANTINTEGERVEXTPROC __glewGetLocalConstantIntegervEXT;
extern __declspec(dllimport) PFNGLGETVARIANTBOOLEANVEXTPROC __glewGetVariantBooleanvEXT;
extern __declspec(dllimport) PFNGLGETVARIANTFLOATVEXTPROC __glewGetVariantFloatvEXT;
extern __declspec(dllimport) PFNGLGETVARIANTINTEGERVEXTPROC __glewGetVariantIntegervEXT;
extern __declspec(dllimport) PFNGLGETVARIANTPOINTERVEXTPROC __glewGetVariantPointervEXT;
extern __declspec(dllimport) PFNGLINSERTCOMPONENTEXTPROC __glewInsertComponentEXT;
extern __declspec(dllimport) PFNGLISVARIANTENABLEDEXTPROC __glewIsVariantEnabledEXT;
extern __declspec(dllimport) PFNGLSETINVARIANTEXTPROC __glewSetInvariantEXT;
extern __declspec(dllimport) PFNGLSETLOCALCONSTANTEXTPROC __glewSetLocalConstantEXT;
extern __declspec(dllimport) PFNGLSHADEROP1EXTPROC __glewShaderOp1EXT;
extern __declspec(dllimport) PFNGLSHADEROP2EXTPROC __glewShaderOp2EXT;
extern __declspec(dllimport) PFNGLSHADEROP3EXTPROC __glewShaderOp3EXT;
extern __declspec(dllimport) PFNGLSWIZZLEEXTPROC __glewSwizzleEXT;
extern __declspec(dllimport) PFNGLVARIANTPOINTEREXTPROC __glewVariantPointerEXT;
extern __declspec(dllimport) PFNGLVARIANTBVEXTPROC __glewVariantbvEXT;
extern __declspec(dllimport) PFNGLVARIANTDVEXTPROC __glewVariantdvEXT;
extern __declspec(dllimport) PFNGLVARIANTFVEXTPROC __glewVariantfvEXT;
extern __declspec(dllimport) PFNGLVARIANTIVEXTPROC __glewVariantivEXT;
extern __declspec(dllimport) PFNGLVARIANTSVEXTPROC __glewVariantsvEXT;
extern __declspec(dllimport) PFNGLVARIANTUBVEXTPROC __glewVariantubvEXT;
extern __declspec(dllimport) PFNGLVARIANTUIVEXTPROC __glewVariantuivEXT;
extern __declspec(dllimport) PFNGLVARIANTUSVEXTPROC __glewVariantusvEXT;
extern __declspec(dllimport) PFNGLWRITEMASKEXTPROC __glewWriteMaskEXT;

extern __declspec(dllimport) PFNGLVERTEXWEIGHTPOINTEREXTPROC __glewVertexWeightPointerEXT;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTFEXTPROC __glewVertexWeightfEXT;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTFVEXTPROC __glewVertexWeightfvEXT;

extern __declspec(dllimport) PFNGLIMPORTSYNCEXTPROC __glewImportSyncEXT;

extern __declspec(dllimport) PFNGLFRAMETERMINATORGREMEDYPROC __glewFrameTerminatorGREMEDY;

extern __declspec(dllimport) PFNGLSTRINGMARKERGREMEDYPROC __glewStringMarkerGREMEDY;

extern __declspec(dllimport) PFNGLGETIMAGETRANSFORMPARAMETERFVHPPROC __glewGetImageTransformParameterfvHP;
extern __declspec(dllimport) PFNGLGETIMAGETRANSFORMPARAMETERIVHPPROC __glewGetImageTransformParameterivHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERFHPPROC __glewImageTransformParameterfHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERFVHPPROC __glewImageTransformParameterfvHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERIHPPROC __glewImageTransformParameteriHP;
extern __declspec(dllimport) PFNGLIMAGETRANSFORMPARAMETERIVHPPROC __glewImageTransformParameterivHP;

extern __declspec(dllimport) PFNGLMULTIMODEDRAWARRAYSIBMPROC __glewMultiModeDrawArraysIBM;
extern __declspec(dllimport) PFNGLMULTIMODEDRAWELEMENTSIBMPROC __glewMultiModeDrawElementsIBM;

extern __declspec(dllimport) PFNGLCOLORPOINTERLISTIBMPROC __glewColorPointerListIBM;
extern __declspec(dllimport) PFNGLEDGEFLAGPOINTERLISTIBMPROC __glewEdgeFlagPointerListIBM;
extern __declspec(dllimport) PFNGLFOGCOORDPOINTERLISTIBMPROC __glewFogCoordPointerListIBM;
extern __declspec(dllimport) PFNGLINDEXPOINTERLISTIBMPROC __glewIndexPointerListIBM;
extern __declspec(dllimport) PFNGLNORMALPOINTERLISTIBMPROC __glewNormalPointerListIBM;
extern __declspec(dllimport) PFNGLSECONDARYCOLORPOINTERLISTIBMPROC __glewSecondaryColorPointerListIBM;
extern __declspec(dllimport) PFNGLTEXCOORDPOINTERLISTIBMPROC __glewTexCoordPointerListIBM;
extern __declspec(dllimport) PFNGLVERTEXPOINTERLISTIBMPROC __glewVertexPointerListIBM;

extern __declspec(dllimport) PFNGLMAPTEXTURE2DINTELPROC __glewMapTexture2DINTEL;
extern __declspec(dllimport) PFNGLSYNCTEXTUREINTELPROC __glewSyncTextureINTEL;
extern __declspec(dllimport) PFNGLUNMAPTEXTURE2DINTELPROC __glewUnmapTexture2DINTEL;

extern __declspec(dllimport) PFNGLCOLORPOINTERVINTELPROC __glewColorPointervINTEL;
extern __declspec(dllimport) PFNGLNORMALPOINTERVINTELPROC __glewNormalPointervINTEL;
extern __declspec(dllimport) PFNGLTEXCOORDPOINTERVINTELPROC __glewTexCoordPointervINTEL;
extern __declspec(dllimport) PFNGLVERTEXPOINTERVINTELPROC __glewVertexPointervINTEL;

extern __declspec(dllimport) PFNGLBEGINPERFQUERYINTELPROC __glewBeginPerfQueryINTEL;
extern __declspec(dllimport) PFNGLCREATEPERFQUERYINTELPROC __glewCreatePerfQueryINTEL;
extern __declspec(dllimport) PFNGLDELETEPERFQUERYINTELPROC __glewDeletePerfQueryINTEL;
extern __declspec(dllimport) PFNGLENDPERFQUERYINTELPROC __glewEndPerfQueryINTEL;
extern __declspec(dllimport) PFNGLGETFIRSTPERFQUERYIDINTELPROC __glewGetFirstPerfQueryIdINTEL;
extern __declspec(dllimport) PFNGLGETNEXTPERFQUERYIDINTELPROC __glewGetNextPerfQueryIdINTEL;
extern __declspec(dllimport) PFNGLGETPERFCOUNTERINFOINTELPROC __glewGetPerfCounterInfoINTEL;
extern __declspec(dllimport) PFNGLGETPERFQUERYDATAINTELPROC __glewGetPerfQueryDataINTEL;
extern __declspec(dllimport) PFNGLGETPERFQUERYIDBYNAMEINTELPROC __glewGetPerfQueryIdByNameINTEL;
extern __declspec(dllimport) PFNGLGETPERFQUERYINFOINTELPROC __glewGetPerfQueryInfoINTEL;

extern __declspec(dllimport) PFNGLTEXSCISSORFUNCINTELPROC __glewTexScissorFuncINTEL;
extern __declspec(dllimport) PFNGLTEXSCISSORINTELPROC __glewTexScissorINTEL;

extern __declspec(dllimport) PFNGLBLENDBARRIERKHRPROC __glewBlendBarrierKHR;

extern __declspec(dllimport) PFNGLDEBUGMESSAGECALLBACKPROC __glewDebugMessageCallback;
extern __declspec(dllimport) PFNGLDEBUGMESSAGECONTROLPROC __glewDebugMessageControl;
extern __declspec(dllimport) PFNGLDEBUGMESSAGEINSERTPROC __glewDebugMessageInsert;
extern __declspec(dllimport) PFNGLGETDEBUGMESSAGELOGPROC __glewGetDebugMessageLog;
extern __declspec(dllimport) PFNGLGETOBJECTLABELPROC __glewGetObjectLabel;
extern __declspec(dllimport) PFNGLGETOBJECTPTRLABELPROC __glewGetObjectPtrLabel;
extern __declspec(dllimport) PFNGLOBJECTLABELPROC __glewObjectLabel;
extern __declspec(dllimport) PFNGLOBJECTPTRLABELPROC __glewObjectPtrLabel;
extern __declspec(dllimport) PFNGLPOPDEBUGGROUPPROC __glewPopDebugGroup;
extern __declspec(dllimport) PFNGLPUSHDEBUGGROUPPROC __glewPushDebugGroup;

extern __declspec(dllimport) PFNGLGETNUNIFORMFVPROC __glewGetnUniformfv;
extern __declspec(dllimport) PFNGLGETNUNIFORMIVPROC __glewGetnUniformiv;
extern __declspec(dllimport) PFNGLGETNUNIFORMUIVPROC __glewGetnUniformuiv;
extern __declspec(dllimport) PFNGLREADNPIXELSPROC __glewReadnPixels;

extern __declspec(dllimport) PFNGLBUFFERREGIONENABLEDPROC __glewBufferRegionEnabled;
extern __declspec(dllimport) PFNGLDELETEBUFFERREGIONPROC __glewDeleteBufferRegion;
extern __declspec(dllimport) PFNGLDRAWBUFFERREGIONPROC __glewDrawBufferRegion;
extern __declspec(dllimport) PFNGLNEWBUFFERREGIONPROC __glewNewBufferRegion;
extern __declspec(dllimport) PFNGLREADBUFFERREGIONPROC __glewReadBufferRegion;

extern __declspec(dllimport) PFNGLRESIZEBUFFERSMESAPROC __glewResizeBuffersMESA;

extern __declspec(dllimport) PFNGLWINDOWPOS2DMESAPROC __glewWindowPos2dMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2DVMESAPROC __glewWindowPos2dvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2FMESAPROC __glewWindowPos2fMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2FVMESAPROC __glewWindowPos2fvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2IMESAPROC __glewWindowPos2iMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2IVMESAPROC __glewWindowPos2ivMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2SMESAPROC __glewWindowPos2sMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS2SVMESAPROC __glewWindowPos2svMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3DMESAPROC __glewWindowPos3dMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3DVMESAPROC __glewWindowPos3dvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3FMESAPROC __glewWindowPos3fMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3FVMESAPROC __glewWindowPos3fvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3IMESAPROC __glewWindowPos3iMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3IVMESAPROC __glewWindowPos3ivMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3SMESAPROC __glewWindowPos3sMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS3SVMESAPROC __glewWindowPos3svMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4DMESAPROC __glewWindowPos4dMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4DVMESAPROC __glewWindowPos4dvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4FMESAPROC __glewWindowPos4fMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4FVMESAPROC __glewWindowPos4fvMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4IMESAPROC __glewWindowPos4iMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4IVMESAPROC __glewWindowPos4ivMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4SMESAPROC __glewWindowPos4sMESA;
extern __declspec(dllimport) PFNGLWINDOWPOS4SVMESAPROC __glewWindowPos4svMESA;

extern __declspec(dllimport) PFNGLBEGINCONDITIONALRENDERNVXPROC __glewBeginConditionalRenderNVX;
extern __declspec(dllimport) PFNGLENDCONDITIONALRENDERNVXPROC __glewEndConditionalRenderNVX;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSNVPROC __glewMultiDrawArraysIndirectBindlessNV;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSNVPROC __glewMultiDrawElementsIndirectBindlessNV;

extern __declspec(dllimport) PFNGLMULTIDRAWARRAYSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawArraysIndirectBindlessCountNV;
extern __declspec(dllimport) PFNGLMULTIDRAWELEMENTSINDIRECTBINDLESSCOUNTNVPROC __glewMultiDrawElementsIndirectBindlessCountNV;

extern __declspec(dllimport) PFNGLGETIMAGEHANDLENVPROC __glewGetImageHandleNV;
extern __declspec(dllimport) PFNGLGETTEXTUREHANDLENVPROC __glewGetTextureHandleNV;
extern __declspec(dllimport) PFNGLGETTEXTURESAMPLERHANDLENVPROC __glewGetTextureSamplerHandleNV;
extern __declspec(dllimport) PFNGLISIMAGEHANDLERESIDENTNVPROC __glewIsImageHandleResidentNV;
extern __declspec(dllimport) PFNGLISTEXTUREHANDLERESIDENTNVPROC __glewIsTextureHandleResidentNV;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLENONRESIDENTNVPROC __glewMakeImageHandleNonResidentNV;
extern __declspec(dllimport) PFNGLMAKEIMAGEHANDLERESIDENTNVPROC __glewMakeImageHandleResidentNV;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLENONRESIDENTNVPROC __glewMakeTextureHandleNonResidentNV;
extern __declspec(dllimport) PFNGLMAKETEXTUREHANDLERESIDENTNVPROC __glewMakeTextureHandleResidentNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64NVPROC __glewProgramUniformHandleui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMHANDLEUI64VNVPROC __glewProgramUniformHandleui64vNV;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64NVPROC __glewUniformHandleui64NV;
extern __declspec(dllimport) PFNGLUNIFORMHANDLEUI64VNVPROC __glewUniformHandleui64vNV;

extern __declspec(dllimport) PFNGLBLENDBARRIERNVPROC __glewBlendBarrierNV;
extern __declspec(dllimport) PFNGLBLENDPARAMETERINVPROC __glewBlendParameteriNV;

extern __declspec(dllimport) PFNGLBEGINCONDITIONALRENDERNVPROC __glewBeginConditionalRenderNV;
extern __declspec(dllimport) PFNGLENDCONDITIONALRENDERNVPROC __glewEndConditionalRenderNV;

extern __declspec(dllimport) PFNGLCOPYIMAGESUBDATANVPROC __glewCopyImageSubDataNV;

extern __declspec(dllimport) PFNGLCLEARDEPTHDNVPROC __glewClearDepthdNV;
extern __declspec(dllimport) PFNGLDEPTHBOUNDSDNVPROC __glewDepthBoundsdNV;
extern __declspec(dllimport) PFNGLDEPTHRANGEDNVPROC __glewDepthRangedNV;

extern __declspec(dllimport) PFNGLDRAWTEXTURENVPROC __glewDrawTextureNV;

extern __declspec(dllimport) PFNGLEVALMAPSNVPROC __glewEvalMapsNV;
extern __declspec(dllimport) PFNGLGETMAPATTRIBPARAMETERFVNVPROC __glewGetMapAttribParameterfvNV;
extern __declspec(dllimport) PFNGLGETMAPATTRIBPARAMETERIVNVPROC __glewGetMapAttribParameterivNV;
extern __declspec(dllimport) PFNGLGETMAPCONTROLPOINTSNVPROC __glewGetMapControlPointsNV;
extern __declspec(dllimport) PFNGLGETMAPPARAMETERFVNVPROC __glewGetMapParameterfvNV;
extern __declspec(dllimport) PFNGLGETMAPPARAMETERIVNVPROC __glewGetMapParameterivNV;
extern __declspec(dllimport) PFNGLMAPCONTROLPOINTSNVPROC __glewMapControlPointsNV;
extern __declspec(dllimport) PFNGLMAPPARAMETERFVNVPROC __glewMapParameterfvNV;
extern __declspec(dllimport) PFNGLMAPPARAMETERIVNVPROC __glewMapParameterivNV;

extern __declspec(dllimport) PFNGLGETMULTISAMPLEFVNVPROC __glewGetMultisamplefvNV;
extern __declspec(dllimport) PFNGLSAMPLEMASKINDEXEDNVPROC __glewSampleMaskIndexedNV;
extern __declspec(dllimport) PFNGLTEXRENDERBUFFERNVPROC __glewTexRenderbufferNV;

extern __declspec(dllimport) PFNGLDELETEFENCESNVPROC __glewDeleteFencesNV;
extern __declspec(dllimport) PFNGLFINISHFENCENVPROC __glewFinishFenceNV;
extern __declspec(dllimport) PFNGLGENFENCESNVPROC __glewGenFencesNV;
extern __declspec(dllimport) PFNGLGETFENCEIVNVPROC __glewGetFenceivNV;
extern __declspec(dllimport) PFNGLISFENCENVPROC __glewIsFenceNV;
extern __declspec(dllimport) PFNGLSETFENCENVPROC __glewSetFenceNV;
extern __declspec(dllimport) PFNGLTESTFENCENVPROC __glewTestFenceNV;

extern __declspec(dllimport) PFNGLGETPROGRAMNAMEDPARAMETERDVNVPROC __glewGetProgramNamedParameterdvNV;
extern __declspec(dllimport) PFNGLGETPROGRAMNAMEDPARAMETERFVNVPROC __glewGetProgramNamedParameterfvNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4DNVPROC __glewProgramNamedParameter4dNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4DVNVPROC __glewProgramNamedParameter4dvNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4FNVPROC __glewProgramNamedParameter4fNV;
extern __declspec(dllimport) PFNGLPROGRAMNAMEDPARAMETER4FVNVPROC __glewProgramNamedParameter4fvNV;

extern __declspec(dllimport) PFNGLRENDERBUFFERSTORAGEMULTISAMPLECOVERAGENVPROC __glewRenderbufferStorageMultisampleCoverageNV;

extern __declspec(dllimport) PFNGLPROGRAMVERTEXLIMITNVPROC __glewProgramVertexLimitNV;

extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4INVPROC __glewProgramEnvParameterI4iNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4IVNVPROC __glewProgramEnvParameterI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4UINVPROC __glewProgramEnvParameterI4uiNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERI4UIVNVPROC __glewProgramEnvParameterI4uivNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERSI4IVNVPROC __glewProgramEnvParametersI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMENVPARAMETERSI4UIVNVPROC __glewProgramEnvParametersI4uivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4INVPROC __glewProgramLocalParameterI4iNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4IVNVPROC __glewProgramLocalParameterI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4UINVPROC __glewProgramLocalParameterI4uiNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERI4UIVNVPROC __glewProgramLocalParameterI4uivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERSI4IVNVPROC __glewProgramLocalParametersI4ivNV;
extern __declspec(dllimport) PFNGLPROGRAMLOCALPARAMETERSI4UIVNVPROC __glewProgramLocalParametersI4uivNV;

extern __declspec(dllimport) PFNGLGETUNIFORMI64VNVPROC __glewGetUniformi64vNV;
extern __declspec(dllimport) PFNGLGETUNIFORMUI64VNVPROC __glewGetUniformui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1I64NVPROC __glewProgramUniform1i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1I64VNVPROC __glewProgramUniform1i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UI64NVPROC __glewProgramUniform1ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM1UI64VNVPROC __glewProgramUniform1ui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2I64NVPROC __glewProgramUniform2i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2I64VNVPROC __glewProgramUniform2i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UI64NVPROC __glewProgramUniform2ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM2UI64VNVPROC __glewProgramUniform2ui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3I64NVPROC __glewProgramUniform3i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3I64VNVPROC __glewProgramUniform3i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UI64NVPROC __glewProgramUniform3ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM3UI64VNVPROC __glewProgramUniform3ui64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4I64NVPROC __glewProgramUniform4i64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4I64VNVPROC __glewProgramUniform4i64vNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UI64NVPROC __glewProgramUniform4ui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORM4UI64VNVPROC __glewProgramUniform4ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM1I64NVPROC __glewUniform1i64NV;
extern __declspec(dllimport) PFNGLUNIFORM1I64VNVPROC __glewUniform1i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM1UI64NVPROC __glewUniform1ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM1UI64VNVPROC __glewUniform1ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM2I64NVPROC __glewUniform2i64NV;
extern __declspec(dllimport) PFNGLUNIFORM2I64VNVPROC __glewUniform2i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM2UI64NVPROC __glewUniform2ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM2UI64VNVPROC __glewUniform2ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM3I64NVPROC __glewUniform3i64NV;
extern __declspec(dllimport) PFNGLUNIFORM3I64VNVPROC __glewUniform3i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM3UI64NVPROC __glewUniform3ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM3UI64VNVPROC __glewUniform3ui64vNV;
extern __declspec(dllimport) PFNGLUNIFORM4I64NVPROC __glewUniform4i64NV;
extern __declspec(dllimport) PFNGLUNIFORM4I64VNVPROC __glewUniform4i64vNV;
extern __declspec(dllimport) PFNGLUNIFORM4UI64NVPROC __glewUniform4ui64NV;
extern __declspec(dllimport) PFNGLUNIFORM4UI64VNVPROC __glewUniform4ui64vNV;

extern __declspec(dllimport) PFNGLCOLOR3HNVPROC __glewColor3hNV;
extern __declspec(dllimport) PFNGLCOLOR3HVNVPROC __glewColor3hvNV;
extern __declspec(dllimport) PFNGLCOLOR4HNVPROC __glewColor4hNV;
extern __declspec(dllimport) PFNGLCOLOR4HVNVPROC __glewColor4hvNV;
extern __declspec(dllimport) PFNGLFOGCOORDHNVPROC __glewFogCoordhNV;
extern __declspec(dllimport) PFNGLFOGCOORDHVNVPROC __glewFogCoordhvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1HNVPROC __glewMultiTexCoord1hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD1HVNVPROC __glewMultiTexCoord1hvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2HNVPROC __glewMultiTexCoord2hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD2HVNVPROC __glewMultiTexCoord2hvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3HNVPROC __glewMultiTexCoord3hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD3HVNVPROC __glewMultiTexCoord3hvNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4HNVPROC __glewMultiTexCoord4hNV;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4HVNVPROC __glewMultiTexCoord4hvNV;
extern __declspec(dllimport) PFNGLNORMAL3HNVPROC __glewNormal3hNV;
extern __declspec(dllimport) PFNGLNORMAL3HVNVPROC __glewNormal3hvNV;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3HNVPROC __glewSecondaryColor3hNV;
extern __declspec(dllimport) PFNGLSECONDARYCOLOR3HVNVPROC __glewSecondaryColor3hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD1HNVPROC __glewTexCoord1hNV;
extern __declspec(dllimport) PFNGLTEXCOORD1HVNVPROC __glewTexCoord1hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD2HNVPROC __glewTexCoord2hNV;
extern __declspec(dllimport) PFNGLTEXCOORD2HVNVPROC __glewTexCoord2hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD3HNVPROC __glewTexCoord3hNV;
extern __declspec(dllimport) PFNGLTEXCOORD3HVNVPROC __glewTexCoord3hvNV;
extern __declspec(dllimport) PFNGLTEXCOORD4HNVPROC __glewTexCoord4hNV;
extern __declspec(dllimport) PFNGLTEXCOORD4HVNVPROC __glewTexCoord4hvNV;
extern __declspec(dllimport) PFNGLVERTEX2HNVPROC __glewVertex2hNV;
extern __declspec(dllimport) PFNGLVERTEX2HVNVPROC __glewVertex2hvNV;
extern __declspec(dllimport) PFNGLVERTEX3HNVPROC __glewVertex3hNV;
extern __declspec(dllimport) PFNGLVERTEX3HVNVPROC __glewVertex3hvNV;
extern __declspec(dllimport) PFNGLVERTEX4HNVPROC __glewVertex4hNV;
extern __declspec(dllimport) PFNGLVERTEX4HVNVPROC __glewVertex4hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1HNVPROC __glewVertexAttrib1hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1HVNVPROC __glewVertexAttrib1hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2HNVPROC __glewVertexAttrib2hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2HVNVPROC __glewVertexAttrib2hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3HNVPROC __glewVertexAttrib3hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3HVNVPROC __glewVertexAttrib3hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4HNVPROC __glewVertexAttrib4hNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4HVNVPROC __glewVertexAttrib4hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1HVNVPROC __glewVertexAttribs1hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2HVNVPROC __glewVertexAttribs2hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3HVNVPROC __glewVertexAttribs3hvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4HVNVPROC __glewVertexAttribs4hvNV;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTHNVPROC __glewVertexWeighthNV;
extern __declspec(dllimport) PFNGLVERTEXWEIGHTHVNVPROC __glewVertexWeighthvNV;

extern __declspec(dllimport) PFNGLBEGINOCCLUSIONQUERYNVPROC __glewBeginOcclusionQueryNV;
extern __declspec(dllimport) PFNGLDELETEOCCLUSIONQUERIESNVPROC __glewDeleteOcclusionQueriesNV;
extern __declspec(dllimport) PFNGLENDOCCLUSIONQUERYNVPROC __glewEndOcclusionQueryNV;
extern __declspec(dllimport) PFNGLGENOCCLUSIONQUERIESNVPROC __glewGenOcclusionQueriesNV;
extern __declspec(dllimport) PFNGLGETOCCLUSIONQUERYIVNVPROC __glewGetOcclusionQueryivNV;
extern __declspec(dllimport) PFNGLGETOCCLUSIONQUERYUIVNVPROC __glewGetOcclusionQueryuivNV;
extern __declspec(dllimport) PFNGLISOCCLUSIONQUERYNVPROC __glewIsOcclusionQueryNV;

extern __declspec(dllimport) PFNGLPROGRAMBUFFERPARAMETERSIIVNVPROC __glewProgramBufferParametersIivNV;
extern __declspec(dllimport) PFNGLPROGRAMBUFFERPARAMETERSIUIVNVPROC __glewProgramBufferParametersIuivNV;
extern __declspec(dllimport) PFNGLPROGRAMBUFFERPARAMETERSFVNVPROC __glewProgramBufferParametersfvNV;

extern __declspec(dllimport) PFNGLCOPYPATHNVPROC __glewCopyPathNV;
extern __declspec(dllimport) PFNGLCOVERFILLPATHINSTANCEDNVPROC __glewCoverFillPathInstancedNV;
extern __declspec(dllimport) PFNGLCOVERFILLPATHNVPROC __glewCoverFillPathNV;
extern __declspec(dllimport) PFNGLCOVERSTROKEPATHINSTANCEDNVPROC __glewCoverStrokePathInstancedNV;
extern __declspec(dllimport) PFNGLCOVERSTROKEPATHNVPROC __glewCoverStrokePathNV;
extern __declspec(dllimport) PFNGLDELETEPATHSNVPROC __glewDeletePathsNV;
extern __declspec(dllimport) PFNGLGENPATHSNVPROC __glewGenPathsNV;
extern __declspec(dllimport) PFNGLGETPATHCOLORGENFVNVPROC __glewGetPathColorGenfvNV;
extern __declspec(dllimport) PFNGLGETPATHCOLORGENIVNVPROC __glewGetPathColorGenivNV;
extern __declspec(dllimport) PFNGLGETPATHCOMMANDSNVPROC __glewGetPathCommandsNV;
extern __declspec(dllimport) PFNGLGETPATHCOORDSNVPROC __glewGetPathCoordsNV;
extern __declspec(dllimport) PFNGLGETPATHDASHARRAYNVPROC __glewGetPathDashArrayNV;
extern __declspec(dllimport) PFNGLGETPATHLENGTHNVPROC __glewGetPathLengthNV;
extern __declspec(dllimport) PFNGLGETPATHMETRICRANGENVPROC __glewGetPathMetricRangeNV;
extern __declspec(dllimport) PFNGLGETPATHMETRICSNVPROC __glewGetPathMetricsNV;
extern __declspec(dllimport) PFNGLGETPATHPARAMETERFVNVPROC __glewGetPathParameterfvNV;
extern __declspec(dllimport) PFNGLGETPATHPARAMETERIVNVPROC __glewGetPathParameterivNV;
extern __declspec(dllimport) PFNGLGETPATHSPACINGNVPROC __glewGetPathSpacingNV;
extern __declspec(dllimport) PFNGLGETPATHTEXGENFVNVPROC __glewGetPathTexGenfvNV;
extern __declspec(dllimport) PFNGLGETPATHTEXGENIVNVPROC __glewGetPathTexGenivNV;
extern __declspec(dllimport) PFNGLINTERPOLATEPATHSNVPROC __glewInterpolatePathsNV;
extern __declspec(dllimport) PFNGLISPATHNVPROC __glewIsPathNV;
extern __declspec(dllimport) PFNGLISPOINTINFILLPATHNVPROC __glewIsPointInFillPathNV;
extern __declspec(dllimport) PFNGLISPOINTINSTROKEPATHNVPROC __glewIsPointInStrokePathNV;
extern __declspec(dllimport) PFNGLPATHCOLORGENNVPROC __glewPathColorGenNV;
extern __declspec(dllimport) PFNGLPATHCOMMANDSNVPROC __glewPathCommandsNV;
extern __declspec(dllimport) PFNGLPATHCOORDSNVPROC __glewPathCoordsNV;
extern __declspec(dllimport) PFNGLPATHCOVERDEPTHFUNCNVPROC __glewPathCoverDepthFuncNV;
extern __declspec(dllimport) PFNGLPATHDASHARRAYNVPROC __glewPathDashArrayNV;
extern __declspec(dllimport) PFNGLPATHFOGGENNVPROC __glewPathFogGenNV;
extern __declspec(dllimport) PFNGLPATHGLYPHRANGENVPROC __glewPathGlyphRangeNV;
extern __declspec(dllimport) PFNGLPATHGLYPHSNVPROC __glewPathGlyphsNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERFNVPROC __glewPathParameterfNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERFVNVPROC __glewPathParameterfvNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERINVPROC __glewPathParameteriNV;
extern __declspec(dllimport) PFNGLPATHPARAMETERIVNVPROC __glewPathParameterivNV;
extern __declspec(dllimport) PFNGLPATHSTENCILDEPTHOFFSETNVPROC __glewPathStencilDepthOffsetNV;
extern __declspec(dllimport) PFNGLPATHSTENCILFUNCNVPROC __glewPathStencilFuncNV;
extern __declspec(dllimport) PFNGLPATHSTRINGNVPROC __glewPathStringNV;
extern __declspec(dllimport) PFNGLPATHSUBCOMMANDSNVPROC __glewPathSubCommandsNV;
extern __declspec(dllimport) PFNGLPATHSUBCOORDSNVPROC __glewPathSubCoordsNV;
extern __declspec(dllimport) PFNGLPATHTEXGENNVPROC __glewPathTexGenNV;
extern __declspec(dllimport) PFNGLPOINTALONGPATHNVPROC __glewPointAlongPathNV;
extern __declspec(dllimport) PFNGLSTENCILFILLPATHINSTANCEDNVPROC __glewStencilFillPathInstancedNV;
extern __declspec(dllimport) PFNGLSTENCILFILLPATHNVPROC __glewStencilFillPathNV;
extern __declspec(dllimport) PFNGLSTENCILSTROKEPATHINSTANCEDNVPROC __glewStencilStrokePathInstancedNV;
extern __declspec(dllimport) PFNGLSTENCILSTROKEPATHNVPROC __glewStencilStrokePathNV;
extern __declspec(dllimport) PFNGLTRANSFORMPATHNVPROC __glewTransformPathNV;
extern __declspec(dllimport) PFNGLWEIGHTPATHSNVPROC __glewWeightPathsNV;

extern __declspec(dllimport) PFNGLFLUSHPIXELDATARANGENVPROC __glewFlushPixelDataRangeNV;
extern __declspec(dllimport) PFNGLPIXELDATARANGENVPROC __glewPixelDataRangeNV;

extern __declspec(dllimport) PFNGLPOINTPARAMETERINVPROC __glewPointParameteriNV;
extern __declspec(dllimport) PFNGLPOINTPARAMETERIVNVPROC __glewPointParameterivNV;

extern __declspec(dllimport) PFNGLGETVIDEOI64VNVPROC __glewGetVideoi64vNV;
extern __declspec(dllimport) PFNGLGETVIDEOIVNVPROC __glewGetVideoivNV;
extern __declspec(dllimport) PFNGLGETVIDEOUI64VNVPROC __glewGetVideoui64vNV;
extern __declspec(dllimport) PFNGLGETVIDEOUIVNVPROC __glewGetVideouivNV;
extern __declspec(dllimport) PFNGLPRESENTFRAMEDUALFILLNVPROC __glewPresentFrameDualFillNV;
extern __declspec(dllimport) PFNGLPRESENTFRAMEKEYEDNVPROC __glewPresentFrameKeyedNV;

extern __declspec(dllimport) PFNGLPRIMITIVERESTARTINDEXNVPROC __glewPrimitiveRestartIndexNV;
extern __declspec(dllimport) PFNGLPRIMITIVERESTARTNVPROC __glewPrimitiveRestartNV;

extern __declspec(dllimport) PFNGLCOMBINERINPUTNVPROC __glewCombinerInputNV;
extern __declspec(dllimport) PFNGLCOMBINEROUTPUTNVPROC __glewCombinerOutputNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERFNVPROC __glewCombinerParameterfNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERFVNVPROC __glewCombinerParameterfvNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERINVPROC __glewCombinerParameteriNV;
extern __declspec(dllimport) PFNGLCOMBINERPARAMETERIVNVPROC __glewCombinerParameterivNV;
extern __declspec(dllimport) PFNGLFINALCOMBINERINPUTNVPROC __glewFinalCombinerInputNV;
extern __declspec(dllimport) PFNGLGETCOMBINERINPUTPARAMETERFVNVPROC __glewGetCombinerInputParameterfvNV;
extern __declspec(dllimport) PFNGLGETCOMBINERINPUTPARAMETERIVNVPROC __glewGetCombinerInputParameterivNV;
extern __declspec(dllimport) PFNGLGETCOMBINEROUTPUTPARAMETERFVNVPROC __glewGetCombinerOutputParameterfvNV;
extern __declspec(dllimport) PFNGLGETCOMBINEROUTPUTPARAMETERIVNVPROC __glewGetCombinerOutputParameterivNV;
extern __declspec(dllimport) PFNGLGETFINALCOMBINERINPUTPARAMETERFVNVPROC __glewGetFinalCombinerInputParameterfvNV;
extern __declspec(dllimport) PFNGLGETFINALCOMBINERINPUTPARAMETERIVNVPROC __glewGetFinalCombinerInputParameterivNV;

extern __declspec(dllimport) PFNGLCOMBINERSTAGEPARAMETERFVNVPROC __glewCombinerStageParameterfvNV;
extern __declspec(dllimport) PFNGLGETCOMBINERSTAGEPARAMETERFVNVPROC __glewGetCombinerStageParameterfvNV;

extern __declspec(dllimport) PFNGLGETBUFFERPARAMETERUI64VNVPROC __glewGetBufferParameterui64vNV;
extern __declspec(dllimport) PFNGLGETINTEGERUI64VNVPROC __glewGetIntegerui64vNV;
extern __declspec(dllimport) PFNGLGETNAMEDBUFFERPARAMETERUI64VNVPROC __glewGetNamedBufferParameterui64vNV;
extern __declspec(dllimport) PFNGLISBUFFERRESIDENTNVPROC __glewIsBufferResidentNV;
extern __declspec(dllimport) PFNGLISNAMEDBUFFERRESIDENTNVPROC __glewIsNamedBufferResidentNV;
extern __declspec(dllimport) PFNGLMAKEBUFFERNONRESIDENTNVPROC __glewMakeBufferNonResidentNV;
extern __declspec(dllimport) PFNGLMAKEBUFFERRESIDENTNVPROC __glewMakeBufferResidentNV;
extern __declspec(dllimport) PFNGLMAKENAMEDBUFFERNONRESIDENTNVPROC __glewMakeNamedBufferNonResidentNV;
extern __declspec(dllimport) PFNGLMAKENAMEDBUFFERRESIDENTNVPROC __glewMakeNamedBufferResidentNV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMUI64NVPROC __glewProgramUniformui64NV;
extern __declspec(dllimport) PFNGLPROGRAMUNIFORMUI64VNVPROC __glewProgramUniformui64vNV;
extern __declspec(dllimport) PFNGLUNIFORMUI64NVPROC __glewUniformui64NV;
extern __declspec(dllimport) PFNGLUNIFORMUI64VNVPROC __glewUniformui64vNV;

extern __declspec(dllimport) PFNGLTEXTUREBARRIERNVPROC __glewTextureBarrierNV;

extern __declspec(dllimport) PFNGLTEXIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTexImage2DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTexImage3DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE2DMULTISAMPLECOVERAGENVPROC __glewTextureImage2DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE2DMULTISAMPLENVPROC __glewTextureImage2DMultisampleNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE3DMULTISAMPLECOVERAGENVPROC __glewTextureImage3DMultisampleCoverageNV;
extern __declspec(dllimport) PFNGLTEXTUREIMAGE3DMULTISAMPLENVPROC __glewTextureImage3DMultisampleNV;

extern __declspec(dllimport) PFNGLACTIVEVARYINGNVPROC __glewActiveVaryingNV;
extern __declspec(dllimport) PFNGLBEGINTRANSFORMFEEDBACKNVPROC __glewBeginTransformFeedbackNV;
extern __declspec(dllimport) PFNGLBINDBUFFERBASENVPROC __glewBindBufferBaseNV;
extern __declspec(dllimport) PFNGLBINDBUFFEROFFSETNVPROC __glewBindBufferOffsetNV;
extern __declspec(dllimport) PFNGLBINDBUFFERRANGENVPROC __glewBindBufferRangeNV;
extern __declspec(dllimport) PFNGLENDTRANSFORMFEEDBACKNVPROC __glewEndTransformFeedbackNV;
extern __declspec(dllimport) PFNGLGETACTIVEVARYINGNVPROC __glewGetActiveVaryingNV;
extern __declspec(dllimport) PFNGLGETTRANSFORMFEEDBACKVARYINGNVPROC __glewGetTransformFeedbackVaryingNV;
extern __declspec(dllimport) PFNGLGETVARYINGLOCATIONNVPROC __glewGetVaryingLocationNV;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKATTRIBSNVPROC __glewTransformFeedbackAttribsNV;
extern __declspec(dllimport) PFNGLTRANSFORMFEEDBACKVARYINGSNVPROC __glewTransformFeedbackVaryingsNV;

extern __declspec(dllimport) PFNGLBINDTRANSFORMFEEDBACKNVPROC __glewBindTransformFeedbackNV;
extern __declspec(dllimport) PFNGLDELETETRANSFORMFEEDBACKSNVPROC __glewDeleteTransformFeedbacksNV;
extern __declspec(dllimport) PFNGLDRAWTRANSFORMFEEDBACKNVPROC __glewDrawTransformFeedbackNV;
extern __declspec(dllimport) PFNGLGENTRANSFORMFEEDBACKSNVPROC __glewGenTransformFeedbacksNV;
extern __declspec(dllimport) PFNGLISTRANSFORMFEEDBACKNVPROC __glewIsTransformFeedbackNV;
extern __declspec(dllimport) PFNGLPAUSETRANSFORMFEEDBACKNVPROC __glewPauseTransformFeedbackNV;
extern __declspec(dllimport) PFNGLRESUMETRANSFORMFEEDBACKNVPROC __glewResumeTransformFeedbackNV;

extern __declspec(dllimport) PFNGLVDPAUFININVPROC __glewVDPAUFiniNV;
extern __declspec(dllimport) PFNGLVDPAUGETSURFACEIVNVPROC __glewVDPAUGetSurfaceivNV;
extern __declspec(dllimport) PFNGLVDPAUINITNVPROC __glewVDPAUInitNV;
extern __declspec(dllimport) PFNGLVDPAUISSURFACENVPROC __glewVDPAUIsSurfaceNV;
extern __declspec(dllimport) PFNGLVDPAUMAPSURFACESNVPROC __glewVDPAUMapSurfacesNV;
extern __declspec(dllimport) PFNGLVDPAUREGISTEROUTPUTSURFACENVPROC __glewVDPAURegisterOutputSurfaceNV;
extern __declspec(dllimport) PFNGLVDPAUREGISTERVIDEOSURFACENVPROC __glewVDPAURegisterVideoSurfaceNV;
extern __declspec(dllimport) PFNGLVDPAUSURFACEACCESSNVPROC __glewVDPAUSurfaceAccessNV;
extern __declspec(dllimport) PFNGLVDPAUUNMAPSURFACESNVPROC __glewVDPAUUnmapSurfacesNV;
extern __declspec(dllimport) PFNGLVDPAUUNREGISTERSURFACENVPROC __glewVDPAUUnregisterSurfaceNV;

extern __declspec(dllimport) PFNGLFLUSHVERTEXARRAYRANGENVPROC __glewFlushVertexArrayRangeNV;
extern __declspec(dllimport) PFNGLVERTEXARRAYRANGENVPROC __glewVertexArrayRangeNV;

extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLI64VNVPROC __glewGetVertexAttribLi64vNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBLUI64VNVPROC __glewGetVertexAttribLui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1I64NVPROC __glewVertexAttribL1i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1I64VNVPROC __glewVertexAttribL1i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64NVPROC __glewVertexAttribL1ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL1UI64VNVPROC __glewVertexAttribL1ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2I64NVPROC __glewVertexAttribL2i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2I64VNVPROC __glewVertexAttribL2i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2UI64NVPROC __glewVertexAttribL2ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL2UI64VNVPROC __glewVertexAttribL2ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3I64NVPROC __glewVertexAttribL3i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3I64VNVPROC __glewVertexAttribL3i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3UI64NVPROC __glewVertexAttribL3ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL3UI64VNVPROC __glewVertexAttribL3ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4I64NVPROC __glewVertexAttribL4i64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4I64VNVPROC __glewVertexAttribL4i64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4UI64NVPROC __glewVertexAttribL4ui64NV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBL4UI64VNVPROC __glewVertexAttribL4ui64vNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBLFORMATNVPROC __glewVertexAttribLFormatNV;

extern __declspec(dllimport) PFNGLBUFFERADDRESSRANGENVPROC __glewBufferAddressRangeNV;
extern __declspec(dllimport) PFNGLCOLORFORMATNVPROC __glewColorFormatNV;
extern __declspec(dllimport) PFNGLEDGEFLAGFORMATNVPROC __glewEdgeFlagFormatNV;
extern __declspec(dllimport) PFNGLFOGCOORDFORMATNVPROC __glewFogCoordFormatNV;
extern __declspec(dllimport) PFNGLGETINTEGERUI64I_VNVPROC __glewGetIntegerui64i_vNV;
extern __declspec(dllimport) PFNGLINDEXFORMATNVPROC __glewIndexFormatNV;
extern __declspec(dllimport) PFNGLNORMALFORMATNVPROC __glewNormalFormatNV;
extern __declspec(dllimport) PFNGLSECONDARYCOLORFORMATNVPROC __glewSecondaryColorFormatNV;
extern __declspec(dllimport) PFNGLTEXCOORDFORMATNVPROC __glewTexCoordFormatNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBFORMATNVPROC __glewVertexAttribFormatNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBIFORMATNVPROC __glewVertexAttribIFormatNV;
extern __declspec(dllimport) PFNGLVERTEXFORMATNVPROC __glewVertexFormatNV;

extern __declspec(dllimport) PFNGLAREPROGRAMSRESIDENTNVPROC __glewAreProgramsResidentNV;
extern __declspec(dllimport) PFNGLBINDPROGRAMNVPROC __glewBindProgramNV;
extern __declspec(dllimport) PFNGLDELETEPROGRAMSNVPROC __glewDeleteProgramsNV;
extern __declspec(dllimport) PFNGLEXECUTEPROGRAMNVPROC __glewExecuteProgramNV;
extern __declspec(dllimport) PFNGLGENPROGRAMSNVPROC __glewGenProgramsNV;
extern __declspec(dllimport) PFNGLGETPROGRAMPARAMETERDVNVPROC __glewGetProgramParameterdvNV;
extern __declspec(dllimport) PFNGLGETPROGRAMPARAMETERFVNVPROC __glewGetProgramParameterfvNV;
extern __declspec(dllimport) PFNGLGETPROGRAMSTRINGNVPROC __glewGetProgramStringNV;
extern __declspec(dllimport) PFNGLGETPROGRAMIVNVPROC __glewGetProgramivNV;
extern __declspec(dllimport) PFNGLGETTRACKMATRIXIVNVPROC __glewGetTrackMatrixivNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBPOINTERVNVPROC __glewGetVertexAttribPointervNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBDVNVPROC __glewGetVertexAttribdvNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBFVNVPROC __glewGetVertexAttribfvNV;
extern __declspec(dllimport) PFNGLGETVERTEXATTRIBIVNVPROC __glewGetVertexAttribivNV;
extern __declspec(dllimport) PFNGLISPROGRAMNVPROC __glewIsProgramNV;
extern __declspec(dllimport) PFNGLLOADPROGRAMNVPROC __glewLoadProgramNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4DNVPROC __glewProgramParameter4dNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4DVNVPROC __glewProgramParameter4dvNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4FNVPROC __glewProgramParameter4fNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETER4FVNVPROC __glewProgramParameter4fvNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERS4DVNVPROC __glewProgramParameters4dvNV;
extern __declspec(dllimport) PFNGLPROGRAMPARAMETERS4FVNVPROC __glewProgramParameters4fvNV;
extern __declspec(dllimport) PFNGLREQUESTRESIDENTPROGRAMSNVPROC __glewRequestResidentProgramsNV;
extern __declspec(dllimport) PFNGLTRACKMATRIXNVPROC __glewTrackMatrixNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DNVPROC __glewVertexAttrib1dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1DVNVPROC __glewVertexAttrib1dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FNVPROC __glewVertexAttrib1fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1FVNVPROC __glewVertexAttrib1fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SNVPROC __glewVertexAttrib1sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB1SVNVPROC __glewVertexAttrib1svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DNVPROC __glewVertexAttrib2dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2DVNVPROC __glewVertexAttrib2dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FNVPROC __glewVertexAttrib2fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2FVNVPROC __glewVertexAttrib2fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SNVPROC __glewVertexAttrib2sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB2SVNVPROC __glewVertexAttrib2svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DNVPROC __glewVertexAttrib3dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3DVNVPROC __glewVertexAttrib3dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FNVPROC __glewVertexAttrib3fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3FVNVPROC __glewVertexAttrib3fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SNVPROC __glewVertexAttrib3sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB3SVNVPROC __glewVertexAttrib3svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DNVPROC __glewVertexAttrib4dNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4DVNVPROC __glewVertexAttrib4dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FNVPROC __glewVertexAttrib4fNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4FVNVPROC __glewVertexAttrib4fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SNVPROC __glewVertexAttrib4sNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4SVNVPROC __glewVertexAttrib4svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBNVPROC __glewVertexAttrib4ubNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIB4UBVNVPROC __glewVertexAttrib4ubvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBPOINTERNVPROC __glewVertexAttribPointerNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1DVNVPROC __glewVertexAttribs1dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1FVNVPROC __glewVertexAttribs1fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS1SVNVPROC __glewVertexAttribs1svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2DVNVPROC __glewVertexAttribs2dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2FVNVPROC __glewVertexAttribs2fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS2SVNVPROC __glewVertexAttribs2svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3DVNVPROC __glewVertexAttribs3dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3FVNVPROC __glewVertexAttribs3fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS3SVNVPROC __glewVertexAttribs3svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4DVNVPROC __glewVertexAttribs4dvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4FVNVPROC __glewVertexAttribs4fvNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4SVNVPROC __glewVertexAttribs4svNV;
extern __declspec(dllimport) PFNGLVERTEXATTRIBS4UBVNVPROC __glewVertexAttribs4ubvNV;

extern __declspec(dllimport) PFNGLBEGINVIDEOCAPTURENVPROC __glewBeginVideoCaptureNV;
extern __declspec(dllimport) PFNGLBINDVIDEOCAPTURESTREAMBUFFERNVPROC __glewBindVideoCaptureStreamBufferNV;
extern __declspec(dllimport) PFNGLBINDVIDEOCAPTURESTREAMTEXTURENVPROC __glewBindVideoCaptureStreamTextureNV;
extern __declspec(dllimport) PFNGLENDVIDEOCAPTURENVPROC __glewEndVideoCaptureNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTURESTREAMDVNVPROC __glewGetVideoCaptureStreamdvNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTURESTREAMFVNVPROC __glewGetVideoCaptureStreamfvNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTURESTREAMIVNVPROC __glewGetVideoCaptureStreamivNV;
extern __declspec(dllimport) PFNGLGETVIDEOCAPTUREIVNVPROC __glewGetVideoCaptureivNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURENVPROC __glewVideoCaptureNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURESTREAMPARAMETERDVNVPROC __glewVideoCaptureStreamParameterdvNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURESTREAMPARAMETERFVNVPROC __glewVideoCaptureStreamParameterfvNV;
extern __declspec(dllimport) PFNGLVIDEOCAPTURESTREAMPARAMETERIVNVPROC __glewVideoCaptureStreamParameterivNV;

extern __declspec(dllimport) PFNGLCLEARDEPTHFOESPROC __glewClearDepthfOES;
extern __declspec(dllimport) PFNGLCLIPPLANEFOESPROC __glewClipPlanefOES;
extern __declspec(dllimport) PFNGLDEPTHRANGEFOESPROC __glewDepthRangefOES;
extern __declspec(dllimport) PFNGLFRUSTUMFOESPROC __glewFrustumfOES;
extern __declspec(dllimport) PFNGLGETCLIPPLANEFOESPROC __glewGetClipPlanefOES;
extern __declspec(dllimport) PFNGLORTHOFOESPROC __glewOrthofOES;

extern __declspec(dllimport) PFNGLALPHAFUNCXPROC __glewAlphaFuncx;
extern __declspec(dllimport) PFNGLCLEARCOLORXPROC __glewClearColorx;
extern __declspec(dllimport) PFNGLCLEARDEPTHXPROC __glewClearDepthx;
extern __declspec(dllimport) PFNGLCOLOR4XPROC __glewColor4x;
extern __declspec(dllimport) PFNGLDEPTHRANGEXPROC __glewDepthRangex;
extern __declspec(dllimport) PFNGLFOGXPROC __glewFogx;
extern __declspec(dllimport) PFNGLFOGXVPROC __glewFogxv;
extern __declspec(dllimport) PFNGLFRUSTUMFPROC __glewFrustumf;
extern __declspec(dllimport) PFNGLFRUSTUMXPROC __glewFrustumx;
extern __declspec(dllimport) PFNGLLIGHTMODELXPROC __glewLightModelx;
extern __declspec(dllimport) PFNGLLIGHTMODELXVPROC __glewLightModelxv;
extern __declspec(dllimport) PFNGLLIGHTXPROC __glewLightx;
extern __declspec(dllimport) PFNGLLIGHTXVPROC __glewLightxv;
extern __declspec(dllimport) PFNGLLINEWIDTHXPROC __glewLineWidthx;
extern __declspec(dllimport) PFNGLLOADMATRIXXPROC __glewLoadMatrixx;
extern __declspec(dllimport) PFNGLMATERIALXPROC __glewMaterialx;
extern __declspec(dllimport) PFNGLMATERIALXVPROC __glewMaterialxv;
extern __declspec(dllimport) PFNGLMULTMATRIXXPROC __glewMultMatrixx;
extern __declspec(dllimport) PFNGLMULTITEXCOORD4XPROC __glewMultiTexCoord4x;
extern __declspec(dllimport) PFNGLNORMAL3XPROC __glewNormal3x;
extern __declspec(dllimport) PFNGLORTHOFPROC __glewOrthof;
extern __declspec(dllimport) PFNGLORTHOXPROC __glewOrthox;
extern __declspec(dllimport) PFNGLPOINTSIZEXPROC __glewPointSizex;
extern __declspec(dllimport) PFNGLPOLYGONOFFSETXPROC __glewPolygonOffsetx;
extern __declspec(dllimport) PFNGLROTATEXPROC __glewRotatex;
extern __declspec(dllimport) PFNGLSAMPLECOVERAGEXPROC __glewSampleCoveragex;
extern __declspec(dllimport) PFNGLSCALEXPROC __glewScalex;
extern __declspec(dllimport) PFNGLTEXENVXPROC __glewTexEnvx;
extern __declspec(dllimport) PFNGLTEXENVXVPROC __glewTexEnvxv;
extern __declspec(dllimport) PFNGLTEXPARAMETERXPROC __glewTexParameterx;
extern __declspec(dllimport) PFNGLTRANSLATEXPROC __glewTranslatex;

extern __declspec(dllimport) PFNGLCLIPPLANEFPROC __glewClipPlanef;
extern __declspec(dllimport) PFNGLCLIPPLANEXPROC __glewClipPlanex;
extern __declspec(dllimport) PFNGLGETCLIPPLANEFPROC __glewGetClipPlanef;
extern __declspec(dllimport) PFNGLGETCLIPPLANEXPROC __glewGetClipPlanex;
extern __declspec(dllimport) PFNGLGETFIXEDVPROC __glewGetFixedv;
extern __declspec(dllimport) PFNGLGETLIGHTXVPROC __glewGetLightxv;
extern __declspec(dllimport) PFNGLGETMATERIALXVPROC __glewGetMaterialxv;
extern __declspec(dllimport) PFNGLGETTEXENVXVPROC __glewGetTexEnvxv;
extern __declspec(dllimport) PFNGLGETTEXPARAMETERXVPROC __glewGetTexParameterxv;
extern __declspec(dllimport) PFNGLPOINTPARAMETERXPROC __glewPointParameterx;
extern __declspec(dllimport) PFNGLPOINTPARAMETERXVPROC __glewPointParameterxv;
extern __declspec(dllimport) PFNGLPOINTSIZEPOINTEROESPROC __glewPointSizePointerOES;
extern __declspec(dllimport) PFNGLTEXPARAMETERXVPROC __glewTexParameterxv;

extern __declspec(dllimport) PFNGLERRORSTRINGREGALPROC __glewErrorStringREGAL;

extern __declspec(dllimport) PFNGLGETEXTENSIONREGALPROC __glewGetExtensionREGAL;
extern __declspec(dllimport) PFNGLISSUPPORTEDREGALPROC __glewIsSupportedREGAL;

extern __declspec(dllimport) PFNGLLOGMESSAGECALLBACKREGALPROC __glewLogMessageCallbackREGAL;

extern __declspec(dllimport) PFNGLGETPROCADDRESSREGALPROC __glewGetProcAddressREGAL;

extern __declspec(dllimport) PFNGLDETAILTEXFUNCSGISPROC __glewDetailTexFuncSGIS;
extern __declspec(dllimport) PFNGLGETDETAILTEXFUNCSGISPROC __glewGetDetailTexFuncSGIS;

extern __declspec(dllimport) PFNGLFOGFUNCSGISPROC __glewFogFuncSGIS;
extern __declspec(dllimport) PFNGLGETFOGFUNCSGISPROC __glewGetFogFuncSGIS;

extern __declspec(dllimport) PFNGLSAMPLEMASKSGISPROC __glewSampleMaskSGIS;
extern __declspec(dllimport) PFNGLSAMPLEPATTERNSGISPROC __glewSamplePatternSGIS;

extern __declspec(dllimport) PFNGLGETSHARPENTEXFUNCSGISPROC __glewGetSharpenTexFuncSGIS;
extern __declspec(dllimport) PFNGLSHARPENTEXFUNCSGISPROC __glewSharpenTexFuncSGIS;

extern __declspec(dllimport) PFNGLTEXIMAGE4DSGISPROC __glewTexImage4DSGIS;
extern __declspec(dllimport) PFNGLTEXSUBIMAGE4DSGISPROC __glewTexSubImage4DSGIS;

extern __declspec(dllimport) PFNGLGETTEXFILTERFUNCSGISPROC __glewGetTexFilterFuncSGIS;
extern __declspec(dllimport) PFNGLTEXFILTERFUNCSGISPROC __glewTexFilterFuncSGIS;

extern __declspec(dllimport) PFNGLASYNCMARKERSGIXPROC __glewAsyncMarkerSGIX;
extern __declspec(dllimport) PFNGLDELETEASYNCMARKERSSGIXPROC __glewDeleteAsyncMarkersSGIX;
extern __declspec(dllimport) PFNGLFINISHASYNCSGIXPROC __glewFinishAsyncSGIX;
extern __declspec(dllimport) PFNGLGENASYNCMARKERSSGIXPROC __glewGenAsyncMarkersSGIX;
extern __declspec(dllimport) PFNGLISASYNCMARKERSGIXPROC __glewIsAsyncMarkerSGIX;
extern __declspec(dllimport) PFNGLPOLLASYNCSGIXPROC __glewPollAsyncSGIX;

extern __declspec(dllimport) PFNGLFLUSHRASTERSGIXPROC __glewFlushRasterSGIX;

extern __declspec(dllimport) PFNGLTEXTUREFOGSGIXPROC __glewTextureFogSGIX;

extern __declspec(dllimport) PFNGLFRAGMENTCOLORMATERIALSGIXPROC __glewFragmentColorMaterialSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFSGIXPROC __glewFragmentLightModelfSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELFVSGIXPROC __glewFragmentLightModelfvSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELISGIXPROC __glewFragmentLightModeliSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTMODELIVSGIXPROC __glewFragmentLightModelivSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFSGIXPROC __glewFragmentLightfSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTFVSGIXPROC __glewFragmentLightfvSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTISGIXPROC __glewFragmentLightiSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTLIGHTIVSGIXPROC __glewFragmentLightivSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFSGIXPROC __glewFragmentMaterialfSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALFVSGIXPROC __glewFragmentMaterialfvSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALISGIXPROC __glewFragmentMaterialiSGIX;
extern __declspec(dllimport) PFNGLFRAGMENTMATERIALIVSGIXPROC __glewFragmentMaterialivSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTFVSGIXPROC __glewGetFragmentLightfvSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTLIGHTIVSGIXPROC __glewGetFragmentLightivSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALFVSGIXPROC __glewGetFragmentMaterialfvSGIX;
extern __declspec(dllimport) PFNGLGETFRAGMENTMATERIALIVSGIXPROC __glewGetFragmentMaterialivSGIX;

extern __declspec(dllimport) PFNGLFRAMEZOOMSGIXPROC __glewFrameZoomSGIX;

extern __declspec(dllimport) PFNGLPIXELTEXGENSGIXPROC __glewPixelTexGenSGIX;

extern __declspec(dllimport) PFNGLREFERENCEPLANESGIXPROC __glewReferencePlaneSGIX;

extern __declspec(dllimport) PFNGLSPRITEPARAMETERFSGIXPROC __glewSpriteParameterfSGIX;
extern __declspec(dllimport) PFNGLSPRITEPARAMETERFVSGIXPROC __glewSpriteParameterfvSGIX;
extern __declspec(dllimport) PFNGLSPRITEPARAMETERISGIXPROC __glewSpriteParameteriSGIX;
extern __declspec(dllimport) PFNGLSPRITEPARAMETERIVSGIXPROC __glewSpriteParameterivSGIX;

extern __declspec(dllimport) PFNGLTAGSAMPLEBUFFERSGIXPROC __glewTagSampleBufferSGIX;

extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERFVSGIPROC __glewColorTableParameterfvSGI;
extern __declspec(dllimport) PFNGLCOLORTABLEPARAMETERIVSGIPROC __glewColorTableParameterivSGI;
extern __declspec(dllimport) PFNGLCOLORTABLESGIPROC __glewColorTableSGI;
extern __declspec(dllimport) PFNGLCOPYCOLORTABLESGIPROC __glewCopyColorTableSGI;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERFVSGIPROC __glewGetColorTableParameterfvSGI;
extern __declspec(dllimport) PFNGLGETCOLORTABLEPARAMETERIVSGIPROC __glewGetColorTableParameterivSGI;
extern __declspec(dllimport) PFNGLGETCOLORTABLESGIPROC __glewGetColorTableSGI;

extern __declspec(dllimport) PFNGLFINISHTEXTURESUNXPROC __glewFinishTextureSUNX;

extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORBSUNPROC __glewGlobalAlphaFactorbSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORDSUNPROC __glewGlobalAlphaFactordSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORFSUNPROC __glewGlobalAlphaFactorfSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORISUNPROC __glewGlobalAlphaFactoriSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORSSUNPROC __glewGlobalAlphaFactorsSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORUBSUNPROC __glewGlobalAlphaFactorubSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORUISUNPROC __glewGlobalAlphaFactoruiSUN;
extern __declspec(dllimport) PFNGLGLOBALALPHAFACTORUSSUNPROC __glewGlobalAlphaFactorusSUN;

extern __declspec(dllimport) PFNGLREADVIDEOPIXELSSUNPROC __glewReadVideoPixelsSUN;

extern __declspec(dllimport) PFNGLREPLACEMENTCODEPOINTERSUNPROC __glewReplacementCodePointerSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUBSUNPROC __glewReplacementCodeubSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUBVSUNPROC __glewReplacementCodeubvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUISUNPROC __glewReplacementCodeuiSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUIVSUNPROC __glewReplacementCodeuivSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUSSUNPROC __glewReplacementCodeusSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUSVSUNPROC __glewReplacementCodeusvSUN;

extern __declspec(dllimport) PFNGLCOLOR3FVERTEX3FSUNPROC __glewColor3fVertex3fSUN;
extern __declspec(dllimport) PFNGLCOLOR3FVERTEX3FVSUNPROC __glewColor3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX2FSUNPROC __glewColor4ubVertex2fSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX2FVSUNPROC __glewColor4ubVertex2fvSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX3FSUNPROC __glewColor4ubVertex3fSUN;
extern __declspec(dllimport) PFNGLCOLOR4UBVERTEX3FVSUNPROC __glewColor4ubVertex3fvSUN;
extern __declspec(dllimport) PFNGLNORMAL3FVERTEX3FSUNPROC __glewNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLNORMAL3FVERTEX3FVSUNPROC __glewNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FSUNPROC __glewReplacementCodeuiColor3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FSUNPROC __glewReplacementCodeuiColor4ubVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUICOLOR4UBVERTEX3FVSUNPROC __glewReplacementCodeuiColor4ubVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUINORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUITEXCOORD2FVERTEX3FVSUNPROC __glewReplacementCodeuiTexCoord2fVertex3fvSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUIVERTEX3FSUNPROC __glewReplacementCodeuiVertex3fSUN;
extern __declspec(dllimport) PFNGLREPLACEMENTCODEUIVERTEX3FVSUNPROC __glewReplacementCodeuiVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR3FVERTEX3FSUNPROC __glewTexCoord2fColor3fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR3FVERTEX3FVSUNPROC __glewTexCoord2fColor3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fColor4fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FSUNPROC __glewTexCoord2fColor4ubVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FCOLOR4UBVERTEX3FVSUNPROC __glewTexCoord2fColor4ubVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FNORMAL3FVERTEX3FSUNPROC __glewTexCoord2fNormal3fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FNORMAL3FVERTEX3FVSUNPROC __glewTexCoord2fNormal3fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FVERTEX3FSUNPROC __glewTexCoord2fVertex3fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD2FVERTEX3FVSUNPROC __glewTexCoord2fVertex3fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FCOLOR4FNORMAL3FVERTEX4FVSUNPROC __glewTexCoord4fColor4fNormal3fVertex4fvSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FVERTEX4FSUNPROC __glewTexCoord4fVertex4fSUN;
extern __declspec(dllimport) PFNGLTEXCOORD4FVERTEX4FVSUNPROC __glewTexCoord4fVertex4fvSUN;

extern __declspec(dllimport) PFNGLADDSWAPHINTRECTWINPROC __glewAddSwapHintRectWIN;




#line 18357 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_2;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_2_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_3;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_4;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_1_5;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_2_0;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_2_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_0;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_2;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_3_3;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_0;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_1;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_2;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_3;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_4;
extern __declspec(dllimport) GLboolean __GLEW_VERSION_4_5;
extern __declspec(dllimport) GLboolean __GLEW_3DFX_multisample;
extern __declspec(dllimport) GLboolean __GLEW_3DFX_tbuffer;
extern __declspec(dllimport) GLboolean __GLEW_3DFX_texture_compression_FXT1;
extern __declspec(dllimport) GLboolean __GLEW_AMD_blend_minmax_factor;
extern __declspec(dllimport) GLboolean __GLEW_AMD_conservative_depth;
extern __declspec(dllimport) GLboolean __GLEW_AMD_debug_output;
extern __declspec(dllimport) GLboolean __GLEW_AMD_depth_clamp_separate;
extern __declspec(dllimport) GLboolean __GLEW_AMD_draw_buffers_blend;
extern __declspec(dllimport) GLboolean __GLEW_AMD_gcn_shader;
extern __declspec(dllimport) GLboolean __GLEW_AMD_gpu_shader_int64;
extern __declspec(dllimport) GLboolean __GLEW_AMD_interleaved_elements;
extern __declspec(dllimport) GLboolean __GLEW_AMD_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_AMD_name_gen_delete;
extern __declspec(dllimport) GLboolean __GLEW_AMD_occlusion_query_event;
extern __declspec(dllimport) GLboolean __GLEW_AMD_performance_monitor;
extern __declspec(dllimport) GLboolean __GLEW_AMD_pinned_memory;
extern __declspec(dllimport) GLboolean __GLEW_AMD_query_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_AMD_sample_positions;
extern __declspec(dllimport) GLboolean __GLEW_AMD_seamless_cubemap_per_texture;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_atomic_counter_ops;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_stencil_export;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_stencil_value_export;
extern __declspec(dllimport) GLboolean __GLEW_AMD_shader_trinary_minmax;
extern __declspec(dllimport) GLboolean __GLEW_AMD_sparse_texture;
extern __declspec(dllimport) GLboolean __GLEW_AMD_stencil_operation_extended;
extern __declspec(dllimport) GLboolean __GLEW_AMD_texture_texture4;
extern __declspec(dllimport) GLboolean __GLEW_AMD_transform_feedback3_lines_triangles;
extern __declspec(dllimport) GLboolean __GLEW_AMD_transform_feedback4;
extern __declspec(dllimport) GLboolean __GLEW_AMD_vertex_shader_layer;
extern __declspec(dllimport) GLboolean __GLEW_AMD_vertex_shader_tessellator;
extern __declspec(dllimport) GLboolean __GLEW_AMD_vertex_shader_viewport_index;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_depth_texture;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_framebuffer_blit;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_framebuffer_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_instanced_arrays;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_pack_reverse_row_order;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_program_binary;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_compression_dxt1;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_compression_dxt3;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_compression_dxt5;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_texture_usage;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_timer_query;
extern __declspec(dllimport) GLboolean __GLEW_ANGLE_translated_shader_source;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_aux_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_client_storage;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_element_array;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_fence;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_float_pixels;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_flush_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_object_purgeable;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_pixel_buffer;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_rgb_422;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_row_bytes;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_specular_vector;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_texture_range;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_transform_hint;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_vertex_array_range;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_vertex_program_evaluators;
extern __declspec(dllimport) GLboolean __GLEW_APPLE_ycbcr_422;
extern __declspec(dllimport) GLboolean __GLEW_ARB_ES2_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_ES3_1_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_ES3_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_arrays_of_arrays;
extern __declspec(dllimport) GLboolean __GLEW_ARB_base_instance;
extern __declspec(dllimport) GLboolean __GLEW_ARB_bindless_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_blend_func_extended;
extern __declspec(dllimport) GLboolean __GLEW_ARB_buffer_storage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_cl_event;
extern __declspec(dllimport) GLboolean __GLEW_ARB_clear_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_clear_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_clip_control;
extern __declspec(dllimport) GLboolean __GLEW_ARB_color_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compressed_texture_pixel_storage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compute_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_compute_variable_group_size;
extern __declspec(dllimport) GLboolean __GLEW_ARB_conditional_render_inverted;
extern __declspec(dllimport) GLboolean __GLEW_ARB_conservative_depth;
extern __declspec(dllimport) GLboolean __GLEW_ARB_copy_buffer;
extern __declspec(dllimport) GLboolean __GLEW_ARB_copy_image;
extern __declspec(dllimport) GLboolean __GLEW_ARB_cull_distance;
extern __declspec(dllimport) GLboolean __GLEW_ARB_debug_output;
extern __declspec(dllimport) GLboolean __GLEW_ARB_depth_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_ARB_depth_clamp;
extern __declspec(dllimport) GLboolean __GLEW_ARB_depth_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_derivative_control;
extern __declspec(dllimport) GLboolean __GLEW_ARB_direct_state_access;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_buffers_blend;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_elements_base_vertex;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_ARB_draw_instanced;
extern __declspec(dllimport) GLboolean __GLEW_ARB_enhanced_layouts;
extern __declspec(dllimport) GLboolean __GLEW_ARB_explicit_attrib_location;
extern __declspec(dllimport) GLboolean __GLEW_ARB_explicit_uniform_location;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_coord_conventions;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_layer_viewport;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_program;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_program_shadow;
extern __declspec(dllimport) GLboolean __GLEW_ARB_fragment_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_framebuffer_no_attachments;
extern __declspec(dllimport) GLboolean __GLEW_ARB_framebuffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_framebuffer_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_ARB_geometry_shader4;
extern __declspec(dllimport) GLboolean __GLEW_ARB_get_program_binary;
extern __declspec(dllimport) GLboolean __GLEW_ARB_get_texture_sub_image;
extern __declspec(dllimport) GLboolean __GLEW_ARB_gpu_shader5;
extern __declspec(dllimport) GLboolean __GLEW_ARB_gpu_shader_fp64;
extern __declspec(dllimport) GLboolean __GLEW_ARB_half_float_pixel;
extern __declspec(dllimport) GLboolean __GLEW_ARB_half_float_vertex;
extern __declspec(dllimport) GLboolean __GLEW_ARB_imaging;
extern __declspec(dllimport) GLboolean __GLEW_ARB_indirect_parameters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_instanced_arrays;
extern __declspec(dllimport) GLboolean __GLEW_ARB_internalformat_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_internalformat_query2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_invalidate_subdata;
extern __declspec(dllimport) GLboolean __GLEW_ARB_map_buffer_alignment;
extern __declspec(dllimport) GLboolean __GLEW_ARB_map_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_ARB_matrix_palette;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multi_bind;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ARB_multitexture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_occlusion_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_occlusion_query2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_pipeline_statistics_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_pixel_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_point_parameters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_point_sprite;
extern __declspec(dllimport) GLboolean __GLEW_ARB_program_interface_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_provoking_vertex;
extern __declspec(dllimport) GLboolean __GLEW_ARB_query_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robust_buffer_access_behavior;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robustness;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robustness_application_isolation;
extern __declspec(dllimport) GLboolean __GLEW_ARB_robustness_share_group_isolation;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sample_shading;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sampler_objects;
extern __declspec(dllimport) GLboolean __GLEW_ARB_seamless_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_ARB_seamless_cubemap_per_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_separate_shader_objects;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_atomic_counters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_bit_encoding;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_draw_parameters;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_group_vote;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_image_load_store;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_image_size;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_objects;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_precision;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_stencil_export;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_storage_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_subroutine;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_texture_image_samples;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shader_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_100;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_420pack;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_include;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shading_language_packing;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shadow;
extern __declspec(dllimport) GLboolean __GLEW_ARB_shadow_ambient;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sparse_buffer;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sparse_texture;
extern __declspec(dllimport) GLboolean __GLEW_ARB_stencil_texturing;
extern __declspec(dllimport) GLboolean __GLEW_ARB_sync;
extern __declspec(dllimport) GLboolean __GLEW_ARB_tessellation_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_barrier;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_border_clamp;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_buffer_object_rgb32;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_buffer_range;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_compression;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_compression_bptc;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_compression_rgtc;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_cube_map_array;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_add;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_combine;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_crossbar;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_env_dot3;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_float;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_gather;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_mirror_clamp_to_edge;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_mirrored_repeat;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_non_power_of_two;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_query_levels;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_query_lod;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_rg;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_rgb10_a2ui;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_stencil8;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_storage;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_storage_multisample;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_swizzle;
extern __declspec(dllimport) GLboolean __GLEW_ARB_texture_view;
extern __declspec(dllimport) GLboolean __GLEW_ARB_timer_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback2;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback3;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback_instanced;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transform_feedback_overflow_query;
extern __declspec(dllimport) GLboolean __GLEW_ARB_transpose_matrix;
extern __declspec(dllimport) GLboolean __GLEW_ARB_uniform_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_array_bgra;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_attrib_64bit;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_attrib_binding;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_blend;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_program;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_shader;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_type_10f_11f_11f_rev;
extern __declspec(dllimport) GLboolean __GLEW_ARB_vertex_type_2_10_10_10_rev;
extern __declspec(dllimport) GLboolean __GLEW_ARB_viewport_array;
extern __declspec(dllimport) GLboolean __GLEW_ARB_window_pos;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_point_sprites;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_texture_env_combine3;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_texture_env_route;
extern __declspec(dllimport) GLboolean __GLEW_ATIX_vertex_shader_output_point_size;
extern __declspec(dllimport) GLboolean __GLEW_ATI_draw_buffers;
extern __declspec(dllimport) GLboolean __GLEW_ATI_element_array;
extern __declspec(dllimport) GLboolean __GLEW_ATI_envmap_bumpmap;
extern __declspec(dllimport) GLboolean __GLEW_ATI_fragment_shader;
extern __declspec(dllimport) GLboolean __GLEW_ATI_map_object_buffer;
extern __declspec(dllimport) GLboolean __GLEW_ATI_meminfo;
extern __declspec(dllimport) GLboolean __GLEW_ATI_pn_triangles;
extern __declspec(dllimport) GLboolean __GLEW_ATI_separate_stencil;
extern __declspec(dllimport) GLboolean __GLEW_ATI_shader_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_ATI_text_fragment_shader;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_compression_3dc;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_env_combine3;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_float;
extern __declspec(dllimport) GLboolean __GLEW_ATI_texture_mirror_once;
extern __declspec(dllimport) GLboolean __GLEW_ATI_vertex_array_object;
extern __declspec(dllimport) GLboolean __GLEW_ATI_vertex_attrib_array_object;
extern __declspec(dllimport) GLboolean __GLEW_ATI_vertex_streams;
extern __declspec(dllimport) GLboolean __GLEW_EXT_422_pixels;
extern __declspec(dllimport) GLboolean __GLEW_EXT_Cg_shader;
extern __declspec(dllimport) GLboolean __GLEW_EXT_abgr;
extern __declspec(dllimport) GLboolean __GLEW_EXT_bgra;
extern __declspec(dllimport) GLboolean __GLEW_EXT_bindable_uniform;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_color;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_equation_separate;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_func_separate;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_logic_op;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_minmax;
extern __declspec(dllimport) GLboolean __GLEW_EXT_blend_subtract;
extern __declspec(dllimport) GLboolean __GLEW_EXT_clip_volume_hint;
extern __declspec(dllimport) GLboolean __GLEW_EXT_cmyka;
extern __declspec(dllimport) GLboolean __GLEW_EXT_color_subtable;
extern __declspec(dllimport) GLboolean __GLEW_EXT_compiled_vertex_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_convolution;
extern __declspec(dllimport) GLboolean __GLEW_EXT_coordinate_frame;
extern __declspec(dllimport) GLboolean __GLEW_EXT_copy_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_cull_vertex;
extern __declspec(dllimport) GLboolean __GLEW_EXT_debug_label;
extern __declspec(dllimport) GLboolean __GLEW_EXT_debug_marker;
extern __declspec(dllimport) GLboolean __GLEW_EXT_depth_bounds_test;
extern __declspec(dllimport) GLboolean __GLEW_EXT_direct_state_access;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_buffers2;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_instanced;
extern __declspec(dllimport) GLboolean __GLEW_EXT_draw_range_elements;
extern __declspec(dllimport) GLboolean __GLEW_EXT_fog_coord;
extern __declspec(dllimport) GLboolean __GLEW_EXT_fragment_lighting;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_blit;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_multisample;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_multisample_blit_scaled;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_framebuffer_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_EXT_geometry_shader4;
extern __declspec(dllimport) GLboolean __GLEW_EXT_gpu_program_parameters;
extern __declspec(dllimport) GLboolean __GLEW_EXT_gpu_shader4;
extern __declspec(dllimport) GLboolean __GLEW_EXT_histogram;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_array_formats;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_func;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_material;
extern __declspec(dllimport) GLboolean __GLEW_EXT_index_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_light_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_misc_attribute;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multi_draw_arrays;
extern __declspec(dllimport) GLboolean __GLEW_EXT_multisample;
extern __declspec(dllimport) GLboolean __GLEW_EXT_packed_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_EXT_packed_float;
extern __declspec(dllimport) GLboolean __GLEW_EXT_packed_pixels;
extern __declspec(dllimport) GLboolean __GLEW_EXT_paletted_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pixel_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pixel_transform;
extern __declspec(dllimport) GLboolean __GLEW_EXT_pixel_transform_color_table;
extern __declspec(dllimport) GLboolean __GLEW_EXT_point_parameters;
extern __declspec(dllimport) GLboolean __GLEW_EXT_polygon_offset;
extern __declspec(dllimport) GLboolean __GLEW_EXT_provoking_vertex;
extern __declspec(dllimport) GLboolean __GLEW_EXT_rescale_normal;
extern __declspec(dllimport) GLboolean __GLEW_EXT_scene_marker;
extern __declspec(dllimport) GLboolean __GLEW_EXT_secondary_color;
extern __declspec(dllimport) GLboolean __GLEW_EXT_separate_shader_objects;
extern __declspec(dllimport) GLboolean __GLEW_EXT_separate_specular_color;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_image_load_formatted;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_image_load_store;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shader_integer_mix;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shadow_funcs;
extern __declspec(dllimport) GLboolean __GLEW_EXT_shared_texture_palette;
extern __declspec(dllimport) GLboolean __GLEW_EXT_stencil_clear_tag;
extern __declspec(dllimport) GLboolean __GLEW_EXT_stencil_two_side;
extern __declspec(dllimport) GLboolean __GLEW_EXT_stencil_wrap;
extern __declspec(dllimport) GLboolean __GLEW_EXT_subtexture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture3D;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_dxt1;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_latc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_rgtc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_compression_s3tc;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_cube_map;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_edge_clamp;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env_add;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env_combine;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_env_dot3;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_filter_anisotropic;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_integer;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_lod_bias;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_mirror_clamp;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_object;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_perturb_normal;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_sRGB;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_sRGB_decode;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_shared_exponent;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_snorm;
extern __declspec(dllimport) GLboolean __GLEW_EXT_texture_swizzle;
extern __declspec(dllimport) GLboolean __GLEW_EXT_timer_query;
extern __declspec(dllimport) GLboolean __GLEW_EXT_transform_feedback;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_array;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_array_bgra;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_attrib_64bit;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_shader;
extern __declspec(dllimport) GLboolean __GLEW_EXT_vertex_weighting;
extern __declspec(dllimport) GLboolean __GLEW_EXT_x11_sync_object;
extern __declspec(dllimport) GLboolean __GLEW_GREMEDY_frame_terminator;
extern __declspec(dllimport) GLboolean __GLEW_GREMEDY_string_marker;
extern __declspec(dllimport) GLboolean __GLEW_HP_convolution_border_modes;
extern __declspec(dllimport) GLboolean __GLEW_HP_image_transform;
extern __declspec(dllimport) GLboolean __GLEW_HP_occlusion_test;
extern __declspec(dllimport) GLboolean __GLEW_HP_texture_lighting;
extern __declspec(dllimport) GLboolean __GLEW_IBM_cull_vertex;
extern __declspec(dllimport) GLboolean __GLEW_IBM_multimode_draw_arrays;
extern __declspec(dllimport) GLboolean __GLEW_IBM_rasterpos_clip;
extern __declspec(dllimport) GLboolean __GLEW_IBM_static_data;
extern __declspec(dllimport) GLboolean __GLEW_IBM_texture_mirrored_repeat;
extern __declspec(dllimport) GLboolean __GLEW_IBM_vertex_array_lists;
extern __declspec(dllimport) GLboolean __GLEW_INGR_color_clamp;
extern __declspec(dllimport) GLboolean __GLEW_INGR_interlace_read;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_fragment_shader_ordering;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_map_texture;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_parallel_arrays;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_performance_query;
extern __declspec(dllimport) GLboolean __GLEW_INTEL_texture_scissor;
extern __declspec(dllimport) GLboolean __GLEW_KHR_blend_equation_advanced;
extern __declspec(dllimport) GLboolean __GLEW_KHR_blend_equation_advanced_coherent;
extern __declspec(dllimport) GLboolean __GLEW_KHR_context_flush_control;
extern __declspec(dllimport) GLboolean __GLEW_KHR_debug;
extern __declspec(dllimport) GLboolean __GLEW_KHR_robust_buffer_access_behavior;
extern __declspec(dllimport) GLboolean __GLEW_KHR_robustness;
extern __declspec(dllimport) GLboolean __GLEW_KHR_texture_compression_astc_hdr;
extern __declspec(dllimport) GLboolean __GLEW_KHR_texture_compression_astc_ldr;
extern __declspec(dllimport) GLboolean __GLEW_KTX_buffer_region;
extern __declspec(dllimport) GLboolean __GLEW_MESAX_texture_stack;
extern __declspec(dllimport) GLboolean __GLEW_MESA_pack_invert;
extern __declspec(dllimport) GLboolean __GLEW_MESA_resize_buffers;
extern __declspec(dllimport) GLboolean __GLEW_MESA_window_pos;
extern __declspec(dllimport) GLboolean __GLEW_MESA_ycbcr_texture;
extern __declspec(dllimport) GLboolean __GLEW_NVX_conditional_render;
extern __declspec(dllimport) GLboolean __GLEW_NVX_gpu_memory_info;
extern __declspec(dllimport) GLboolean __GLEW_NV_bindless_multi_draw_indirect;
extern __declspec(dllimport) GLboolean __GLEW_NV_bindless_multi_draw_indirect_count;
extern __declspec(dllimport) GLboolean __GLEW_NV_bindless_texture;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_equation_advanced;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_equation_advanced_coherent;
extern __declspec(dllimport) GLboolean __GLEW_NV_blend_square;
extern __declspec(dllimport) GLboolean __GLEW_NV_compute_program5;
extern __declspec(dllimport) GLboolean __GLEW_NV_conditional_render;
extern __declspec(dllimport) GLboolean __GLEW_NV_copy_depth_to_color;
extern __declspec(dllimport) GLboolean __GLEW_NV_copy_image;
extern __declspec(dllimport) GLboolean __GLEW_NV_deep_texture3D;
extern __declspec(dllimport) GLboolean __GLEW_NV_depth_buffer_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_depth_clamp;
extern __declspec(dllimport) GLboolean __GLEW_NV_depth_range_unclamped;
extern __declspec(dllimport) GLboolean __GLEW_NV_draw_texture;
extern __declspec(dllimport) GLboolean __GLEW_NV_evaluators;
extern __declspec(dllimport) GLboolean __GLEW_NV_explicit_multisample;
extern __declspec(dllimport) GLboolean __GLEW_NV_fence;
extern __declspec(dllimport) GLboolean __GLEW_NV_float_buffer;
extern __declspec(dllimport) GLboolean __GLEW_NV_fog_distance;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program2;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_fragment_program_option;
extern __declspec(dllimport) GLboolean __GLEW_NV_framebuffer_multisample_coverage;
extern __declspec(dllimport) GLboolean __GLEW_NV_geometry_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_geometry_shader4;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program5;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program5_mem_extended;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_program_fp64;
extern __declspec(dllimport) GLboolean __GLEW_NV_gpu_shader5;
extern __declspec(dllimport) GLboolean __GLEW_NV_half_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_light_max_exponent;
extern __declspec(dllimport) GLboolean __GLEW_NV_multisample_coverage;
extern __declspec(dllimport) GLboolean __GLEW_NV_multisample_filter_hint;
extern __declspec(dllimport) GLboolean __GLEW_NV_occlusion_query;
extern __declspec(dllimport) GLboolean __GLEW_NV_packed_depth_stencil;
extern __declspec(dllimport) GLboolean __GLEW_NV_parameter_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_NV_parameter_buffer_object2;
extern __declspec(dllimport) GLboolean __GLEW_NV_path_rendering;
extern __declspec(dllimport) GLboolean __GLEW_NV_pixel_data_range;
extern __declspec(dllimport) GLboolean __GLEW_NV_point_sprite;
extern __declspec(dllimport) GLboolean __GLEW_NV_present_video;
extern __declspec(dllimport) GLboolean __GLEW_NV_primitive_restart;
extern __declspec(dllimport) GLboolean __GLEW_NV_register_combiners;
extern __declspec(dllimport) GLboolean __GLEW_NV_register_combiners2;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_counters;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_float;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_atomic_int64;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_buffer_load;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_storage_buffer_object;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_thread_group;
extern __declspec(dllimport) GLboolean __GLEW_NV_shader_thread_shuffle;
extern __declspec(dllimport) GLboolean __GLEW_NV_tessellation_program5;
extern __declspec(dllimport) GLboolean __GLEW_NV_texgen_emboss;
extern __declspec(dllimport) GLboolean __GLEW_NV_texgen_reflection;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_barrier;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_compression_vtc;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_env_combine4;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_expand_normal;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_multisample;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_rectangle;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_shader;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_shader2;
extern __declspec(dllimport) GLboolean __GLEW_NV_texture_shader3;
extern __declspec(dllimport) GLboolean __GLEW_NV_transform_feedback;
extern __declspec(dllimport) GLboolean __GLEW_NV_transform_feedback2;
extern __declspec(dllimport) GLboolean __GLEW_NV_vdpau_interop;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_array_range;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_array_range2;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_attrib_integer_64bit;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_buffer_unified_memory;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program1_1;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program2;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program2_option;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program3;
extern __declspec(dllimport) GLboolean __GLEW_NV_vertex_program4;
extern __declspec(dllimport) GLboolean __GLEW_NV_video_capture;
extern __declspec(dllimport) GLboolean __GLEW_OES_byte_coordinates;
extern __declspec(dllimport) GLboolean __GLEW_OES_compressed_paletted_texture;
extern __declspec(dllimport) GLboolean __GLEW_OES_read_format;
extern __declspec(dllimport) GLboolean __GLEW_OES_single_precision;
extern __declspec(dllimport) GLboolean __GLEW_OML_interlace;
extern __declspec(dllimport) GLboolean __GLEW_OML_resample;
extern __declspec(dllimport) GLboolean __GLEW_OML_subsample;
extern __declspec(dllimport) GLboolean __GLEW_PGI_misc_hints;
extern __declspec(dllimport) GLboolean __GLEW_PGI_vertex_hints;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_ES1_0_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_ES1_1_compatibility;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_enable;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_error_string;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_extension_query;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_log;
extern __declspec(dllimport) GLboolean __GLEW_REGAL_proc_address;
extern __declspec(dllimport) GLboolean __GLEW_REND_screen_coordinates;
extern __declspec(dllimport) GLboolean __GLEW_S3_s3tc;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_color_range;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_detail_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_fog_function;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_generate_mipmap;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_multisample;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_pixel_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_point_line_texgen;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_sharpen_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture4D;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_border_clamp;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_edge_clamp;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_filter4;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_lod;
extern __declspec(dllimport) GLboolean __GLEW_SGIS_texture_select;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_async;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_async_histogram;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_async_pixel;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_blend_alpha_minmax;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_clipmap;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_convolution_accuracy;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_depth_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_flush_raster;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_offset;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fog_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_fragment_specular_lighting;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_framezoom;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_interlace;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_ir_instrument1;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_list_priority;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_pixel_texture;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_pixel_texture_bits;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_reference_plane;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_resample;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_shadow;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_shadow_ambient;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_sprite;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_tag_sample_buffer;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_add_env;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_coordinate_clamp;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_lod_bias;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_multi_buffer;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_range;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_texture_scale_bias;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_vertex_preclip;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_vertex_preclip_hint;
extern __declspec(dllimport) GLboolean __GLEW_SGIX_ycrcb;
extern __declspec(dllimport) GLboolean __GLEW_SGI_color_matrix;
extern __declspec(dllimport) GLboolean __GLEW_SGI_color_table;
extern __declspec(dllimport) GLboolean __GLEW_SGI_texture_color_table;
extern __declspec(dllimport) GLboolean __GLEW_SUNX_constant_data;
extern __declspec(dllimport) GLboolean __GLEW_SUN_convolution_border_modes;
extern __declspec(dllimport) GLboolean __GLEW_SUN_global_alpha;
extern __declspec(dllimport) GLboolean __GLEW_SUN_mesh_array;
extern __declspec(dllimport) GLboolean __GLEW_SUN_read_video_pixels;
extern __declspec(dllimport) GLboolean __GLEW_SUN_slice_accum;
extern __declspec(dllimport) GLboolean __GLEW_SUN_triangle_list;
extern __declspec(dllimport) GLboolean __GLEW_SUN_vertex;
extern __declspec(dllimport) GLboolean __GLEW_WIN_phong_shading;
extern __declspec(dllimport) GLboolean __GLEW_WIN_specular_fog;
extern __declspec(dllimport) GLboolean __GLEW_WIN_swap_hint;








































extern __declspec(dllimport) GLenum __stdcall glewInit (void);
extern __declspec(dllimport) GLboolean __stdcall glewIsSupported (const char *name);





#line 18956 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

extern __declspec(dllimport) GLboolean glewExperimental;
extern __declspec(dllimport) GLboolean __stdcall glewGetExtension (const char *name);
extern __declspec(dllimport) const GLubyte * __stdcall glewGetErrorString (GLenum error);
extern __declspec(dllimport) const GLubyte * __stdcall glewGetString (GLenum name);


}
#line 18965 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




#line 18970 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




#line 18975 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




#line 18980 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"




#line 18985 "d:\\gl files\\glew-1.11.0\\include\\gl\\glew.h"

#line 4 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\gl files\\freeglut\\include\\gl\\freeglut.h"
















#line 1 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"































    extern "C" {
#line 34 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"




















#line 55 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"
#line 56 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"



#line 60 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"


#line 63 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"





















#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"



















#pragma warning(push)
#line 22 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"
#pragma warning(disable:4001) 
#line 24 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#pragma once



































































































































































#line 190 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"











#line 202 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"







#line 210 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"
#line 211 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"







#line 219 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"
#line 220 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"






#line 227 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 229 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 231 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 233 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 235 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 237 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 239 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 241 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"


#line 244 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"
#line 245 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"








#line 254 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"



#line 258 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"



#line 262 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"



#line 266 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"



#line 270 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"



#line 274 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 276 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"



#pragma warning(pop)


#line 283 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"
#line 284 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 286 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdkddkver.h"

#line 23 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"





#pragma once
#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#pragma region Application Family



















































#line 84 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"




















#line 105 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"



#line 109 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"



#line 113 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"



#line 117 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"



#line 121 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"



#line 125 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"





#line 131 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"




#line 136 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 137 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"







#line 145 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 146 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"



#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 153 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#pragma warning(push)
#line 156 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 160 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\excpt.h"








#pragma once


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 13 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\excpt.h"

__pragma(pack(push, 8)) extern "C" {




typedef enum _EXCEPTION_DISPOSITION
{
    ExceptionContinueExecution,
    ExceptionContinueSearch,
    ExceptionNestedException,
    ExceptionCollidedUnwind
} EXCEPTION_DISPOSITION;






    struct _EXCEPTION_RECORD;
    struct _CONTEXT;

    EXCEPTION_DISPOSITION __cdecl _except_handler(
          struct _EXCEPTION_RECORD* _ExceptionRecord,
          void*                     _EstablisherFrame,
          struct _CONTEXT*       _ContextRecord,
          void*                  _DispatcherContext
        );
















#line 58 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\excpt.h"











unsigned long __cdecl _exception_code(void);
void *        __cdecl _exception_info(void);
int           __cdecl _abnormal_termination(void);










} __pragma(pack(pop))
#line 161 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdarg.h"







#pragma once


#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vcruntime.h"































































































































































































































































































































#line 12 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\stdarg.h"

__pragma(pack(push, 8)) extern "C" {










} __pragma(pack(pop))
#line 162 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 163 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"













#pragma once


extern "C" {
#line 19 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"





#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"











#pragma once

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"
















#pragma once
#line 19 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"



 

#line 25 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"
  
 #line 27 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"

 



  
 #line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"

 
  
  
 #line 39 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"

#line 41 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"



















#line 61 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"


extern "C" {
#line 65 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"




























#line 94 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"












#line 107 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"






































































































#line 210 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"
#line 211 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"





































#line 249 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"



























#line 277 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"























































































#line 365 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"



















#line 385 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"





#line 391 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"


#line 394 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"




































































#line 463 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"










#line 474 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"








                                

}
#line 486 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"



























#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings_strict.h"




























#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings_strict.h"





























































































































































#pragma once
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings_undef.h"








































































































































































































































































































































































































































































#line 189 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings_strict.h"











































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1065 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings_strict.h"
































































#line 1130 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings_strict.h"






















































#line 1185 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings_strict.h"
#line 1186 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings_strict.h"
#line 1187 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings_strict.h"

#line 514 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"
#line 515 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"

















#line 533 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"




























































































































#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdv_driverspecs.h"





















#line 23 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\sdv_driverspecs.h"
#line 126 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"



#pragma once
#line 131 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"


extern "C" {
#line 135 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"




































































































#line 236 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"

    
    
    
    
    
    
    
    
    
    
    


#line 251 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"

    
    
    
    
    

    
    
    
    
    
    
    

    
    
    
    



    
    


    
    
    
    
    
    
    
    
    
    
    
    


    
    


    
    


    
    



    
    









    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    


    


    
    
    
    
    

    


    
    
    
    
    

    


    
    
    
    
    

    


    
    
    
    
    


    




    
    
    
    
    

    


    
    
    
    
    


    


    
    
    
    
    
    

    


    
    
    

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    

    
    
    
    
    

    
    
    
    
    

    
    
    
    
    

    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    
    

    
    

    
    
    
    

    

    
    
    

    

    
    
    
    
    
    
    
    
    
    
    
    

    
    


    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    


    
    
    
    
     
    

    
    
        
        
        
        
    
    
    
    
    
    

    
    
    

    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    

    

    
    
    
    
    
    
    
    
    
    
    
#line 665 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"
    
#line 667 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"
    


    
    
    
    
    
    


    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    

    
    
    
    
    
    

    
    
    
    
    
    
    
    
    

    
    

    
    

    
    
    
    
    
    


    
    
    

    
	

    
    


    
    


    
    
    


    
    
    


    
    











































































    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

#line 853 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"

    
    
    

    
    
    


}
#line 865 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"

#line 867 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\driverspecs.h"


#line 535 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"












#line 548 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"

#line 550 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\specstrings.h"



#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"



#pragma region Application Family





#line 25 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"
#line 26 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"













#line 40 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"


extern "C" {
#line 44 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"







typedef unsigned long ULONG;
typedef ULONG *PULONG;
typedef unsigned short USHORT;
typedef USHORT *PUSHORT;
typedef unsigned char UCHAR;
typedef UCHAR *PUCHAR;
typedef   char *PSZ;
#line 59 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"













#line 73 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"



#line 77 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"



#line 81 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"



#line 85 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"



#line 89 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"












#line 102 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"






#line 109 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"



#line 113 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"
#line 114 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"


























#line 141 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"




#line 146 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"
#line 147 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"







#line 155 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"

typedef unsigned long       DWORD;
typedef int                 BOOL;
typedef unsigned char       BYTE;
typedef unsigned short      WORD;
typedef float               FLOAT;
typedef FLOAT               *PFLOAT;
typedef BOOL            *PBOOL;
typedef BOOL             *LPBOOL;
typedef BYTE            *PBYTE;
typedef BYTE             *LPBYTE;
typedef int             *PINT;
typedef int              *LPINT;
typedef WORD            *PWORD;
typedef WORD             *LPWORD;
typedef long             *LPLONG;
typedef DWORD           *PDWORD;
typedef DWORD            *LPDWORD;
typedef void             *LPVOID;
typedef const void       *LPCVOID;

typedef int                 INT;
typedef unsigned int        UINT;
typedef unsigned int        *PUINT;



#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





















#pragma warning(push)
#line 24 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma warning(disable:4201) 
#pragma warning(disable:4214) 


extern "C" {
#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



















#line 50 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"









#line 60 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 61 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"









#line 71 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 78 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 79 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\kernelspecs.h"






































#pragma once
#line 41 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\kernelspecs.h"


extern "C" {
#line 45 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\kernelspecs.h"

    
    
    

    
    
    

    
    
    #line 57 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\kernelspecs.h"
    

#line 60 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\kernelspecs.h"
    

#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\kernelspecs.h"
    

#line 66 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\kernelspecs.h"

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    
    
    
    
    
    
    


    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    

    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    

    
    
    
    
    
    
    

    
    















}
#line 251 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\kernelspecs.h"

#line 253 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\kernelspecs.h"
#line 84 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 88 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





#line 94 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 96 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"









#line 106 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 110 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"







#line 118 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


#line 121 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"









#line 131 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 135 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"













#line 149 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





#line 155 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"














#line 170 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"





























#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"
 


#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"
  
   
  

#line 40 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"
  typedef unsigned long POINTER_64_INT;
 #line 42 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"
 
#line 44 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"



#line 48 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"

#line 50 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"







#line 58 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"





#pragma once
#line 65 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"


extern "C" {
#line 69 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"

typedef signed char         INT8, *PINT8;
typedef signed short        INT16, *PINT16;
typedef signed int          INT32, *PINT32;
typedef signed __int64      INT64, *PINT64;
typedef unsigned char       UINT8, *PUINT8;
typedef unsigned short      UINT16, *PUINT16;
typedef unsigned int        UINT32, *PUINT32;
typedef unsigned __int64    UINT64, *PUINT64;





typedef signed int LONG32, *PLONG32;





typedef unsigned int ULONG32, *PULONG32;
typedef unsigned int DWORD32, *PDWORD32;







#line 99 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"

















#line 117 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"











#line 129 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"
    typedef  int INT_PTR, *PINT_PTR;
    typedef  unsigned int UINT_PTR, *PUINT_PTR;

    typedef  long LONG_PTR, *PLONG_PTR;
    typedef  unsigned long ULONG_PTR, *PULONG_PTR;

    

#line 138 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"
#line 139 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"





























































































































































































typedef unsigned short UHALF_PTR, *PUHALF_PTR;
typedef short HALF_PTR, *PHALF_PTR;
typedef  long SHANDLE_PTR;
typedef  unsigned long HANDLE_PTR;

















__inline
void * __ptr64
PtrToPtr64(
    const void *p
    )
{
    return((void * __ptr64) (unsigned __int64) (ULONG_PTR)p );
}

__inline
void *
Ptr64ToPtr(
    const void * __ptr64 p
    )
{
    return((void *) (ULONG_PTR) (unsigned __int64) p);
}

__inline
void * __ptr64
HandleToHandle64(
    const void *h
    )
{
    return((void * __ptr64)(__int64)(LONG_PTR)h );
}

__inline
void *
Handle64ToHandle(
    const void * __ptr64 h
    )
{
    return((void *) (ULONG_PTR) (unsigned __int64) h );
}
#line 385 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"






#line 392 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"























typedef ULONG_PTR SIZE_T, *PSIZE_T;
typedef LONG_PTR SSIZE_T, *PSSIZE_T;









































#line 459 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"





typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;





typedef __int64 LONG64, *PLONG64;






typedef unsigned __int64 ULONG64, *PULONG64;
typedef unsigned __int64 DWORD64, *PDWORD64;







typedef ULONG_PTR KAFFINITY;
typedef KAFFINITY *PKAFFINITY;




}
#line 494 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"

#line 496 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\basetsd.h"
#line 172 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 179 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 186 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 187 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 194 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 195 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 202 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 203 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








#line 212 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 213 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 217 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 224 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 225 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 232 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 233 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 240 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 241 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 248 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 249 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




#line 254 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 256 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 257 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 264 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 265 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#line 272 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 273 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"







#line 281 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 282 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








#line 291 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 292 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

























#line 318 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 319 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"














#line 334 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"







typedef void *PVOID;
typedef void * __ptr64 PVOID64;








#line 352 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





#line 358 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
















#line 375 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








typedef char CHAR;
typedef short SHORT;
typedef long LONG;

typedef int INT;
#line 389 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 390 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






typedef wchar_t WCHAR;    



#line 401 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
typedef const WCHAR *LPCWCH, *PCWCH;

typedef   WCHAR *NWPSTR, *LPWSTR, *PWSTR;
typedef   PWSTR *PZPWSTR;
typedef   const PWSTR *PCZPWSTR;
typedef   WCHAR  *LPUWSTR, *PUWSTR;
typedef   const WCHAR *LPCWSTR, *PCWSTR;
typedef   PCWSTR *PZPCWSTR;
typedef   const PCWSTR *PCZPCWSTR;
typedef   const WCHAR  *LPCUWSTR, *PCUWSTR;

typedef   WCHAR *PZZWSTR;
typedef   const WCHAR *PCZZWSTR;
typedef   WCHAR  *PUZZWSTR;
typedef   const WCHAR  *PCUZZWSTR;

typedef  WCHAR *PNZWCH;
typedef  const WCHAR *PCNZWCH;
typedef  WCHAR  *PUNZWCH;
typedef  const WCHAR  *PCUNZWCH;



typedef const WCHAR *LPCWCHAR, *PCWCHAR;
typedef const WCHAR  *LPCUWCHAR, *PCUWCHAR;





typedef unsigned long UCSCHAR;



















typedef UCSCHAR *PUCSCHAR;
typedef const UCSCHAR *PCUCSCHAR;

typedef UCSCHAR *PUCSSTR;
typedef UCSCHAR  *PUUCSSTR;

typedef const UCSCHAR *PCUCSSTR;
typedef const UCSCHAR  *PCUUCSSTR;

typedef UCSCHAR  *PUUCSCHAR;
typedef const UCSCHAR  *PCUUCSCHAR;

#line 466 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





typedef CHAR *PCHAR, *LPCH, *PCH;
typedef const CHAR *LPCCH, *PCCH;

typedef   CHAR *NPSTR, *LPSTR, *PSTR;
typedef   PSTR *PZPSTR;
typedef   const PSTR *PCZPSTR;
typedef   const CHAR *LPCSTR, *PCSTR;
typedef   PCSTR *PZPCSTR;
typedef   const PCSTR *PCZPCSTR;

typedef   CHAR *PZZSTR;
typedef   const CHAR *PCZZSTR;

typedef  CHAR *PNZCH;
typedef  const CHAR *PCNZCH;

































typedef char TCHAR, *PTCHAR;
typedef unsigned char TBYTE , *PTBYTE ;

#line 523 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef LPCH LPTCH, PTCH;
typedef LPCCH LPCTCH, PCTCH;
typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
typedef PZZSTR PZZTSTR, PUZZTSTR;
typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
typedef PZPSTR PZPTSTR;
typedef PNZCH PNZTCH, PUNZTCH;
typedef PCNZCH PCNZTCH, PCUNZTCH;


#line 536 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



typedef SHORT *PSHORT;  
typedef LONG *PLONG;    








typedef struct _PROCESSOR_NUMBER {
    WORD   Group;
    BYTE  Number;
    BYTE  Reserved;
} PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;






typedef struct _GROUP_AFFINITY {
    KAFFINITY Mask;
    WORD   Group;
    WORD   Reserved[3];
} GROUP_AFFINITY, *PGROUP_AFFINITY;








typedef void *HANDLE;


#line 577 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 579 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 583 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
typedef HANDLE *PHANDLE;







typedef BYTE   FCHAR;
typedef WORD   FSHORT;
typedef DWORD  FLONG;










typedef   long HRESULT;
#line 606 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 607 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




    


#line 615 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"









#line 625 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"













#line 639 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




























typedef char CCHAR;          
typedef DWORD LCID;         
typedef PDWORD PLCID;       
typedef WORD   LANGID;      








typedef enum {
    UNSPECIFIED_COMPARTMENT_ID = 0,
    DEFAULT_COMPARTMENT_ID
} COMPARTMENT_ID, *PCOMPARTMENT_ID;

#line 685 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
























#line 710 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
typedef struct _FLOAT128 {
    __int64 LowPart;
    __int64 HighPart;
} FLOAT128;

typedef FLOAT128 *PFLOAT128;









typedef __int64 LONGLONG;
typedef unsigned __int64 ULONGLONG;


















#line 746 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef LONGLONG *PLONGLONG;
typedef ULONGLONG *PULONGLONG;



typedef LONGLONG USN;



#line 757 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
typedef union _LARGE_INTEGER {
    struct {
        DWORD LowPart;
        LONG HighPart;
    } ;
    struct {
        DWORD LowPart;
        LONG HighPart;
    } u;
#line 767 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
    LONGLONG QuadPart;
} LARGE_INTEGER;

typedef LARGE_INTEGER *PLARGE_INTEGER;



#line 775 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
typedef union _ULARGE_INTEGER {
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } ;
    struct {
        DWORD LowPart;
        DWORD HighPart;
    } u;
#line 785 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
    ULONGLONG QuadPart;
} ULARGE_INTEGER;

typedef ULARGE_INTEGER *PULARGE_INTEGER;





typedef LONG_PTR RTL_REFERENCE_COUNT, *PRTL_REFERENCE_COUNT;









typedef struct _LUID {
    DWORD LowPart;
    LONG HighPart;
} LUID, *PLUID;


typedef ULONGLONG  DWORDLONG;
typedef DWORDLONG *PDWORDLONG;





























#line 844 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"












ULONGLONG
__stdcall
Int64ShllMod32 (
      ULONGLONG Value,
      DWORD ShiftCount
    );

LONGLONG
__stdcall
Int64ShraMod32 (
      LONGLONG Value,
      DWORD ShiftCount
    );

ULONGLONG
__stdcall
Int64ShrlMod32 (
      ULONGLONG Value,
      DWORD ShiftCount
    );


#pragma warning(push)
#line 880 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma warning(disable:4035 4793)               

__inline ULONGLONG
__stdcall
Int64ShllMod32 (
      ULONGLONG Value,
      DWORD ShiftCount
    )
{
    __asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shld    edx, eax, cl
        shl     eax, cl
    }
}

__inline LONGLONG
__stdcall
Int64ShraMod32 (
      LONGLONG Value,
      DWORD ShiftCount
    )
{
    __asm {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        sar     edx, cl
    }
}

__inline ULONGLONG
__stdcall
Int64ShrlMod32 (
      ULONGLONG Value,
      DWORD ShiftCount
    )
{
    __asm    {
        mov     ecx, ShiftCount
        mov     eax, dword ptr [Value]
        mov     edx, dword ptr [Value+4]
        shrd    eax, edx, cl
        shr     edx, cl
    }
}


#pragma warning(pop)


#line 935 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





#line 941 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






extern "C" {
#line 949 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"









































#line 991 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








unsigned int
__cdecl
_rotl (
      unsigned int Value,
      int Shift
    );

unsigned __int64
__cdecl
_rotl64 (
      unsigned __int64 Value,
      int Shift
    );

unsigned int
__cdecl
_rotr (
      unsigned int Value,
      int Shift
    );

unsigned __int64
__cdecl
_rotr64 (
      unsigned __int64 Value,
      int Shift
    );

#pragma intrinsic(_rotl)
#pragma intrinsic(_rotl64)
#pragma intrinsic(_rotr)
#pragma intrinsic(_rotr64)

#line 1033 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


}
#line 1037 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





typedef BYTE  BOOLEAN;           
typedef BOOLEAN *PBOOLEAN;       





typedef struct _LIST_ENTRY {
   struct _LIST_ENTRY *Flink;
   struct _LIST_ENTRY *Blink;
} LIST_ENTRY, *PLIST_ENTRY, * PRLIST_ENTRY;






typedef struct _SINGLE_LIST_ENTRY {
    struct _SINGLE_LIST_ENTRY *Next;
} SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;








typedef struct LIST_ENTRY32 {
    DWORD Flink;
    DWORD Blink;
} LIST_ENTRY32;
typedef LIST_ENTRY32 *PLIST_ENTRY32;

typedef struct LIST_ENTRY64 {
    ULONGLONG Flink;
    ULONGLONG Blink;
} LIST_ENTRY64;
typedef LIST_ENTRY64 *PLIST_ENTRY64;


#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"




















#line 22 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
typedef struct _GUID {
    unsigned long  Data1;
    unsigned short Data2;
    unsigned short Data3;
    unsigned char  Data4[ 8 ];
} GUID;
#line 29 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"




































#line 67 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"








typedef GUID *LPGUID;
#line 77 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"



typedef const GUID *LPCGUID;
#line 82 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"




typedef GUID IID;
typedef IID *LPIID;


typedef GUID CLSID;
typedef CLSID *LPCLSID;


typedef GUID FMTID;
typedef FMTID *LPFMTID;







#line 104 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"







#line 112 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 113 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"







#line 121 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 122 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"







#line 130 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 131 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"







#line 139 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 140 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"

#line 142 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"








__inline int InlineIsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
   return (
      ((unsigned long *) &rguid1)[0] == ((unsigned long *) &rguid2)[0] &&
      ((unsigned long *) &rguid1)[1] == ((unsigned long *) &rguid2)[1] &&
      ((unsigned long *) &rguid1)[2] == ((unsigned long *) &rguid2)[2] &&
      ((unsigned long *) &rguid1)[3] == ((unsigned long *) &rguid2)[3]);
}

__inline int IsEqualGUID(const GUID & rguid1, const GUID & rguid2)
{
    return !memcmp(&rguid1, &rguid2, sizeof(GUID));
}











#line 175 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"

















__inline bool operator==(const GUID & guidOne, const GUID & guidOther)
{
    return !!IsEqualGUID(guidOne,guidOther);
}

__inline bool operator!=(const GUID & guidOne, const GUID & guidOther)
{
    return !(guidOne == guidOther);
}
#line 202 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 203 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 204 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 205 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 206 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\guiddef.h"
#line 1084 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




typedef struct  _OBJECTID {     
    GUID Lineage;
    DWORD Uniquifier;
} OBJECTID;
#line 1093 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"











































































#pragma region Application Family




extern "C++" 
template <typename T, size_t N>
char (*RtlpNumberOf(  T (&)[N] ))[N];



#line 1185 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion











































#line 1230 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





#line 1236 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"









































#line 1278 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




























typedef
 
 
EXCEPTION_DISPOSITION
__stdcall
EXCEPTION_ROUTINE (
      struct _EXCEPTION_RECORD *ExceptionRecord,
      PVOID EstablisherFrame,
      struct _CONTEXT *ContextRecord,
      PVOID DispatcherContext
    );

typedef EXCEPTION_ROUTINE *PEXCEPTION_ROUTINE;























































































































































































































































































































































































































































































































































































































































































































































































































#line 2111 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


























#line 2138 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"











extern "C++" {

    template <size_t S>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE;

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<1>
    {
        typedef INT8 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<2>
    {
        typedef INT16 type;
    };

    template <>
    struct _ENUM_FLAG_INTEGER_FOR_SIZE<4>
    {
        typedef INT32 type;
    };

    
    template <class T>
    struct _ENUM_FLAG_SIZED_INTEGER
    {
        typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type;
    };

}













#line 2194 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"















  


























































#line 2269 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
  
#line 2271 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 2272 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





typedef ULONG_PTR KSPIN_LOCK;
typedef KSPIN_LOCK *PKSPIN_LOCK;







typedef struct __declspec(align(16)) _M128A {
    ULONGLONG Low;
    LONGLONG High;
} M128A, *PM128A;





typedef struct __declspec(align(16)) _XSAVE_FORMAT {
    WORD   ControlWord;
    WORD   StatusWord;
    BYTE  TagWord;
    BYTE  Reserved1;
    WORD   ErrorOpcode;
    DWORD ErrorOffset;
    WORD   ErrorSelector;
    WORD   Reserved2;
    DWORD DataOffset;
    WORD   DataSelector;
    WORD   Reserved3;
    DWORD MxCsr;
    DWORD MxCsr_Mask;
    M128A FloatRegisters[8];






#line 2317 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

    M128A XmmRegisters[8];
    BYTE  Reserved4[224];

#line 2322 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

} XSAVE_FORMAT, *PXSAVE_FORMAT;



typedef struct __declspec(align(8)) _XSAVE_AREA_HEADER {
    DWORD64 Mask;
    DWORD64 Reserved[7];
} XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

typedef struct __declspec(align(16)) _XSAVE_AREA {
    XSAVE_FORMAT LegacyState;
    XSAVE_AREA_HEADER Header;
} XSAVE_AREA, *PXSAVE_AREA;

typedef struct _XSTATE_CONTEXT {
    DWORD64 Mask;
    DWORD Length;
    DWORD Reserved1;
      PXSAVE_AREA Area;


    DWORD Reserved2;
#line 2346 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

    PVOID Buffer;


    DWORD Reserved3;
#line 2352 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

} XSTATE_CONTEXT, *PXSTATE_CONTEXT;





typedef struct _SCOPE_TABLE_AMD64 {
    DWORD Count;
    struct {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_AMD64, *PSCOPE_TABLE_AMD64;







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































typedef struct _SCOPE_TABLE_ARM {
    DWORD Count;
    struct
    {
        DWORD BeginAddress;
        DWORD EndAddress;
        DWORD HandlerAddress;
        DWORD JumpTarget;
    } ScopeRecord[1];
} SCOPE_TABLE_ARM, *PSCOPE_TABLE_ARM;






















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































extern "C" {
#line 4809 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


















#line 4828 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




















#line 4849 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





void
__int2c (
    void
    );

#pragma intrinsic(__int2c)





#line 4866 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"























#line 4890 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 4892 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"










































#line 4935 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 4936 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


}
#line 4940 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"














#line 4955 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 4959 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"











#pragma warning(push)
#line 4972 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

                                


#pragma warning( pop )


#line 4980 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 4982 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 4983 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








extern "C" {
#line 4993 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




















 
BOOLEAN
_bittest (
      LONG const *Base,
      LONG Offset
    );

BOOLEAN
_bittestandcomplement (
      LONG *Base,
      LONG Offset
    );

BOOLEAN
_bittestandset (
      LONG *Base,
      LONG Offset
    );

BOOLEAN
_bittestandreset (
      LONG *Base,
      LONG Offset
    );

BOOLEAN
_interlockedbittestandset (
       LONG volatile *Base,
      LONG Offset
    );

BOOLEAN
_interlockedbittestandreset (
       LONG volatile *Base,
      LONG Offset
    );

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)








 
BOOLEAN
_BitScanForward (
      DWORD *Index,
      DWORD Mask
    );

 
BOOLEAN
_BitScanReverse (
      DWORD *Index,
      DWORD Mask
    );

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)


#line 5083 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



























SHORT
_InterlockedIncrement16 (
       SHORT volatile *Addend
    );

SHORT
_InterlockedDecrement16 (
       SHORT volatile *Addend
    );

SHORT
_InterlockedCompareExchange16 (
       SHORT volatile *Destination,
      SHORT ExChange,
      SHORT Comperand
    );

LONG64
_InterlockedCompareExchange64 (
       LONG64 volatile *Destination,
      LONG64 ExChange,
      LONG64 Comperand
    );

#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedCompareExchange64)

#line 5140 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
















































LONG
_InterlockedAnd (
       LONG volatile *Destination,
      LONG Value
    );

LONG
_InterlockedOr (
       LONG volatile *Destination,
      LONG Value
    );

LONG
_InterlockedXor (
       LONG volatile *Destination,
      LONG Value
    );

LONG
__cdecl
_InterlockedIncrement (
       LONG volatile *Addend
    );

LONG
__cdecl
_InterlockedDecrement (
       LONG volatile *Addend
    );

LONG
__cdecl
_InterlockedExchange (
       LONG volatile *Target,
      LONG Value
    );

LONG
__cdecl
_InterlockedExchangeAdd (
       LONG volatile *Addend,
      LONG Value
    );

__forceinline
LONG
_InterlockedAdd (
       LONG volatile *Addend,
      LONG Value
    )

{

    return _InterlockedExchangeAdd(Addend, Value) + Value;
}

LONG
__cdecl
_InterlockedCompareExchange (
       LONG volatile * Destination,
      LONG ExChange,
      LONG Comperand
    );



__forceinline
 
PVOID
_InlineInterlockedExchangePointer(
      
#line 5261 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
     PVOID volatile * Destination,
      PVOID Value
    )
{
    return (PVOID)_InterlockedExchange((LONG volatile *) Destination,
                                      (LONG) Value);
}






__forceinline
 
PVOID
_InlineInterlockedCompareExchangePointer (
      
#line 5281 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
     PVOID volatile * Destination,
      PVOID ExChange,
      PVOID Comperand
    )
{
    return (PVOID)_InterlockedCompareExchange((LONG volatile *) Destination,
                                             (LONG) ExChange,
                                             (LONG) Comperand);
}










#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)








CHAR
_InterlockedExchange8 (
       CHAR volatile *Target,
      CHAR Value
    );

SHORT
_InterlockedExchange16 (
       SHORT volatile *Destination,
      SHORT ExChange
    );

#pragma intrinsic(_InterlockedExchange8)
#pragma intrinsic(_InterlockedExchange16)

#line 5332 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"













char
_InterlockedAnd8 (
       char volatile *Destination,
      char Value
    );

char
_InterlockedOr8 (
       char volatile *Destination,
      char Value
    );

char
_InterlockedXor8 (
       char volatile *Destination,
      char Value
    );

SHORT
_InterlockedAnd16 (
       SHORT volatile *Destination,
      SHORT Value
    );

SHORT
_InterlockedXor16(
       SHORT volatile *Destination,
      SHORT Value
    );

SHORT
_InterlockedCompareExchange16 (
       SHORT volatile *Destination,
      SHORT ExChange,
      SHORT Comperand
    );

SHORT
_InterlockedOr16 (
       SHORT volatile *Destination,
      SHORT Value
    );

SHORT
_InterlockedIncrement16 (
       SHORT volatile *Destination
    );

SHORT
_InterlockedDecrement16 (
       SHORT volatile *Destination
    );

#pragma intrinsic (_InterlockedAnd8)
#pragma intrinsic (_InterlockedOr8)
#pragma intrinsic (_InterlockedXor8)
#pragma intrinsic (_InterlockedAnd16)
#pragma intrinsic (_InterlockedOr16)
#pragma intrinsic (_InterlockedXor16)
#pragma intrinsic (_InterlockedCompareExchange16)
#pragma intrinsic (_InterlockedIncrement16)
#pragma intrinsic (_InterlockedDecrement16)

#line 5409 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








__forceinline
LONG64
_InterlockedAnd64 (
       LONG64 volatile *Destination,
      LONG64 Value
    )
{
    LONG64 Old;

    do {
        Old = *Destination;
    } while (_InterlockedCompareExchange64(Destination,
                                          Old & Value,
                                          Old) != Old);

    return Old;
}






__forceinline
LONG64
_InterlockedAdd64 (
       LONG64 volatile *Addend,
      LONG64 Value
    )
{
    LONG64 Old;

    do {
        Old = *Addend;
    } while (_InterlockedCompareExchange64(Addend,
                                          Old + Value,
                                          Old) != Old);

    return Old + Value;
}







#line 5465 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"













LONG
_InterlockedXor (
       LONG volatile *Target,
      LONG Set
    );

#pragma intrinsic(_InterlockedXor)





LONGLONG
__forceinline
_InterlockedOr64 (
       LONGLONG volatile *Destination,
      LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Destination;
    } while (_InterlockedCompareExchange64(Destination,
                                          Old | Value,
                                          Old) != Old);

    return Old;
}



__forceinline
LONG64
_InterlockedXor64 (
       LONG64 volatile *Destination,
      LONG64 Value
    )
{
    LONG64 Old;

    do {
        Old = *Destination;
    } while (_InterlockedCompareExchange64(Destination,
                                          Old ^ Value,
                                          Old) != Old);

    return Old;
}



LONGLONG
__forceinline
_InterlockedIncrement64 (
       LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (_InterlockedCompareExchange64(Addend,
                                          Old + 1,
                                          Old) != Old);

    return Old + 1;
}





__forceinline
LONGLONG
_InterlockedDecrement64 (
       LONGLONG volatile *Addend
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (_InterlockedCompareExchange64(Addend,
                                          Old - 1,
                                          Old) != Old);

    return Old - 1;
}



__forceinline
LONGLONG
_InterlockedExchange64 (
       LONGLONG volatile *Target,
      LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Target;
    } while (_InterlockedCompareExchange64(Target,
                                          Value,
                                          Old) != Old);

    return Old;
}






__forceinline
LONGLONG
_InterlockedExchangeAdd64 (
       LONGLONG volatile *Addend,
      LONGLONG Value
    )
{
    LONGLONG Old;

    do {
        Old = *Addend;
    } while (_InterlockedCompareExchange64(Addend,
                                          Old + Value,
                                          Old) != Old);

    return Old;
}








void
__incfsbyte (
      DWORD Offset
    );

void
__addfsbyte (
      DWORD Offset,
      BYTE  Value
    );

void
__incfsword (
      DWORD Offset
    );

void
__addfsword (
      DWORD Offset,
      WORD   Value
    );

void
__incfsdword (
      DWORD Offset
    );

void
__addfsdword (
      DWORD Offset,
      DWORD Value
    );

#pragma intrinsic(__incfsbyte)
#pragma intrinsic(__addfsbyte)
#pragma intrinsic(__incfsword)
#pragma intrinsic(__addfsword)
#pragma intrinsic(__incfsdword)
#pragma intrinsic(__addfsdword)

#line 5659 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"













void
__cpuidex (
    int CPUInfo[4],
    int Function,
    int SubLeaf
    );

#pragma intrinsic(__cpuidex)

#line 5682 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"







BYTE 
__readfsbyte (
      DWORD Offset
    );

WORD  
__readfsword (
      DWORD Offset
    );

DWORD
__readfsdword (
      DWORD Offset
    );

void
__writefsbyte (
      DWORD Offset,
      BYTE  Data
    );

void
__writefsword (
      DWORD Offset,
      WORD   Data
    );

void
__writefsdword (
      DWORD Offset,
      DWORD Data
    );

#pragma intrinsic(__readfsbyte)
#pragma intrinsic(__readfsword)
#pragma intrinsic(__readfsdword)
#pragma intrinsic(__writefsbyte)
#pragma intrinsic(__writefsword)
#pragma intrinsic(__writefsdword)

#line 5730 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



void
_mm_pause (
    void
    );

#pragma intrinsic(_mm_pause)



#line 5743 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


}
#line 5747 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 5749 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"







#pragma prefast(push)
#pragma warning(push)
#pragma prefast(disable: 6001 28113, "The barrier variable is accessed only to create a side effect.")
#pragma warning(disable: 4793)
__forceinline
void
MemoryBarrier (
    void
    )
{
    LONG Barrier;

    _InterlockedOr(&Barrier, 0);
    return;
}

#pragma warning(pop)
#pragma prefast(pop)

#line 5776 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"










void
_mm_prefetch (
      CHAR const *a,
      int sel
    );

#pragma intrinsic(_mm_prefetch)






















DWORD64
__readpmc (
      DWORD Counter
    );

#pragma intrinsic(__readpmc)







DWORD64
__rdtsc (
    void
    );

#pragma intrinsic(__rdtsc)

#line 5836 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






__inline PVOID GetFiberData( void )    { return *(PVOID *) (ULONG_PTR) __readfsdword (0x10);}
__inline PVOID GetCurrentFiber( void ) { return (PVOID) (ULONG_PTR) __readfsdword (0x10);}

#line 5846 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 5850 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
























































#line 5907 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[80];
    DWORD   Spare0;
} FLOATING_SAVE_AREA;

typedef FLOATING_SAVE_AREA *PFLOATING_SAVE_AREA;









typedef char __C_ASSERT__[(sizeof(XSAVE_FORMAT) == 512)?1:-1];

#line 5933 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 5938 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"











typedef struct _CONTEXT {

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    DWORD ContextFlags;

    
    
    
    
    

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    
    
    
    

    FLOATING_SAVE_AREA FloatSave;

    
    
    
    

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    
    
    
    

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    
    
    
    

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              
    DWORD   EFlags;             
    DWORD   Esp;
    DWORD   SegSs;

    
    
    
    
    

    BYTE    ExtendedRegisters[512];

} CONTEXT;

typedef CONTEXT *PCONTEXT;

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 6038 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 6042 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





typedef struct _LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     
            BYTE    Flags2;     
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} LDT_ENTRY, *PLDT_ENTRY;

#line 6073 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 7275 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


























































































































































#line 7430 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
































































































































































































































































































































































































































































































































extern "C" {
#line 7944 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

__forceinline
CHAR
ReadAcquire8 (
       CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
CHAR
ReadNoFence8 (
       CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease8 (
       CHAR volatile *Destination,
      CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence8 (
       CHAR volatile *Destination,
      CHAR Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
SHORT
ReadAcquire16 (
       SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
SHORT
ReadNoFence16 (
       SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease16 (
       SHORT volatile *Destination,
      SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence16 (
       SHORT volatile *Destination,
      SHORT Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG
ReadAcquire (
       LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG
ReadNoFence (
       LONG const volatile *Source
    )

{

    LONG Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease (
       LONG volatile *Destination,
      LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence (
       LONG volatile *Destination,
      LONG Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
LONG64
ReadAcquire64 (
       LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
LONG64
ReadNoFence64 (
       LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *Source;
    return Value;
}

__forceinline
void
WriteRelease64 (
       LONG64 volatile *Destination,
      LONG64 Value
    )

{

    *Destination = Value;
    return;
}

__forceinline
void
WriteNoFence64 (
       LONG64 volatile *Destination,
      LONG64 Value
    )

{

    *Destination = Value;
    return;
}


}
#line 8164 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 8166 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





__forceinline
CHAR
ReadRaw8 (
       CHAR const volatile *Source
    )

{

    CHAR Value;

    Value = *(CHAR *)Source;
    return Value;
}

__forceinline
void
WriteRaw8 (
       CHAR volatile *Destination,
      CHAR Value
    )

{

    *(CHAR *)Destination = Value;
    return;
}

__forceinline
SHORT
ReadRaw16 (
       SHORT const volatile *Source
    )

{

    SHORT Value;

    Value = *(SHORT *)Source;
    return Value;
}

__forceinline
void
WriteRaw16 (
       SHORT volatile *Destination,
      SHORT Value
    )

{

    *(SHORT *)Destination = Value;
    return;
}

__forceinline
LONG
ReadRaw (
       LONG const volatile *Source
    )

{

    LONG Value;

    Value = *(LONG *)Source;
    return Value;
}

__forceinline
void
WriteRaw (
       LONG volatile *Destination,
      LONG Value
    )

{

    *(LONG *)Destination = Value;
    return;
}

__forceinline
LONG64
ReadRaw64 (
       LONG64 const volatile *Source
    )

{

    LONG64 Value;

    Value = *(LONG64 *)Source;
    return Value;
}

__forceinline
void
WriteRaw64 (
       LONG64 volatile *Destination,
      LONG64 Value
    )

{

    *(LONG64 *)Destination = Value;
    return;
}





__forceinline
BYTE 
ReadUCharAcquire (
       BYTE  const volatile *Source
    )

{

    return (BYTE )ReadAcquire8((PCHAR)Source);
}

__forceinline
BYTE 
ReadUCharNoFence (
       BYTE  const volatile *Source
    )

{

    return (BYTE )ReadNoFence8((PCHAR)Source);
}

__forceinline
BYTE 
ReadUCharRaw (
       BYTE  const volatile *Source
    )

{

    return (BYTE )ReadRaw8((PCHAR)Source);
}

__forceinline
void
WriteUCharRelease (
       BYTE  volatile *Destination,
      BYTE  Value
    )

{

    WriteRelease8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharNoFence (
       BYTE  volatile *Destination,
      BYTE  Value
    )

{

    WriteNoFence8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
void
WriteUCharRaw (
       BYTE  volatile *Destination,
      BYTE  Value
    )

{

    WriteRaw8((PCHAR)Destination, (CHAR)Value);
    return;
}

__forceinline
WORD  
ReadUShortAcquire (
       WORD   const volatile *Source
    )

{

    return (WORD  )ReadAcquire16((PSHORT)Source);
}

__forceinline
WORD  
ReadUShortNoFence (
       WORD   const volatile *Source
    )

{

    return (WORD  )ReadNoFence16((PSHORT)Source);
}

__forceinline
WORD  
ReadUShortRaw (
       WORD   const volatile *Source
    )

{

    return (WORD  )ReadRaw16((PSHORT)Source);
}

__forceinline
void
WriteUShortRelease (
       WORD   volatile *Destination,
      WORD   Value
    )

{

    WriteRelease16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortNoFence (
       WORD   volatile *Destination,
      WORD   Value
    )

{

    WriteNoFence16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
void
WriteUShortRaw (
       WORD   volatile *Destination,
      WORD   Value
    )

{

    WriteRaw16((PSHORT)Destination, (SHORT)Value);
    return;
}

__forceinline
DWORD
ReadULongAcquire (
       DWORD const volatile *Source
    )

{

    return (DWORD)ReadAcquire((PLONG)Source);
}

__forceinline
DWORD
ReadULongNoFence (
       DWORD const volatile *Source
    )

{

    return (DWORD)ReadNoFence((PLONG)Source);
}

__forceinline
DWORD
ReadULongRaw (
       DWORD const volatile *Source
    )

{

    return (DWORD)ReadRaw((PLONG)Source);
}

__forceinline
void
WriteULongRelease (
       DWORD volatile *Destination,
      DWORD Value
    )

{

    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongNoFence (
       DWORD volatile *Destination,
      DWORD Value
    )

{

    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WriteULongRaw (
       DWORD volatile *Destination,
      DWORD Value
    )

{

    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
DWORD64
ReadULong64Acquire (
       DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadAcquire64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64NoFence (
       DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadNoFence64((PLONG64)Source);
}

__forceinline
DWORD64
ReadULong64Raw (
       DWORD64 const volatile *Source
    )

{

    return (DWORD64)ReadRaw64((PLONG64)Source);
}

__forceinline
void
WriteULong64Release (
       DWORD64 volatile *Destination,
      DWORD64 Value
    )

{

    WriteRelease64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64NoFence (
       DWORD64 volatile *Destination,
      DWORD64 Value
    )

{

    WriteNoFence64((PLONG64)Destination, (LONG64)Value);
    return;
}

__forceinline
void
WriteULong64Raw (
       DWORD64 volatile *Destination,
      DWORD64 Value
    )

{

    WriteRaw64((PLONG64)Destination, (LONG64)Value);
    return;
}















__forceinline
PVOID
ReadPointerAcquire (
       PVOID const volatile *Source
    )

{

    return (PVOID)ReadAcquire((PLONG)Source);
}

__forceinline
PVOID
ReadPointerNoFence (
       PVOID const volatile *Source
    )

{

    return (PVOID)ReadNoFence((PLONG)Source);
}

__forceinline
PVOID
ReadPointerRaw (
       PVOID const volatile *Source
    )

{

    return (PVOID)ReadRaw((PLONG)Source);
}

__forceinline
void
WritePointerRelease (
       PVOID volatile *Destination,
      PVOID Value
    )

{

    WriteRelease((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WritePointerNoFence (
       PVOID volatile *Destination,
      PVOID Value
    )

{

    WriteNoFence((PLONG)Destination, (LONG)Value);
    return;
}

__forceinline
void
WritePointerRaw (
       PVOID volatile *Destination,
      PVOID Value
    )

{

    WriteRaw((PLONG)Destination, (LONG)Value);
    return;
}



























































































































#line 8780 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 8782 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


#line 8785 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


























#line 8812 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"









typedef struct _WOW64_FLOATING_SAVE_AREA {
    DWORD   ControlWord;
    DWORD   StatusWord;
    DWORD   TagWord;
    DWORD   ErrorOffset;
    DWORD   ErrorSelector;
    DWORD   DataOffset;
    DWORD   DataSelector;
    BYTE    RegisterArea[80];
    DWORD   Cr0NpxState;
} WOW64_FLOATING_SAVE_AREA;

typedef WOW64_FLOATING_SAVE_AREA *PWOW64_FLOATING_SAVE_AREA;

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 8836 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"











typedef struct _WOW64_CONTEXT {

    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    

    DWORD ContextFlags;

    
    
    
    
    

    DWORD   Dr0;
    DWORD   Dr1;
    DWORD   Dr2;
    DWORD   Dr3;
    DWORD   Dr6;
    DWORD   Dr7;

    
    
    
    

    WOW64_FLOATING_SAVE_AREA FloatSave;

    
    
    
    

    DWORD   SegGs;
    DWORD   SegFs;
    DWORD   SegEs;
    DWORD   SegDs;

    
    
    
    

    DWORD   Edi;
    DWORD   Esi;
    DWORD   Ebx;
    DWORD   Edx;
    DWORD   Ecx;
    DWORD   Eax;

    
    
    
    

    DWORD   Ebp;
    DWORD   Eip;
    DWORD   SegCs;              
    DWORD   EFlags;             
    DWORD   Esp;
    DWORD   SegSs;

    
    
    
    
    

    BYTE    ExtendedRegisters[512];

} WOW64_CONTEXT;

typedef WOW64_CONTEXT *PWOW64_CONTEXT;

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 8936 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


typedef struct _WOW64_LDT_ENTRY {
    WORD    LimitLow;
    WORD    BaseLow;
    union {
        struct {
            BYTE    BaseMid;
            BYTE    Flags1;     
            BYTE    Flags2;     
            BYTE    BaseHi;
        } Bytes;
        struct {
            DWORD   BaseMid : 8;
            DWORD   Type : 5;
            DWORD   Dpl : 2;
            DWORD   Pres : 1;
            DWORD   LimitHi : 4;
            DWORD   Sys : 1;
            DWORD   Reserved_0 : 1;
            DWORD   Default_Big : 1;
            DWORD   Granularity : 1;
            DWORD   BaseHi : 8;
        } Bits;
    } HighWord;
} WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;

typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY {
    DWORD Selector;
    WOW64_LDT_ENTRY Descriptor;
} WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;






















typedef struct _EXCEPTION_RECORD {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    DWORD NumberParameters;
    ULONG_PTR ExceptionInformation[15];
    } EXCEPTION_RECORD;

typedef EXCEPTION_RECORD *PEXCEPTION_RECORD;

typedef struct _EXCEPTION_RECORD32 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD ExceptionRecord;
    DWORD ExceptionAddress;
    DWORD NumberParameters;
    DWORD ExceptionInformation[15];
} EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

typedef struct _EXCEPTION_RECORD64 {
    DWORD    ExceptionCode;
    DWORD ExceptionFlags;
    DWORD64 ExceptionRecord;
    DWORD64 ExceptionAddress;
    DWORD NumberParameters;
    DWORD __unusedAlignment;
    DWORD64 ExceptionInformation[15];
} EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;





typedef struct _EXCEPTION_POINTERS {
    PEXCEPTION_RECORD ExceptionRecord;
    PCONTEXT ContextRecord;
} EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;


















#line 9046 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef PVOID PACCESS_TOKEN;            
typedef PVOID PSECURITY_DESCRIPTOR;     
typedef PVOID PSID;     
typedef PVOID PCLAIMS_BLOB;     








































typedef DWORD ACCESS_MASK;
typedef ACCESS_MASK *PACCESS_MASK;
























































typedef struct _GENERIC_MAPPING {
    ACCESS_MASK GenericRead;
    ACCESS_MASK GenericWrite;
    ACCESS_MASK GenericExecute;
    ACCESS_MASK GenericAll;
} GENERIC_MAPPING;
typedef GENERIC_MAPPING *PGENERIC_MAPPING;












#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 9169 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _LUID_AND_ATTRIBUTES {
    LUID Luid;
    DWORD Attributes;
    } LUID_AND_ATTRIBUTES, * PLUID_AND_ATTRIBUTES;
typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
typedef LUID_AND_ATTRIBUTES_ARRAY *PLUID_AND_ATTRIBUTES_ARRAY;

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 9178 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


































typedef struct _SID_IDENTIFIER_AUTHORITY {
    BYTE  Value[6];
} SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;
#line 9216 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




typedef struct _SID {
   BYTE  Revision;
   BYTE  SubAuthorityCount;
   SID_IDENTIFIER_AUTHORITY IdentifierAuthority;



   DWORD SubAuthority[1];
#line 9229 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
} SID, *PISID;
#line 9231 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





                                                



#line 9241 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


typedef enum _SID_NAME_USE {
    SidTypeUser = 1,
    SidTypeGroup,
    SidTypeDomain,
    SidTypeAlias,
    SidTypeWellKnownGroup,
    SidTypeDeletedAccount,
    SidTypeInvalid,
    SidTypeUnknown,
    SidTypeComputer,
    SidTypeLabel
} SID_NAME_USE, *PSID_NAME_USE;

typedef struct _SID_AND_ATTRIBUTES {



    PSID Sid;
#line 9262 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
    DWORD Attributes;
    } SID_AND_ATTRIBUTES, * PSID_AND_ATTRIBUTES;

typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
typedef SID_AND_ATTRIBUTES_ARRAY *PSID_AND_ATTRIBUTES_ARRAY;


typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

typedef struct _SID_AND_ATTRIBUTES_HASH {
    DWORD SidCount;
    PSID_AND_ATTRIBUTES SidAttr;
    SID_HASH_ENTRY Hash[32];
} SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;










































































































































































































































































































































































typedef enum {

    WinNullSid                                  = 0,
    WinWorldSid                                 = 1,
    WinLocalSid                                 = 2,
    WinCreatorOwnerSid                          = 3,
    WinCreatorGroupSid                          = 4,
    WinCreatorOwnerServerSid                    = 5,
    WinCreatorGroupServerSid                    = 6,
    WinNtAuthoritySid                           = 7,
    WinDialupSid                                = 8,
    WinNetworkSid                               = 9,
    WinBatchSid                                 = 10,
    WinInteractiveSid                           = 11,
    WinServiceSid                               = 12,
    WinAnonymousSid                             = 13,
    WinProxySid                                 = 14,
    WinEnterpriseControllersSid                 = 15,
    WinSelfSid                                  = 16,
    WinAuthenticatedUserSid                     = 17,
    WinRestrictedCodeSid                        = 18,
    WinTerminalServerSid                        = 19,
    WinRemoteLogonIdSid                         = 20,
    WinLogonIdsSid                              = 21,
    WinLocalSystemSid                           = 22,
    WinLocalServiceSid                          = 23,
    WinNetworkServiceSid                        = 24,
    WinBuiltinDomainSid                         = 25,
    WinBuiltinAdministratorsSid                 = 26,
    WinBuiltinUsersSid                          = 27,
    WinBuiltinGuestsSid                         = 28,
    WinBuiltinPowerUsersSid                     = 29,
    WinBuiltinAccountOperatorsSid               = 30,
    WinBuiltinSystemOperatorsSid                = 31,
    WinBuiltinPrintOperatorsSid                 = 32,
    WinBuiltinBackupOperatorsSid                = 33,
    WinBuiltinReplicatorSid                     = 34,
    WinBuiltinPreWindows2000CompatibleAccessSid = 35,
    WinBuiltinRemoteDesktopUsersSid             = 36,
    WinBuiltinNetworkConfigurationOperatorsSid  = 37,
    WinAccountAdministratorSid                  = 38,
    WinAccountGuestSid                          = 39,
    WinAccountKrbtgtSid                         = 40,
    WinAccountDomainAdminsSid                   = 41,
    WinAccountDomainUsersSid                    = 42,
    WinAccountDomainGuestsSid                   = 43,
    WinAccountComputersSid                      = 44,
    WinAccountControllersSid                    = 45,
    WinAccountCertAdminsSid                     = 46,
    WinAccountSchemaAdminsSid                   = 47,
    WinAccountEnterpriseAdminsSid               = 48,
    WinAccountPolicyAdminsSid                   = 49,
    WinAccountRasAndIasServersSid               = 50,
    WinNTLMAuthenticationSid                    = 51,
    WinDigestAuthenticationSid                  = 52,
    WinSChannelAuthenticationSid                = 53,
    WinThisOrganizationSid                      = 54,
    WinOtherOrganizationSid                     = 55,
    WinBuiltinIncomingForestTrustBuildersSid    = 56,
    WinBuiltinPerfMonitoringUsersSid            = 57,
    WinBuiltinPerfLoggingUsersSid               = 58,
    WinBuiltinAuthorizationAccessSid            = 59,
    WinBuiltinTerminalServerLicenseServersSid   = 60,
    WinBuiltinDCOMUsersSid                      = 61,
    WinBuiltinIUsersSid                         = 62,
    WinIUserSid                                 = 63,
    WinBuiltinCryptoOperatorsSid                = 64,
    WinUntrustedLabelSid                        = 65,
    WinLowLabelSid                              = 66,
    WinMediumLabelSid                           = 67,
    WinHighLabelSid                             = 68,
    WinSystemLabelSid                           = 69,
    WinWriteRestrictedCodeSid                   = 70,
    WinCreatorOwnerRightsSid                    = 71,
    WinCacheablePrincipalsGroupSid              = 72,
    WinNonCacheablePrincipalsGroupSid           = 73,
    WinEnterpriseReadonlyControllersSid         = 74,
    WinAccountReadonlyControllersSid            = 75,
    WinBuiltinEventLogReadersGroup              = 76,
    WinNewEnterpriseReadonlyControllersSid      = 77,
    WinBuiltinCertSvcDComAccessGroup            = 78,
    WinMediumPlusLabelSid                       = 79,
    WinLocalLogonSid                            = 80,
    WinConsoleLogonSid                          = 81,
    WinThisOrganizationCertificateSid           = 82,
    WinApplicationPackageAuthoritySid           = 83,
    WinBuiltinAnyPackageSid                     = 84,
    WinCapabilityInternetClientSid              = 85,
    WinCapabilityInternetClientServerSid        = 86,
    WinCapabilityPrivateNetworkClientServerSid  = 87,
    WinCapabilityPicturesLibrarySid             = 88,
    WinCapabilityVideosLibrarySid               = 89,
    WinCapabilityMusicLibrarySid                = 90,
    WinCapabilityDocumentsLibrarySid            = 91,
    WinCapabilitySharedUserCertificatesSid      = 92,
    WinCapabilityEnterpriseAuthenticationSid    = 93,
    WinCapabilityRemovableStorageSid            = 94,
    WinBuiltinRDSRemoteAccessServersSid         = 95,
    WinBuiltinRDSEndpointServersSid             = 96,
    WinBuiltinRDSManagementServersSid           = 97,
    WinUserModeDriversSid                       = 98,
    WinBuiltinHyperVAdminsSid                   = 99,
    WinAccountCloneableControllersSid           = 100,
    WinBuiltinAccessControlAssistanceOperatorsSid = 101,
    WinBuiltinRemoteManagementUsersSid          = 102,
    WinAuthenticationAuthorityAssertedSid       = 103,
    WinAuthenticationServiceAssertedSid         = 104,
    WinLocalAccountSid                          = 105,
    WinLocalAccountAndAdministratorSid          = 106,
    WinAccountProtectedUsersSid                 = 107,
} WELL_KNOWN_SID_TYPE;
































































































typedef struct _ACL {
    BYTE  AclRevision;
    BYTE  Sbz1;
    WORD   AclSize;
    WORD   AceCount;
    WORD   Sbz2;
} ACL;
typedef ACL *PACL;






















typedef struct _ACE_HEADER {
    BYTE  AceType;
    BYTE  AceFlags;
    WORD   AceSize;
} ACE_HEADER;
typedef ACE_HEADER *PACE_HEADER;












































































































typedef struct _ACCESS_ALLOWED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_ALLOWED_ACE;

typedef ACCESS_ALLOWED_ACE *PACCESS_ALLOWED_ACE;

typedef struct _ACCESS_DENIED_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} ACCESS_DENIED_ACE;
typedef ACCESS_DENIED_ACE *PACCESS_DENIED_ACE;

typedef struct _SYSTEM_AUDIT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_AUDIT_ACE;
typedef SYSTEM_AUDIT_ACE *PSYSTEM_AUDIT_ACE;

typedef struct _SYSTEM_ALARM_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_ALARM_ACE;
typedef SYSTEM_ALARM_ACE *PSYSTEM_ALARM_ACE;

typedef struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} SYSTEM_RESOURCE_ATTRIBUTE_ACE, *PSYSTEM_RESOURCE_ATTRIBUTE_ACE;

typedef struct _SYSTEM_SCOPED_POLICY_ID_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_SCOPED_POLICY_ID_ACE, *PSYSTEM_SCOPED_POLICY_ID_ACE;

typedef struct _SYSTEM_MANDATORY_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

typedef struct _SYSTEM_PROCESS_TRUST_LABEL_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
} SYSTEM_PROCESS_TRUST_LABEL_ACE, *PSYSTEM_PROCESS_TRUST_LABEL_ACE;















typedef struct _ACCESS_ALLOWED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

typedef struct _ACCESS_DENIED_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
} SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;






typedef struct _ACCESS_ALLOWED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD SidStart;
    
} SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;

typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;

typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;

typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    DWORD Flags;
    GUID ObjectType;
    GUID InheritedObjectType;
    DWORD SidStart;
    
} SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;















typedef enum _ACL_INFORMATION_CLASS {
    AclRevisionInformation = 1,
    AclSizeInformation
} ACL_INFORMATION_CLASS;






typedef struct _ACL_REVISION_INFORMATION {
    DWORD AclRevision;
} ACL_REVISION_INFORMATION;
typedef ACL_REVISION_INFORMATION *PACL_REVISION_INFORMATION;





typedef struct _ACL_SIZE_INFORMATION {
    DWORD AceCount;
    DWORD AclBytesInUse;
    DWORD AclBytesFree;
} ACL_SIZE_INFORMATION;
typedef ACL_SIZE_INFORMATION *PACL_SIZE_INFORMATION;


























typedef WORD   SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

























































































typedef struct _SECURITY_DESCRIPTOR_RELATIVE {
    BYTE  Revision;
    BYTE  Sbz1;
    SECURITY_DESCRIPTOR_CONTROL Control;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
    } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

typedef struct _SECURITY_DESCRIPTOR {
   BYTE  Revision;
   BYTE  Sbz1;
   SECURITY_DESCRIPTOR_CONTROL Control;
   PSID Owner;
   PSID Group;
   PACL Sacl;
   PACL Dacl;

   } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

   
typedef struct _SECURITY_OBJECT_AI_PARAMS {
    DWORD Size;             
    DWORD ConstraintMask;
} SECURITY_OBJECT_AI_PARAMS, *PSECURITY_OBJECT_AI_PARAMS;



















































typedef struct _OBJECT_TYPE_LIST {
    WORD   Level;
    WORD   Sbz;
    GUID *ObjectType;
} OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;















typedef enum _AUDIT_EVENT_TYPE {
    AuditEventObjectAccess,
    AuditEventDirectoryServiceAccess
} AUDIT_EVENT_TYPE, *PAUDIT_EVENT_TYPE;


















































typedef struct _PRIVILEGE_SET {
    DWORD PrivilegeCount;
    DWORD Control;
    LUID_AND_ATTRIBUTES Privilege[1];
    } PRIVILEGE_SET, * PPRIVILEGE_SET;
















typedef enum _ACCESS_REASON_TYPE{

    AccessReasonNone                    = 0x00000000,   

    
    
    
    
    
    AccessReasonAllowedAce                  = 0x00010000,   
    AccessReasonDeniedAce                   = 0x00020000,   

    AccessReasonAllowedParentAce            = 0x00030000,   
    AccessReasonDeniedParentAce             = 0x00040000,   

    AccessReasonNotGrantedByCape            = 0x00050000,   
    AccessReasonNotGrantedByParentCape      = 0x00060000,   

    AccessReasonNotGrantedToAppContainer    = 0x00070000,   

    AccessReasonMissingPrivilege            = 0x00100000,
    AccessReasonFromPrivilege               = 0x00200000,


    AccessReasonIntegrityLevel              = 0x00300000,

    AccessReasonOwnership                   = 0x00400000,

    AccessReasonNullDacl                    = 0x00500000,
    AccessReasonEmptyDacl                   = 0x00600000,

    AccessReasonNoSD                        = 0x00700000,
    AccessReasonNoGrant                     = 0x00800000,   

    AccessReasonTrustLabel                  = 0x00900000    
}
ACCESS_REASON_TYPE;

 












typedef DWORD ACCESS_REASON;

typedef struct _ACCESS_REASONS{
        ACCESS_REASON Data[32];
} ACCESS_REASONS, *PACCESS_REASONS;
























typedef struct _SE_SECURITY_DESCRIPTOR
{
    DWORD Size;
    DWORD Flags;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
} SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;

typedef struct _SE_ACCESS_REQUEST
{
    DWORD Size;
    PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
    ACCESS_MASK DesiredAccess;
    ACCESS_MASK PreviouslyGrantedAccess;
    PSID PrincipalSelfSid;      
    PGENERIC_MAPPING GenericMapping;
    DWORD ObjectTypeListCount;
    POBJECT_TYPE_LIST ObjectTypeList;
} SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;


typedef struct _SE_ACCESS_REPLY
{
    DWORD Size;
    DWORD ResultListCount;  
    PACCESS_MASK GrantedAccess;
    PDWORD    AccessStatus;
    PACCESS_REASONS AccessReason;
    PPRIVILEGE_SET* Privileges;
} SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;






























































typedef enum _SECURITY_IMPERSONATION_LEVEL {
    SecurityAnonymous,
    SecurityIdentification,
    SecurityImpersonation,
    SecurityDelegation
    } SECURITY_IMPERSONATION_LEVEL, * PSECURITY_IMPERSONATION_LEVEL;












































#line 10715 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





















typedef enum _TOKEN_TYPE {
    TokenPrimary = 1,
    TokenImpersonation
    } TOKEN_TYPE;
typedef TOKEN_TYPE *PTOKEN_TYPE;







typedef enum _TOKEN_ELEVATION_TYPE {
    TokenElevationTypeDefault = 1,
    TokenElevationTypeFull,
    TokenElevationTypeLimited,
} TOKEN_ELEVATION_TYPE, *PTOKEN_ELEVATION_TYPE;






typedef enum _TOKEN_INFORMATION_CLASS {
    TokenUser = 1,
    TokenGroups,
    TokenPrivileges,
    TokenOwner,
    TokenPrimaryGroup,
    TokenDefaultDacl,
    TokenSource,
    TokenType,
    TokenImpersonationLevel,
    TokenStatistics,
    TokenRestrictedSids,
    TokenSessionId,
    TokenGroupsAndPrivileges,
    TokenSessionReference,
    TokenSandBoxInert,
    TokenAuditPolicy,
    TokenOrigin,
    TokenElevationType,
    TokenLinkedToken,
    TokenElevation,
    TokenHasRestrictions,
    TokenAccessInformation,
    TokenVirtualizationAllowed,
    TokenVirtualizationEnabled,
    TokenIntegrityLevel,
    TokenUIAccess,
    TokenMandatoryPolicy,
    TokenLogonSid,
    TokenIsAppContainer,
    TokenCapabilities,
    TokenAppContainerSid,
    TokenAppContainerNumber,
    TokenUserClaimAttributes,
    TokenDeviceClaimAttributes,
    TokenRestrictedUserClaimAttributes,
    TokenRestrictedDeviceClaimAttributes,
    TokenDeviceGroups,
    TokenRestrictedDeviceGroups,
    TokenSecurityAttributes,
    TokenIsRestricted,
    TokenProcessTrustLevel,
    MaxTokenInfoClass  
} TOKEN_INFORMATION_CLASS, *PTOKEN_INFORMATION_CLASS;






typedef struct _TOKEN_USER {
    SID_AND_ATTRIBUTES User;
} TOKEN_USER, *PTOKEN_USER;

typedef struct _TOKEN_GROUPS {
    DWORD GroupCount;



    SID_AND_ATTRIBUTES Groups[1];
#line 10820 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
} TOKEN_GROUPS, *PTOKEN_GROUPS;


typedef struct _TOKEN_PRIVILEGES {
    DWORD PrivilegeCount;
    LUID_AND_ATTRIBUTES Privileges[1];
} TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;


typedef struct _TOKEN_OWNER {
    PSID Owner;
} TOKEN_OWNER, *PTOKEN_OWNER;


typedef struct _TOKEN_PRIMARY_GROUP {
    PSID PrimaryGroup;
} TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;


typedef struct _TOKEN_DEFAULT_DACL {
    PACL DefaultDacl;
} TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

typedef struct _TOKEN_USER_CLAIMS {
    PCLAIMS_BLOB UserClaims;
} TOKEN_USER_CLAIMS, *PTOKEN_USER_CLAIMS;

typedef struct _TOKEN_DEVICE_CLAIMS {
    PCLAIMS_BLOB DeviceClaims;
} TOKEN_DEVICE_CLAIMS, *PTOKEN_DEVICE_CLAIMS;

typedef struct _TOKEN_GROUPS_AND_PRIVILEGES {
    DWORD SidCount;
    DWORD SidLength;
    PSID_AND_ATTRIBUTES Sids;
    DWORD RestrictedSidCount;
    DWORD RestrictedSidLength;
    PSID_AND_ATTRIBUTES RestrictedSids;
    DWORD PrivilegeCount;
    DWORD PrivilegeLength;
    PLUID_AND_ATTRIBUTES Privileges;
    LUID AuthenticationId;
} TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

typedef struct _TOKEN_LINKED_TOKEN {
    HANDLE LinkedToken;
} TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

typedef struct _TOKEN_ELEVATION {
    DWORD TokenIsElevated;
} TOKEN_ELEVATION, *PTOKEN_ELEVATION;

typedef struct _TOKEN_MANDATORY_LABEL {
    SID_AND_ATTRIBUTES Label;
} TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;








typedef struct _TOKEN_MANDATORY_POLICY {
    DWORD Policy;
} TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

typedef struct _TOKEN_ACCESS_INFORMATION {
    PSID_AND_ATTRIBUTES_HASH SidHash;
    PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
    PTOKEN_PRIVILEGES Privileges;
    LUID AuthenticationId;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    TOKEN_MANDATORY_POLICY MandatoryPolicy;
    DWORD Flags;
    DWORD AppContainerNumber;
    PSID PackageSid;
    PSID_AND_ATTRIBUTES_HASH CapabilitiesHash;
    PSID TrustLevelSid;
} TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;







typedef struct _TOKEN_AUDIT_POLICY {
    BYTE  PerUserPolicy[(((56)) >> 1) + 1];
} TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;



typedef struct _TOKEN_SOURCE {
    CHAR SourceName[8];
    LUID SourceIdentifier;
} TOKEN_SOURCE, *PTOKEN_SOURCE;


typedef struct _TOKEN_STATISTICS {
    LUID TokenId;
    LUID AuthenticationId;
    LARGE_INTEGER ExpirationTime;
    TOKEN_TYPE TokenType;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    DWORD DynamicCharged;
    DWORD DynamicAvailable;
    DWORD GroupCount;
    DWORD PrivilegeCount;
    LUID ModifiedId;
} TOKEN_STATISTICS, *PTOKEN_STATISTICS;



typedef struct _TOKEN_CONTROL {
    LUID TokenId;
    LUID AuthenticationId;
    LUID ModifiedId;
    TOKEN_SOURCE TokenSource;
} TOKEN_CONTROL, *PTOKEN_CONTROL;

typedef struct _TOKEN_ORIGIN {
    LUID OriginatingLogonSession ;
} TOKEN_ORIGIN, * PTOKEN_ORIGIN ;


typedef enum _MANDATORY_LEVEL {
    MandatoryLevelUntrusted = 0,
    MandatoryLevelLow,
    MandatoryLevelMedium,
    MandatoryLevelHigh,
    MandatoryLevelSystem,
    MandatoryLevelSecureProcess,
    MandatoryLevelCount
} MANDATORY_LEVEL, *PMANDATORY_LEVEL;

typedef struct _TOKEN_APPCONTAINER_INFORMATION {
    PSID TokenAppContainer;
} TOKEN_APPCONTAINER_INFORMATION, *PTOKEN_APPCONTAINER_INFORMATION;

typedef struct _TOKEN_SID_INFORMATION {
    PSID Sid;
} TOKEN_SID_INFORMATION, *PTOKEN_SID_INFORMATION;






























typedef struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE {
    DWORD64             Version;
    PWSTR               Name;
} CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE, *PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;








typedef struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE {
    PVOID   pValue;         
    DWORD   ValueLength;    
} CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
    *PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;



































































typedef struct _CLAIM_SECURITY_ATTRIBUTE_V1 {

    
    
    
    

    PWSTR   Name; 

    
    
    

    WORD    ValueType;

    
    
    
    

    WORD    Reserved;

    
    
    

    DWORD   Flags;

    
    
    

    DWORD   ValueCount;

    
    
    

    union {
        PLONG64                                         pInt64;
        PDWORD64                                        pUint64;
        PWSTR                                           *ppString;
        PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE            pFqbn;
        PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE    pOctetString;
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_V1, *PCLAIM_SECURITY_ATTRIBUTE_V1;






typedef struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 {

    
    
    
    

    DWORD   Name;

    
    
    

    WORD    ValueType;

    
    
    
    

    WORD    Reserved;

    
    
    

    DWORD   Flags;

    
    
    

    DWORD   ValueCount;

    
    
    

    union {
        DWORD pInt64[1];
        DWORD pUint64[1];
        DWORD ppString[1];
        DWORD pFqbn[1];
        DWORD pOctetString[1];
    } Values;
} CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1, *PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;





















typedef struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION {

    
    
    

    WORD    Version;

    
    
    

    WORD    Reserved;

    DWORD   AttributeCount;
    union {
        PCLAIM_SECURITY_ATTRIBUTE_V1    pAttributeV1;
    } Attribute;
} CLAIM_SECURITY_ATTRIBUTES_INFORMATION, *PCLAIM_SECURITY_ATTRIBUTES_INFORMATION;








typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE,
                    * PSECURITY_CONTEXT_TRACKING_MODE;







typedef struct _SECURITY_QUALITY_OF_SERVICE {
    DWORD Length;
    SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
    BOOLEAN EffectiveOnly;
    } SECURITY_QUALITY_OF_SERVICE, * PSECURITY_QUALITY_OF_SERVICE;






typedef struct _SE_IMPERSONATION_STATE {
    PACCESS_TOKEN Token;
    BOOLEAN CopyOnOpen;
    BOOLEAN EffectiveOnly;
    SECURITY_IMPERSONATION_LEVEL Level;
} SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;






typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;





















typedef enum _SE_LEARNING_MODE_DATA_TYPE {
    SeLearningModeInvalidType = 0,
    SeLearningModeSettings,
    SeLearningModeMax
} SE_LEARNING_MODE_DATA_TYPE;



typedef struct _SECURITY_CAPABILITIES {
    PSID AppContainerSid;
    PSID_AND_ATTRIBUTES Capabilities;
    DWORD CapabilityCount;
    DWORD Reserved;
} SECURITY_CAPABILITIES, *PSECURITY_CAPABILITIES, *LPSECURITY_CAPABILITIES;





















#line 11315 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





#line 11321 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 11325 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






















#line 11348 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








typedef struct _JOB_SET_ARRAY {
    HANDLE JobHandle;   
    DWORD MemberLevel;  
    DWORD Flags;        
} JOB_SET_ARRAY, *PJOB_SET_ARRAY;




typedef struct _EXCEPTION_REGISTRATION_RECORD {
    struct _EXCEPTION_REGISTRATION_RECORD *Next;
    PEXCEPTION_ROUTINE Handler;
} EXCEPTION_REGISTRATION_RECORD;

typedef EXCEPTION_REGISTRATION_RECORD *PEXCEPTION_REGISTRATION_RECORD;

typedef struct _NT_TIB {
    struct _EXCEPTION_REGISTRATION_RECORD *ExceptionList;
    PVOID StackBase;
    PVOID StackLimit;
    PVOID SubSystemTib;

    union {
        PVOID FiberData;
        DWORD Version;
    };


#line 11385 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
    PVOID ArbitraryUserPointer;
    struct _NT_TIB *Self;
} NT_TIB;
typedef NT_TIB *PNT_TIB;




typedef struct _NT_TIB32 {
    DWORD ExceptionList;
    DWORD StackBase;
    DWORD StackLimit;
    DWORD SubSystemTib;


    union {
        DWORD FiberData;
        DWORD Version;
    };


#line 11407 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

    DWORD ArbitraryUserPointer;
    DWORD Self;
} NT_TIB32, *PNT_TIB32;

typedef struct _NT_TIB64 {
    DWORD64 ExceptionList;
    DWORD64 StackBase;
    DWORD64 StackLimit;
    DWORD64 SubSystemTib;


    union {
        DWORD64 FiberData;
        DWORD Version;
    };



#line 11427 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

    DWORD64 ArbitraryUserPointer;
    DWORD64 Self;
} NT_TIB64, *PNT_TIB64;








typedef struct _UMS_CREATE_THREAD_ATTRIBUTES {  
    DWORD UmsVersion;   
        PVOID UmsContext;   
        PVOID UmsCompletionList;   
} UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES; 

typedef struct _QUOTA_LIMITS {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;
    LARGE_INTEGER TimeLimit;
} QUOTA_LIMITS, *PQUOTA_LIMITS;







typedef union _RATE_QUOTA_LIMIT {
    DWORD RateData;
    struct {
        DWORD RatePercent : 7;
        DWORD Reserved0   : 25;
    } ;
} RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

typedef struct _QUOTA_LIMITS_EX {
    SIZE_T PagedPoolLimit;
    SIZE_T NonPagedPoolLimit;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    SIZE_T PagefileLimit;               
    LARGE_INTEGER TimeLimit;
    SIZE_T WorkingSetLimit;             
    SIZE_T Reserved2;
    SIZE_T Reserved3;
    SIZE_T Reserved4;
    DWORD  Flags;
    RATE_QUOTA_LIMIT CpuRateLimit;
} QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

typedef struct _IO_COUNTERS {
    ULONGLONG  ReadOperationCount;
    ULONGLONG  WriteOperationCount;
    ULONGLONG  OtherOperationCount;
    ULONGLONG ReadTransferCount;
    ULONGLONG WriteTransferCount;
    ULONGLONG OtherTransferCount;
} IO_COUNTERS;
typedef IO_COUNTERS *PIO_COUNTERS;




typedef enum _HARDWARE_COUNTER_TYPE {
    PMCCounter,
    MaxHardwareCounterType
} HARDWARE_COUNTER_TYPE, *PHARDWARE_COUNTER_TYPE;
typedef enum _PROCESS_MITIGATION_POLICY {
    ProcessDEPPolicy,
    ProcessASLRPolicy,
    ProcessDynamicCodePolicy,
    ProcessStrictHandleCheckPolicy,
    ProcessSystemCallDisablePolicy,
    ProcessMitigationOptionsMask,
    ProcessExtensionPointDisablePolicy,
    ProcessReserved1Policy,
    ProcessSignaturePolicy,
    MaxProcessMitigationPolicy
} PROCESS_MITIGATION_POLICY, *PPROCESS_MITIGATION_POLICY;






typedef struct _PROCESS_MITIGATION_ASLR_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD EnableBottomUpRandomization : 1;
            DWORD EnableForceRelocateImages : 1;
            DWORD EnableHighEntropy : 1;
            DWORD DisallowStrippedImages : 1;
            DWORD ReservedFlags : 28;
        };
    };
} PROCESS_MITIGATION_ASLR_POLICY, *PPROCESS_MITIGATION_ASLR_POLICY;

typedef struct _PROCESS_MITIGATION_DEP_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD Enable : 1;
            DWORD DisableAtlThunkEmulation : 1;
            DWORD ReservedFlags : 30;
        };
    };
    BOOLEAN Permanent;
} PROCESS_MITIGATION_DEP_POLICY, *PPROCESS_MITIGATION_DEP_POLICY;

typedef struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD RaiseExceptionOnInvalidHandleReference : 1;
            DWORD HandleExceptionsPermanentlyEnabled : 1;
            DWORD ReservedFlags : 30;
        };
    };
} PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;

typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisallowWin32kSystemCalls : 1;
            DWORD ReservedFlags : 31;
        };
    };
} PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD DisableExtensionPoints : 1;
            DWORD ReservedFlags : 31;
        };
    };
} PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;

typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD ProhibitDynamicCode : 1;
            DWORD ReservedFlags : 31;
        };
    };
} PROCESS_MITIGATION_DYNAMIC_CODE_POLICY, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY;


typedef struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY {
    union {
        DWORD Flags;
        struct {
            DWORD MicrosoftSignedOnly : 1;
            DWORD ReservedFlags : 31;
        };
    };
} PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;


typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION {
    LARGE_INTEGER TotalUserTime;
    LARGE_INTEGER TotalKernelTime;
    LARGE_INTEGER ThisPeriodTotalUserTime;
    LARGE_INTEGER ThisPeriodTotalKernelTime;
    DWORD TotalPageFaultCount;
    DWORD TotalProcesses;
    DWORD ActiveProcesses;
    DWORD TotalTerminatedProcesses;
} JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION {
    LARGE_INTEGER PerProcessUserTimeLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD LimitFlags;
    SIZE_T MinimumWorkingSetSize;
    SIZE_T MaximumWorkingSetSize;
    DWORD ActiveProcessLimit;
    ULONG_PTR Affinity;
    DWORD PriorityClass;
    DWORD SchedulingClass;
} JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION {
    JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    IO_COUNTERS IoInfo;
    SIZE_T ProcessMemoryLimit;
    SIZE_T JobMemoryLimit;
    SIZE_T PeakProcessMemoryUsed;
    SIZE_T PeakJobMemoryUsed;
} JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST {
    DWORD NumberOfAssignedProcesses;
    DWORD NumberOfProcessIdsInList;
    ULONG_PTR ProcessIdList[1];
} JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;

typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS {
    DWORD UIRestrictionsClass;
} JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;





typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION {
    DWORD SecurityLimitFlags ;
    HANDLE JobToken ;
    PTOKEN_GROUPS SidsToDisable ;
    PTOKEN_PRIVILEGES PrivilegesToDelete ;
    PTOKEN_GROUPS RestrictedSids ;
} JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION ;

typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION {
    DWORD EndOfJobTimeAction;
} JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT {
    PVOID CompletionKey;
    HANDLE CompletionPort;
} JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION {
    JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    IO_COUNTERS IoInfo;
} JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

typedef struct _JOBOBJECT_JOBSET_INFORMATION {
    DWORD MemberLevel;
} JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE {
    ToleranceLow = 1,
    ToleranceMedium,
    ToleranceHigh
} JOBOBJECT_RATE_CONTROL_TOLERANCE;

typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL {
    ToleranceIntervalShort = 1,
    ToleranceIntervalMedium,
    ToleranceIntervalLong
} JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;

typedef struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION {
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
    DWORD LimitFlags;
} JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION, *PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;

typedef struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION {
    DWORD LimitFlags;
    DWORD ViolationLimitFlags;
    DWORD64 IoReadBytes;
    DWORD64 IoReadBytesLimit;
    DWORD64 IoWriteBytes;
    DWORD64 IoWriteBytesLimit;
    LARGE_INTEGER PerJobUserTime;
    LARGE_INTEGER PerJobUserTimeLimit;
    DWORD64 JobMemory;
    DWORD64 JobMemoryLimit;
    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceLimit;
} JOBOBJECT_LIMIT_VIOLATION_INFORMATION, *PJOBOBJECT_LIMIT_VIOLATION_INFORMATION;

typedef struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION {
    DWORD ControlFlags;
    union {
        DWORD CpuRate;
        DWORD Weight;
    };
} JOBOBJECT_CPU_RATE_CONTROL_INFORMATION, *PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION;




















































































































typedef enum _JOBOBJECTINFOCLASS {
    JobObjectBasicAccountingInformation = 1,
    JobObjectBasicLimitInformation,
    JobObjectBasicProcessIdList,
    JobObjectBasicUIRestrictions,
    JobObjectSecurityLimitInformation,  
    JobObjectEndOfJobTimeInformation,
    JobObjectAssociateCompletionPortInformation,
    JobObjectBasicAndIoAccountingInformation,
    JobObjectExtendedLimitInformation,
    JobObjectJobSetInformation,
    JobObjectGroupInformation,
    JobObjectNotificationLimitInformation,
    JobObjectLimitViolationInformation,
    JobObjectGroupInformationEx,
    JobObjectCpuRateControlInformation,
    JobObjectCompletionFilter,
    JobObjectCompletionCounter,
    JobObjectReserved1Information = 18,
    JobObjectReserved2Information,
    JobObjectReserved3Information,
    JobObjectReserved4Information,
    JobObjectReserved5Information,
    JobObjectReserved6Information,
    JobObjectReserved7Information,
    JobObjectReserved8Information,
    JobObjectReserved9Information,
    MaxJobObjectInfoClass
} JOBOBJECTINFOCLASS;


typedef enum _FIRMWARE_TYPE {
    FirmwareTypeUnknown,
    FirmwareTypeBios,
    FirmwareTypeUefi,
    FirmwareTypeMax
} FIRMWARE_TYPE, *PFIRMWARE_TYPE;






























typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP {
    RelationProcessorCore,
    RelationNumaNode,
    RelationCache,
    RelationProcessorPackage,
    RelationGroup,
    RelationAll = 0xffff
} LOGICAL_PROCESSOR_RELATIONSHIP;



typedef enum _PROCESSOR_CACHE_TYPE {
    CacheUnified,
    CacheInstruction,
    CacheData,
    CacheTrace
} PROCESSOR_CACHE_TYPE;



typedef struct _CACHE_DESCRIPTOR {
    BYTE   Level;
    BYTE   Associativity;
    WORD   LineSize;
    DWORD  Size;
    PROCESSOR_CACHE_TYPE Type;
} CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION {
    ULONG_PTR   ProcessorMask;
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    union {
        struct {
            BYTE  Flags;
        } ProcessorCore;
        struct {
            DWORD NodeNumber;
        } NumaNode;
        CACHE_DESCRIPTOR Cache;
        ULONGLONG  Reserved[2];
    } ;
} SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

typedef struct _PROCESSOR_RELATIONSHIP {
    BYTE  Flags;
    BYTE  Reserved[21];
    WORD   GroupCount;
      GROUP_AFFINITY GroupMask[1];
} PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;

typedef struct _NUMA_NODE_RELATIONSHIP {
    DWORD NodeNumber;
    BYTE  Reserved[20];
    GROUP_AFFINITY GroupMask;
} NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;

typedef struct _CACHE_RELATIONSHIP {
    BYTE  Level;
    BYTE  Associativity;
    WORD   LineSize;
    DWORD CacheSize;
    PROCESSOR_CACHE_TYPE Type;
    BYTE  Reserved[20];
    GROUP_AFFINITY GroupMask;
} CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;

typedef struct _PROCESSOR_GROUP_INFO {
    BYTE  MaximumProcessorCount;
    BYTE  ActiveProcessorCount;
    BYTE  Reserved[38];
    KAFFINITY ActiveProcessorMask;
} PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;

typedef struct _GROUP_RELATIONSHIP {
    WORD   MaximumGroupCount;
    WORD   ActiveGroupCount;
    BYTE  Reserved[20];
    PROCESSOR_GROUP_INFO GroupInfo[1];
} GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;

  struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX {
    LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    DWORD Size;
    union {
        PROCESSOR_RELATIONSHIP Processor;
        NUMA_NODE_RELATIONSHIP NumaNode;
        CACHE_RELATIONSHIP Cache;
        GROUP_RELATIONSHIP Group;
    } ;
};

typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;



typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION {
    DWORD64 CycleTime;
} SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;




























































































typedef struct _XSTATE_FEATURE {
    DWORD Offset;
    DWORD Size;
} XSTATE_FEATURE, *PXSTATE_FEATURE;

typedef struct _XSTATE_CONFIGURATION {
    
    DWORD64 EnabledFeatures;

    
    DWORD64 EnabledVolatileFeatures;

    
    DWORD Size;

    DWORD OptimizedSave : 1;

    
    XSTATE_FEATURE Features[(64)];

} XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;


typedef struct _MEMORY_BASIC_INFORMATION {
    PVOID BaseAddress;
    PVOID AllocationBase;
    DWORD AllocationProtect;
    SIZE_T RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

typedef struct _MEMORY_BASIC_INFORMATION32 {
    DWORD BaseAddress;
    DWORD AllocationBase;
    DWORD AllocationProtect;
    DWORD RegionSize;
    DWORD State;
    DWORD Protect;
    DWORD Type;
} MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

typedef struct __declspec(align(16)) _MEMORY_BASIC_INFORMATION64 {
    ULONGLONG BaseAddress;
    ULONGLONG AllocationBase;
    DWORD     AllocationProtect;
    DWORD     __alignment1;
    ULONGLONG RegionSize;
    DWORD     State;
    DWORD     Protect;
    DWORD     Type;
    DWORD     __alignment2;
} MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;

























#pragma region Desktop Family           





#line 12171 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion                       





















































































































































typedef struct _FILE_ID_128 {                               
    BYTE  Identifier[16];                                   
} FILE_ID_128, *PFILE_ID_128;                               





typedef struct _FILE_NOTIFY_INFORMATION {
    DWORD NextEntryOffset;
    DWORD Action;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;






typedef union _FILE_SEGMENT_ELEMENT {
    PVOID64 Buffer;
    ULONGLONG Alignment;
}FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;













































#line 12391 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"










typedef struct _REPARSE_GUID_DATA_BUFFER {
    DWORD  ReparseTag;
    WORD   ReparseDataLength;
    WORD   Reserved;
    GUID   ReparseGuid;
    struct {
        BYTE   DataBuffer[1];
    } GenericReparseBuffer;
} REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;





























































































#line 12504 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _SCRUB_DATA_INPUT {

    
    
    

    DWORD Size;

    
    
    
    
    
    

    DWORD Flags;

    
    
    
    
    

    DWORD MaximumIos;

    
    
    

    DWORD Reserved[17];

    
    
    
    
    

    BYTE  ResumeContext[816];

} SCRUB_DATA_INPUT, *PSCRUB_DATA_INPUT;



typedef struct _SCRUB_PARITY_EXTENT {

    LONGLONG Offset;

    ULONGLONG Length;

} SCRUB_PARITY_EXTENT, *PSCRUB_PARITY_EXTENT;

typedef struct _SCRUB_PARITY_EXTENT_DATA {

    
    
    

    WORD   Size;

    
    
    

    WORD   Flags;

    
    
    

    WORD   NumberOfParityExtents;

    
    
    

    WORD   MaximumNumberOfParityExtents;

    
    
    

    SCRUB_PARITY_EXTENT ParityExtents[1];

} SCRUB_PARITY_EXTENT_DATA, *PSCRUB_PARITY_EXTENT_DATA;

#line 12591 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _SCRUB_DATA_OUTPUT {

    
    
    

    DWORD Size;

    
    
    
    
    
    
    

    DWORD Flags;

    
    
    

    DWORD Status;

    
    
    
    

    ULONGLONG ErrorFileOffset;

    
    
    
    

    ULONGLONG ErrorLength;

    
    
    

    ULONGLONG NumberOfBytesRepaired;

    
    
    

    ULONGLONG NumberOfBytesFailed;

    
    
    

    ULONGLONG InternalFileReference;



    
    
    
    
    
    

    WORD   ResumeContextLength;

    
    
    
    
    

    WORD   ParityExtentDataOffset;

    
    
    

    DWORD Reserved[5];









#line 12682 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

    
    
    
    
    
    
    
    
    
    
    
    

    BYTE  ResumeContext[816];

} SCRUB_DATA_OUTPUT, *PSCRUB_DATA_OUTPUT;

#line 12701 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"












typedef enum _SharedVirtualDiskSupportType
{
    
    
    
    SharedVirtualDisksUnsupported = 0,

    
    
    
    SharedVirtualDisksSupported = 1
} SharedVirtualDiskSupportType;

typedef enum _SharedVirtualDiskHandleState
{
    
    
    
    SharedVirtualDiskHandleStateNone = 0,

    
    
    
    
    SharedVirtualDiskHandleStateFileShared = 1,

    
    
    
    
    SharedVirtualDiskHandleStateHandleShared = 3
} SharedVirtualDiskHandleState;





typedef struct _SHARED_VIRTUAL_DISK_SUPPORT {
    
    
    
    
    SharedVirtualDiskSupportType SharedVirtualDiskSupport;

    
    
    
    
    SharedVirtualDiskHandleState HandleState;
} SHARED_VIRTUAL_DISK_SUPPORT, *PSHARED_VIRTUAL_DISK_SUPPORT;







#line 12771 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
































extern "C" const GUID  GUID_MAX_POWER_SAVINGS;






extern "C" const GUID  GUID_MIN_POWER_SAVINGS;






extern "C" const GUID  GUID_TYPICAL_POWER_SAVINGS;







extern "C" const GUID  NO_SUBGROUP_GUID;







extern "C" const GUID  ALL_POWERSCHEMES_GUID;




































extern "C" const GUID  GUID_POWERSCHEME_PERSONALITY;








extern "C" const GUID  GUID_ACTIVE_POWERSCHEME;














extern "C" const GUID  GUID_IDLE_RESILIENCY_SUBGROUP;





extern "C" const GUID  GUID_IDLE_RESILIENCY_PERIOD;






extern "C" const GUID  GUID_IDLE_RESILIENCY_PLATFORM_STATE;






extern "C" const GUID  GUID_DISK_COALESCING_POWERDOWN_TIMEOUT;












extern "C" const GUID  GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT;








extern "C" const GUID  GUID_VIDEO_SUBGROUP;





extern "C" const GUID  GUID_VIDEO_POWERDOWN_TIMEOUT;





extern "C" const GUID  GUID_VIDEO_ANNOYANCE_TIMEOUT;





extern "C" const GUID  GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE;





extern "C" const GUID  GUID_VIDEO_DIM_TIMEOUT;





extern "C" const GUID  GUID_VIDEO_ADAPTIVE_POWERDOWN;





extern "C" const GUID  GUID_MONITOR_POWER_ON;




extern "C" const GUID  GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS;





extern "C" const GUID  GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS;




extern "C" const GUID  GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS;






extern "C" const GUID  GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS;





extern "C" const GUID  GUID_CONSOLE_DISPLAY_STATE;







extern "C" const GUID  GUID_ALLOW_DISPLAY_REQUIRED;







extern "C" const GUID  GUID_VIDEO_CONSOLE_LOCK_TIMEOUT;






extern "C" const GUID  GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP;






extern "C" const GUID  GUID_NON_ADAPTIVE_INPUT_TIMEOUT;







extern "C" const GUID  GUID_DISK_SUBGROUP;





extern "C" const GUID  GUID_DISK_POWERDOWN_TIMEOUT;






extern "C" const GUID  GUID_DISK_IDLE_TIMEOUT;








extern "C" const GUID  GUID_DISK_BURST_IGNORE_THRESHOLD;





extern "C" const GUID  GUID_DISK_ADAPTIVE_POWERDOWN;








extern "C" const GUID  GUID_SLEEP_SUBGROUP;







extern "C" const GUID  GUID_SLEEP_IDLE_THRESHOLD;





extern "C" const GUID  GUID_STANDBY_TIMEOUT;








extern "C" const GUID  GUID_UNATTEND_SLEEP_TIMEOUT;





extern "C" const GUID  GUID_HIBERNATE_TIMEOUT;





extern "C" const GUID  GUID_HIBERNATE_FASTS4_POLICY;








extern "C" const GUID  GUID_CRITICAL_POWER_TRANSITION;





extern "C" const GUID  GUID_SYSTEM_AWAYMODE;





extern "C" const GUID  GUID_ALLOW_AWAYMODE;





extern "C" const GUID  GUID_VIDEO_FULLSCREEN_PLAYBACK;






extern "C" const GUID  GUID_AUDIO_PLAYBACK;







extern "C" const GUID  GUID_ALLOW_STANDBY_STATES;






extern "C" const GUID  GUID_ALLOW_RTC_WAKE;







extern "C" const GUID  GUID_ALLOW_SYSTEM_REQUIRED;








extern "C" const GUID  GUID_SYSTEM_BUTTON_SUBGROUP;


















extern "C" const GUID  GUID_POWERBUTTON_ACTION;





extern "C" const GUID  GUID_SLEEPBUTTON_ACTION;






extern "C" const GUID  GUID_USERINTERFACEBUTTON_ACTION;





extern "C" const GUID  GUID_LIDCLOSE_ACTION;
extern "C" const GUID  GUID_LIDOPEN_POWERSTATE;








extern "C" const GUID  GUID_BATTERY_SUBGROUP;











extern "C" const GUID  GUID_BATTERY_DISCHARGE_ACTION_0;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_LEVEL_0;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_FLAGS_0;

extern "C" const GUID  GUID_BATTERY_DISCHARGE_ACTION_1;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_LEVEL_1;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_FLAGS_1;

extern "C" const GUID  GUID_BATTERY_DISCHARGE_ACTION_2;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_LEVEL_2;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_FLAGS_2;

extern "C" const GUID  GUID_BATTERY_DISCHARGE_ACTION_3;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_LEVEL_3;
extern "C" const GUID  GUID_BATTERY_DISCHARGE_FLAGS_3;

extern "C" const GUID  GUID_CS_BATTERY_SAVER_THRESHOLD;
extern "C" const GUID  GUID_CS_BATTERY_SAVER_ACTION;
extern "C" const GUID  GUID_CS_BATTERY_SAVER_TIMEOUT;








extern "C" const GUID  GUID_PROCESSOR_SETTINGS_SUBGROUP;





extern "C" const GUID  GUID_PROCESSOR_THROTTLE_POLICY;















extern "C" const GUID  GUID_PROCESSOR_THROTTLE_MAXIMUM;







extern "C" const GUID  GUID_PROCESSOR_THROTTLE_MINIMUM;







extern "C" const GUID  GUID_PROCESSOR_ALLOW_THROTTLING;





extern "C" const GUID  GUID_PROCESSOR_IDLESTATE_POLICY;





extern "C" const GUID  GUID_PROCESSOR_PERFSTATE_POLICY;







extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_THRESHOLD;







extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_THRESHOLD;







extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_POLICY;







extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_POLICY;








extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_TIME;








extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_TIME;







extern "C" const GUID  GUID_PROCESSOR_PERF_TIME_CHECK;







extern "C" const GUID  GUID_PROCESSOR_PERF_BOOST_POLICY;
#line 13382 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"










extern "C" const GUID  GUID_PROCESSOR_PERF_BOOST_MODE;
#line 13394 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"














extern "C" const GUID  GUID_PROCESSOR_IDLE_ALLOW_SCALING;






extern "C" const GUID  GUID_PROCESSOR_IDLE_DISABLE;








extern "C" const GUID  GUID_PROCESSOR_IDLE_STATE_MAXIMUM;








extern "C" const GUID  GUID_PROCESSOR_IDLE_TIME_CHECK;








extern "C" const GUID  GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD;







extern "C" const GUID  GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY;












extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_MAX_CORES;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_MIN_CORES;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING;






extern "C" const GUID  GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD;







extern "C" const GUID  GUID_PROCESSOR_PARKING_CORE_OVERRIDE;







extern "C" const GUID  GUID_PROCESSOR_PARKING_PERF_STATE;







extern "C" const GUID  GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD;







extern "C" const GUID  GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD;








extern "C" const GUID  GUID_PROCESSOR_PERF_HISTORY;







extern "C" const GUID  GUID_PROCESSOR_PERF_INCREASE_HISTORY;







extern "C" const GUID  GUID_PROCESSOR_PERF_DECREASE_HISTORY;







extern "C" const GUID  GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY;









extern "C" const GUID  GUID_PROCESSOR_PERF_LATENCY_HINT;






extern "C" const GUID  GUID_PROCESSOR_PERF_LATENCY_HINT_PERF;







extern "C" const GUID  GUID_PROCESSOR_DISTRIBUTE_UTILITY;







extern "C" const GUID  GUID_SYSTEM_COOLING_POLICY;









extern "C" const GUID  GUID_LOCK_CONSOLE_ON_WAKE;









extern "C" const GUID  GUID_DEVICE_IDLE_POLICY;




















extern "C" const GUID  GUID_ACDC_POWER_SOURCE;















extern "C" const GUID  GUID_LIDSWITCH_STATE_CHANGE;
















extern "C" const GUID  GUID_BATTERY_PERCENTAGE_REMAINING;






extern "C" const GUID  GUID_GLOBAL_USER_PRESENCE;










extern "C" const GUID  GUID_SESSION_DISPLAY_STATUS;









extern "C" const GUID  GUID_SESSION_USER_PRESENCE;






extern "C" const GUID  GUID_IDLE_BACKGROUND_TASK;






extern "C" const GUID  GUID_BACKGROUND_TASK_NOTIFICATION;







extern "C" const GUID  GUID_APPLAUNCH_BUTTON;










extern "C" const GUID  GUID_PCIEXPRESS_SETTINGS_SUBGROUP;





extern "C" const GUID  GUID_PCIEXPRESS_ASPM_POLICY;











extern "C" const GUID  GUID_ENABLE_SWITCH_FORCED_SHUTDOWN;






extern "C" const GUID  GUID_INTSTEER_SUBGROUP;
#line 13821 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  GUID_INTSTEER_MODE;
#line 13825 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  GUID_INTSTEER_LOAD_PER_PROC_TRIGGER;
#line 13829 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  GUID_INTSTEER_TIME_UNPARK_TRIGGER;
#line 13833 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


typedef enum _SYSTEM_POWER_STATE {
    PowerSystemUnspecified = 0,
    PowerSystemWorking     = 1,
    PowerSystemSleeping1   = 2,
    PowerSystemSleeping2   = 3,
    PowerSystemSleeping3   = 4,
    PowerSystemHibernate   = 5,
    PowerSystemShutdown    = 6,
    PowerSystemMaximum     = 7
} SYSTEM_POWER_STATE, *PSYSTEM_POWER_STATE;



typedef enum {
    PowerActionNone = 0,
    PowerActionReserved,
    PowerActionSleep,
    PowerActionHibernate,
    PowerActionShutdown,
    PowerActionShutdownReset,
    PowerActionShutdownOff,
    PowerActionWarmEject
} POWER_ACTION, *PPOWER_ACTION;

typedef enum _DEVICE_POWER_STATE {
    PowerDeviceUnspecified = 0,
    PowerDeviceD0,
    PowerDeviceD1,
    PowerDeviceD2,
    PowerDeviceD3,
    PowerDeviceMaximum
} DEVICE_POWER_STATE, *PDEVICE_POWER_STATE;

typedef enum _MONITOR_DISPLAY_STATE {
    PowerMonitorOff = 0,
    PowerMonitorOn,
    PowerMonitorDim
} MONITOR_DISPLAY_STATE, *PMONITOR_DISPLAY_STATE;

typedef enum _USER_ACTIVITY_PRESENCE {
    PowerUserPresent = 0,
    PowerUserNotPresent,
    PowerUserInactive,
    PowerUserMaximum,
    PowerUserInvalid = PowerUserMaximum
} USER_ACTIVITY_PRESENCE, *PUSER_ACTIVITY_PRESENCE;









typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;

typedef enum {
    LT_DONT_CARE,
    LT_LOWEST_LATENCY
} LATENCY_TIME;

















typedef enum _POWER_REQUEST_TYPE {
    PowerRequestDisplayRequired,
    PowerRequestSystemRequired,
    PowerRequestAwayModeRequired,
    PowerRequestExecutionRequired
} POWER_REQUEST_TYPE, *PPOWER_REQUEST_TYPE;




















typedef struct CM_Power_Data_s {
    DWORD               PD_Size;
    DEVICE_POWER_STATE  PD_MostRecentPowerState;
    DWORD               PD_Capabilities;
    DWORD               PD_D1Latency;
    DWORD               PD_D2Latency;
    DWORD               PD_D3Latency;
    DEVICE_POWER_STATE  PD_PowerStateMapping[7];
    SYSTEM_POWER_STATE  PD_DeepestSystemWake;
} CM_POWER_DATA, *PCM_POWER_DATA;

#line 13951 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



typedef enum {
    SystemPowerPolicyAc,
    SystemPowerPolicyDc,
    VerifySystemPolicyAc,
    VerifySystemPolicyDc,
    SystemPowerCapabilities,
    SystemBatteryState,
    SystemPowerStateHandler,
    ProcessorStateHandler,
    SystemPowerPolicyCurrent,
    AdministratorPowerPolicy,
    SystemReserveHiberFile,
    ProcessorInformation,
    SystemPowerInformation,
    ProcessorStateHandler2,
    LastWakeTime,                                   
    LastSleepTime,                                  
    SystemExecutionState,
    SystemPowerStateNotifyHandler,
    ProcessorPowerPolicyAc,
    ProcessorPowerPolicyDc,
    VerifyProcessorPowerPolicyAc,
    VerifyProcessorPowerPolicyDc,
    ProcessorPowerPolicyCurrent,
    SystemPowerStateLogging,
    SystemPowerLoggingEntry,
    SetPowerSettingValue,
    NotifyUserPowerSetting,
    PowerInformationLevelUnused0,
    SystemMonitorHiberBootPowerOff,
    SystemVideoState,
    TraceApplicationPowerMessage,
    TraceApplicationPowerMessageEnd,
    ProcessorPerfStates,
    ProcessorIdleStates,
    ProcessorCap,
    SystemWakeSource,
    SystemHiberFileInformation,
    TraceServicePowerMessage,
    ProcessorLoad,
    PowerShutdownNotification,
    MonitorCapabilities,
    SessionPowerInit,
    SessionDisplayState,
    PowerRequestCreate,
    PowerRequestAction,
    GetPowerRequestList,
    ProcessorInformationEx,
    NotifyUserModeLegacyPowerEvent,
    GroupPark,
    ProcessorIdleDomains,
    WakeTimerList,
    SystemHiberFileSize,
    ProcessorIdleStatesHv,
    ProcessorPerfStatesHv,
    ProcessorPerfCapHv,
    ProcessorSetIdle,
    LogicalProcessorIdling,
    UserPresence,
    PowerSettingNotificationName,
    GetPowerSettingValue,
    IdleResiliency,
    SessionRITState,
    SessionConnectNotification,
    SessionPowerCleanup,
    SessionLockState,
    SystemHiberbootState,
    PlatformInformation,
    PdcInvocation,
    MonitorInvocation,
    FirmwareTableInformationRegistered,
    SetShutdownSelectedTime,
    SuspendResumeInvocation,
    PlmPowerRequestCreate,
    ScreenOff,
    CsDeviceNotification,
    PlatformRole,
    LastResumePerformance,
    DisplayBurst,
    ExitLatencySamplingPercentage,
    RegisterSpmPowerSettings,
    PlatformIdleStates,
    ProcessorIdleVeto,
    PlatformIdleVeto,
    SystemBatteryStatePrecise,
    ThermalEvent,
    PowerInformationLevelMaximum
} POWER_INFORMATION_LEVEL;





typedef enum {
    UserNotPresent = 0,
    UserPresent = 1,
    UserUnknown = 0xff
} POWER_USER_PRESENCE_TYPE, *PPOWER_USER_PRESENCE_TYPE;

typedef struct _POWER_USER_PRESENCE {
	POWER_USER_PRESENCE_TYPE UserPresence;
} POWER_USER_PRESENCE, *PPOWER_USER_PRESENCE;




typedef struct _POWER_SESSION_CONNECT {
    BOOLEAN Connected;  
    BOOLEAN Console;    
} POWER_SESSION_CONNECT, *PPOWER_SESSION_CONNECT;

typedef struct _POWER_SESSION_TIMEOUTS {
    DWORD InputTimeout;
    DWORD DisplayTimeout;
} POWER_SESSION_TIMEOUTS, *PPOWER_SESSION_TIMEOUTS;




typedef struct _POWER_SESSION_RIT_STATE {
    BOOLEAN Active;  
    DWORD LastInputTime; 
} POWER_SESSION_RIT_STATE, *PPOWER_SESSION_RIT_STATE;




typedef struct _POWER_SESSION_WINLOGON {
    DWORD SessionId; 
    BOOLEAN Console; 
    BOOLEAN Locked; 
} POWER_SESSION_WINLOGON, *PPOWER_SESSION_WINLOGON;




typedef struct _POWER_IDLE_RESILIENCY {
    DWORD CoalescingTimeout;
    DWORD IdleResiliencyPeriod;
} POWER_IDLE_RESILIENCY, *PPOWER_IDLE_RESILIENCY;




typedef enum {
    MonitorRequestReasonUnknown,
    MonitorRequestReasonPowerButton,
    MonitorRequestReasonRemoteConnection,
    MonitorRequestReasonScMonitorpower,
    MonitorRequestReasonUserInput,
    MonitorRequestReasonAcDcDisplayBurst,
    MonitorRequestReasonUserDisplayBurst,
    MonitorRequestReasonPoSetSystemState,
    MonitorRequestReasonSetThreadExecutionState,
    MonitorRequestReasonFullWake,
    MonitorRequestReasonSessionUnlock,
    MonitorRequestReasonScreenOffRequest,
    MonitorRequestReasonIdleTimeout,
    MonitorRequestReasonPolicyChange,
    MonitorRequestReasonSleepButton,
    MonitorRequestReasonLid,
    MonitorRequestReasonBatteryCountChange,
    MonitorRequestReasonMax
} POWER_MONITOR_REQUEST_REASON;




typedef struct _POWER_MONITOR_INVOCATION {
    BOOLEAN On;
    BOOLEAN Console;
    POWER_MONITOR_REQUEST_REASON RequestReason;
} POWER_MONITOR_INVOCATION, *PPOWER_MONITOR_INVOCATION;





typedef struct _RESUME_PERFORMANCE {
    DWORD PostTimeMs;
    ULONGLONG TotalResumeTimeMs;
    ULONGLONG ResumeCompleteTimestamp;
} RESUME_PERFORMANCE, *PRESUME_PERFORMANCE;





typedef enum {
    PoAc,
    PoDc,
    PoHot,
    PoConditionMaximum
} SYSTEM_POWER_CONDITION;

typedef struct {

    
    
    
    
    DWORD       Version;


    
    
    
    GUID        Guid;


    
    
    
    
    SYSTEM_POWER_CONDITION PowerCondition;

    
    
    
    DWORD       DataLength;

    
    
    
    BYTE    Data[1];
} SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;



typedef struct {
    GUID Guid;
} NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;






typedef struct _APPLICATIONLAUNCH_SETTING_VALUE {

    
    
    
    
    LARGE_INTEGER       ActivationTime;

    
    
    
    DWORD               Flags;

    
    
    
    DWORD               ButtonInstanceID;


} APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;





typedef enum _POWER_PLATFORM_ROLE {
    PlatformRoleUnspecified = 0,
    PlatformRoleDesktop,
    PlatformRoleMobile,
    PlatformRoleWorkstation,
    PlatformRoleEnterpriseServer,
    PlatformRoleSOHOServer,
    PlatformRoleAppliancePC,
    PlatformRolePerformanceServer, 
    PlatformRoleSlate,             
    PlatformRoleMaximum
} POWER_PLATFORM_ROLE, *PPOWER_PLATFORM_ROLE;

















#line 14247 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _POWER_PLATFORM_INFORMATION {
    BOOLEAN AoAc;
} POWER_PLATFORM_INFORMATION, *PPOWER_PLATFORM_INFORMATION;






typedef struct {
    DWORD       Granularity;
    DWORD       Capacity;
} BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;
#line 14262 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



typedef struct {
    DWORD   Frequency;
    DWORD   Flags;
    DWORD   PercentFrequency;
} PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;

typedef struct {
    DWORD Latency;
    DWORD Power;
    DWORD TimeCheck;
    BYTE  PromotePercent;
    BYTE  DemotePercent;
    BYTE  StateType;
    BYTE  Reserved;
    DWORD StateFlags;
    DWORD Context;
    DWORD IdleHandler;
    DWORD Reserved1;            
} PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;          
    DWORD OldState;             
    DWORD64 TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;

typedef struct {
    DWORD Type;
    DWORD Count;
    DWORD TargetState;          
    DWORD OldState;             
    PVOID TargetProcessors;
    PPM_WMI_IDLE_STATE State[1];
} PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;

typedef struct {
    DWORD Frequency;            
    DWORD Power;                
    BYTE  PercentFrequency;
    BYTE  IncreaseLevel;        
    BYTE  DecreaseLevel;        
    BYTE  Type;                 
    DWORD IncreaseTime;         
    DWORD DecreaseTime;         
    DWORD64 Control;            
    DWORD64 Status;             
    DWORD HitCount;
    DWORD Reserved1;            
    DWORD64 Reserved2;
    DWORD64 Reserved3;
} PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;         
    DWORD MaxPerfState;         
    DWORD MinPerfState;         
    DWORD LowestPerfState;      
    DWORD ThermalConstraint;
    BYTE  BusyAdjThreshold;
    BYTE  PolicyType;           
    BYTE  Type;
    BYTE  Reserved;
    DWORD TimerInterval;
    DWORD64 TargetProcessors;   
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;

typedef struct {
    DWORD Count;
    DWORD MaxFrequency;
    DWORD CurrentState;         
    DWORD MaxPerfState;         
    DWORD MinPerfState;         
    DWORD LowestPerfState;      
    DWORD ThermalConstraint;
    BYTE  BusyAdjThreshold;
    BYTE  PolicyType;           
    BYTE  Type;
    BYTE  Reserved;
    DWORD TimerInterval;
    PVOID TargetProcessors;     
    DWORD PStateHandler;
    DWORD PStateContext;
    DWORD TStateHandler;
    DWORD TStateContext;
    DWORD FeedbackHandler;
    DWORD Reserved1;
    DWORD64 Reserved2;
    PPM_WMI_PERF_STATE State[1];
} PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;







typedef struct {
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD64 TotalTime;
    DWORD IdleTimeBuckets[6];
} PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD64 StartTime;
    PPM_IDLE_STATE_ACCOUNTING State[1];
} PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;







typedef struct {
    DWORD64 TotalTimeUs;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD Count;
} PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;

typedef struct {
    DWORD64 TotalTime;
    DWORD IdleTransitions;
    DWORD FailedTransitions;
    DWORD InvalidBucketIndex;
    DWORD MinTimeUs;
    DWORD MaxTimeUs;
    DWORD CancelledTransitions;
    PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
} PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;

typedef struct {
    DWORD StateCount;
    DWORD TotalTransitions;
    DWORD ResetCount;
    DWORD AbortCount;
    DWORD64 StartTime;
      PPM_IDLE_STATE_ACCOUNTING_EX State[1];
} PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;




























































extern "C" const GUID  PPM_PERFSTATE_CHANGE_GUID;
#line 14484 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  PPM_PERFSTATE_DOMAIN_CHANGE_GUID;
#line 14488 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  PPM_IDLESTATE_CHANGE_GUID;
#line 14492 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  PPM_PERFSTATES_DATA_GUID;
#line 14496 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  PPM_IDLESTATES_DATA_GUID;
#line 14500 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  PPM_IDLE_ACCOUNTING_GUID;
#line 14504 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  PPM_IDLE_ACCOUNTING_EX_GUID;
#line 14508 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  PPM_THERMALCONSTRAINT_GUID;
#line 14512 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  PPM_PERFMON_PERFSTATE_GUID;
#line 14516 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


extern "C" const GUID  PPM_THERMAL_POLICY_CHANGE_GUID;
#line 14520 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


typedef struct {
    DWORD State;
    DWORD Status;
    DWORD Latency;
    DWORD Speed;
    DWORD Processor;
} PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;

typedef struct {
    DWORD State;
    DWORD Latency;
    DWORD Speed;
    DWORD64 Processors;
} PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;

typedef struct {
    DWORD NewState;
    DWORD OldState;
    DWORD64 Processors;
} PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;

typedef struct {
    DWORD ThermalConstraint;
    DWORD64 Processors;
} PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;

#pragma warning(push)
#pragma warning(disable:4121)

typedef struct {
    BYTE  Mode;
    DWORD64 Processors;
} PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;

#pragma warning(pop)




typedef struct {
    POWER_ACTION    Action;
    DWORD           Flags;
    DWORD           EventCode;
} POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;
































typedef struct {
    BOOLEAN                 Enable;
    BYTE                    Spare[3];
    DWORD                   BatteryLevel;
    POWER_ACTION_POLICY     PowerPolicy;
    SYSTEM_POWER_STATE      MinSystemState;
} SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;








typedef struct _SYSTEM_POWER_POLICY {
    DWORD                   Revision;       

    
    POWER_ACTION_POLICY     PowerButton;
    POWER_ACTION_POLICY     SleepButton;
    POWER_ACTION_POLICY     LidClose;
    SYSTEM_POWER_STATE      LidOpenWake;
    DWORD                   Reserved;

    
    POWER_ACTION_POLICY     Idle;
    DWORD                   IdleTimeout;
    BYTE                    IdleSensitivity;

    BYTE                    DynamicThrottle;
    BYTE                    Spare2[2];

    
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;
    SYSTEM_POWER_STATE      ReducedLatencySleep;
    DWORD                   WinLogonFlags;

    DWORD                   Spare3;

    
    
    DWORD                   DozeS4Timeout;

    
    DWORD                   BroadcastCapacityResolution;
    SYSTEM_POWER_LEVEL      DischargePolicy[4];

    
    DWORD                   VideoTimeout;
    BOOLEAN                 VideoDimDisplay;
    DWORD                   VideoReserved[3];

    
    DWORD                   SpindownTimeout;

    
    BOOLEAN                 OptimizeForPower;
    BYTE                    FanThrottleTolerance;
    BYTE                    ForcedThrottle;
    BYTE                    MinThrottle;
    POWER_ACTION_POLICY     OverThrottled;

} SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;










typedef struct {
    DWORD TimeCheck;
    BYTE  DemotePercent;
    BYTE  PromotePercent;
    BYTE  Spare[2];
} PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;

typedef struct {
    WORD   Revision;
    union {
        WORD   AsWORD  ;
        struct {
            WORD   AllowScaling : 1;
            WORD   Disabled : 1;
            WORD   Reserved : 14;
        } ;
    } Flags;

    DWORD PolicyCount;
    PROCESSOR_IDLESTATE_INFO Policy[0x3];
} PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;














typedef struct _PROCESSOR_POWER_POLICY_INFO {

    
    DWORD                   TimeCheck;                      
    DWORD                   DemoteLimit;                    
    DWORD                   PromoteLimit;                   

    
    BYTE                    DemotePercent;
    BYTE                    PromotePercent;
    BYTE                    Spare[2];

    
    DWORD                   AllowDemotion:1;
    DWORD                   AllowPromotion:1;
    DWORD                   Reserved:30;

} PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;


typedef struct _PROCESSOR_POWER_POLICY {
    DWORD                       Revision;       

    
    BYTE                        DynamicThrottle;
    BYTE                        Spare[3];

    
    DWORD                       DisableCStates:1;
    DWORD                       Reserved:31;

    
    
    
    DWORD                       PolicyCount;
    PROCESSOR_POWER_POLICY_INFO Policy[3];

} PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;





typedef struct {
    DWORD Revision;
    BYTE  MaxThrottle;
    BYTE  MinThrottle;
    BYTE  BusyAdjThreshold;
    union {
        BYTE  Spare;
        union {
            BYTE  AsBYTE ;
            struct {
                BYTE  NoDomainAccounting : 1;
                BYTE  IncreasePolicy: 2;
                BYTE  DecreasePolicy: 2;
                BYTE  Reserved : 3;
            } ;
        } Flags;
    } ;

    DWORD TimeCheck;
    DWORD IncreaseTime;
    DWORD DecreaseTime;
    DWORD IncreasePercent;
    DWORD DecreasePercent;
} PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;


typedef struct _ADMINISTRATOR_POWER_POLICY {

    
    SYSTEM_POWER_STATE      MinSleep;
    SYSTEM_POWER_STATE      MaxSleep;

    
    DWORD                   MinVideoTimeout;
    DWORD                   MaxVideoTimeout;

    
    DWORD                   MinSpindownTimeout;
    DWORD                   MaxSpindownTimeout;
} ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;


typedef struct {
    
    BOOLEAN             PowerButtonPresent;
    BOOLEAN             SleepButtonPresent;
    BOOLEAN             LidPresent;
    BOOLEAN             SystemS1;
    BOOLEAN             SystemS2;
    BOOLEAN             SystemS3;
    BOOLEAN             SystemS4;           
    BOOLEAN             SystemS5;           
    BOOLEAN             HiberFilePresent;
    BOOLEAN             FullWake;
    BOOLEAN             VideoDimPresent;
    BOOLEAN             ApmPresent;
    BOOLEAN             UpsPresent;

    
    BOOLEAN             ThermalControl;
    BOOLEAN             ProcessorThrottle;
    BYTE                ProcessorMinThrottle;




#line 14818 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
    BYTE                ProcessorMaxThrottle;
    BOOLEAN             FastSystemS4;
    BOOLEAN             Hiberboot;
    BOOLEAN             WakeAlarmPresent;
    BOOLEAN             AoAc;
#line 14824 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

    
    BOOLEAN             DiskSpinDown;
    BYTE                spare3[8];

    
    BOOLEAN             SystemBatteriesPresent;
    BOOLEAN             BatteriesAreShortTerm;
    BATTERY_REPORTING_SCALE BatteryScale[3];

    
    SYSTEM_POWER_STATE  AcOnLineWake;
    SYSTEM_POWER_STATE  SoftLidWake;
    SYSTEM_POWER_STATE  RtcWake;
    SYSTEM_POWER_STATE  MinDeviceWakeState; 
    SYSTEM_POWER_STATE  DefaultLowLatencyWake;
} SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

typedef struct {
    BOOLEAN             AcOnLine;
    BOOLEAN             BatteryPresent;
    BOOLEAN             Charging;
    BOOLEAN             Discharging;
    BOOLEAN             Spare1[3];

    BYTE                Tag;

    DWORD               MaxCapacity;
    DWORD               RemainingCapacity;
    DWORD               Rate;
    DWORD               EstimatedTime;

    DWORD               DefaultAlert1;
    DWORD               DefaultAlert2;
} SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;










#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 14870 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"







#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 14878 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"









#line 14888 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _IMAGE_DOS_HEADER {      
    WORD   e_magic;                     
    WORD   e_cblp;                      
    WORD   e_cp;                        
    WORD   e_crlc;                      
    WORD   e_cparhdr;                   
    WORD   e_minalloc;                  
    WORD   e_maxalloc;                  
    WORD   e_ss;                        
    WORD   e_sp;                        
    WORD   e_csum;                      
    WORD   e_ip;                        
    WORD   e_cs;                        
    WORD   e_lfarlc;                    
    WORD   e_ovno;                      
    WORD   e_res[4];                    
    WORD   e_oemid;                     
    WORD   e_oeminfo;                   
    WORD   e_res2[10];                  
    LONG   e_lfanew;                    
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

typedef struct _IMAGE_OS2_HEADER {      
    WORD   ne_magic;                    
    CHAR   ne_ver;                      
    CHAR   ne_rev;                      
    WORD   ne_enttab;                   
    WORD   ne_cbenttab;                 
    LONG   ne_crc;                      
    WORD   ne_flags;                    
    WORD   ne_autodata;                 
    WORD   ne_heap;                     
    WORD   ne_stack;                    
    LONG   ne_csip;                     
    LONG   ne_sssp;                     
    WORD   ne_cseg;                     
    WORD   ne_cmod;                     
    WORD   ne_cbnrestab;                
    WORD   ne_segtab;                   
    WORD   ne_rsrctab;                  
    WORD   ne_restab;                   
    WORD   ne_modtab;                   
    WORD   ne_imptab;                   
    LONG   ne_nrestab;                  
    WORD   ne_cmovent;                  
    WORD   ne_align;                    
    WORD   ne_cres;                     
    BYTE   ne_exetyp;                   
    BYTE   ne_flagsothers;              
    WORD   ne_pretthunks;               
    WORD   ne_psegrefbytes;             
    WORD   ne_swaparea;                 
    WORD   ne_expver;                   
  } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

typedef struct _IMAGE_VXD_HEADER {      
    WORD   e32_magic;                   
    BYTE   e32_border;                  
    BYTE   e32_worder;                  
    DWORD  e32_level;                   
    WORD   e32_cpu;                     
    WORD   e32_os;                      
    DWORD  e32_ver;                     
    DWORD  e32_mflags;                  
    DWORD  e32_mpages;                  
    DWORD  e32_startobj;                
    DWORD  e32_eip;                     
    DWORD  e32_stackobj;                
    DWORD  e32_esp;                     
    DWORD  e32_pagesize;                
    DWORD  e32_lastpagesize;            
    DWORD  e32_fixupsize;               
    DWORD  e32_fixupsum;                
    DWORD  e32_ldrsize;                 
    DWORD  e32_ldrsum;                  
    DWORD  e32_objtab;                  
    DWORD  e32_objcnt;                  
    DWORD  e32_objmap;                  
    DWORD  e32_itermap;                 
    DWORD  e32_rsrctab;                 
    DWORD  e32_rsrccnt;                 
    DWORD  e32_restab;                  
    DWORD  e32_enttab;                  
    DWORD  e32_dirtab;                  
    DWORD  e32_dircnt;                  
    DWORD  e32_fpagetab;                
    DWORD  e32_frectab;                 
    DWORD  e32_impmod;                  
    DWORD  e32_impmodcnt;               
    DWORD  e32_impproc;                 
    DWORD  e32_pagesum;                 
    DWORD  e32_datapage;                
    DWORD  e32_preload;                 
    DWORD  e32_nrestab;                 
    DWORD  e32_cbnrestab;               
    DWORD  e32_nressum;                 
    DWORD  e32_autodata;                
    DWORD  e32_debuginfo;               
    DWORD  e32_debuglen;                
    DWORD  e32_instpreload;             
    DWORD  e32_instdemand;              
    DWORD  e32_heapsize;                
    BYTE   e32_res3[12];                
    DWORD  e32_winresoff;
    DWORD  e32_winreslen;
    WORD   e32_devid;                   
    WORD   e32_ddkver;                  
  } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;


#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 15000 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 15001 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;






















































typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;







typedef struct _IMAGE_OPTIONAL_HEADER {
    
    
    

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    
    
    

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

typedef struct _IMAGE_ROM_OPTIONAL_HEADER {
    WORD   Magic;
    BYTE   MajorLinkerVersion;
    BYTE   MinorLinkerVersion;
    DWORD  SizeOfCode;
    DWORD  SizeOfInitializedData;
    DWORD  SizeOfUninitializedData;
    DWORD  AddressOfEntryPoint;
    DWORD  BaseOfCode;
    DWORD  BaseOfData;
    DWORD  BaseOfBss;
    DWORD  GprMask;
    DWORD  CprMask[4];
    DWORD  GpValue;
} IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[16];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;










typedef IMAGE_OPTIONAL_HEADER32             IMAGE_OPTIONAL_HEADER;
typedef PIMAGE_OPTIONAL_HEADER32            PIMAGE_OPTIONAL_HEADER;

#line 15185 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

typedef struct _IMAGE_ROM_HEADERS {
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
} IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;





typedef IMAGE_NT_HEADERS32                  IMAGE_NT_HEADERS;
typedef PIMAGE_NT_HEADERS32                 PIMAGE_NT_HEADERS;
#line 15210 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



































































typedef struct ANON_OBJECT_HEADER {
    WORD    Sig1;            
    WORD    Sig2;            
    WORD    Version;         
    WORD    Machine;
    DWORD   TimeDateStamp;
    CLSID   ClassID;         
    DWORD   SizeOfData;      
} ANON_OBJECT_HEADER;

typedef struct ANON_OBJECT_HEADER_V2 {
    WORD    Sig1;            
    WORD    Sig2;            
    WORD    Version;         
    WORD    Machine;
    DWORD   TimeDateStamp;
    CLSID   ClassID;         
    DWORD   SizeOfData;      
    DWORD   Flags;           
    DWORD   MetaDataSize;    
    DWORD   MetaDataOffset;  
} ANON_OBJECT_HEADER_V2;

typedef struct ANON_OBJECT_HEADER_BIGOBJ {
   
    WORD    Sig1;            
    WORD    Sig2;            
    WORD    Version;         
    WORD    Machine;         
    DWORD   TimeDateStamp;
    CLSID   ClassID;         
    DWORD   SizeOfData;      
    DWORD   Flags;           
    DWORD   MetaDataSize;    
    DWORD   MetaDataOffset;  

    
    DWORD   NumberOfSections; 
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
} ANON_OBJECT_HEADER_BIGOBJ;







typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[8];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

































































#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 15406 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 15407 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





typedef struct _IMAGE_SYMBOL {
    union {
        BYTE    ShortName[8];
        struct {
            DWORD   Short;     
            DWORD   Long;      
        } Name;
        DWORD   LongName[2];    
    } N;
    DWORD   Value;
    SHORT   SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL;
typedef IMAGE_SYMBOL  *PIMAGE_SYMBOL;



typedef struct _IMAGE_SYMBOL_EX {
    union {
        BYTE     ShortName[8];
        struct {
            DWORD   Short;     
            DWORD   Long;      
        } Name;
        DWORD   LongName[2];    
    } N;
    DWORD   Value;
    LONG    SectionNumber;
    WORD    Type;
    BYTE    StorageClass;
    BYTE    NumberOfAuxSymbols;
} IMAGE_SYMBOL_EX;
typedef IMAGE_SYMBOL_EX  *PIMAGE_SYMBOL_EX;
































































































#line 15544 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




#line 15549 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





#line 15555 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




#line 15560 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 15564 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


#line 15567 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 15569 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF {
    BYTE  bAuxType;                  
    BYTE  bReserved;                 
    DWORD SymbolTableIndex;
    BYTE  rgbReserved[12];           
} IMAGE_AUX_SYMBOL_TOKEN_DEF;

typedef IMAGE_AUX_SYMBOL_TOKEN_DEF  *PIMAGE_AUX_SYMBOL_TOKEN_DEF;

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 15580 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





typedef union _IMAGE_AUX_SYMBOL {
    struct {
        DWORD    TagIndex;                      
        union {
            struct {
                WORD    Linenumber;             
                WORD    Size;                   
            } LnSz;
           DWORD    TotalSize;
        } Misc;
        union {
            struct {                            
                DWORD    PointerToLinenumber;
                DWORD    PointerToNextFunction;
            } Function;
            struct {                            
                WORD     Dimension[4];
            } Array;
        } FcnAry;
        WORD    TvIndex;                        
    } Sym;
    struct {
        BYTE    Name[18];
    } File;
    struct {
        DWORD   Length;                         
        WORD    NumberOfRelocations;            
        WORD    NumberOfLinenumbers;            
        DWORD   CheckSum;                       
        SHORT   Number;                         
        BYTE    Selection;                      
	BYTE    bReserved;
	SHORT   HighNumber;                     
    } Section;
    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    struct {
        DWORD crc;
        BYTE  rgbReserved[14];
    } CRC;
} IMAGE_AUX_SYMBOL;
typedef IMAGE_AUX_SYMBOL  *PIMAGE_AUX_SYMBOL;

typedef union _IMAGE_AUX_SYMBOL_EX {
    struct {
        DWORD   WeakDefaultSymIndex;                       
        DWORD   WeakSearchType;
        BYTE    rgbReserved[12];
    } Sym;
    struct {
        BYTE    Name[sizeof(IMAGE_SYMBOL_EX)];
    } File;
    struct {
        DWORD   Length;                         
        WORD    NumberOfRelocations;            
        WORD    NumberOfLinenumbers;            
        DWORD   CheckSum;                       
        SHORT   Number;                         
        BYTE    Selection;                      
        BYTE    bReserved;
        SHORT   HighNumber;                     
        BYTE    rgbReserved[2];
    } Section;
    struct{
        IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
        BYTE  rgbReserved[2];
    };
    struct {
        DWORD crc;
        BYTE  rgbReserved[16];
    } CRC;
} IMAGE_AUX_SYMBOL_EX;
typedef IMAGE_AUX_SYMBOL_EX  *PIMAGE_AUX_SYMBOL_EX;

typedef enum IMAGE_AUX_SYMBOL_TYPE {
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
} IMAGE_AUX_SYMBOL_TYPE;






















typedef struct _IMAGE_RELOCATION {
    union {
        DWORD   VirtualAddress;
        DWORD   RelocCount;             
    } ;
    DWORD   SymbolTableIndex;
    WORD    Type;
} IMAGE_RELOCATION;
typedef IMAGE_RELOCATION  *PIMAGE_RELOCATION;




























































































































                                                
                                                
                                                
                                                




















































































































































































































































typedef struct _IMAGE_LINENUMBER {
    union {
        DWORD   SymbolTableIndex;               
        DWORD   VirtualAddress;                 
    } Type;
    WORD    Linenumber;                         
} IMAGE_LINENUMBER;
typedef IMAGE_LINENUMBER  *PIMAGE_LINENUMBER;


#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 16075 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 16076 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





typedef struct _IMAGE_BASE_RELOCATION {
    DWORD   VirtualAddress;
    DWORD   SizeOfBlock;

} IMAGE_BASE_RELOCATION;
typedef IMAGE_BASE_RELOCATION  * PIMAGE_BASE_RELOCATION;









































typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER {
    BYTE     Name[16];                          
    BYTE     Date[12];                          
    BYTE     UserID[6];                         
    BYTE     GroupID[6];                        
    BYTE     Mode[8];                           
    BYTE     Size[10];                          
    BYTE     EndHeader[2];                      
} IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;











typedef struct _IMAGE_EXPORT_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Name;
    DWORD   Base;
    DWORD   NumberOfFunctions;
    DWORD   NumberOfNames;
    DWORD   AddressOfFunctions;     
    DWORD   AddressOfNames;         
    DWORD   AddressOfNameOrdinals;  
} IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;





typedef struct _IMAGE_IMPORT_BY_NAME {
    WORD    Hint;
    CHAR   Name[1];
} IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack8.h"























#pragma warning(disable:4103)

#pragma pack(push,8)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack8.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack8.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack8.h"
#line 16172 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _IMAGE_THUNK_DATA64 {
    union {
        ULONGLONG ForwarderString;  
        ULONGLONG Function;         
        ULONGLONG Ordinal;
        ULONGLONG AddressOfData;    
    } u1;
} IMAGE_THUNK_DATA64;
typedef IMAGE_THUNK_DATA64 * PIMAGE_THUNK_DATA64;

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 16184 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _IMAGE_THUNK_DATA32 {
    union {
        DWORD ForwarderString;      
        DWORD Function;             
        DWORD Ordinal;
        DWORD AddressOfData;        
    } u1;
} IMAGE_THUNK_DATA32;
typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32;












typedef void
(__stdcall *PIMAGE_TLS_CALLBACK) (
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
    );

typedef struct _IMAGE_TLS_DIRECTORY64 {
    ULONGLONG StartAddressOfRawData;
    ULONGLONG EndAddressOfRawData;
    ULONGLONG AddressOfIndex;         
    ULONGLONG AddressOfCallBacks;     
    DWORD SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } ;
    } ;

} IMAGE_TLS_DIRECTORY64;

typedef IMAGE_TLS_DIRECTORY64 * PIMAGE_TLS_DIRECTORY64;

typedef struct _IMAGE_TLS_DIRECTORY32 {
    DWORD   StartAddressOfRawData;
    DWORD   EndAddressOfRawData;
    DWORD   AddressOfIndex;             
    DWORD   AddressOfCallBacks;         
    DWORD   SizeOfZeroFill;
    union {
        DWORD Characteristics;
        struct {
            DWORD Reserved0 : 20;
            DWORD Alignment : 4;
            DWORD Reserved1 : 8;
        } ;
    } ;

} IMAGE_TLS_DIRECTORY32;
typedef IMAGE_TLS_DIRECTORY32 * PIMAGE_TLS_DIRECTORY32;












typedef IMAGE_THUNK_DATA32              IMAGE_THUNK_DATA;
typedef PIMAGE_THUNK_DATA32             PIMAGE_THUNK_DATA;

typedef IMAGE_TLS_DIRECTORY32           IMAGE_TLS_DIRECTORY;
typedef PIMAGE_TLS_DIRECTORY32          PIMAGE_TLS_DIRECTORY;
#line 16267 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _IMAGE_IMPORT_DESCRIPTOR {
    union {
        DWORD   Characteristics;            
        DWORD   OriginalFirstThunk;         
    } ;
    DWORD   TimeDateStamp;                  
                                            
                                            
                                            

    DWORD   ForwarderChain;                 
    DWORD   Name;
    DWORD   FirstThunk;                     
} IMAGE_IMPORT_DESCRIPTOR;
typedef IMAGE_IMPORT_DESCRIPTOR  *PIMAGE_IMPORT_DESCRIPTOR;





typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    NumberOfModuleForwarderRefs;

} IMAGE_BOUND_IMPORT_DESCRIPTOR,  *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

typedef struct _IMAGE_BOUND_FORWARDER_REF {
    DWORD   TimeDateStamp;
    WORD    OffsetModuleName;
    WORD    Reserved;
} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;

typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR {
    union {
        DWORD AllAttributes;
        struct {
            DWORD RvaBased : 1;             
            DWORD ReservedAttributes : 31;
        };
    } Attributes;

    DWORD DllNameRVA;                       
    DWORD ModuleHandleRVA;                  
    DWORD ImportAddressTableRVA;            
    DWORD ImportNameTableRVA;               
    DWORD BoundImportAddressTableRVA;       
    DWORD UnloadInformationTableRVA;        
    DWORD TimeDateStamp;                    
                                            

} IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;

typedef const IMAGE_DELAYLOAD_DESCRIPTOR *PCIMAGE_DELAYLOAD_DESCRIPTOR;



















typedef struct _IMAGE_RESOURCE_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    WORD    NumberOfNamedEntries;
    WORD    NumberOfIdEntries;

} IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;


















typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY {
    union {
        struct {
            DWORD NameOffset:31;
            DWORD NameIsString:1;
        } ;
        DWORD   Name;
        WORD    Id;
    } ;
    union {
        DWORD   OffsetToData;
        struct {
            DWORD   OffsetToDirectory:31;
            DWORD   DataIsDirectory:1;
        } ;
    } ;
} IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;










typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING {
    WORD    Length;
    CHAR    NameString[ 1 ];
} IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;


typedef struct _IMAGE_RESOURCE_DIR_STRING_U {
    WORD    Length;
    WCHAR   NameString[ 1 ];
} IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;











typedef struct _IMAGE_RESOURCE_DATA_ENTRY {
    DWORD   OffsetToData;
    DWORD   Size;
    DWORD   CodePage;
    DWORD   Reserved;
} IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;





typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32 {
    DWORD   Size;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   GlobalFlagsClear;
    DWORD   GlobalFlagsSet;
    DWORD   CriticalSectionDefaultTimeout;
    DWORD   DeCommitFreeBlockThreshold;
    DWORD   DeCommitTotalFreeThreshold;
    DWORD   LockPrefixTable;                
    DWORD   MaximumAllocationSize;
    DWORD   VirtualMemoryThreshold;
    DWORD   ProcessHeapFlags;
    DWORD   ProcessAffinityMask;
    WORD    CSDVersion;
    WORD    Reserved1;
    DWORD   EditList;                       
    DWORD   SecurityCookie;                 
    DWORD   SEHandlerTable;                 
    DWORD   SEHandlerCount;
    DWORD   GuardCFCheckFunctionPointer;    
    DWORD   Reserved2;
    DWORD   GuardCFFunctionTable;           
    DWORD   GuardCFFunctionCount;
    DWORD   GuardFlags;
} IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64 {
    DWORD      Size;
    DWORD      TimeDateStamp;
    WORD       MajorVersion;
    WORD       MinorVersion;
    DWORD      GlobalFlagsClear;
    DWORD      GlobalFlagsSet;
    DWORD      CriticalSectionDefaultTimeout;
    ULONGLONG  DeCommitFreeBlockThreshold;
    ULONGLONG  DeCommitTotalFreeThreshold;
    ULONGLONG  LockPrefixTable;             
    ULONGLONG  MaximumAllocationSize;
    ULONGLONG  VirtualMemoryThreshold;
    ULONGLONG  ProcessAffinityMask;
    DWORD      ProcessHeapFlags;
    WORD       CSDVersion;
    WORD       Reserved1;
    ULONGLONG  EditList;                    
    ULONGLONG  SecurityCookie;              
    ULONGLONG  SEHandlerTable;              
    ULONGLONG  SEHandlerCount;
    ULONGLONG  GuardCFCheckFunctionPointer; 
    ULONGLONG  Reserved2;
    ULONGLONG  GuardCFFunctionTable;        
    ULONGLONG  GuardCFFunctionCount;
    DWORD      GuardFlags;
} IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;





typedef IMAGE_LOAD_CONFIG_DIRECTORY32     IMAGE_LOAD_CONFIG_DIRECTORY;
typedef PIMAGE_LOAD_CONFIG_DIRECTORY32    PIMAGE_LOAD_CONFIG_DIRECTORY;
#line 16490 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



















typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY {
    DWORD FuncStart;
    DWORD PrologLen : 8;
    DWORD FuncLen : 22;
    DWORD ThirtyTwoBit : 1;
    DWORD ExceptionFlag : 1;
} IMAGE_CE_RUNTIME_FUNCTION_ENTRY, * PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    union {
        DWORD UnwindData;
        struct {
            DWORD Flag : 2;
            DWORD FunctionLength : 11;
            DWORD Ret : 2;
            DWORD H : 1;
            DWORD Reg : 3;
            DWORD R : 1;
            DWORD L : 1;
            DWORD C : 1;
            DWORD StackAdjust : 10;
        } ;
    } ;
} IMAGE_ARM_RUNTIME_FUNCTION_ENTRY, * PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY {
    ULONGLONG BeginAddress;
    ULONGLONG EndAddress;
    ULONGLONG ExceptionHandler;
    ULONGLONG HandlerData;
    ULONGLONG PrologEndAddress;
} IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    DWORD ExceptionHandler;
    DWORD HandlerData;
    DWORD PrologEndAddress;
} IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY {
    DWORD BeginAddress;
    DWORD EndAddress;
    union {
        DWORD UnwindInfoAddress;
        DWORD UnwindData;
    } ;
} _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;








#line 16571 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




#line 16576 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




#line 16581 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef  _IMAGE_RUNTIME_FUNCTION_ENTRY  IMAGE_RUNTIME_FUNCTION_ENTRY;
typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

#line 16586 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





typedef struct _IMAGE_DEBUG_DIRECTORY {
    DWORD   Characteristics;
    DWORD   TimeDateStamp;
    WORD    MajorVersion;
    WORD    MinorVersion;
    DWORD   Type;
    DWORD   SizeOfData;
    DWORD   AddressOfRawData;
    DWORD   PointerToRawData;
} IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;















typedef struct _IMAGE_COFF_SYMBOLS_HEADER {
    DWORD   NumberOfSymbols;
    DWORD   LvaToFirstSymbol;
    DWORD   NumberOfLinenumbers;
    DWORD   LvaToFirstLinenumber;
    DWORD   RvaToFirstByteOfCode;
    DWORD   RvaToLastByteOfCode;
    DWORD   RvaToFirstByteOfData;
    DWORD   RvaToLastByteOfData;
} IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;






typedef struct _FPO_DATA {
    DWORD       ulOffStart;             
    DWORD       cbProcSize;             
    DWORD       cdwLocals;              
    WORD        cdwParams;              
    WORD        cbProlog : 8;           
    WORD        cbRegs   : 3;           
    WORD        fHasSEH  : 1;           
    WORD        fUseBP   : 1;           
    WORD        reserved : 1;           
    WORD        cbFrame  : 2;           
} FPO_DATA, *PFPO_DATA;





typedef struct _IMAGE_DEBUG_MISC {
    DWORD       DataType;               
    DWORD       Length;                 
                                        
    BOOLEAN     Unicode;                
    BYTE        Reserved[ 3 ];
    BYTE        Data[ 1 ];              
} IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;








typedef struct _IMAGE_FUNCTION_ENTRY {
    DWORD   StartingAddress;
    DWORD   EndingAddress;
    DWORD   EndOfPrologue;
} IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

typedef struct _IMAGE_FUNCTION_ENTRY64 {
    ULONGLONG   StartingAddress;
    ULONGLONG   EndingAddress;
    union {
        ULONGLONG   EndOfPrologue;
        ULONGLONG   UnwindInfoAddress;
    } ;
} IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;





















typedef struct _IMAGE_SEPARATE_DEBUG_HEADER {
    WORD        Signature;
    WORD        Flags;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       ImageBase;
    DWORD       SizeOfImage;
    DWORD       NumberOfSections;
    DWORD       ExportedNamesSize;
    DWORD       DebugDirectorySize;
    DWORD       SectionAlignment;
    DWORD       Reserved[2];
} IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

typedef struct _NON_PAGED_DEBUG_INFO {
    WORD        Signature;
    WORD        Flags;
    DWORD       Size;
    WORD        Machine;
    WORD        Characteristics;
    DWORD       TimeDateStamp;
    DWORD       CheckSum;
    DWORD       SizeOfImage;
    ULONGLONG   ImageBase;
    
    
} NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;







#line 16737 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



                                                









typedef struct _ImageArchitectureHeader {
    unsigned int AmaskValue: 1;                 
                                                
    int :7;                                     
    unsigned int AmaskShift: 8;                 
    int :16;                                    
    DWORD FirstEntryRVA;                        
} IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

typedef struct _ImageArchitectureEntry {
    DWORD FixupInstRVA;                         
    DWORD NewInst;                              
} IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 16765 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








typedef struct IMPORT_OBJECT_HEADER {
    WORD    Sig1;                       
    WORD    Sig2;                       
    WORD    Version;
    WORD    Machine;
    DWORD   TimeDateStamp;              
    DWORD   SizeOfData;                 

    union {
        WORD    Ordinal;                
        WORD    Hint;
    } ;

    WORD    Type : 2;                   
    WORD    NameType : 3;               
    WORD    Reserved : 11;              
} IMPORT_OBJECT_HEADER;

typedef enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE = 0,
    IMPORT_OBJECT_DATA = 1,
    IMPORT_OBJECT_CONST = 2,
} IMPORT_OBJECT_TYPE;

typedef enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL = 0,          
    IMPORT_OBJECT_NAME = 1,             
    IMPORT_OBJECT_NAME_NO_PREFIX = 2,   
    IMPORT_OBJECT_NAME_UNDECORATE = 3,  
                                        
} IMPORT_OBJECT_NAME_TYPE;





typedef enum ReplacesCorHdrNumericDefines
{

    COMIMAGE_FLAGS_ILONLY               =0x00000001,
    COMIMAGE_FLAGS_32BITREQUIRED        =0x00000002,
    COMIMAGE_FLAGS_IL_LIBRARY           =0x00000004,
    COMIMAGE_FLAGS_STRONGNAMESIGNED     =0x00000008,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT    =0x00000010,
    COMIMAGE_FLAGS_TRACKDEBUGDATA       =0x00010000,


    COR_VERSION_MAJOR_V2                =2,
    COR_VERSION_MAJOR                   =COR_VERSION_MAJOR_V2,
    COR_VERSION_MINOR                   =5,
    COR_DELETED_NAME_LENGTH             =8,
    COR_VTABLEGAP_NAME_LENGTH           =8,


    NATIVE_TYPE_MAX_CB                  =1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=0xFF,


    IMAGE_COR_MIH_METHODRVA             =0x01,
    IMAGE_COR_MIH_EHRVA                 =0x02,
    IMAGE_COR_MIH_BASICBLOCK            =0x08,


    COR_VTABLE_32BIT                    =0x01,          
    COR_VTABLE_64BIT                    =0x02,          
    COR_VTABLE_FROM_UNMANAGED           =0x04,          
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN  =0x08,  
    COR_VTABLE_CALL_MOST_DERIVED        =0x10,          


    IMAGE_COR_EATJ_THUNK_SIZE           =32,            


    
    MAX_CLASS_NAME                      =1024,
    MAX_PACKAGE_NAME                    =1024,
} ReplacesCorHdrNumericDefines;


typedef struct IMAGE_COR20_HEADER
{
    
    DWORD                   cb;
    WORD                    MajorRuntimeVersion;
    WORD                    MinorRuntimeVersion;

    
    IMAGE_DATA_DIRECTORY    MetaData;
    DWORD                   Flags;

    
    
    union {
        DWORD               EntryPointToken;
        DWORD               EntryPointRVA;
    } ;

    
    IMAGE_DATA_DIRECTORY    Resources;
    IMAGE_DATA_DIRECTORY    StrongNameSignature;

    
    IMAGE_DATA_DIRECTORY    CodeManagerTable;
    IMAGE_DATA_DIRECTORY    VTableFixups;
    IMAGE_DATA_DIRECTORY    ExportAddressTableJumps;

    
    IMAGE_DATA_DIRECTORY    ManagedNativeHeader;

} IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

#line 16887 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apiset.h"








































































































#line 106 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apiset.h"



#line 110 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apiset.h"









































































































































#line 248 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apiset.h"
#line 16893 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"







#pragma region Application Family






__declspec(dllimport)
 
WORD  
__stdcall
RtlCaptureStackBackTrace(
      DWORD FramesToSkip,
      DWORD FramesToCapture,
      PVOID * BackTrace,
      PDWORD BackTraceHash
    );


#line 16920 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 16922 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion

#pragma region Desktop Family






__declspec(dllimport)
void
__stdcall
RtlCaptureContext(
      PCONTEXT ContextRecord
    );


#line 16940 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 16942 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion



#pragma region Application Family



__declspec(dllimport)
void
__stdcall
RtlUnwind(
      PVOID TargetFrame,
      PVOID TargetIp,
      PEXCEPTION_RECORD ExceptionRecord,
      PVOID ReturnValue
    );


#line 16962 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion




























































































































































#line 17120 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





























































































































































#line 17278 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




































































































#line 17379 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

























#line 17405 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


#pragma region Application Family






__declspec(dllimport)
PVOID
__stdcall
RtlPcToFileHeader(
      PVOID PcValue,
      PVOID * BaseOfImage
    );


#line 17424 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 17426 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion


#pragma region Desktop Family








 
__declspec(dllimport)
SIZE_T
__stdcall
RtlCompareMemory(
      const void * Source1,
      const void * Source2,
      SIZE_T Length
    );


#line 17450 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 17452 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 17454 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion










#line 17466 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

























#line 17492 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _SINGLE_LIST_ENTRY SLIST_ENTRY, *PSLIST_ENTRY;

#line 17496 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
















#line 17513 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef union _SLIST_HEADER {
    ULONGLONG Alignment;
    struct {
        SLIST_ENTRY Next;
        WORD   Depth;
        WORD   CpuId;
    } ;
} SLIST_HEADER, *PSLIST_HEADER;












#line 17535 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 17537 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


#pragma region Desktop Family


__declspec(dllimport)
void
__stdcall
RtlInitializeSListHead (
      PSLIST_HEADER ListHead
    );

 
__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlFirstEntrySList (
      const SLIST_HEADER *ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPopEntrySList (
      PSLIST_HEADER ListHead
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushEntrySList (
      PSLIST_HEADER ListHead,
        PSLIST_ENTRY ListEntry
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedPushListSListEx (
      PSLIST_HEADER ListHead,
        PSLIST_ENTRY List,
      PSLIST_ENTRY ListEnd,
      DWORD Count
    );

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
RtlInterlockedFlushSList (
      PSLIST_HEADER ListHead
    );

__declspec(dllimport)
WORD  
__stdcall
RtlQueryDepthSList (
      PSLIST_HEADER ListHead
    );

#line 17597 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion


























typedef union _RTL_RUN_ONCE {       
    PVOID Ptr;                      
} RTL_RUN_ONCE, *PRTL_RUN_ONCE;     

#line 17629 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _RTL_BARRIER {                       
            DWORD Reserved1;                        
            DWORD Reserved2;                        
            ULONG_PTR Reserved3[2];                 
            DWORD Reserved4;                        
            DWORD Reserved5;                        
} RTL_BARRIER, *PRTL_BARRIER;                       






































__declspec(noreturn)
void
__fastfail(
      unsigned int Code
    );

#pragma intrinsic(__fastfail)

#line 17684 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"















#pragma region Desktop Family


__forceinline
DWORD
HEAP_MAKE_TAG_FLAGS (
      DWORD TagBase,
      DWORD Tag
    )

{
    return ((DWORD)((TagBase) + ((Tag) << 18)));
}
#line 17713 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#line 17714 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion






















































#line 17770 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"











__forceinline
PVOID
RtlSecureZeroMemory(
      PVOID ptr,
      SIZE_T cnt
    )
{
    volatile char *vptr = (volatile char *)ptr;





#line 17795 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

    while (cnt) {





#line 17803 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

        *vptr = 0;

#line 17807 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

        vptr++;
        cnt--;
    }

#line 17813 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

    return ptr;
}

#line 17818 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"




















typedef struct _MESSAGE_RESOURCE_ENTRY {
    WORD   Length;
    WORD   Flags;
    BYTE  Text[ 1 ];
} MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;



typedef struct _MESSAGE_RESOURCE_BLOCK {
    DWORD LowId;
    DWORD HighId;
    DWORD OffsetToEntries;
} MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

typedef struct _MESSAGE_RESOURCE_DATA {
    DWORD NumberOfBlocks;
    MESSAGE_RESOURCE_BLOCK Blocks[ 1 ];
} MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

typedef struct _OSVERSIONINFOA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     
} OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

typedef struct _OSVERSIONINFOW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     
} OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;





typedef OSVERSIONINFOA OSVERSIONINFO;
typedef POSVERSIONINFOA POSVERSIONINFO;
typedef LPOSVERSIONINFOA LPOSVERSIONINFO;
#line 17883 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

typedef struct _OSVERSIONINFOEXA {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    CHAR   szCSDVersion[ 128 ];     
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
typedef struct _OSVERSIONINFOEXW {
    DWORD dwOSVersionInfoSize;
    DWORD dwMajorVersion;
    DWORD dwMinorVersion;
    DWORD dwBuildNumber;
    DWORD dwPlatformId;
    WCHAR  szCSDVersion[ 128 ];     
    WORD   wServicePackMajor;
    WORD   wServicePackMinor;
    WORD   wSuiteMask;
    BYTE  wProductType;
    BYTE  wReserved;
} OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;





typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;
#line 17919 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"













































#pragma region Desktop Family


















__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
      ULONGLONG ConditionMask,
      DWORD TypeMask,
      BYTE  Condition
    );

#line 17993 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 17995 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 17997 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion



#pragma region Desktop Family






__declspec(dllimport)
BOOLEAN
__stdcall
RtlGetProductInfo(
       DWORD  OSMajorVersion,
       DWORD  OSMinorVersion,
       DWORD  SpMajorVersion,
       DWORD  SpMinorVersion,
      PDWORD ReturnedProductType
    );

#line 18020 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



#line 18024 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion



typedef enum _RTL_UMS_THREAD_INFO_CLASS {
    UmsThreadInvalidInfoClass = 0,
    UmsThreadUserContext,
    UmsThreadPriority,              
    UmsThreadAffinity,              
    UmsThreadTeb,
    UmsThreadIsSuspended,
    UmsThreadIsTerminated,
    UmsThreadMaxInfoClass
} RTL_UMS_THREAD_INFO_CLASS, *PRTL_UMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON {
    UmsSchedulerStartup = 0,
    UmsSchedulerThreadBlocked,
    UmsSchedulerThreadYield,
} RTL_UMS_SCHEDULER_REASON, *PRTL_UMS_SCHEDULER_REASON;

typedef
 
void
__stdcall
RTL_UMS_SCHEDULER_ENTRY_POINT(
      RTL_UMS_SCHEDULER_REASON Reason,
      ULONG_PTR ActivationPayload,
      PVOID SchedulerParam
    );

typedef RTL_UMS_SCHEDULER_ENTRY_POINT *PRTL_UMS_SCHEDULER_ENTRY_POINT;
































#line 18089 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 18091 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"










#line 18102 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"






#pragma region Desktop Family








__declspec(dllimport)
DWORD
__stdcall
RtlCrc32(
      const void *Buffer,
      size_t Size,
      DWORD InitialCrc
    );

__declspec(dllimport)
ULONGLONG
__stdcall
RtlCrc64(
      const void *Buffer,
      size_t Size,
      ULONGLONG InitialCrc
    );



#line 18138 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma endregion



#line 18143 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


typedef struct _RTL_CRITICAL_SECTION_DEBUG {
    WORD   Type;
    WORD   CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION *CriticalSection;
    LIST_ENTRY ProcessLocksList;
    DWORD EntryCount;
    DWORD ContentionCount;
    DWORD Flags;
    WORD   CreatorBackTraceIndexHigh;
    WORD   SpareWORD  ;
} RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;




















#pragma pack(push, 8)

typedef struct _RTL_CRITICAL_SECTION {
    PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

    
    
    
    

    LONG LockCount;
    LONG RecursionCount;
    HANDLE OwningThread;        
    HANDLE LockSemaphore;
    ULONG_PTR SpinCount;        
} RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

#pragma pack(pop)

typedef struct _RTL_SRWLOCK {                            
        PVOID Ptr;                                       
} RTL_SRWLOCK, *PRTL_SRWLOCK;                            

typedef struct _RTL_CONDITION_VARIABLE {                    
        PVOID Ptr;                                       
} RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;      


typedef
void
(__stdcall *PAPCFUNC)(
      ULONG_PTR Parameter
    );
typedef LONG (__stdcall *PVECTORED_EXCEPTION_HANDLER)(
    struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef enum _HEAP_INFORMATION_CLASS {

    HeapCompatibilityInformation = 0,
    HeapEnableTerminationOnCorruption = 1







#line 18226 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


} HEAP_INFORMATION_CLASS;










#line 18241 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"













typedef void (__stdcall * WAITORTIMERCALLBACKFUNC) (PVOID, BOOLEAN );   
typedef void (__stdcall * WORKERCALLBACKFUNC) (PVOID );                 
typedef void (__stdcall * APC_CALLBACK_FUNCTION) (DWORD   , PVOID, PVOID); 
typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK; 
typedef
void
(__stdcall *PFLS_CALLBACK_FUNCTION) (
     PVOID lpFlsData
    );

typedef
BOOLEAN
(__stdcall *PSECURE_MEMORY_CACHE_CALLBACK) (
      PVOID Addr,
      SIZE_T Range
    );




typedef enum _ACTIVATION_CONTEXT_INFO_CLASS {
    ActivationContextBasicInformation                       = 1,
    ActivationContextDetailedInformation                    = 2,
    AssemblyDetailedInformationInActivationContext          = 3,
    FileInformationInAssemblyOfAssemblyInActivationContext  = 4,
    RunlevelInformationInActivationContext                  = 5,
    CompatibilityInformationInActivationContext             = 6,
    ActivationContextManifestResourceName                   = 7,
    MaxActivationContextInfoClass,

    
    
    
    AssemblyDetailedInformationInActivationContxt           = 3,
    FileInformationInAssemblyOfAssemblyInActivationContxt   = 4
} ACTIVATION_CONTEXT_INFO_CLASS;




typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX {
    DWORD ulAssemblyIndex;
    DWORD ulFileIndexInAssembly;
} ACTIVATION_CONTEXT_QUERY_INDEX, * PACTIVATION_CONTEXT_QUERY_INDEX;

typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX * PCACTIVATION_CONTEXT_QUERY_INDEX;







typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulFilenameLength;
    DWORD ulPathLength;

    PCWSTR lpFileName;
    PCWSTR lpFilePath;
} ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
typedef const ASSEMBLY_FILE_DETAILED_INFORMATION *PCASSEMBLY_FILE_DETAILED_INFORMATION;










typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION {
    DWORD ulFlags;
    DWORD ulEncodedAssemblyIdentityLength;      
    DWORD ulManifestPathType;                   
    DWORD ulManifestPathLength;                 
    LARGE_INTEGER liManifestLastWriteTime;      
    DWORD ulPolicyPathType;                     
    DWORD ulPolicyPathLength;                   
    LARGE_INTEGER liPolicyLastWriteTime;        
    DWORD ulMetadataSatelliteRosterIndex;

    DWORD ulManifestVersionMajor;               
    DWORD ulManifestVersionMinor;               
    DWORD ulPolicyVersionMajor;                 
    DWORD ulPolicyVersionMinor;                 
    DWORD ulAssemblyDirectoryNameLength;        

    PCWSTR lpAssemblyEncodedAssemblyIdentity;
    PCWSTR lpAssemblyManifestPath;
    PCWSTR lpAssemblyPolicyPath;
    PCWSTR lpAssemblyDirectoryName;

    DWORD  ulFileCount;
} ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, * PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION * PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION ;

typedef enum
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
    ACTCTX_RUN_LEVEL_AS_INVOKER,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
    ACTCTX_RUN_LEVEL_NUMBERS
} ACTCTX_REQUESTED_RUN_LEVEL;

typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION {
    DWORD ulFlags;
    ACTCTX_REQUESTED_RUN_LEVEL  RunLevel;
    DWORD UiAccess;
} ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, * PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION * PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION ;

typedef enum
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
} ACTCTX_COMPATIBILITY_ELEMENT_TYPE;

typedef struct _COMPATIBILITY_CONTEXT_ELEMENT {
    GUID Id;
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
} COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;

typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT *PCCOMPATIBILITY_CONTEXT_ELEMENT;

#pragma warning(push)
#pragma warning(disable:4200)

typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION {
    DWORD ElementCount;
    COMPATIBILITY_CONTEXT_ELEMENT Elements[];
} ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, * PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

#pragma warning(pop)

typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION * PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;




typedef struct _SUPPORTED_OS_INFO {
    WORD   OsCount;
    WORD   MitigationExist;
    WORD   OsList[(4)];
} SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;

typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION {
    DWORD dwFlags;
    DWORD ulFormatVersion;
    DWORD ulAssemblyCount;
    DWORD ulRootManifestPathType;
    DWORD ulRootManifestPathChars;
    DWORD ulRootConfigurationPathType;
    DWORD ulRootConfigurationPathChars;
    DWORD ulAppDirPathType;
    DWORD ulAppDirPathChars;
    PCWSTR lpRootManifestPath;
    PCWSTR lpRootConfigurationPath;
    PCWSTR lpAppDirPath;
} ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION *PCACTIVATION_CONTEXT_DETAILED_INFORMATION;




typedef struct _HARDWARE_COUNTER_DATA {
    HARDWARE_COUNTER_TYPE Type;
    DWORD Reserved;
    DWORD64 Value;
} HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;



typedef struct _PERFORMANCE_DATA {
    WORD   Size;
    BYTE  Version;
    BYTE  HwCountersCount;
    DWORD ContextSwitchCount;
    DWORD64 WaitReasonBitMap;
    DWORD64 CycleTime;
    DWORD RetryCount;
    DWORD Reserved;
    HARDWARE_COUNTER_DATA HwCounters[16];
} PERFORMANCE_DATA, *PPERFORMANCE_DATA;














































typedef struct _EVENTLOGRECORD {
    DWORD  Length;        
    DWORD  Reserved;      
    DWORD  RecordNumber;  
    DWORD  TimeGenerated; 
    DWORD  TimeWritten;   
    DWORD  EventID;
    WORD   EventType;
    WORD   NumStrings;
    WORD   EventCategory;
    WORD   ReservedFlags; 
    DWORD  ClosingRecordNumber; 
    DWORD  StringOffset;  
    DWORD  UserSidLength;
    DWORD  UserSidOffset;
    DWORD  DataLength;
    DWORD  DataOffset;    
    
    
    
    
    
    
    
    
    
    
    
} EVENTLOGRECORD, *PEVENTLOGRECORD;






#pragma warning(push)
#line 18527 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
#pragma warning(disable : 4200) 

struct _EVENTSFORLOGFILE;
typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;

struct _PACKEDEVENTINFO;
typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;



struct _EVENTSFORLOGFILE
{
    DWORD           ulSize;
    WCHAR           szLogicalLogFile[256];        
    DWORD           ulNumRecords;
    EVENTLOGRECORD  pEventLogRecords[];
};

struct _PACKEDEVENTINFO
{
    DWORD               ulSize;  
    DWORD               ulNumEventsForLogFile; 
    DWORD               ulOffsets[];           
};

#line 18553 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


#pragma warning(pop)


#line 18559 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





















































                                                    


                                                    


                                                    


                                                    
                                                    






























































                                                      


















                                            






























































typedef enum _CM_SERVICE_NODE_TYPE {
    DriverType               = 0x00000001,
    FileSystemType           = 0x00000002,
    Win32ServiceOwnProcess   = 0x00000010,
    Win32ServiceShareProcess = 0x00000020,
    AdapterType              = 0x00000004,
    RecognizerType           = 0x00000008
} SERVICE_NODE_TYPE;

typedef enum _CM_SERVICE_LOAD_TYPE {
    BootLoad    = 0x00000000,
    SystemLoad  = 0x00000001,
    AutoLoad    = 0x00000002,
    DemandLoad  = 0x00000003,
    DisableLoad = 0x00000004
} SERVICE_LOAD_TYPE;

typedef enum _CM_ERROR_CONTROL_TYPE {
    IgnoreError   = 0x00000000,
    NormalError   = 0x00000001,
    SevereError   = 0x00000002,
    CriticalError = 0x00000003
} SERVICE_ERROR_TYPE;

































































typedef struct _TAPE_ERASE {
    DWORD Type;
    BOOLEAN Immediate;
} TAPE_ERASE, *PTAPE_ERASE;












typedef struct _TAPE_PREPARE {
    DWORD Operation;
    BOOLEAN Immediate;
} TAPE_PREPARE, *PTAPE_PREPARE;










typedef struct _TAPE_WRITE_MARKS {
    DWORD Type;
    DWORD Count;
    BOOLEAN Immediate;
} TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;









typedef struct _TAPE_GET_POSITION {
    DWORD Type;
    DWORD Partition;
    LARGE_INTEGER Offset;
} TAPE_GET_POSITION, *PTAPE_GET_POSITION;
















typedef struct _TAPE_SET_POSITION {
    DWORD Method;
    DWORD Partition;
    LARGE_INTEGER Offset;
    BOOLEAN Immediate;
} TAPE_SET_POSITION, *PTAPE_SET_POSITION;























































































typedef struct _TAPE_GET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD DefaultBlockSize;
    DWORD MaximumBlockSize;
    DWORD MinimumBlockSize;
    DWORD MaximumPartitionCount;
    DWORD FeaturesLow;
    DWORD FeaturesHigh;
    DWORD EOTWarningZoneSize;
} TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;





typedef struct _TAPE_SET_DRIVE_PARAMETERS {
    BOOLEAN ECC;
    BOOLEAN Compression;
    BOOLEAN DataPadding;
    BOOLEAN ReportSetmarks;
    DWORD EOTWarningZoneSize;
} TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;





typedef struct _TAPE_GET_MEDIA_PARAMETERS {
    LARGE_INTEGER Capacity;
    LARGE_INTEGER Remaining;
    DWORD BlockSize;
    DWORD PartitionCount;
    BOOLEAN WriteProtected;
} TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;





typedef struct _TAPE_SET_MEDIA_PARAMETERS {
    DWORD BlockSize;
} TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;









typedef struct _TAPE_CREATE_PARTITION {
    DWORD Method;
    DWORD Count;
    DWORD Size;
} TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;











typedef struct _TAPE_WMI_OPERATIONS {
   DWORD Method;
   DWORD DataBufferSize;
   PVOID DataBuffer;
} TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;




typedef enum _TAPE_DRIVE_PROBLEM_TYPE {
   TapeDriveProblemNone, TapeDriveReadWriteWarning,
   TapeDriveReadWriteError, TapeDriveReadWarning,
   TapeDriveWriteWarning, TapeDriveReadError,
   TapeDriveWriteError, TapeDriveHardwareError,
   TapeDriveUnsupportedMedia, TapeDriveScsiConnectionError,
   TapeDriveTimetoClean, TapeDriveCleanDriveNow,
   TapeDriveMediaLifeExpired, TapeDriveSnappedTape
} TAPE_DRIVE_PROBLEM_TYPE;

#line 19103 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"





extern "C" {
#line 19110 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\ktmtypes.h"






















extern "C" {
#line 25 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\ktmtypes.h"


typedef GUID UOW, *PUOW;
typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;

















































typedef ULONG NOTIFICATION_MASK;






















































typedef struct _TRANSACTION_NOTIFICATION {
    PVOID         TransactionKey;
    ULONG         TransactionNotification;
    LARGE_INTEGER TmVirtualClock;
    ULONG         ArgumentLength;
} TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;

typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT {
    GUID   EnlistmentId;
    UOW    UOW;
} TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;



typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT {
    GUID TmIdentity;
    ULONG Flags;
} TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;

typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;

typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT {
    SAVEPOINT_ID SavepointId;
} TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT {
    ULONG PropagationCookie;
    GUID  UOW;
    GUID  TmIdentity;
    ULONG BufferLength;
    
} TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;

typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT {
    ULONG MarshalCookie;
    GUID  UOW;
} TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;

typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;







typedef struct _KCRM_MARSHAL_HEADER {
    ULONG              VersionMajor;
    ULONG              VersionMinor;
    ULONG              NumProtocols;
    ULONG              Unused;        
} KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, * PRKCRM_MARSHAL_HEADER;

typedef struct _KCRM_TRANSACTION_BLOB {
    UOW                UOW;
    GUID               TmIdentity;
    ULONG              IsolationLevel;
    ULONG              IsolationFlags;
    ULONG              Timeout;
    WCHAR              Description[64];
} KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, * PRKCRM_TRANSACTION_BLOB;

typedef struct _KCRM_PROTOCOL_BLOB {
    CRM_PROTOCOL_ID    ProtocolId;
      ULONG StaticInfoLength;
    ULONG              TransactionIdInfoLength; 
    ULONG              Unused1;        
    ULONG              Unused2;        
} KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, * PRKCRM_PROTOCOL_BLOB;


}
#line 206 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\ktmtypes.h"

#line 208 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\ktmtypes.h"
#line 19113 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








































































































































































typedef enum _TRANSACTION_OUTCOME {
    TransactionOutcomeUndetermined = 1,
    TransactionOutcomeCommitted,
    TransactionOutcomeAborted,
} TRANSACTION_OUTCOME;


typedef enum _TRANSACTION_STATE {
    TransactionStateNormal = 1,
    TransactionStateIndoubt,
    TransactionStateCommittedNotify,
} TRANSACTION_STATE;


typedef struct _TRANSACTION_BASIC_INFORMATION {
    GUID    TransactionId;
    DWORD   State;
    DWORD   Outcome;
} TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION {
    GUID    TmIdentity;
    LARGE_INTEGER VirtualClock;
} TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION {
    GUID  LogIdentity;
} TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION {
    DWORD LogPathLength;
      WCHAR LogPath[1]; 

} TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION {
    ULONGLONG  LastRecoveredLsn;
} TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;



typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION {
    GUID OldestTransactionGuid;
} TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;



typedef struct _TRANSACTION_PROPERTIES_INFORMATION {
    DWORD              IsolationLevel;
    DWORD              IsolationFlags;
    LARGE_INTEGER      Timeout;
    DWORD              Outcome;
    DWORD              DescriptionLength;
    WCHAR              Description[1];            

} TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;



typedef struct _TRANSACTION_BIND_INFORMATION {
    HANDLE TmHandle;
} TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

typedef struct _TRANSACTION_ENLISTMENT_PAIR {
    GUID   EnlistmentId;
    GUID   ResourceManagerId;
} TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION {
    DWORD                       NumberOfEnlistments;
    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1]; 
} TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION {
    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
} TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;


typedef struct _RESOURCEMANAGER_BASIC_INFORMATION {
    GUID    ResourceManagerId;
    DWORD   DescriptionLength;
    WCHAR   Description[1];            
} RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION {
    HANDLE    IoCompletionPortHandle;
    ULONG_PTR CompletionKey;
} RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;




typedef enum _TRANSACTION_INFORMATION_CLASS {
    TransactionBasicInformation,
    TransactionPropertiesInformation,
    TransactionEnlistmentInformation,
    TransactionSuperiorEnlistmentInformation

    ,


    TransactionBindInformation, 
    TransactionDTCPrivateInformation 
    ,

} TRANSACTION_INFORMATION_CLASS;


typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS {
    TransactionManagerBasicInformation,
    TransactionManagerLogInformation,
    TransactionManagerLogPathInformation,
    TransactionManagerRecoveryInformation = 4

    ,



    TransactionManagerOnlineProbeInformation = 3,
    TransactionManagerOldestTransactionInformation = 5



} TRANSACTIONMANAGER_INFORMATION_CLASS;



typedef enum _RESOURCEMANAGER_INFORMATION_CLASS {
    ResourceManagerBasicInformation,
    ResourceManagerCompletionInformation,
} RESOURCEMANAGER_INFORMATION_CLASS;


typedef struct _ENLISTMENT_BASIC_INFORMATION {
    GUID    EnlistmentId;
    GUID    TransactionId;
    GUID    ResourceManagerId;
} ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

typedef struct _ENLISTMENT_CRM_INFORMATION {
    GUID   CrmTransactionManagerId;
    GUID   CrmResourceManagerId;
    GUID   CrmEnlistmentId;
} ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;



typedef enum _ENLISTMENT_INFORMATION_CLASS {
    EnlistmentBasicInformation,
    EnlistmentRecoveryInformation,
    EnlistmentCrmInformation
} ENLISTMENT_INFORMATION_CLASS;

typedef struct _TRANSACTION_LIST_ENTRY {
    UOW    UOW;
} TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

typedef struct _TRANSACTION_LIST_INFORMATION {
    DWORD   NumberOfTransactions;
    TRANSACTION_LIST_ENTRY TransactionInformation[1]; 
} TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;






typedef enum _KTMOBJECT_TYPE {

    KTMOBJECT_TRANSACTION,
    KTMOBJECT_TRANSACTION_MANAGER,
    KTMOBJECT_RESOURCE_MANAGER,
    KTMOBJECT_ENLISTMENT,
    KTMOBJECT_INVALID

} KTMOBJECT_TYPE, *PKTMOBJECT_TYPE;









typedef struct _KTMOBJECT_CURSOR {

    
    
    

    GUID    LastQuery;

    
    
    

    DWORD   ObjectIdCount;

    
    
    

    GUID    ObjectIds[1];

} KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;




}
#line 19493 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 19495 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
typedef DWORD TP_VERSION, *PTP_VERSION; 

typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;

typedef void (__stdcall *PTP_SIMPLE_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context
    );

typedef struct _TP_POOL TP_POOL, *PTP_POOL; 

typedef enum _TP_CALLBACK_PRIORITY {
    TP_CALLBACK_PRIORITY_HIGH,
    TP_CALLBACK_PRIORITY_NORMAL,
    TP_CALLBACK_PRIORITY_LOW,
    TP_CALLBACK_PRIORITY_INVALID,
    TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID
} TP_CALLBACK_PRIORITY;

typedef struct _TP_POOL_STACK_INFORMATION {
    SIZE_T StackReserve;
    SIZE_T StackCommit;
}TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;

typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP; 

typedef void (__stdcall *PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(
      PVOID ObjectContext,
      PVOID CleanupContext
    );








typedef struct _TP_CALLBACK_ENVIRON_V3 {
    TP_VERSION                         Version;
    PTP_POOL                           Pool;
    PTP_CLEANUP_GROUP                  CleanupGroup;
    PTP_CLEANUP_GROUP_CANCEL_CALLBACK  CleanupGroupCancelCallback;
    PVOID                              RaceDll;
    struct _ACTIVATION_CONTEXT        *ActivationContext;
    PTP_SIMPLE_CALLBACK                FinalizationCallback;
    union {
        DWORD                          Flags;
        struct {
            DWORD                      LongFunction :  1;
            DWORD                      Persistent   :  1;
            DWORD                      Private      : 30;
        } s;
    } u;
    TP_CALLBACK_PRIORITY               CallbackPriority;
    DWORD                              Size;
} TP_CALLBACK_ENVIRON_V3;

typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;























#line 19578 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"



__forceinline
void
TpInitializeCallbackEnviron(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{



    CallbackEnviron->Version = 3;





#line 19597 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

    CallbackEnviron->Pool = 0;
    CallbackEnviron->CleanupGroup = 0;
    CallbackEnviron->CleanupGroupCancelCallback = 0;
    CallbackEnviron->RaceDll = 0;
    CallbackEnviron->ActivationContext = 0;
    CallbackEnviron->FinalizationCallback = 0;
    CallbackEnviron->u.Flags = 0;



    CallbackEnviron->CallbackPriority = TP_CALLBACK_PRIORITY_NORMAL;
    CallbackEnviron->Size = sizeof(TP_CALLBACK_ENVIRON);

#line 19612 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

}

__forceinline
void
TpSetCallbackThreadpool(
      PTP_CALLBACK_ENVIRON CallbackEnviron,
         PTP_POOL             Pool
    )
{
    CallbackEnviron->Pool = Pool;
}

__forceinline
void
TpSetCallbackCleanupGroup(
       PTP_CALLBACK_ENVIRON              CallbackEnviron,
          PTP_CLEANUP_GROUP                 CleanupGroup,
      PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback
    )
{
    CallbackEnviron->CleanupGroup = CleanupGroup;
    CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
}

__forceinline
void
TpSetCallbackActivationContext(
       PTP_CALLBACK_ENVIRON CallbackEnviron,
      struct _ACTIVATION_CONTEXT *ActivationContext
    )
{
    CallbackEnviron->ActivationContext = ActivationContext;
}

__forceinline
void
TpSetCallbackNoActivationContext(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT *)(LONG_PTR) -1; 
}

__forceinline
void
TpSetCallbackLongFunction(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.LongFunction = 1;
}

__forceinline
void
TpSetCallbackRaceWithDll(
      PTP_CALLBACK_ENVIRON CallbackEnviron,
         PVOID                DllHandle
    )
{
    CallbackEnviron->RaceDll = DllHandle;
}

__forceinline
void
TpSetCallbackFinalizationCallback(
      PTP_CALLBACK_ENVIRON CallbackEnviron,
         PTP_SIMPLE_CALLBACK  FinalizationCallback
    )
{
    CallbackEnviron->FinalizationCallback = FinalizationCallback;
}



__forceinline
void
TpSetCallbackPriority(
      PTP_CALLBACK_ENVIRON CallbackEnviron,
         TP_CALLBACK_PRIORITY Priority
    )
{
    CallbackEnviron->CallbackPriority = Priority;
}

#line 19698 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

__forceinline
void
TpSetCallbackPersistent(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    CallbackEnviron->u.s.Persistent = 1;
}


__forceinline
void
TpDestroyCallbackEnviron(
      PTP_CALLBACK_ENVIRON CallbackEnviron
    )
{
    
    
    
    
    

    (CallbackEnviron);
}

#line 19725 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


typedef struct _TP_WORK TP_WORK, *PTP_WORK;

typedef void (__stdcall *PTP_WORK_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context,
          PTP_WORK              Work
    );

typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;

typedef void (__stdcall *PTP_TIMER_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context,
          PTP_TIMER             Timer
    );

typedef DWORD    TP_WAIT_RESULT;

typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;

typedef void (__stdcall *PTP_WAIT_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context,
          PTP_WAIT              Wait,
             TP_WAIT_RESULT        WaitResult
    );

typedef struct _TP_IO TP_IO, *PTP_IO;



































#line 19791 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"
































#line 19824 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"








__inline struct _TEB * NtCurrentTeb( void ) { return (struct _TEB *) (ULONG_PTR) __readfsdword (0x18); }

#line 19835 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 19837 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"













#line 19851 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


}
#line 19855 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


#pragma warning(pop)



#line 19862 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"

#line 19864 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnt.h"


#line 183 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"
#line 184 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"


typedef UINT_PTR            WPARAM;
typedef LONG_PTR            LPARAM;
typedef LONG_PTR            LRESULT;




















typedef HANDLE          *SPHANDLE;
typedef HANDLE           *LPHANDLE;
typedef HANDLE              HGLOBAL;
typedef HANDLE              HLOCAL;
typedef HANDLE              GLOBALHANDLE;
typedef HANDLE              LOCALHANDLE;







typedef int ( __stdcall *FARPROC)();
typedef int ( __stdcall *NEARPROC)();
typedef int (__stdcall *PROC)();
#line 226 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"




#line 231 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"




#line 236 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"

typedef WORD                ATOM;   

struct HKEY__{int unused;}; typedef struct HKEY__ *HKEY;
typedef HKEY *PHKEY;
struct HMETAFILE__{int unused;}; typedef struct HMETAFILE__ *HMETAFILE;
struct HINSTANCE__{int unused;}; typedef struct HINSTANCE__ *HINSTANCE;
typedef HINSTANCE HMODULE;      
struct HRGN__{int unused;}; typedef struct HRGN__ *HRGN;
struct HRSRC__{int unused;}; typedef struct HRSRC__ *HRSRC;
struct HSPRITE__{int unused;}; typedef struct HSPRITE__ *HSPRITE;
struct HLSURF__{int unused;}; typedef struct HLSURF__ *HLSURF;
struct HSTR__{int unused;}; typedef struct HSTR__ *HSTR;
struct HTASK__{int unused;}; typedef struct HTASK__ *HTASK;
struct HWINSTA__{int unused;}; typedef struct HWINSTA__ *HWINSTA;
struct HKL__{int unused;}; typedef struct HKL__ *HKL;


typedef int HFILE;


#line 258 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"





typedef struct _FILETIME {
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME, *PFILETIME, *LPFILETIME;



}
#line 272 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"

#line 274 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"
#pragma endregion

#line 277 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\minwindef.h"

#line 25 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"







#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"



#pragma region Application Family


struct HWND__{int unused;}; typedef struct HWND__ *HWND;
struct HHOOK__{int unused;}; typedef struct HHOOK__ *HHOOK;

#line 43 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
#pragma endregion












#line 57 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

#pragma region Application Family




typedef void * HGDIOBJ;


#line 67 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
#line 68 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"


struct HACCEL__{int unused;}; typedef struct HACCEL__ *HACCEL;
#line 72 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

struct HBITMAP__{int unused;}; typedef struct HBITMAP__ *HBITMAP;
struct HBRUSH__{int unused;}; typedef struct HBRUSH__ *HBRUSH;
#line 76 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

struct HCOLORSPACE__{int unused;}; typedef struct HCOLORSPACE__ *HCOLORSPACE;
#line 79 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

struct HDC__{int unused;}; typedef struct HDC__ *HDC;
#line 82 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
struct HGLRC__{int unused;}; typedef struct HGLRC__ *HGLRC;          
struct HDESK__{int unused;}; typedef struct HDESK__ *HDESK;
struct HENHMETAFILE__{int unused;}; typedef struct HENHMETAFILE__ *HENHMETAFILE;

struct HFONT__{int unused;}; typedef struct HFONT__ *HFONT;
#line 88 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
struct HICON__{int unused;}; typedef struct HICON__ *HICON;

struct HMENU__{int unused;}; typedef struct HMENU__ *HMENU;
#line 92 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

struct HPALETTE__{int unused;}; typedef struct HPALETTE__ *HPALETTE;
struct HPEN__{int unused;}; typedef struct HPEN__ *HPEN;
#line 96 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"


struct HWINEVENTHOOK__{int unused;}; typedef struct HWINEVENTHOOK__ *HWINEVENTHOOK;
#line 100 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

#line 102 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
#pragma endregion




#pragma region Application Family


struct HMONITOR__{int unused;}; typedef struct HMONITOR__ *HMONITOR;

#line 113 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
#pragma endregion

#line 116 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

#pragma region Desktop Family


struct HUMPD__{int unused;}; typedef struct HUMPD__ *HUMPD;

#line 123 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
#pragma endregion

#line 126 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

#pragma region Application Family



typedef HICON HCURSOR;      


#line 135 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

typedef DWORD   COLORREF;

#line 139 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
#pragma endregion

#pragma region Desktop Family


typedef DWORD   *LPCOLORREF;



#line 149 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
#pragma endregion

#pragma region Application Family


typedef struct tagRECT
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECT, *PRECT,  *NPRECT,  *LPRECT;

typedef const RECT * LPCRECT;

typedef struct _RECTL       
{
    LONG    left;
    LONG    top;
    LONG    right;
    LONG    bottom;
} RECTL, *PRECTL, *LPRECTL;

typedef const RECTL * LPCRECTL;

typedef struct tagPOINT
{
    LONG  x;
    LONG  y;
} POINT, *PPOINT,  *NPPOINT,  *LPPOINT;

typedef struct _POINTL      
{
    LONG  x;
    LONG  y;
} POINTL, *PPOINTL;

typedef struct tagSIZE
{
    LONG        cx;
    LONG        cy;
} SIZE, *PSIZE, *LPSIZE;

typedef SIZE               SIZEL;
typedef SIZE               *PSIZEL, *LPSIZEL;

typedef struct tagPOINTS
{

    SHORT   x;
    SHORT   y;



#line 204 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
} POINTS, *PPOINTS, *LPPOINTS;

#line 207 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"
#pragma endregion

































}
#line 243 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

#line 245 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\windef.h"

#line 165 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"















#pragma once
#line 18 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#pragma warning(push)
#line 21 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma warning(disable:4001) 
#pragma warning(disable:4201) 
#pragma warning(disable:4214) 
#line 25 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
















#line 18 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 19 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"






#line 26 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 27 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"






#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"








#line 44 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 45 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"







#line 53 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"






#line 60 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 61 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"






#line 68 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 69 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"






#line 76 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 77 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"






#line 84 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 85 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"






#line 92 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 93 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"

#line 95 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\apisetcconv.h"
#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"







#pragma once




#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 17 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"

#pragma warning(push)
#line 20 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 24 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"





extern "C" {
#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"














typedef struct _SECURITY_ATTRIBUTES {
    DWORD nLength;
    LPVOID lpSecurityDescriptor;
    BOOL bInheritHandle;
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

typedef struct _OVERLAPPED {
    ULONG_PTR Internal;
    ULONG_PTR InternalHigh;
    union {
        struct {
            DWORD Offset;
            DWORD OffsetHigh;
        } ;
        PVOID Pointer;
    } ;

    HANDLE  hEvent;
} OVERLAPPED, *LPOVERLAPPED;

typedef struct _OVERLAPPED_ENTRY {
    ULONG_PTR lpCompletionKey;
    LPOVERLAPPED lpOverlapped;
    ULONG_PTR Internal;
    DWORD dwNumberOfBytesTransferred;
} OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;


















typedef struct _SYSTEMTIME {
    WORD wYear;
    WORD wMonth;
    WORD wDayOfWeek;
    WORD wDay;
    WORD wHour;
    WORD wMinute;
    WORD wSecond;
    WORD wMilliseconds;
} SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;


typedef struct _WIN32_FIND_DATAA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
      CHAR   cFileName[ 260 ];
      CHAR   cAlternateFileName[ 14 ];





} WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
typedef struct _WIN32_FIND_DATAW {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD dwReserved0;
    DWORD dwReserved1;
      WCHAR  cFileName[ 260 ];
      WCHAR  cAlternateFileName[ 14 ];





} WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;





typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;
#line 144 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"



typedef enum _FINDEX_INFO_LEVELS {
    FindExInfoStandard,
    FindExInfoBasic,
    FindExInfoMaxInfoLevel
} FINDEX_INFO_LEVELS;




typedef enum _FINDEX_SEARCH_OPS {
    FindExSearchNameMatch,
    FindExSearchLimitToDirectories,
    FindExSearchLimitToDevices,
    FindExSearchMaxSearchOp
} FINDEX_SEARCH_OPS;
#line 163 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"

typedef enum _GET_FILEEX_INFO_LEVELS {
    GetFileExInfoStandard,
    GetFileExMaxInfoLevel
} GET_FILEEX_INFO_LEVELS;


typedef enum _FILE_INFO_BY_HANDLE_CLASS {
    FileBasicInfo,
    FileStandardInfo,
    FileNameInfo,
    FileRenameInfo,
    FileDispositionInfo,
    FileAllocationInfo,
    FileEndOfFileInfo,
    FileStreamInfo,
    FileCompressionInfo,
    FileAttributeTagInfo,
    FileIdBothDirectoryInfo,
    FileIdBothDirectoryRestartInfo,
    FileIoPriorityHintInfo,
    FileRemoteProtocolInfo,
    FileFullDirectoryInfo,
    FileFullDirectoryRestartInfo,

    FileStorageInfo, 
    FileAlignmentInfo,    
    FileIdInfo,
    FileIdExtdDirectoryInfo,
    FileIdExtdDirectoryRestartInfo,
#line 194 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"
    MaximumFileInfoByHandleClass
} FILE_INFO_BY_HANDLE_CLASS, *PFILE_INFO_BY_HANDLE_CLASS;
#line 197 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"

typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

typedef
void
(__stdcall *LPOVERLAPPED_COMPLETION_ROUTINE)(
         DWORD dwErrorCode,
         DWORD dwNumberOfBytesTransfered,
      LPOVERLAPPED lpOverlapped
    );




typedef struct _PROCESS_HEAP_ENTRY {
    PVOID lpData;
    DWORD cbData;
    BYTE cbOverhead;
    BYTE iRegionIndex;
    WORD wFlags;
    union {
        struct {
            HANDLE hMem;
            DWORD dwReserved[ 3 ];
        } Block;
        struct {
            DWORD dwCommittedSize;
            DWORD dwUnCommittedSize;
            LPVOID lpFirstBlock;
            LPVOID lpLastBlock;
        } Region;
    } ;
} PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;








typedef struct _REASON_CONTEXT {
    ULONG Version;
    DWORD Flags;
    union {
        struct {
            HMODULE LocalizedReasonModule;
            ULONG LocalizedReasonId;
            ULONG ReasonStringCount;
            LPWSTR *ReasonStrings;

        } Detailed;

        LPWSTR SimpleReasonString;
    } Reason;
} REASON_CONTEXT, *PREASON_CONTEXT;














typedef DWORD (__stdcall *PTHREAD_START_ROUTINE)(
    LPVOID lpThreadParameter
    );
typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

typedef struct _EXCEPTION_DEBUG_INFO {
    EXCEPTION_RECORD ExceptionRecord;
    DWORD dwFirstChance;
} EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

typedef struct _CREATE_THREAD_DEBUG_INFO {
    HANDLE hThread;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
} CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

typedef struct _CREATE_PROCESS_DEBUG_INFO {
    HANDLE hFile;
    HANDLE hProcess;
    HANDLE hThread;
    LPVOID lpBaseOfImage;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpThreadLocalBase;
    LPTHREAD_START_ROUTINE lpStartAddress;
    LPVOID lpImageName;
    WORD fUnicode;
} CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

typedef struct _EXIT_THREAD_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

typedef struct _EXIT_PROCESS_DEBUG_INFO {
    DWORD dwExitCode;
} EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

typedef struct _LOAD_DLL_DEBUG_INFO {
    HANDLE hFile;
    LPVOID lpBaseOfDll;
    DWORD dwDebugInfoFileOffset;
    DWORD nDebugInfoSize;
    LPVOID lpImageName;
    WORD fUnicode;
} LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

typedef struct _UNLOAD_DLL_DEBUG_INFO {
    LPVOID lpBaseOfDll;
} UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

typedef struct _OUTPUT_DEBUG_STRING_INFO {
    LPSTR lpDebugStringData;
    WORD fUnicode;
    WORD nDebugStringLength;
} OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

typedef struct _RIP_INFO {
    DWORD dwError;
    DWORD dwType;
} RIP_INFO, *LPRIP_INFO;


typedef struct _DEBUG_EVENT {
    DWORD dwDebugEventCode;
    DWORD dwProcessId;
    DWORD dwThreadId;
    union {
        EXCEPTION_DEBUG_INFO Exception;
        CREATE_THREAD_DEBUG_INFO CreateThread;
        CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        EXIT_THREAD_DEBUG_INFO ExitThread;
        EXIT_PROCESS_DEBUG_INFO ExitProcess;
        LOAD_DLL_DEBUG_INFO LoadDll;
        UNLOAD_DLL_DEBUG_INFO UnloadDll;
        OUTPUT_DEBUG_STRING_INFO DebugString;
        RIP_INFO RipInfo;
    } u;
} DEBUG_EVENT, *LPDEBUG_EVENT;







typedef PCONTEXT LPCONTEXT;
#line 360 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"

























































}
#line 419 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"





#pragma warning(pop)





#line 431 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"
#line 432 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"

#line 434 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\minwinbase.h"

#line 32 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"
 











#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"




















#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"


extern "C" {
#line 40 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"




#pragma region Desktop Family





__declspec(dllimport)
 
LPCH
__stdcall
GetEnvironmentStrings(
    void
    );


__declspec(dllimport)
 
LPWCH
__stdcall
GetEnvironmentStringsW(
    void
    );






#line 73 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsW(
         LPWCH NewEnvironment
    );





__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsA(
         LPCH penv
    );

__declspec(dllimport)
BOOL
__stdcall
FreeEnvironmentStringsW(
         LPWCH penv
    );





#line 104 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

__declspec(dllimport)
HANDLE
__stdcall
GetStdHandle(
      DWORD nStdHandle
    );


__declspec(dllimport)
BOOL
__stdcall
SetStdHandle(
      DWORD nStdHandle,
      HANDLE hHandle
    );





__declspec(dllimport)
BOOL
__stdcall
SetStdHandleEx(
      DWORD nStdHandle,
      HANDLE hHandle,
      PHANDLE phPrevValue
    );


#line 136 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"



#line 140 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"
#pragma endregion

#pragma region Application Family





__declspec(dllimport)
LPSTR
__stdcall
GetCommandLineA(
    void
    );

__declspec(dllimport)
LPWSTR
__stdcall
GetCommandLineW(
    void
    );





#line 167 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"



#line 171 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
 
DWORD
__stdcall
GetEnvironmentVariableA(
      LPCSTR lpName,
      LPSTR lpBuffer,
      DWORD nSize
    );

__declspec(dllimport)
 
DWORD
__stdcall
GetEnvironmentVariableW(
      LPCWSTR lpName,
      LPWSTR lpBuffer,
      DWORD nSize
    );





#line 204 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableA(
      LPCSTR lpName,
      LPCSTR lpValue
    );

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentVariableW(
      LPCWSTR lpName,
      LPCWSTR lpValue
    );





#line 226 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

__declspec(dllimport)
 
DWORD
__stdcall
ExpandEnvironmentStringsA(
      LPCSTR lpSrc,
      LPSTR lpDst,
      DWORD nSize
    );

__declspec(dllimport)
 
DWORD
__stdcall
ExpandEnvironmentStringsW(
      LPCWSTR lpSrc,
      LPWSTR lpDst,
      DWORD nSize
    );





#line 252 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryA(
      LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
SetCurrentDirectoryW(
      LPCWSTR lpPathName
    );





#line 272 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetCurrentDirectoryA(
      DWORD nBufferLength,
      LPSTR lpBuffer
    );

__declspec(dllimport)
 
DWORD
__stdcall
GetCurrentDirectoryW(
      DWORD nBufferLength,
      LPWSTR lpBuffer
    );





#line 296 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

__declspec(dllimport)
DWORD
__stdcall
SearchPathW(
      LPCWSTR lpPath,
      LPCWSTR lpFileName,
      LPCWSTR lpExtension,
      DWORD nBufferLength,
      LPWSTR lpBuffer,
      LPWSTR * lpFilePart
    );






#line 315 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"








__declspec(dllimport)
DWORD
__stdcall
SearchPathA(
      LPCSTR lpPath,
      LPCSTR lpFileName,
      LPCSTR lpExtension,
      DWORD nBufferLength,
      LPSTR lpBuffer,
      LPSTR * lpFilePart
    );





__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathA(
      LPCSTR ExeName
    );

__declspec(dllimport)
BOOL
__stdcall
NeedCurrentDirectoryForExePathW(
      LPCWSTR ExeName
    );





#line 358 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

#line 360 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

#line 362 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"



#line 366 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"
#pragma endregion





}
#line 374 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"

#line 376 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processenv.h"


#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
 
 












#pragma once
#line 17 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"





















#line 39 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"


extern "C" {
#line 43 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#pragma region Application Family
















#line 62 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion







#pragma region Desktop Family



__declspec(dllimport)
LONG
__stdcall
CompareFileTime(
      const FILETIME * lpFileTime1,
      const FILETIME * lpFileTime2
    );


#line 84 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryA(
      LPCSTR lpPathName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryW(
      LPCWSTR lpPathName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );





#line 111 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 113 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
HANDLE
__stdcall
CreateFileA(
      LPCSTR lpFileName,
      DWORD dwDesiredAccess,
      DWORD dwShareMode,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      DWORD dwCreationDisposition,
      DWORD dwFlagsAndAttributes,
      HANDLE hTemplateFile
    );

__declspec(dllimport)
HANDLE
__stdcall
CreateFileW(
      LPCWSTR lpFileName,
      DWORD dwDesiredAccess,
      DWORD dwShareMode,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      DWORD dwCreationDisposition,
      DWORD dwFlagsAndAttributes,
      HANDLE hTemplateFile
    );





#line 150 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceW(
      DWORD dwFlags,
      LPCWSTR lpDeviceName,
      LPCWSTR lpTargetPath
    );






#line 166 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
DeleteFileA(
      LPCSTR lpFileName
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteFileW(
      LPCWSTR lpFileName
    );





#line 191 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 193 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointW(
      LPCWSTR lpszVolumeMountPoint
    );






__declspec(dllimport)
BOOL
__stdcall
FileTimeToLocalFileTime(
      const FILETIME * lpFileTime,
      LPFILETIME lpLocalFileTime
    );


#line 221 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family






__declspec(dllimport)
BOOL
__stdcall
FindClose(
      HANDLE hFindFile
    );


#line 239 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
FindCloseChangeNotification(
      HANDLE hChangeHandle
    );


__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationA(
      LPCSTR lpPathName,
      BOOL bWatchSubtree,
      DWORD dwNotifyFilter
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstChangeNotificationW(
      LPCWSTR lpPathName,
      BOOL bWatchSubtree,
      DWORD dwNotifyFilter
    );





#line 276 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileA(
      LPCSTR lpFileName,
      LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileW(
      LPCWSTR lpFileName,
      LPWIN32_FIND_DATAW lpFindFileData
    );





#line 298 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 300 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family






__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExA(
      LPCSTR lpFileName,
      FINDEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFindFileData,
      FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
      DWORD dwAdditionalFlags
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileExW(
      LPCWSTR lpFileName,
      FINDEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFindFileData,
      FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
      DWORD dwAdditionalFlags
    );





#line 338 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 340 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 342 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeW(
      LPWSTR lpszVolumeName,
      DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindNextChangeNotification(
      HANDLE hChangeHandle
    );


#line 370 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
FindNextFileA(
      HANDLE hFindFile,
      LPWIN32_FIND_DATAA lpFindFileData
    );

__declspec(dllimport)
BOOL
__stdcall
FindNextFileW(
      HANDLE hFindFile,
      LPWIN32_FIND_DATAW lpFindFileData
    );





#line 397 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 399 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeW(
      HANDLE hFindVolume,
      LPWSTR lpszVolumeName,
      DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
FindVolumeClose(
      HANDLE hFindVolume
    );


#line 428 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
FlushFileBuffers(
      HANDLE hFile
    );


#line 443 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceA(
      LPCSTR lpRootPathName,
      LPDWORD lpSectorsPerCluster,
      LPDWORD lpBytesPerSector,
      LPDWORD lpNumberOfFreeClusters,
      LPDWORD lpTotalNumberOfClusters
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceW(
      LPCWSTR lpRootPathName,
      LPDWORD lpSectorsPerCluster,
      LPDWORD lpBytesPerSector,
      LPDWORD lpNumberOfFreeClusters,
      LPDWORD lpTotalNumberOfClusters
    );





#line 476 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 478 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExA(
      LPCSTR lpDirectoryName,
      PULARGE_INTEGER lpFreeBytesAvailableToCaller,
      PULARGE_INTEGER lpTotalNumberOfBytes,
      PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );

__declspec(dllimport)
BOOL
__stdcall
GetDiskFreeSpaceExW(
      LPCWSTR lpDirectoryName,
      PULARGE_INTEGER lpFreeBytesAvailableToCaller,
      PULARGE_INTEGER lpTotalNumberOfBytes,
      PULARGE_INTEGER lpTotalNumberOfFreeBytes
    );





#line 509 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 511 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
UINT
__stdcall
GetDriveTypeA(
      LPCSTR lpRootPathName
    );

__declspec(dllimport)
UINT
__stdcall
GetDriveTypeW(
      LPCWSTR lpRootPathName
    );





#line 536 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesA(
      LPCSTR lpFileName
    );

__declspec(dllimport)
DWORD
__stdcall
GetFileAttributesW(
      LPCWSTR lpFileName
    );





#line 556 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 558 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



typedef struct _WIN32_FILE_ATTRIBUTE_DATA {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
} WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

#line 574 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExA(
      LPCSTR lpFileName,
      GET_FILEEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFileInformation
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesExW(
      LPCWSTR lpFileName,
      GET_FILEEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFileInformation
    );





#line 603 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 605 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



typedef struct _BY_HANDLE_FILE_INFORMATION {
    DWORD dwFileAttributes;
    FILETIME ftCreationTime;
    FILETIME ftLastAccessTime;
    FILETIME ftLastWriteTime;
    DWORD dwVolumeSerialNumber;
    DWORD nFileSizeHigh;
    DWORD nFileSizeLow;
    DWORD nNumberOfLinks;
    DWORD nFileIndexHigh;
    DWORD nFileIndexLow;
} BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandle(
      HANDLE hFile,
      LPBY_HANDLE_FILE_INFORMATION lpFileInformation
    );


__declspec(dllimport)
DWORD
__stdcall
GetFileSize(
      HANDLE hFile,
      LPDWORD lpFileSizeHigh
    );


__declspec(dllimport)
BOOL
__stdcall
GetFileSizeEx(
      HANDLE hFile,
      PLARGE_INTEGER lpFileSize
    );


__declspec(dllimport)
BOOL
__stdcall
GetFileTime(
      HANDLE hFile,
      LPFILETIME lpCreationTime,
      LPFILETIME lpLastAccessTime,
      LPFILETIME lpLastWriteTime
    );


__declspec(dllimport)
DWORD
__stdcall
GetFileType(
      HANDLE hFile
    );





__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleA(
      HANDLE hFile,
      LPSTR lpszFilePath,
      DWORD cchFilePath,
      DWORD dwFlags
    );

__declspec(dllimport)
DWORD
__stdcall
GetFinalPathNameByHandleW(
      HANDLE hFile,
      LPWSTR lpszFilePath,
      DWORD cchFilePath,
      DWORD dwFlags
    );





#line 698 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 700 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetFullPathNameA(
      LPCSTR lpFileName,
      DWORD nBufferLength,
      LPSTR lpBuffer,
     LPSTR * lpFilePart
    );

__declspec(dllimport)
 
DWORD
__stdcall
GetFullPathNameW(
      LPCWSTR lpFileName,
      DWORD nBufferLength,
      LPWSTR lpBuffer,
     LPWSTR * lpFilePart
    );





#line 728 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

__declspec(dllimport)
DWORD
__stdcall
GetLogicalDrives(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetLogicalDriveStringsW(
      DWORD nBufferLength,
      LPWSTR lpBuffer
    );






__declspec(dllimport)
 
DWORD
__stdcall
GetLongPathNameA(
      LPCSTR lpszShortPath,
      LPSTR lpszLongPath,
      DWORD cchBuffer
    );

__declspec(dllimport)
 
DWORD
__stdcall
GetLongPathNameW(
      LPCWSTR lpszShortPath,
      LPWSTR lpszLongPath,
      DWORD cchBuffer
    );





#line 775 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetShortPathNameW(
      LPCWSTR lpszLongPath,
      LPWSTR lpszShortPath,
      DWORD cchBuffer
    );






__declspec(dllimport)
UINT
__stdcall
GetTempFileNameW(
      LPCWSTR lpPathName,
      LPCWSTR lpPrefixString,
      UINT uUnique,
      LPWSTR lpTempFileName
    );









__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationByHandleW(
      HANDLE hFile,
      LPWSTR lpVolumeNameBuffer,
      DWORD nVolumeNameSize,
      LPDWORD lpVolumeSerialNumber,
      LPDWORD lpMaximumComponentLength,
      LPDWORD lpFileSystemFlags,
      LPWSTR lpFileSystemNameBuffer,
      DWORD nFileSystemNameSize
    );


#line 825 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationW(
      LPCWSTR lpRootPathName,
      LPWSTR lpVolumeNameBuffer,
      DWORD nVolumeNameSize,
      LPDWORD lpVolumeSerialNumber,
      LPDWORD lpMaximumComponentLength,
      LPDWORD lpFileSystemFlags,
      LPWSTR lpFileSystemNameBuffer,
      DWORD nFileSystemNameSize
    );






__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameW(
      LPCWSTR lpszFileName,
      LPWSTR lpszVolumePathName,
      DWORD cchBufferLength
    );






__declspec(dllimport)
BOOL
__stdcall
LocalFileTimeToFileTime(
      const FILETIME * lpLocalFileTime,
      LPFILETIME lpFileTime
    );


__declspec(dllimport)
BOOL
__stdcall
LockFile(
      HANDLE hFile,
      DWORD dwFileOffsetLow,
      DWORD dwFileOffsetHigh,
      DWORD nNumberOfBytesToLockLow,
      DWORD nNumberOfBytesToLockHigh
    );


#line 881 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
LockFileEx(
      HANDLE hFile,
      DWORD dwFlags,
      DWORD dwReserved,
      DWORD nNumberOfBytesToLockLow,
      DWORD nNumberOfBytesToLockHigh,
      LPOVERLAPPED lpOverlapped
    );


#line 901 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceW(
      LPCWSTR lpDeviceName,
      LPWSTR lpTargetPath,
      DWORD ucchMax
    );






#line 922 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
 
BOOL
__stdcall
ReadFile(
      HANDLE hFile,
       LPVOID lpBuffer,
      DWORD nNumberOfBytesToRead,
      LPDWORD lpNumberOfBytesRead,
      LPOVERLAPPED lpOverlapped
    );


#line 942 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
 
BOOL
__stdcall
ReadFileEx(
      HANDLE hFile,
       LPVOID lpBuffer,
      DWORD nNumberOfBytesToRead,
      LPOVERLAPPED lpOverlapped,
      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


__declspec(dllimport)
 
BOOL
__stdcall
ReadFileScatter(
      HANDLE hFile,
      FILE_SEGMENT_ELEMENT aSegmentArray[],
      DWORD nNumberOfBytesToRead,
      LPDWORD lpReserved,
      LPOVERLAPPED lpOverlapped
    );


#line 975 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryA(
      LPCSTR lpPathName
    );

__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryW(
      LPCWSTR lpPathName
    );





#line 1000 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetEndOfFile(
      HANDLE hFile
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesA(
      LPCSTR lpFileName,
      DWORD dwFileAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesW(
      LPCWSTR lpFileName,
      DWORD dwFileAttributes
    );





#line 1030 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"




__declspec(dllimport)
BOOL
__stdcall
SetFileInformationByHandle(
      HANDLE hFile,
      FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
      LPVOID lpFileInformation,
      DWORD dwBufferSize
    );


#line 1046 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 1048 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
SetFilePointer(
      HANDLE hFile,
      LONG lDistanceToMove,
      PLONG lpDistanceToMoveHigh,
      DWORD dwMoveMethod
    );


#line 1066 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
SetFilePointerEx(
      HANDLE hFile,
      LARGE_INTEGER liDistanceToMove,
      PLARGE_INTEGER lpNewFilePointer,
      DWORD dwMoveMethod
    );


#line 1084 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
SetFileTime(
      HANDLE hFile,
      const FILETIME * lpCreationTime,
      const FILETIME * lpLastAccessTime,
      const FILETIME * lpLastWriteTime
    );





__declspec(dllimport)
BOOL
__stdcall
SetFileValidData(
      HANDLE hFile,
      LONGLONG ValidDataLength
    );


#line 1114 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

__declspec(dllimport)
BOOL
__stdcall
UnlockFile(
      HANDLE hFile,
      DWORD dwFileOffsetLow,
      DWORD dwFileOffsetHigh,
      DWORD nNumberOfBytesToUnlockLow,
      DWORD nNumberOfBytesToUnlockHigh
    );


#line 1128 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
UnlockFileEx(
      HANDLE hFile,
      DWORD dwReserved,
      DWORD nNumberOfBytesToUnlockLow,
      DWORD nNumberOfBytesToUnlockHigh,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFile(
      HANDLE hFile,
      LPCVOID lpBuffer,
      DWORD nNumberOfBytesToWrite,
      LPDWORD lpNumberOfBytesWritten,
      LPOVERLAPPED lpOverlapped
    );


#line 1159 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
WriteFileEx(
      HANDLE hFile,
      LPCVOID lpBuffer,
      DWORD nNumberOfBytesToWrite,
      LPOVERLAPPED lpOverlapped,
      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );


__declspec(dllimport)
BOOL
__stdcall
WriteFileGather(
      HANDLE hFile,
      FILE_SEGMENT_ELEMENT aSegmentArray[],
      DWORD nNumberOfBytesToWrite,
      LPDWORD lpReserved,
      LPOVERLAPPED lpOverlapped
    );


#line 1190 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion








#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
GetTempPathW(
      DWORD nBufferLength,
      LPWSTR lpBuffer
    );






__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointW(
      LPCWSTR lpszVolumeMountPoint,
      LPWSTR lpszVolumeName,
      DWORD cchBufferLength
    );









__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameW(
      LPCWSTR lpszVolumeName,
         LPWCH lpszVolumePathNames,
      DWORD cchBufferLength,
      PDWORD lpcchReturnLength
    );






#line 1249 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 1251 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Application Family






typedef struct _CREATEFILE2_EXTENDED_PARAMETERS {
    DWORD dwSize;   
    DWORD dwFileAttributes;
    DWORD dwFileFlags;   
    DWORD dwSecurityQosFlags;	
    LPSECURITY_ATTRIBUTES lpSecurityAttributes; 
    HANDLE hTemplateFile;      
} CREATEFILE2_EXTENDED_PARAMETERS, *PCREATEFILE2_EXTENDED_PARAMETERS, *LPCREATEFILE2_EXTENDED_PARAMETERS;

__declspec(dllimport)
HANDLE
__stdcall
CreateFile2(
      LPCWSTR lpFileName,
      DWORD dwDesiredAccess,
      DWORD dwShareMode,
      DWORD dwCreationDisposition,
      LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams
    );


#line 1282 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 1284 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#line 1287 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"







#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
SetFileIoOverlappedRange(
      HANDLE FileHandle,
      PUCHAR OverlappedRangeStart,
      ULONG Length
    );


#line 1312 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 1314 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#pragma region Desktop Family






__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeA(
      LPCSTR lpFileName,
      LPDWORD lpFileSizeHigh
    );

__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeW(
      LPCWSTR lpFileName,
      LPDWORD lpFileSizeHigh
    );





#line 1344 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 1346 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 1348 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#pragma endregion

#line 1351 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"







}
#line 1360 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"

#line 1362 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fileapi.h"
#line 39 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"
 











#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"



















#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"


extern "C" {
#line 39 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"






#pragma region Application Family





__declspec(dllimport)
BOOL
__stdcall
IsDebuggerPresent(
    void
    );

#line 59 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"

#line 61 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
void
__stdcall
DebugBreak(
    void
    );


#line 76 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
void
__stdcall
OutputDebugStringA(
      LPCSTR lpOutputString
    );

__declspec(dllimport)
void
__stdcall
OutputDebugStringW(
      LPCWSTR lpOutputString
    );





#line 101 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"

#line 103 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"
#pragma endregion



#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
ContinueDebugEvent(
      DWORD dwProcessId,
      DWORD dwThreadId,
      DWORD dwContinueStatus
    );


__declspec(dllimport)
BOOL
__stdcall
WaitForDebugEvent(
      LPDEBUG_EVENT lpDebugEvent,
      DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcess(
      DWORD dwProcessId
    );


__declspec(dllimport)
BOOL
__stdcall
DebugActiveProcessStop(
      DWORD dwProcessId
    );




  
__declspec(dllimport)
BOOL
__stdcall
CheckRemoteDebuggerPresent(
      HANDLE hProcess,
      PBOOL pbDebuggerPresent
    );
  
  
#line 162 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"

#line 164 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"

#line 166 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"
#pragma endregion






}
#line 175 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"


#line 178 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\debugapi.h"


#line 40 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\utilapiset.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\utilapiset.h"
















#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\utilapiset.h"


extern "C" {
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\utilapiset.h"

#pragma region Application Family



__declspec(dllimport)
 
PVOID
__stdcall
EncodePointer(
      PVOID Ptr
    );


__declspec(dllimport)
 
PVOID
__stdcall
DecodePointer(
      PVOID Ptr
    );


#line 58 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\utilapiset.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
 
PVOID
__stdcall
EncodeSystemPointer(
      PVOID Ptr
    );


__declspec(dllimport)
 
PVOID
__stdcall
DecodeSystemPointer(
      PVOID Ptr
    );


__declspec(dllimport)
BOOL
__stdcall
Beep(
      DWORD dwFreq,
      DWORD dwDuration
    );


#line 92 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\utilapiset.h"
#pragma endregion


}
#line 97 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\utilapiset.h"

#line 99 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\utilapiset.h"
#line 41 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\handleapi.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\handleapi.h"
















#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\handleapi.h"


extern "C" {
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\handleapi.h"






#pragma region Application Family






__declspec(dllimport)
BOOL
__stdcall
CloseHandle(
      HANDLE hObject
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateHandle(
      HANDLE hSourceProcessHandle,
      HANDLE hSourceHandle,
      HANDLE hTargetProcessHandle,
     LPHANDLE lpTargetHandle,
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      DWORD dwOptions
    );


#line 70 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\handleapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
GetHandleInformation(
      HANDLE hObject,
      LPDWORD lpdwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetHandleInformation(
      HANDLE hObject,
      DWORD dwMask,
      DWORD dwFlags
    );


#line 96 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\handleapi.h"
#pragma endregion


}
#line 101 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\handleapi.h"

#line 103 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\handleapi.h"
#line 42 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"
 











#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"


















#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"


extern "C" {
#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"






#pragma region Desktop Family







typedef LONG (__stdcall *PTOP_LEVEL_EXCEPTION_FILTER)(
      struct _EXCEPTION_POINTERS *ExceptionInfo
    );

typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;





#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)

void
__stdcall
RaiseException(
      DWORD dwExceptionCode,
      DWORD dwExceptionFlags,
      DWORD nNumberOfArguments,
      const ULONG_PTR * lpArguments
    );


#line 82 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
LONG
__stdcall
UnhandledExceptionFilter(
      struct _EXCEPTION_POINTERS * ExceptionInfo
    );


__declspec(dllimport)
LPTOP_LEVEL_EXCEPTION_FILTER
__stdcall
SetUnhandledExceptionFilter(
      LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter
    );


#line 106 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Application Family





__declspec(dllimport)
   
DWORD
__stdcall
GetLastError(
    void
    );


#line 124 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"

__declspec(dllimport)
void
__stdcall
SetLastError(
      DWORD dwErrCode
    );


#line 134 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"
#pragma endregion

#pragma region Desktop Family






__declspec(dllimport)
UINT
__stdcall
GetErrorMode(
    void
    );


#line 152 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"

__declspec(dllimport)
UINT
__stdcall
SetErrorMode(
      UINT uMode
    );


#line 162 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"
#pragma endregion





#pragma region Desktop Family






__declspec(dllimport)
 
PVOID
__stdcall
AddVectoredExceptionHandler(
      ULONG First,
      PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredExceptionHandler(
      PVOID Handle
    );


__declspec(dllimport)
 
PVOID
__stdcall
AddVectoredContinueHandler(
      ULONG First,
      PVECTORED_EXCEPTION_HANDLER Handler
    );


__declspec(dllimport)
ULONG
__stdcall
RemoveVectoredContinueHandler(
      PVOID Handle
    );


#line 212 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"























#line 236 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"
#line 237 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"

#line 239 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"

#line 241 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"
#pragma endregion







}
#line 251 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"

#line 253 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\errhandlingapi.h"


#line 43 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"
 











#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"


















#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"


extern "C" {
#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"






#pragma region Application Family








#line 54 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"

__declspec(dllimport)
DWORD
__stdcall
FlsAlloc(
      PFLS_CALLBACK_FUNCTION lpCallback
    );


__declspec(dllimport)
PVOID
__stdcall
FlsGetValue(
      DWORD dwFlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
FlsSetValue(
      DWORD dwFlsIndex,
      PVOID lpFlsData
    );


__declspec(dllimport)
BOOL
__stdcall
FlsFree(
      DWORD dwFlsIndex
    );


#line 89 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"

#line 91 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"
#pragma endregion





#pragma region Application Family






__declspec(dllimport)
BOOL
__stdcall
IsThreadAFiber(
    void
    );


#line 113 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"

#line 115 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"
#pragma endregion







}
#line 125 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"

#line 127 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\fibersapi.h"


#line 44 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namedpipeapi.h"
 
 










#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namedpipeapi.h"



















#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namedpipeapi.h"


extern "C" {
#line 39 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namedpipeapi.h"








__declspec(dllimport)
BOOL
__stdcall
CreatePipe(
      PHANDLE hReadPipe,
      PHANDLE hWritePipe,
      LPSECURITY_ATTRIBUTES lpPipeAttributes,
      DWORD nSize
    );


__declspec(dllimport)
BOOL
__stdcall
ConnectNamedPipe(
      HANDLE hNamedPipe,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
DisconnectNamedPipe(
      HANDLE hNamedPipe
    );


__declspec(dllimport)
BOOL
__stdcall
SetNamedPipeHandleState(
      HANDLE hNamedPipe,
      LPDWORD lpMode,
      LPDWORD lpMaxCollectionCount,
      LPDWORD lpCollectDataTimeout
    );


__declspec(dllimport)
BOOL
__stdcall
PeekNamedPipe(
      HANDLE hNamedPipe,
      LPVOID lpBuffer,
      DWORD nBufferSize,
      LPDWORD lpBytesRead,
      LPDWORD lpTotalBytesAvail,
      LPDWORD lpBytesLeftThisMessage
    );


__declspec(dllimport)
BOOL
__stdcall
TransactNamedPipe(
      HANDLE hNamedPipe,
      LPVOID lpInBuffer,
      DWORD nInBufferSize,
      LPVOID lpOutBuffer,
      DWORD nOutBufferSize,
      LPDWORD lpBytesRead,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeW(
      LPCWSTR lpName,
      DWORD dwOpenMode,
      DWORD dwPipeMode,
      DWORD nMaxInstances,
      DWORD nOutBufferSize,
      DWORD nInBufferSize,
      DWORD nDefaultTimeOut,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );






__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeW(
      LPCWSTR lpNamedPipeName,
      DWORD nTimeOut
    );









__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameW(
      HANDLE Pipe,
      LPWSTR ClientComputerName,
      ULONG ClientComputerNameLength
    );


#line 159 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namedpipeapi.h"





#line 165 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namedpipeapi.h"






__declspec(dllimport)
 
BOOL
__stdcall
ImpersonateNamedPipeClient(
      HANDLE hNamedPipe
    );
                               

#line 181 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namedpipeapi.h"



}
#line 186 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namedpipeapi.h"

#line 188 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namedpipeapi.h"


#line 45 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\profileapi.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\profileapi.h"
















#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\profileapi.h"


extern "C" {
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\profileapi.h"





__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceCounter(
      LARGE_INTEGER * lpPerformanceCount
    );


__declspec(dllimport)
BOOL
__stdcall
QueryPerformanceFrequency(
      LARGE_INTEGER * lpFrequency
    );



}
#line 58 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\profileapi.h"

#line 60 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\profileapi.h"
#line 46 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"



















#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"


extern "C" {
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"

#pragma region Desktop Family







typedef struct _HEAP_SUMMARY {
    DWORD cb;
    SIZE_T cbAllocated;
    SIZE_T cbCommitted;
    SIZE_T cbReserved;
    SIZE_T cbMaxReserve;
} HEAP_SUMMARY, *PHEAP_SUMMARY;
typedef PHEAP_SUMMARY LPHEAP_SUMMARY;

#line 56 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"
#pragma endregion

#pragma region Desktop Family







__declspec(dllimport)
 
HANDLE
__stdcall
HeapCreate(
      DWORD flOptions,
      SIZE_T dwInitialSize,
      SIZE_T dwMaximumSize
    );


__declspec(dllimport)
BOOL
__stdcall
HeapDestroy(
      HANDLE hHeap
    );

    
#line 86 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
 
 
LPVOID
__stdcall
HeapAlloc(
      HANDLE hHeap,
      DWORD dwFlags,
      SIZE_T dwBytes
    );


__declspec(dllimport)
 
 
 
LPVOID
__stdcall
HeapReAlloc(
      HANDLE hHeap,
      DWORD dwFlags,
      LPVOID lpMem,
      SIZE_T dwBytes
    );


__declspec(dllimport)
 
BOOL
__stdcall
HeapFree(
      HANDLE hHeap,
      DWORD dwFlags,
        LPVOID lpMem
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapSize(
      HANDLE hHeap,
      DWORD dwFlags,
      LPCVOID lpMem
    );


#line 140 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
HeapValidate(
      HANDLE hHeap,
      DWORD dwFlags,
      LPCVOID lpMem
    );


__declspec(dllimport)
SIZE_T
__stdcall
HeapCompact(
      HANDLE hHeap,
      DWORD dwFlags
    );





BOOL
__stdcall
HeapSummary(
      HANDLE hHeap,
      DWORD dwFlags,
      LPHEAP_SUMMARY lpSummary
    );


#line 178 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"

#line 180 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
HANDLE
__stdcall
GetProcessHeap(
    void
    );


#line 195 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
GetProcessHeaps(
      DWORD NumberOfHeaps,
      PHANDLE ProcessHeaps
    );


__declspec(dllimport)
BOOL
__stdcall
HeapLock(
      HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapUnlock(
      HANDLE hHeap
    );


__declspec(dllimport)
BOOL
__stdcall
HeapWalk(
      HANDLE hHeap,
      LPPROCESS_HEAP_ENTRY lpEntry
    );


__declspec(dllimport)
BOOL
__stdcall
HeapSetInformation(
      HANDLE HeapHandle,
      HEAP_INFORMATION_CLASS HeapInformationClass,
      PVOID HeapInformation,
      SIZE_T HeapInformationLength
    );


__declspec(dllimport)
BOOL
__stdcall
HeapQueryInformation(
      HANDLE HeapHandle,
      HEAP_INFORMATION_CLASS HeapInformationClass,
      PVOID HeapInformation,
      SIZE_T HeapInformationLength,
      PSIZE_T ReturnLength
    );

    
#line 259 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"
#pragma endregion






}
#line 268 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"

#line 270 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\heapapi.h"
#line 47 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"
 











#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"



















#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"


extern "C" {
#line 39 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"






#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResult(
      HANDLE hFile,
      LPOVERLAPPED lpOverlapped,
      LPDWORD lpNumberOfBytesTransferred,
      BOOL bWait
    );


__declspec(dllimport)
 
HANDLE
__stdcall
CreateIoCompletionPort(
      HANDLE FileHandle,
      HANDLE ExistingCompletionPort,
      ULONG_PTR CompletionKey,
      DWORD NumberOfConcurrentThreads
    );


__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatus(
      HANDLE CompletionPort,
      LPDWORD lpNumberOfBytesTransferred,
      PULONG_PTR lpCompletionKey,
      LPOVERLAPPED * lpOverlapped,
      DWORD dwMilliseconds
    );





__declspec(dllimport)
BOOL
__stdcall
GetQueuedCompletionStatusEx(
      HANDLE CompletionPort,
      LPOVERLAPPED_ENTRY lpCompletionPortEntries,
      ULONG ulCount,
      PULONG ulNumEntriesRemoved,
      DWORD dwMilliseconds,
      BOOL fAlertable
    );


#line 101 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"

__declspec(dllimport)
BOOL
__stdcall
PostQueuedCompletionStatus(
      HANDLE CompletionPort,
      DWORD dwNumberOfBytesTransferred,
      ULONG_PTR dwCompletionKey,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
BOOL
__stdcall
DeviceIoControl(
      HANDLE hDevice,
      DWORD dwIoControlCode,
      LPVOID lpInBuffer,
      DWORD nInBufferSize,
      LPVOID lpOutBuffer,
      DWORD nOutBufferSize,
      LPDWORD lpBytesReturned,
      LPOVERLAPPED lpOverlapped
    );





__declspec(dllimport)
BOOL
__stdcall
CancelIoEx(
      HANDLE hFile,
      LPOVERLAPPED lpOverlapped
    );


#line 141 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"

#line 143 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"
#pragma endregion








#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
GetOverlappedResultEx(
      HANDLE hFile,
      LPOVERLAPPED lpOverlapped,
      LPDWORD lpNumberOfBytesTransferred,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );


#line 169 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
CancelIo(
      HANDLE hFile
    );





__declspec(dllimport)
BOOL
__stdcall
CancelSynchronousIo(
      HANDLE hThread
    );


#line 195 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"

#line 197 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"
#pragma endregion

#line 200 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"







}
#line 209 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"

#line 211 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ioapiset.h"


#line 48 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
 
 











#pragma once
#line 16 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"



















#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"


extern "C" {
#line 40 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"







#pragma region Application Family









typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;

#line 60 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion






#pragma region Application Family






__declspec(dllimport)
void
__stdcall
InitializeSRWLock(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockExclusive(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
ReleaseSRWLockShared(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockExclusive(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

void
__stdcall
AcquireSRWLockShared(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockExclusive(
      PSRWLOCK SRWLock
    );


__declspec(dllimport)

BOOLEAN
__stdcall
TryAcquireSRWLockShared(
      PSRWLOCK SRWLock
    );


#line 137 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

#line 139 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop Family















#line 158 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

__declspec(dllimport)
void
__stdcall
InitializeCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );


#line 168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

#line 170 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
void
__stdcall
EnterCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );


#line 193 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
 
BOOL
__stdcall
InitializeCriticalSectionAndSpinCount(
      LPCRITICAL_SECTION lpCriticalSection,
      DWORD dwSpinCount
    );


#line 210 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Application Family






__declspec(dllimport)
BOOL
__stdcall
InitializeCriticalSectionEx(
      LPCRITICAL_SECTION lpCriticalSection,
      DWORD dwSpinCount,
      DWORD Flags
    );


#line 230 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

#line 232 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
SetCriticalSectionSpinCount(
      LPCRITICAL_SECTION lpCriticalSection,
      DWORD dwSpinCount
    );


#line 248 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Application Family






__declspec(dllimport)
BOOL
__stdcall
TryEnterCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );


#line 266 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

__declspec(dllimport)
void
__stdcall
DeleteCriticalSection(
      LPCRITICAL_SECTION lpCriticalSection
    );










typedef RTL_RUN_ONCE INIT_ONCE;
typedef PRTL_RUN_ONCE PINIT_ONCE;
typedef PRTL_RUN_ONCE LPINIT_ONCE;


















typedef
BOOL
(__stdcall *PINIT_ONCE_FN) (
      PINIT_ONCE InitOnce,
      PVOID Parameter,
     PVOID *Context
    );




__declspec(dllimport)
void
__stdcall
InitOnceInitialize(
      PINIT_ONCE InitOnce
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceExecuteOnce(
      PINIT_ONCE InitOnce,
       PINIT_ONCE_FN InitFn,
      PVOID Parameter,
     LPVOID * Context
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceBeginInitialize(
      LPINIT_ONCE lpInitOnce,
      DWORD dwFlags,
      PBOOL fPending,
     LPVOID * lpContext
    );


__declspec(dllimport)
BOOL
__stdcall
InitOnceComplete(
      LPINIT_ONCE lpInitOnce,
      DWORD dwFlags,
      LPVOID lpContext
    );


#line 356 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"





typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;
















__declspec(dllimport)
void
__stdcall
InitializeConditionVariable(
      PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeConditionVariable(
      PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
void
__stdcall
WakeAllConditionVariable(
      PCONDITION_VARIABLE ConditionVariable
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableCS(
      PCONDITION_VARIABLE ConditionVariable,
      PCRITICAL_SECTION CriticalSection,
      DWORD dwMilliseconds
    );


__declspec(dllimport)
BOOL
__stdcall
SleepConditionVariableSRW(
      PCONDITION_VARIABLE ConditionVariable,
      PSRWLOCK SRWLock,
      DWORD dwMilliseconds,
      ULONG Flags
    );


#line 424 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"





__declspec(dllimport)
BOOL
__stdcall
SetEvent(
      HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ResetEvent(
      HANDLE hEvent
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseSemaphore(
      HANDLE hSemaphore,
      LONG lReleaseCount,
      LPLONG lpPreviousCount
    );


__declspec(dllimport)
BOOL
__stdcall
ReleaseMutex(
      HANDLE hMutex
    );


#line 464 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObject(
      HANDLE hHandle,
      DWORD dwMilliseconds
    );


#line 480 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
DWORD
__stdcall
SleepEx(
      DWORD dwMilliseconds,
      BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForSingleObjectEx(
      HANDLE hHandle,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );


__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjectsEx(
      DWORD nCount,
      const HANDLE * lpHandles,
      BOOL bWaitAll,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );









#line 525 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
 
HANDLE
__stdcall
CreateMutexA(
      LPSECURITY_ATTRIBUTES lpMutexAttributes,
      BOOL bInitialOwner,
      LPCSTR lpName
    );

__declspec(dllimport)
 
HANDLE
__stdcall
CreateMutexW(
      LPSECURITY_ATTRIBUTES lpMutexAttributes,
      BOOL bInitialOwner,
      LPCWSTR lpName
    );





#line 556 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

#line 558 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
 
HANDLE
__stdcall
OpenMutexW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );






#line 580 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
 
HANDLE
__stdcall
CreateEventA(
      LPSECURITY_ATTRIBUTES lpEventAttributes,
      BOOL bManualReset,
      BOOL bInitialState,
      LPCSTR lpName
    );

__declspec(dllimport)
 
HANDLE
__stdcall
CreateEventW(
      LPSECURITY_ATTRIBUTES lpEventAttributes,
      BOOL bManualReset,
      BOOL bInitialState,
      LPCWSTR lpName
    );





#line 613 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

#line 615 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
 
HANDLE
__stdcall
OpenEventA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );

__declspec(dllimport)
 
HANDLE
__stdcall
OpenEventW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );





#line 646 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenSemaphoreW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );






#line 663 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion




#pragma region Desktop Family



typedef
void
(__stdcall *PTIMERAPCROUTINE)(
      LPVOID lpArgToCompletionRoutine,
          DWORD dwTimerLowValue,
          DWORD dwTimerHighValue
    );

__declspec(dllimport)
 
HANDLE
__stdcall
OpenWaitableTimerW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpTimerName
    );









BOOL
__stdcall
SetWaitableTimerEx(
      HANDLE hTimer,
      const LARGE_INTEGER * lpDueTime,
      LONG lPeriod,
      PTIMERAPCROUTINE pfnCompletionRoutine,
      LPVOID lpArgToCompletionRoutine,
      PREASON_CONTEXT WakeContext,
      ULONG TolerableDelay
    );


#line 712 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetWaitableTimer(
      HANDLE hTimer,
      const LARGE_INTEGER * lpDueTime,
      LONG lPeriod,
      PTIMERAPCROUTINE pfnCompletionRoutine,
      LPVOID lpArgToCompletionRoutine,
      BOOL fResume
    );


__declspec(dllimport)
BOOL
__stdcall
CancelWaitableTimer(
      HANDLE hTimer
    );


#line 735 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion




#pragma region Application Family





__declspec(dllimport)
 
HANDLE
__stdcall
CreateMutexExA(
      LPSECURITY_ATTRIBUTES lpMutexAttributes,
      LPCSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );

__declspec(dllimport)
 
HANDLE
__stdcall
CreateMutexExW(
      LPSECURITY_ATTRIBUTES lpMutexAttributes,
      LPCWSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );





#line 773 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"




__declspec(dllimport)
 
HANDLE
__stdcall
CreateEventExA(
      LPSECURITY_ATTRIBUTES lpEventAttributes,
      LPCSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );

__declspec(dllimport)
 
HANDLE
__stdcall
CreateEventExW(
      LPSECURITY_ATTRIBUTES lpEventAttributes,
      LPCWSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );





#line 804 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

__declspec(dllimport)
 
HANDLE
__stdcall
CreateSemaphoreExW(
      LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
      LONG lInitialCount,
      LONG lMaximumCount,
      LPCWSTR lpName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );






#line 824 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
 
HANDLE
__stdcall
CreateWaitableTimerExW(
      LPSECURITY_ATTRIBUTES lpTimerAttributes,
      LPCWSTR lpTimerName,
      DWORD dwFlags,
      DWORD dwDesiredAccess
    );






#line 849 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#line 852 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

#line 854 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"








#pragma region Desktop Family



typedef RTL_BARRIER SYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER;
typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER;





BOOL
__stdcall
EnterSynchronizationBarrier(
      LPSYNCHRONIZATION_BARRIER lpBarrier,
      DWORD dwFlags
    );


BOOL
__stdcall
InitializeSynchronizationBarrier(
      LPSYNCHRONIZATION_BARRIER lpBarrier,
      LONG lTotalThreads,
      LONG lSpinCount
    );


BOOL
__stdcall
DeleteSynchronizationBarrier(
      LPSYNCHRONIZATION_BARRIER lpBarrier
    );


#line 899 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
void
__stdcall
Sleep(
      DWORD dwMilliseconds
    );


BOOL
__stdcall
WaitOnAddress(
      volatile void * Address,
      PVOID CompareAddress,
      SIZE_T AddressSize,
      DWORD dwMilliseconds
    );


void
__stdcall
WakeByAddressSingle(
      PVOID Address
    );


void
__stdcall
WakeByAddressAll(
      PVOID Address
    );

    
#line 938 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
      HANDLE hObjectToSignal,
      HANDLE hObjectToWaitOn,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );


#line 958 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

#line 960 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"
#pragma endregion

#line 963 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"






}
#line 971 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"

#line 973 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\synchapi.h"


#line 49 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"
 
 










#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"


















#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"


extern "C" {
#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"









__declspec(dllimport)
void
__stdcall
InitializeSListHead(
      PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPopEntrySList(
      PSLIST_HEADER ListHead
    );


__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPushEntrySList(
      PSLIST_HEADER ListHead,
      PSLIST_ENTRY ListEntry
    );







__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedPushListSListEx(
      PSLIST_HEADER ListHead,
      PSLIST_ENTRY List,
      PSLIST_ENTRY ListEnd,
      ULONG Count
    );


#line 89 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"

__declspec(dllimport)
PSLIST_ENTRY
__stdcall
InterlockedFlushSList(
      PSLIST_HEADER ListHead
    );


__declspec(dllimport)
USHORT
__stdcall
QueryDepthSList(
      PSLIST_HEADER ListHead
    );


#line 107 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"

#line 109 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"

#line 111 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"





}
#line 118 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"

#line 120 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\interlockedapi.h"

#line 50 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
 












#pragma once
#line 16 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"





















#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"


extern "C" {
#line 42 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"







#pragma region Desktop Family



typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess;
    HANDLE hThread;
    DWORD dwProcessId;
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

typedef struct _STARTUPINFOA {
    DWORD   cb;
    LPSTR   lpReserved;
    LPSTR   lpDesktop;
    LPSTR   lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOA, *LPSTARTUPINFOA;
typedef struct _STARTUPINFOW {
    DWORD   cb;
    LPWSTR  lpReserved;
    LPWSTR  lpDesktop;
    LPWSTR  lpTitle;
    DWORD   dwX;
    DWORD   dwY;
    DWORD   dwXSize;
    DWORD   dwYSize;
    DWORD   dwXCountChars;
    DWORD   dwYCountChars;
    DWORD   dwFillAttribute;
    DWORD   dwFlags;
    WORD    wShowWindow;
    WORD    cbReserved2;
    LPBYTE  lpReserved2;
    HANDLE  hStdInput;
    HANDLE  hStdOutput;
    HANDLE  hStdError;
} STARTUPINFOW, *LPSTARTUPINFOW;




typedef STARTUPINFOA STARTUPINFO;
typedef LPSTARTUPINFOA LPSTARTUPINFO;
#line 107 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"




__declspec(dllimport)
DWORD
__stdcall
QueueUserAPC(
      PAPCFUNC pfnAPC,
      HANDLE hThread,
      ULONG_PTR dwData
    );


#line 122 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetProcessTimes(
      HANDLE hProcess,
      LPFILETIME lpCreationTime,
      LPFILETIME lpExitTime,
      LPFILETIME lpKernelTime,
      LPFILETIME lpUserTime
    );


#line 136 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
HANDLE
__stdcall
GetCurrentProcess(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessId(
    void
    );


#line 159 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitProcess(
      UINT uExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
TerminateProcess(
      HANDLE hProcess,
      UINT uExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
GetExitCodeProcess(
      HANDLE hProcess,
      LPDWORD lpExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
SwitchToThread(
    void
    );

#line 200 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
 
HANDLE
__stdcall
CreateThread(
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      SIZE_T dwStackSize,
      LPTHREAD_START_ROUTINE lpStartAddress,
        LPVOID lpParameter,
      DWORD dwCreationFlags,
      LPDWORD lpThreadId
    );

#line 219 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
 
HANDLE
__stdcall
CreateRemoteThread(
      HANDLE hProcess,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      SIZE_T dwStackSize,
      LPTHREAD_START_ROUTINE lpStartAddress,
      LPVOID lpParameter,
      DWORD dwCreationFlags,
      LPDWORD lpThreadId
    );


#line 240 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
HANDLE
__stdcall
GetCurrentThread(
    void
    );


__declspec(dllimport)
DWORD
__stdcall
GetCurrentThreadId(
    void
    );


#line 263 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
 
HANDLE
__stdcall
OpenThread(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      DWORD dwThreadId
    );

#line 280 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
BOOL
__stdcall
SetThreadPriority(
      HANDLE hThread,
      int nPriority
    );

#line 294 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
SetThreadPriorityBoost(
      HANDLE hThread,
      BOOL bDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadPriorityBoost(
      HANDLE hThread,
      PBOOL pDisablePriorityBoost
    );

#line 318 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
int
__stdcall
GetThreadPriority(
      HANDLE hThread
    );


__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
ExitThread(
      DWORD dwExitCode
    );

#line 340 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
TerminateThread(
      HANDLE hThread,
      DWORD dwExitCode
    );

#line 354 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
 
BOOL
__stdcall
GetExitCodeThread(
      HANDLE hThread,
      LPDWORD lpExitCode
    );


__declspec(dllimport)
DWORD
__stdcall
SuspendThread(
      HANDLE hThread
    );


__declspec(dllimport)
DWORD
__stdcall
ResumeThread(
      HANDLE hThread
    );








#line 393 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion



#pragma region Application Family



















































#line 450 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family



 
__declspec(dllimport)
DWORD
__stdcall
TlsAlloc(
    void
    );


__declspec(dllimport)
LPVOID
__stdcall
TlsGetValue(
      DWORD dwTlsIndex
    );


__declspec(dllimport)
BOOL
__stdcall
TlsSetValue(
      DWORD dwTlsIndex,
      LPVOID lpTlsValue
    );


__declspec(dllimport)
BOOL
__stdcall
TlsFree(
      DWORD dwTlsIndex
    );


#line 491 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
BOOL
__stdcall
CreateProcessA(
      LPCSTR lpApplicationName,
      LPSTR lpCommandLine,
      LPSECURITY_ATTRIBUTES lpProcessAttributes,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      BOOL bInheritHandles,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCSTR lpCurrentDirectory,
      LPSTARTUPINFOA lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation
    );

__declspec(dllimport)
BOOL
__stdcall
CreateProcessW(
      LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
      LPSECURITY_ATTRIBUTES lpProcessAttributes,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      BOOL bInheritHandles,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCWSTR lpCurrentDirectory,
      LPSTARTUPINFOW lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation
    );





#line 536 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"

#line 538 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetProcessShutdownParameters(
      DWORD dwLevel,
      DWORD dwFlags
    );


__declspec(dllimport)
DWORD
__stdcall
GetProcessVersion(
      DWORD ProcessId
    );


__declspec(dllimport)
void
__stdcall
GetStartupInfoW(
      LPSTARTUPINFOW lpStartupInfo
    );





#line 568 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion





#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserW(
      HANDLE hToken,
      LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
      LPSECURITY_ATTRIBUTES lpProcessAttributes,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      BOOL bInheritHandles,
      DWORD dwCreationFlags,
      LPVOID lpEnvironment,
      LPCWSTR lpCurrentDirectory,
      LPSTARTUPINFOW lpStartupInfo,
      LPPROCESS_INFORMATION lpProcessInformation
    );






#line 601 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#line 604 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"

#pragma region Desktop Family



__declspec(dllimport)
 
BOOL
__stdcall
SetThreadToken(
      PHANDLE Thread,
      HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
OpenProcessToken(
      HANDLE ProcessHandle,
      DWORD DesiredAccess,
     PHANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
OpenThreadToken(
      HANDLE ThreadHandle,
      DWORD DesiredAccess,
      BOOL OpenAsSelf,
     PHANDLE TokenHandle
    );


#line 641 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion



#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
SetPriorityClass(
      HANDLE hProcess,
      DWORD dwPriorityClass
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadStackGuarantee(
      PULONG StackSizeInBytes
    );


__declspec(dllimport)
DWORD
__stdcall
GetPriorityClass(
      HANDLE hProcess
    );


__declspec(dllimport)
BOOL
__stdcall
ProcessIdToSessionId(
      DWORD dwProcessId,
      DWORD * pSessionId
    );






__declspec(dllimport)
DWORD
__stdcall
GetProcessId(
      HANDLE Process
    );


#line 696 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"




__declspec(dllimport)
DWORD
__stdcall
GetThreadId(
      HANDLE Thread
    );


#line 709 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"


typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;

#line 714 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion




#pragma region Application Family



__declspec(dllimport)
void
__stdcall
FlushProcessWriteBuffers(
    void
    );


#line 732 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
GetProcessIdOfThread(
      HANDLE Thread
    );


__declspec(dllimport)
 
BOOL
__stdcall
InitializeProcThreadAttributeList(
      LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
      DWORD dwAttributeCount,
      DWORD dwFlags,
      PSIZE_T lpSize
    );


__declspec(dllimport)
void
__stdcall
DeleteProcThreadAttributeList(
      LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList
    );




__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityUpdateMode(
      HANDLE hProcess,
      DWORD dwFlags
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessAffinityUpdateMode(
      HANDLE hProcess,
      LPDWORD lpdwFlags
    );




__declspec(dllimport)
BOOL
__stdcall
UpdateProcThreadAttribute(
      LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
      DWORD dwFlags,
      DWORD_PTR Attribute,
      PVOID lpValue,
      SIZE_T cbSize,
      PVOID lpPreviousValue,
      PSIZE_T lpReturnSize
    );


#line 803 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#line 806 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"

#pragma region Desktop Family



__declspec(dllimport)
 
HANDLE
__stdcall
CreateRemoteThreadEx(
      HANDLE hProcess,
      LPSECURITY_ATTRIBUTES lpThreadAttributes,
      SIZE_T dwStackSize,
      LPTHREAD_START_ROUTINE lpStartAddress,
      LPVOID lpParameter,
      DWORD dwCreationFlags,
      LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
      LPDWORD lpThreadId
    );


#line 828 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion









#pragma region Desktop Family






__declspec(dllimport)
void
__stdcall
GetCurrentThreadStackLimits(
      PULONG_PTR LowLimit,
      PULONG_PTR HighLimit
    );


#line 855 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetThreadContext(
      HANDLE hThread,
      LPCONTEXT lpContext
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadContext(
      HANDLE hThread,
      const CONTEXT * lpContext
    );





__declspec(dllimport)
BOOL
__stdcall
SetProcessMitigationPolicy(
      PROCESS_MITIGATION_POLICY MitigationPolicy,
      PVOID lpBuffer,
      SIZE_T dwLength
    );


__declspec(dllimport)
BOOL
__stdcall
GetProcessMitigationPolicy(
      HANDLE hProcess,
      PROCESS_MITIGATION_POLICY MitigationPolicy,
      PVOID lpBuffer,
      SIZE_T dwLength
    );


#line 899 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"

#line 901 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#line 904 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#line 905 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"




#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
FlushInstructionCache(
      HANDLE hProcess,
      LPCVOID lpBaseAddress,
      SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadTimes(
      HANDLE hThread,
      LPFILETIME lpCreationTime,
      LPFILETIME lpExitTime,
      LPFILETIME lpKernelTime,
      LPFILETIME lpUserTime
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenProcess(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      DWORD dwProcessId
    );


#line 946 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Application Family



BOOL
__stdcall
IsProcessorFeaturePresent(
      DWORD ProcessorFeature
    );


#line 960 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#line 963 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"




#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
GetProcessHandleCount(
      HANDLE hProcess,
      PDWORD pdwHandleCount
    );


#line 981 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#line 984 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"




#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
GetCurrentProcessorNumber(
    void
    );


#line 1001 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#line 1004 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"




#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
SetThreadIdealProcessorEx(
      HANDLE hThread,
      PPROCESSOR_NUMBER lpIdealProcessor,
      PPROCESSOR_NUMBER lpPreviousIdealProcessor
    );


#line 1023 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
GetThreadIdealProcessorEx(
      HANDLE hThread,
      PPROCESSOR_NUMBER lpIdealProcessor
    );


__declspec(dllimport)
void
__stdcall
GetCurrentProcessorNumberEx(
      PPROCESSOR_NUMBER ProcNumber
    );


#line 1047 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#line 1050 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"







#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
GetProcessPriorityBoost(
      HANDLE hProcess,
      PBOOL pDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessPriorityBoost(
      HANDLE hProcess,
      BOOL bDisablePriorityBoost
    );


__declspec(dllimport)
BOOL
__stdcall
GetThreadIOPendingFlag(
      HANDLE hThread,
      PBOOL lpIOIsPending
    );


__declspec(dllimport)
BOOL
__stdcall
GetSystemTimes(
      PFILETIME lpIdleTime,
      PFILETIME lpKernelTime,
      PFILETIME lpUserTime
    );


#line 1102 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"





typedef enum _THREAD_INFORMATION_CLASS {
    ThreadMemoryPriority,
    ThreadAbsoluteCpuPriority,
    ThreadInformationClassMax
} THREAD_INFORMATION_CLASS;




__declspec(dllimport)
BOOL
__stdcall
GetThreadInformation(
      HANDLE hThread,
      THREAD_INFORMATION_CLASS ThreadInformationClass,
      LPVOID ThreadInformation,
      DWORD ThreadInformationSize
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadInformation(
      HANDLE hThread,
      THREAD_INFORMATION_CLASS ThreadInformationClass,
      LPVOID ThreadInformation,
      DWORD ThreadInformationSize
    );













typedef struct _MEMORY_PRIORITY_INFORMATION {
    ULONG MemoryPriority;
} MEMORY_PRIORITY_INFORMATION, *PMEMORY_PRIORITY_INFORMATION;

#line 1154 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"




__declspec(dllimport)
BOOL
__stdcall
IsProcessCritical(
      HANDLE hProcess,
      PBOOL Critical
    );


#line 1168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"




__declspec(dllimport)
BOOL
__stdcall
SetProtectedPolicy(
      LPCGUID PolicyGuid,
      ULONG_PTR PolicyValue,
      PULONG_PTR OldPolicyValue
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProtectedPolicy(
      LPCGUID PolicyGuid,
      PULONG_PTR PolicyValue
    );


#line 1192 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"

#line 1194 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"
#pragma endregion

#line 1197 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"







}
#line 1206 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"

#line 1208 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processthreadsapi.h"



#line 51 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
 
 












#pragma once
#line 17 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"











#pragma warning(disable:4514)

#pragma warning(disable:4103)
#line 32 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"


#pragma warning(push)
#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma warning(disable:4001)
#pragma warning(disable:4201)
#pragma warning(disable:4214)
#line 40 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"













#line 54 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"





#line 60 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"


extern "C" {
#line 64 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"







#pragma region Application Family



typedef struct _SYSTEM_INFO {
    union {
        DWORD dwOemId;          
        struct {
            WORD wProcessorArchitecture;
            WORD wReserved;
        } ;
    } ;
    DWORD dwPageSize;
    LPVOID lpMinimumApplicationAddress;
    LPVOID lpMaximumApplicationAddress;
    DWORD_PTR dwActiveProcessorMask;
    DWORD dwNumberOfProcessors;
    DWORD dwProcessorType;
    DWORD dwAllocationGranularity;
    WORD wProcessorLevel;
    WORD wProcessorRevision;
} SYSTEM_INFO, *LPSYSTEM_INFO;

#line 95 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion





#pragma region Desktop Family



__declspec(deprecated)
__declspec(dllimport)
 
DWORD
__stdcall
GetVersion(
    void
    );


typedef struct _MEMORYSTATUSEX {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    DWORDLONG ullTotalPhys;
    DWORDLONG ullAvailPhys;
    DWORDLONG ullTotalPageFile;
    DWORDLONG ullAvailPageFile;
    DWORDLONG ullTotalVirtual;
    DWORDLONG ullAvailVirtual;
    DWORDLONG ullAvailExtendedVirtual;
} MEMORYSTATUSEX, *LPMEMORYSTATUSEX;

__declspec(dllimport)
BOOL
__stdcall
GlobalMemoryStatusEx(
      LPMEMORYSTATUSEX lpBuffer
    );


#line 136 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
void
__stdcall
GetSystemTime(
      LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)
void
__stdcall
GetSystemTimeAsFileTime(
      LPFILETIME lpSystemTimeAsFileTime
    );


__declspec(dllimport)
void
__stdcall
GetLocalTime(
      LPSYSTEMTIME lpSystemTime
    );


#line 167 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
SetLocalTime(
      const SYSTEMTIME * lpSystemTime
    );


__declspec(dllimport)
void
__stdcall
GetSystemInfo(
      LPSYSTEM_INFO lpSystemInfo
    );


#line 190 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion




#pragma region Desktop Family



 
__declspec(dllimport)
DWORD
__stdcall
GetTickCount(
    void
    );


#line 209 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Application Family






__declspec(dllimport)
ULONGLONG
__stdcall
GetTickCount64(
    void
    );


#line 227 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

#line 229 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
 
BOOL
__stdcall
GetSystemTimeAdjustment(
      PDWORD lpTimeAdjustment,
      PDWORD lpTimeIncrement,
      PBOOL lpTimeAdjustmentDisabled
    );


__declspec(dllimport)
 
UINT
__stdcall
GetSystemDirectoryA(
      LPSTR lpBuffer,
      UINT uSize
    );

__declspec(dllimport)
 
UINT
__stdcall
GetSystemDirectoryW(
      LPWSTR lpBuffer,
      UINT uSize
    );





#line 269 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

__declspec(dllimport)
 
 
UINT
__stdcall
GetWindowsDirectoryA(
      LPSTR lpBuffer,
      UINT uSize
    );

__declspec(dllimport)
 
 
UINT
__stdcall
GetWindowsDirectoryW(
      LPWSTR lpBuffer,
      UINT uSize
    );





#line 295 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

__declspec(dllimport)
 
UINT
__stdcall
GetSystemWindowsDirectoryA(
      LPSTR lpBuffer,
      UINT uSize
    );

__declspec(dllimport)
 
UINT
__stdcall
GetSystemWindowsDirectoryW(
      LPWSTR lpBuffer,
      UINT uSize
    );





#line 319 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

#line 321 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion






#pragma region Desktop Family



typedef enum _COMPUTER_NAME_FORMAT {
    ComputerNameNetBIOS,
    ComputerNameDnsHostname,
    ComputerNameDnsDomain,
    ComputerNameDnsFullyQualified,
    ComputerNamePhysicalNetBIOS,
    ComputerNamePhysicalDnsHostname,
    ComputerNamePhysicalDnsDomain,
    ComputerNamePhysicalDnsFullyQualified,
    ComputerNameMax
} COMPUTER_NAME_FORMAT ;

#line 345 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion






#pragma region Desktop Family



__declspec(dllimport)
 
BOOL
__stdcall
GetComputerNameExA(
      COMPUTER_NAME_FORMAT NameType,
      LPSTR lpBuffer,
      LPDWORD nSize
    );

__declspec(dllimport)
 
BOOL
__stdcall
GetComputerNameExW(
      COMPUTER_NAME_FORMAT NameType,
      LPWSTR lpBuffer,
      LPDWORD nSize
    );





#line 381 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

#line 383 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion







#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExW(
      COMPUTER_NAME_FORMAT NameType,
      LPCWSTR lpBuffer
    );






__declspec(dllimport)
BOOL
__stdcall
SetSystemTime(
      const SYSTEMTIME * lpSystemTime
    );


#line 417 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion

#line 420 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"




#pragma region Desktop Family



__declspec(deprecated)
__declspec(dllimport)
 
BOOL
__stdcall
GetVersionExA(
      LPOSVERSIONINFOA lpVersionInformation
    );

__declspec(deprecated)
__declspec(dllimport)
 
BOOL
__stdcall
GetVersionExW(
      LPOSVERSIONINFOW lpVersionInformation
    );





#line 451 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformation(
      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer,
      PDWORD ReturnedLength
    );





__declspec(dllimport)
BOOL
__stdcall
GetLogicalProcessorInformationEx(
      LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
      PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
      PDWORD ReturnedLength
    );


#line 475 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

#line 477 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion







#pragma region Application Family






__declspec(dllimport)
void
__stdcall
GetNativeSystemInfo(
      LPSYSTEM_INFO lpSystemInfo
    );


#line 501 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

#line 503 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion

#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
GetProductInfo(
      DWORD dwOSMajorVersion,
      DWORD dwOSMinorVersion,
      DWORD dwSpMajorVersion,
      DWORD dwSpMinorVersion,
      PDWORD pdwReturnedProductType
    );


#line 525 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"




__declspec(dllimport)
ULONGLONG
__stdcall
VerSetConditionMask(
      ULONGLONG ConditionMask,
      ULONG TypeMask,
      UCHAR Condition
    );


#line 540 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"




__declspec(dllimport)
BOOL
__stdcall
GetOsSafeBootMode(
      PDWORD Flags
    );


#line 553 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

__declspec(dllimport)
void
__stdcall
GetSystemTimePreciseAsFileTime(
      LPFILETIME lpSystemTimeAsFileTime
    );


__declspec(dllimport)
UINT
__stdcall
EnumSystemFirmwareTables(
      DWORD FirmwareTableProviderSignature,
      PVOID pFirmwareTableEnumBuffer,
      DWORD BufferSize
    );


__declspec(dllimport)
UINT
__stdcall
GetSystemFirmwareTable(
      DWORD FirmwareTableProviderSignature,
      DWORD FirmwareTableID,
      PVOID pFirmwareTableBuffer,
      DWORD BufferSize
    );


#line 584 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion

#line 587 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"







#pragma region Desktop Family



__declspec(dllimport)
 
BOOL
__stdcall
DnsHostnameToComputerNameExW(
      LPCWSTR Hostname,
      LPWSTR ComputerName,
      LPDWORD nSize
    );


__declspec(dllimport)
 
BOOL
__stdcall
GetPhysicallyInstalledSystemMemory(
      PULONGLONG TotalMemoryInKilobytes
    );




__declspec(dllimport)
BOOL
__stdcall
SetComputerNameEx2W(
      COMPUTER_NAME_FORMAT NameType,
      DWORD Flags,
      LPCWSTR lpBuffer
    );






__declspec(dllimport)
 
BOOL
__stdcall
SetSystemTimeAdjustment(
      DWORD dwTimeAdjustment,
      BOOL bTimeAdjustmentDisabled
    );


__declspec(dllimport)
BOOL
__stdcall
InstallELAMCertificateInfo(
      HANDLE ELAMFile
    );


#line 653 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#pragma endregion

#line 656 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"







}
#line 665 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"





#pragma warning(pop)





#line 677 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"
#line 678 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"

#line 680 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\sysinfoapi.h"




#line 52 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
 












#pragma once
#line 16 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"





















#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"



extern "C" {
#line 43 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"

#pragma region Application Family










#line 56 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family





#line 65 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family






#line 75 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion






#pragma region Desktop Family



__declspec(dllimport)
   
LPVOID
__stdcall
VirtualAlloc(
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flAllocationType,
      DWORD flProtect
    );



#line 100 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"


#line 103 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"


#line 106 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
 
__declspec(dllimport)
BOOL
__stdcall
VirtualFree(
        LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD dwFreeType
    );


__declspec(dllimport)
 
BOOL
__stdcall
VirtualProtect(
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flNewProtect,
      PDWORD lpflOldProtect
    );


#line 130 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
SIZE_T
__stdcall
VirtualQuery(
      LPCVOID lpAddress,
      PMEMORY_BASIC_INFORMATION lpBuffer,
      SIZE_T dwLength
    );


#line 147 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
   
LPVOID
__stdcall
VirtualAllocEx(
      HANDLE hProcess,
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flAllocationType,
      DWORD flProtect
    );



#line 168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"


#line 171 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"


#line 174 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"


#line 177 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
 
__declspec(dllimport)
BOOL
__stdcall
VirtualFreeEx(
      HANDLE hProcess,
        LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD dwFreeType
    );


__declspec(dllimport)
 
BOOL
__stdcall
VirtualProtectEx(
      HANDLE hProcess,
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flNewProtect,
      PDWORD lpflOldProtect
    );


__declspec(dllimport)
SIZE_T
__stdcall
VirtualQueryEx(
      HANDLE hProcess,
      LPCVOID lpAddress,
      PMEMORY_BASIC_INFORMATION lpBuffer,
      SIZE_T dwLength
    );


__declspec(dllimport)
 
BOOL
__stdcall
ReadProcessMemory(
      HANDLE hProcess,
      LPCVOID lpBaseAddress,
      LPVOID lpBuffer,
      SIZE_T nSize,
      SIZE_T * lpNumberOfBytesRead
    );


__declspec(dllimport)
 
BOOL
__stdcall
WriteProcessMemory(
      HANDLE hProcess,
      LPVOID lpBaseAddress,
      LPCVOID lpBuffer,
      SIZE_T nSize,
      SIZE_T * lpNumberOfBytesWritten
    );


__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingW(
      HANDLE hFile,
      LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
      DWORD flProtect,
      DWORD dwMaximumSizeHigh,
      DWORD dwMaximumSizeLow,
      LPCWSTR lpName
    );






__declspec(dllimport)
 
HANDLE
__stdcall
OpenFileMappingW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );






__declspec(dllimport)
   
LPVOID
__stdcall
MapViewOfFile(
      HANDLE hFileMappingObject,
      DWORD dwDesiredAccess,
      DWORD dwFileOffsetHigh,
      DWORD dwFileOffsetLow,
      SIZE_T dwNumberOfBytesToMap
    );


__declspec(dllimport)
   
LPVOID
__stdcall
MapViewOfFileEx(
      HANDLE hFileMappingObject,
      DWORD dwDesiredAccess,
      DWORD dwFileOffsetHigh,
      DWORD dwFileOffsetLow,
      SIZE_T dwNumberOfBytesToMap,
      LPVOID lpBaseAddress
    );


#line 300 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
FlushViewOfFile(
      LPCVOID lpBaseAddress,
      SIZE_T dwNumberOfBytesToFlush
    );


__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFile(
      LPCVOID lpBaseAddress
    );


#line 324 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion







#pragma region Desktop Family



__declspec(dllimport)
SIZE_T
__stdcall
GetLargePageMinimum(
    void
    );


__declspec(dllimport)
 
BOOL
__stdcall
GetProcessWorkingSetSizeEx(
      HANDLE hProcess,
      PSIZE_T lpMinimumWorkingSetSize,
      PSIZE_T lpMaximumWorkingSetSize,
      PDWORD Flags
    );


__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSizeEx(
      HANDLE hProcess,
      SIZE_T dwMinimumWorkingSetSize,
      SIZE_T dwMaximumWorkingSetSize,
      DWORD Flags
    );


__declspec(dllimport)
BOOL
__stdcall
VirtualLock(
      LPVOID lpAddress,
      SIZE_T dwSize
    );


__declspec(dllimport)
BOOL
__stdcall
VirtualUnlock(
      LPVOID lpAddress,
      SIZE_T dwSize
    );


__declspec(dllimport)
 
UINT
__stdcall
GetWriteWatch(
      DWORD dwFlags,
      PVOID lpBaseAddress,
      SIZE_T dwRegionSize,
      PVOID * lpAddresses,
      ULONG_PTR * lpdwCount,
      LPDWORD lpdwGranularity
    );


__declspec(dllimport)
UINT
__stdcall
ResetWriteWatch(
      LPVOID lpBaseAddress,
      SIZE_T dwRegionSize
    );





typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE {
    LowMemoryResourceNotification,
    HighMemoryResourceNotification
} MEMORY_RESOURCE_NOTIFICATION_TYPE;

__declspec(dllimport)
 
HANDLE
__stdcall
CreateMemoryResourceNotification(
      MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType
    );


__declspec(dllimport)
 
BOOL
__stdcall
QueryMemoryResourceNotification(
      HANDLE ResourceNotificationHandle,
      PBOOL ResourceState
    );


#line 436 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"










__declspec(dllimport)
 
BOOL
__stdcall
GetSystemFileCacheSize(
      PSIZE_T lpMinimumFileCacheSize,
      PSIZE_T lpMaximumFileCacheSize,
      PDWORD lpFlags
    );


__declspec(dllimport)
BOOL
__stdcall
SetSystemFileCacheSize(
      SIZE_T MinimumFileCacheSize,
      SIZE_T MaximumFileCacheSize,
      DWORD Flags
    );


#line 468 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"




__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingNumaW(
      HANDLE hFile,
      LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
      DWORD flProtect,
      DWORD dwMaximumSizeHigh,
      DWORD dwMaximumSizeLow,
      LPCWSTR lpName,
      DWORD nndPreferred
    );






#line 492 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"




typedef struct _WIN32_MEMORY_RANGE_ENTRY {
    PVOID VirtualAddress;
    SIZE_T NumberOfBytes;
} WIN32_MEMORY_RANGE_ENTRY, *PWIN32_MEMORY_RANGE_ENTRY;

__declspec(dllimport)
BOOL
__stdcall
PrefetchVirtualMemory(
      HANDLE hProcess,
      ULONG_PTR NumberOfEntries,
      PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses,
      ULONG Flags
    );


__declspec(dllimport)
BOOL
__stdcall
UnmapViewOfFileEx(
      PVOID BaseAddress,
      ULONG UnmapFlags
    );


#line 522 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"

#line 524 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion

#pragma region Application Family






__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingFromApp(
      HANDLE hFile,
      PSECURITY_ATTRIBUTES SecurityAttributes,
      ULONG PageProtection,
      ULONG64 MaximumSize,
      PCWSTR Name
    );


__declspec(dllimport)
   
PVOID
__stdcall
MapViewOfFileFromApp(
      HANDLE hFileMappingObject,
      ULONG DesiredAccess,
      ULONG64 FileOffset,
      SIZE_T NumberOfBytesToMap
    );


#line 559 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"

#line 561 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion

#line 564 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"







#pragma region Desktop Family






__declspec(dllimport)
 
BOOL
__stdcall
AllocateUserPhysicalPages(
      HANDLE hProcess,
      PULONG_PTR NumberOfPages,
      PULONG_PTR PageArray
    );


__declspec(dllimport)
 
BOOL
__stdcall
FreeUserPhysicalPages(
      HANDLE hProcess,
      PULONG_PTR NumberOfPages,
      PULONG_PTR PageArray
    );


__declspec(dllimport)
 
BOOL
__stdcall
MapUserPhysicalPages(
      PVOID VirtualAddress,
      ULONG_PTR NumberOfPages,
      PULONG_PTR PageArray
    );


#line 612 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"




__declspec(dllimport)
 
BOOL
__stdcall
AllocateUserPhysicalPagesNuma(
      HANDLE hProcess,
      PULONG_PTR NumberOfPages,
      PULONG_PTR PageArray,
      DWORD nndPreferred
    );


__declspec(dllimport)
 
LPVOID
__stdcall
VirtualAllocExNuma(
      HANDLE hProcess,
      LPVOID lpAddress,
      SIZE_T dwSize,
      DWORD flAllocationType,
      DWORD flProtect,
      DWORD nndPreferred
    );


#line 643 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"






__declspec(dllimport)
 
BOOL
__stdcall
GetMemoryErrorHandlingCapabilities(
      PULONG Capabilities
    );


 
typedef
void
__stdcall
BAD_MEMORY_CALLBACK_ROUTINE(
    void
    );

typedef BAD_MEMORY_CALLBACK_ROUTINE *PBAD_MEMORY_CALLBACK_ROUTINE;

__declspec(dllimport)
 
PVOID
__stdcall
RegisterBadMemoryNotification(
      PBAD_MEMORY_CALLBACK_ROUTINE Callback
    );


__declspec(dllimport)
 
BOOL
__stdcall
UnregisterBadMemoryNotification(
      PVOID RegistrationHandle
    );


#line 687 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"

#line 689 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion

#line 692 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"






#pragma region Application Family















































#line 747 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"

#line 749 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"

#line 751 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"
#pragma endregion

#line 754 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"






}
#line 762 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"

#line 764 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\memoryapi.h"



#line 53 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoollegacyapiset.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoollegacyapiset.h"

















#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoollegacyapiset.h"


extern "C" {
#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoollegacyapiset.h"





#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
QueueUserWorkItem(
      LPTHREAD_START_ROUTINE Function,
      PVOID Context,
      ULONG Flags
    );


__declspec(dllimport)
 
BOOL
__stdcall
UnregisterWaitEx(
      HANDLE WaitHandle,
      HANDLE CompletionEvent
    );


__declspec(dllimport)
 
HANDLE
__stdcall
CreateTimerQueue(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
CreateTimerQueueTimer(
     PHANDLE phNewTimer,
      HANDLE TimerQueue,
      WAITORTIMERCALLBACK Callback,
      PVOID Parameter,
      DWORD DueTime,
      DWORD Period,
      ULONG Flags
    );


__declspec(dllimport)
 
BOOL
__stdcall
ChangeTimerQueueTimer(
      HANDLE TimerQueue,
      HANDLE Timer,
      ULONG DueTime,
      ULONG Period
    );


__declspec(dllimport)
 
BOOL
__stdcall
DeleteTimerQueueTimer(
      HANDLE TimerQueue,
      HANDLE Timer,
      HANDLE CompletionEvent
    );


__declspec(dllimport)
 
BOOL
__stdcall
DeleteTimerQueueEx(
      HANDLE TimerQueue,
      HANDLE CompletionEvent
    );


#line 121 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoollegacyapiset.h"
#pragma endregion


}
#line 126 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoollegacyapiset.h"

#line 128 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoollegacyapiset.h"
#line 54 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoolapiset.h"
 
 









#pragma once
#line 14 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoolapiset.h"



















#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoolapiset.h"


extern "C" {
#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoolapiset.h"





#pragma region Desktop Family



typedef
void
(__stdcall *PTP_WIN32_IO_CALLBACK)(
          PTP_CALLBACK_INSTANCE Instance,
      PVOID                 Context,
      PVOID                 Overlapped,
             ULONG                 IoResult,
             ULONG_PTR             NumberOfBytesTransferred,
          PTP_IO                Io
    );




__declspec(dllimport)
 
PTP_POOL
__stdcall
CreateThreadpool(
      PVOID reserved
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolThreadMaximum(
      PTP_POOL ptpp,
      DWORD cthrdMost
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolThreadMinimum(
      PTP_POOL ptpp,
      DWORD cthrdMic
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolStackInformation(
      PTP_POOL ptpp,
      PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
BOOL
__stdcall
QueryThreadpoolStackInformation(
      PTP_POOL ptpp,
      PTP_POOL_STACK_INFORMATION ptpsi
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpool(
      PTP_POOL ptpp
    );


__declspec(dllimport)
 
PTP_CLEANUP_GROUP
__stdcall
CreateThreadpoolCleanupGroup(
    void
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroupMembers(
      PTP_CLEANUP_GROUP ptpcg,
      BOOL fCancelPendingCallbacks,
      PVOID pvCleanupContext
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolCleanupGroup(
      PTP_CLEANUP_GROUP ptpcg
    );


__declspec(dllimport)
void
__stdcall
SetEventWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      HANDLE evt
    );


__declspec(dllimport)
void
__stdcall
ReleaseSemaphoreWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      HANDLE sem,
      DWORD crel
    );


__declspec(dllimport)
void
__stdcall
ReleaseMutexWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      HANDLE mut
    );


__declspec(dllimport)
void
__stdcall
LeaveCriticalSectionWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      PCRITICAL_SECTION pcs
    );


__declspec(dllimport)
void
__stdcall
FreeLibraryWhenCallbackReturns(
      PTP_CALLBACK_INSTANCE pci,
      HMODULE mod
    );


__declspec(dllimport)
BOOL
__stdcall
CallbackMayRunLong(
      PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)
void
__stdcall
DisassociateCurrentThreadFromCallback(
      PTP_CALLBACK_INSTANCE pci
    );


__declspec(dllimport)
 
BOOL
__stdcall
TrySubmitThreadpoolCallback(
      PTP_SIMPLE_CALLBACK pfns,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
 
PTP_WORK
__stdcall
CreateThreadpoolWork(
      PTP_WORK_CALLBACK pfnwk,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SubmitThreadpoolWork(
      PTP_WORK pwk
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWorkCallbacks(
      PTP_WORK pwk,
      BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWork(
      PTP_WORK pwk
    );


__declspec(dllimport)
 
PTP_TIMER
__stdcall
CreateThreadpoolTimer(
      PTP_TIMER_CALLBACK pfnti,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolTimer(
      PTP_TIMER pti,
      PFILETIME pftDueTime,
      DWORD msPeriod,
      DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
IsThreadpoolTimerSet(
      PTP_TIMER pti
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolTimerCallbacks(
      PTP_TIMER pti,
      BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolTimer(
      PTP_TIMER pti
    );


__declspec(dllimport)
 
PTP_WAIT
__stdcall
CreateThreadpoolWait(
      PTP_WAIT_CALLBACK pfnwa,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
SetThreadpoolWait(
      PTP_WAIT pwa,
      HANDLE h,
      PFILETIME pftTimeout
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolWaitCallbacks(
      PTP_WAIT pwa,
      BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolWait(
      PTP_WAIT pwa
    );


__declspec(dllimport)
 
PTP_IO
__stdcall
CreateThreadpoolIo(
      HANDLE fl,
      PTP_WIN32_IO_CALLBACK pfnio,
      PVOID pv,
      PTP_CALLBACK_ENVIRON pcbe
    );


__declspec(dllimport)
void
__stdcall
StartThreadpoolIo(
      PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
CancelThreadpoolIo(
      PTP_IO pio
    );


__declspec(dllimport)
void
__stdcall
WaitForThreadpoolIoCallbacks(
      PTP_IO pio,
      BOOL fCancelPendingCallbacks
    );


__declspec(dllimport)
void
__stdcall
CloseThreadpoolIo(
      PTP_IO pio
    );





__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolTimerEx(
      PTP_TIMER pti,
      PFILETIME pftDueTime,
      DWORD msPeriod,
      DWORD msWindowLength
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadpoolWaitEx(
      PTP_WAIT pwa,
      HANDLE h,
      PFILETIME pftTimeout,
      PVOID Reserved
    );


#line 406 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoolapiset.h"


#line 409 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoolapiset.h"

#line 411 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoolapiset.h"
#pragma endregion


}
#line 416 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoolapiset.h"

#line 418 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\threadpoolapiset.h"
#line 55 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\bemapiset.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\bemapiset.h"

















#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\bemapiset.h"


extern "C" {
#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\bemapiset.h"

#pragma region Desktop Family






typedef struct _CONTRACT_DESCRIPTION CONTRACT_DESCRIPTION;

typedef struct _BEM_REFERENCE BEM_REFERENCE;

typedef void (__stdcall* BEM_FREE_INTERFACE_CALLBACK)(  void* interfaceInstance);

HRESULT
__stdcall
BemCreateReference(
      const GUID & iid,
      void * interfaceInstance,
      BEM_FREE_INTERFACE_CALLBACK freeCallback,
     BEM_REFERENCE ** reference
    );


HRESULT
__stdcall
BemCreateContractFrom(
      LPCWSTR dllPath,
      const GUID & extensionId,
      const CONTRACT_DESCRIPTION * contractDescription,
      void * hostContract,
     void ** contract
    );


HRESULT
__stdcall
BemCopyReference(
      BEM_REFERENCE * reference,
     BEM_REFERENCE ** copiedReference
    );

        
void
__stdcall
BemFreeReference(
      BEM_REFERENCE * reference
    );

    
void
__stdcall
BemFreeContract(
      void * contract
    );

    
#line 93 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\bemapiset.h"

#line 95 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\bemapiset.h"
#pragma endregion


}
#line 100 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\bemapiset.h"

#line 102 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\bemapiset.h"
#line 56 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\jobapi.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\jobapi.h"

















#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\jobapi.h"


extern "C" {
#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\jobapi.h"

#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
IsProcessInJob(
      HANDLE ProcessHandle,
      HANDLE JobHandle,
      PBOOL Result
    );


#line 54 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\jobapi.h"

#line 56 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\jobapi.h"
#pragma endregion


}
#line 61 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\jobapi.h"

#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\jobapi.h"
#line 57 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"

















#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"


extern "C" {
#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"

#pragma region Desktop Family









__declspec(dllimport)
BOOL
__stdcall
Wow64DisableWow64FsRedirection(
      PVOID * OldValue
    );


__declspec(dllimport)
BOOL
__stdcall
Wow64RevertWow64FsRedirection(
      PVOID OlValue
    );


#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"

#line 65 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"




__declspec(dllimport)
BOOL
__stdcall
IsWow64Process(
      HANDLE hProcess,
      PBOOL Wow64Process
    );


#line 79 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"

#line 81 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"
#pragma endregion


}
#line 86 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"

#line 88 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wow64apiset.h"
#line 58 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
 
 











#pragma once
#line 16 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"





















#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"


extern "C" {
#line 42 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

#pragma region Desktop Family















typedef struct tagENUMUILANG {
    ULONG  NumOfEnumUILang;    
    ULONG  SizeOfEnumUIBuffer; 
    LANGID *pEnumUIBuffer;
} ENUMUILANG, *PENUMUILANG;



typedef BOOL (__stdcall* ENUMRESLANGPROCA)(
      HMODULE hModule,
      LPCSTR lpType,
      LPCSTR lpName,
      WORD wLanguage,
      LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESLANGPROCW)(
      HMODULE hModule,
      LPCWSTR lpType,
      LPCWSTR lpName,
      WORD wLanguage,
      LONG_PTR lParam);




#line 84 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

typedef BOOL (__stdcall* ENUMRESNAMEPROCA)(
      HMODULE hModule,
      LPCSTR lpType,
      LPSTR lpName,
      LONG_PTR lParam);
typedef BOOL (__stdcall* ENUMRESNAMEPROCW)(
      HMODULE hModule,
      LPCWSTR lpType,
      LPWSTR lpName,
      LONG_PTR lParam);




#line 100 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

typedef BOOL (__stdcall* ENUMRESTYPEPROCA)(
      HMODULE hModule,
      LPSTR lpType,
      LONG_PTR lParam
    );
typedef BOOL (__stdcall* ENUMRESTYPEPROCW)(
      HMODULE hModule,
      LPWSTR lpType,
      LONG_PTR lParam
    );




#line 116 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

























#line 142 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

#line 144 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion





#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
DisableThreadLibraryCalls(
      HMODULE hLibModule
    );


#line 163 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
 
HRSRC
__stdcall
FindResourceExW(
      HMODULE hModule,
      LPCWSTR lpType,
      LPCWSTR lpName,
      WORD wLanguage
    );






#line 186 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion

#pragma region Application Family






__declspec(dllimport)
int
__stdcall
FindStringOrdinal(
      DWORD dwFindStringOrdinalFlags,
      LPCWSTR lpStringSource,
      int cchSource,
      LPCWSTR lpStringValue,
      int cchValue,
      BOOL bIgnoreCase
    );


#line 209 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
FreeLibrary(
      HMODULE hLibModule
    );


#line 219 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
__declspec(noreturn)
void
__stdcall
FreeLibraryAndExitThread(
      HMODULE hLibModule,
      DWORD dwExitCode
    );


__declspec(dllimport)
BOOL
__stdcall
FreeResource(
      HGLOBAL hResData
    );


__declspec(dllimport)
 
 
DWORD
__stdcall
GetModuleFileNameA(
      HMODULE hModule,
      LPSTR lpFilename,
      DWORD nSize
    );

__declspec(dllimport)
 
 
DWORD
__stdcall
GetModuleFileNameW(
      HMODULE hModule,
      LPWSTR lpFilename,
      DWORD nSize
    );





#line 270 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleA(
      LPCSTR lpModuleName
    );

__declspec(dllimport)


HMODULE
__stdcall
GetModuleHandleW(
      LPCWSTR lpModuleName
    );





#line 294 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"








typedef
BOOL
(__stdcall*
PGET_MODULE_HANDLE_EXA)(
             DWORD        dwFlags,
         LPCSTR     lpModuleName,
     HMODULE*    phModule
    );
typedef
BOOL
(__stdcall*
PGET_MODULE_HANDLE_EXW)(
             DWORD        dwFlags,
         LPCWSTR     lpModuleName,
     HMODULE*    phModule
    );




#line 323 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExA(
      DWORD dwFlags,
      LPCSTR lpModuleName,
      HMODULE * phModule
    );

__declspec(dllimport)
BOOL
__stdcall
GetModuleHandleExW(
      DWORD dwFlags,
      LPCWSTR lpModuleName,
      HMODULE * phModule
    );





#line 347 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

#line 349 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

#line 351 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
FARPROC
__stdcall
GetProcAddress(
      HMODULE hModule,
      LPCSTR lpProcName
    );


#line 367 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
 
HMODULE
__stdcall
LoadLibraryExA(
      LPCSTR lpLibFileName,
      HANDLE hFile,
      DWORD dwFlags
    );

__declspec(dllimport)
 
HMODULE
__stdcall
LoadLibraryExW(
      LPCWSTR lpLibFileName,
      HANDLE hFile,
      DWORD dwFlags
    );





#line 398 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"















__declspec(dllimport)
 
HGLOBAL
__stdcall
LoadResource(
      HMODULE hModule,
      HRSRC hResInfo
    );


#line 424 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion



#pragma region Desktop Family



__declspec(dllimport)
int
__stdcall
LoadStringA(
      HINSTANCE hInstance,
      UINT uID,
      LPSTR lpBuffer,
      int cchBufferMax
    );

__declspec(dllimport)
int
__stdcall
LoadStringW(
      HINSTANCE hInstance,
      UINT uID,
      LPWSTR lpBuffer,
      int cchBufferMax
    );





#line 457 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

#line 459 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion



#pragma region Desktop Family



__declspec(dllimport)
LPVOID
__stdcall
LockResource(
      HGLOBAL hResData
    );


__declspec(dllimport)
DWORD
__stdcall
SizeofResource(
      HMODULE hModule,
      HRSRC hResInfo
    );


#line 485 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion



#pragma region Desktop Family



typedef PVOID DLL_DIRECTORY_COOKIE, *PDLL_DIRECTORY_COOKIE;

__declspec(dllimport)
DLL_DIRECTORY_COOKIE
__stdcall
AddDllDirectory(
      PCWSTR NewDirectory
    );


__declspec(dllimport)
BOOL
__stdcall
RemoveDllDirectory(
      DLL_DIRECTORY_COOKIE Cookie
    );


__declspec(dllimport)
BOOL
__stdcall
SetDefaultDllDirectories(
      DWORD DirectoryFlags
    );


#line 520 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion






#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExA(
      HMODULE hModule,
      LPCSTR lpType,
      LPCSTR lpName,
      ENUMRESLANGPROCA lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesExW(
      HMODULE hModule,
      LPCWSTR lpType,
      LPCWSTR lpName,
      ENUMRESLANGPROCW lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );





#line 565 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExA(
      HMODULE hModule,
      LPCSTR lpType,
      ENUMRESNAMEPROCA lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesExW(
      HMODULE hModule,
      LPCWSTR lpType,
      ENUMRESNAMEPROCW lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );





#line 595 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExA(
      HMODULE hModule,
      ENUMRESTYPEPROCA lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesExW(
      HMODULE hModule,
      ENUMRESTYPEPROCW lpEnumFunc,
      LONG_PTR lParam,
    DWORD dwFlags,
    LANGID LangId
    );





#line 623 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

#line 625 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

#line 627 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"
#pragma endregion

#line 630 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"






}
#line 638 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

#line 640 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\libloaderapi.h"

#line 59 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"
 
 










#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"



















#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"


extern "C" {
#line 39 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"



#pragma region Desktop Family










__declspec(dllimport)
BOOL
__stdcall
AccessCheck(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      PGENERIC_MAPPING GenericMapping,
      PPRIVILEGE_SET PrivilegeSet,
      LPDWORD PrivilegeSetLength,
      LPDWORD GrantedAccess,
      LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      LPWSTR ObjectTypeName,
      LPWSTR ObjectName,
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      DWORD DesiredAccess,
      PGENERIC_MAPPING GenericMapping,
      BOOL ObjectCreation,
      LPDWORD GrantedAccess,
      LPBOOL AccessStatus,
      LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByType(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSID PrincipalSelfSid,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      PPRIVILEGE_SET PrivilegeSet,
      LPDWORD PrivilegeSetLength,
      LPDWORD GrantedAccess,
      LPBOOL AccessStatus
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultList(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSID PrincipalSelfSid,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      PPRIVILEGE_SET PrivilegeSet,
      LPDWORD PrivilegeSetLength,
      LPDWORD GrantedAccessList,
      LPDWORD AccessStatusList
    );


__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      LPCWSTR ObjectTypeName,
      LPCWSTR ObjectName,
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
      DWORD DesiredAccess,
      AUDIT_EVENT_TYPE AuditType,
      DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      BOOL ObjectCreation,
      LPDWORD GrantedAccess,
      LPBOOL AccessStatus,
      LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      LPCWSTR ObjectTypeName,
      LPCWSTR ObjectName,
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
      DWORD DesiredAccess,
      AUDIT_EVENT_TYPE AuditType,
      DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      BOOL ObjectCreation,
      LPDWORD GrantedAccessList,
      LPDWORD AccessStatusList,
      LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      HANDLE ClientToken,
      LPCWSTR ObjectTypeName,
      LPCWSTR ObjectName,
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
      DWORD DesiredAccess,
      AUDIT_EVENT_TYPE AuditType,
      DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
      DWORD ObjectTypeListLength,
      PGENERIC_MAPPING GenericMapping,
      BOOL ObjectCreation,
      LPDWORD GrantedAccessList,
      LPDWORD AccessStatusList,
      LPBOOL pfGenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AccessMask,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedAceEx(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessAllowedObjectAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      GUID * ObjectTypeGuid,
      GUID * InheritedObjectTypeGuid,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AccessMask,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedAceEx(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAccessDeniedObjectAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      GUID * ObjectTypeGuid,
      GUID * InheritedObjectTypeGuid,
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AddAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD dwStartingAceIndex,
      LPVOID pAceList,
      DWORD nAceListLength
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD dwAccessMask,
      PSID pSid,
      BOOL bAuditSuccess,
      BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessAceEx(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD dwAccessMask,
      PSID pSid,
      BOOL bAuditSuccess,
      BOOL bAuditFailure
    );


__declspec(dllimport)
BOOL
__stdcall
AddAuditAccessObjectAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      GUID * ObjectTypeGuid,
      GUID * InheritedObjectTypeGuid,
      PSID pSid,
      BOOL bAuditSuccess,
      BOOL bAuditFailure
    );





__declspec(dllimport)
BOOL
__stdcall
AddMandatoryAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD MandatoryPolicy,
      PSID pLabelSid
    );


#line 353 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"






__declspec(dllimport)
BOOL
__stdcall
AddResourceAttributeAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      PSID pSid,
      PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo,
      PDWORD pReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AddScopedPolicyIDAce(
      PACL pAcl,
      DWORD dwAceRevision,
      DWORD AceFlags,
      DWORD AccessMask,
      PSID pSid
    );


#line 386 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"



__declspec(dllimport)
BOOL
__stdcall
AdjustTokenGroups(
      HANDLE TokenHandle,
      BOOL ResetToDefault,
      PTOKEN_GROUPS NewState,
      DWORD BufferLength,
      PTOKEN_GROUPS PreviousState,
      PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AdjustTokenPrivileges(
      HANDLE TokenHandle,
      BOOL DisableAllPrivileges,
      PTOKEN_PRIVILEGES NewState,
      DWORD BufferLength,
      PTOKEN_PRIVILEGES PreviousState,
      PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateAndInitializeSid(
      PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
      BYTE nSubAuthorityCount,
      DWORD nSubAuthority0,
      DWORD nSubAuthority1,
      DWORD nSubAuthority2,
      DWORD nSubAuthority3,
      DWORD nSubAuthority4,
      DWORD nSubAuthority5,
      DWORD nSubAuthority6,
      DWORD nSubAuthority7,
     PSID * pSid
    );


__declspec(dllimport)
BOOL
__stdcall
AllocateLocallyUniqueId(
      PLUID Luid
    );


__declspec(dllimport)
BOOL
__stdcall
AreAllAccessesGranted(
      DWORD GrantedAccess,
      DWORD DesiredAccess
    );


__declspec(dllimport)
BOOL
__stdcall
AreAnyAccessesGranted(
      DWORD GrantedAccess,
      DWORD DesiredAccess
    );


__declspec(dllimport)
BOOL
__stdcall
CheckTokenMembership(
      HANDLE TokenHandle,
      PSID SidToCheck,
      PBOOL IsMember
    );







__declspec(dllimport)
BOOL
__stdcall
CheckTokenCapability(
      HANDLE TokenHandle,
      PSID CapabilitySidToCheck,
      PBOOL HasCapability
    );


__declspec(dllimport)
BOOL
__stdcall
GetAppContainerAce(
      PACL Acl,
      DWORD StartingAceIndex,
     PVOID * AppContainerAce,
      DWORD * AppContainerAceIndex
    );


__declspec(dllimport)
BOOL
__stdcall
CheckTokenMembershipEx(
      HANDLE TokenHandle,
      PSID SidToCheck,
      DWORD Flags,
      PBOOL IsMember
    );


#line 507 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"



__declspec(dllimport)
BOOL
__stdcall
ConvertToAutoInheritPrivateObjectSecurity(
      PSECURITY_DESCRIPTOR ParentDescriptor,
      PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
     PSECURITY_DESCRIPTOR * NewSecurityDescriptor,
      GUID * ObjectType,
      BOOLEAN IsDirectoryObject,
      PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CopySid(
      DWORD nDestinationSidLength,
      PSID pDestinationSid,
      PSID pSourceSid
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurity(
      PSECURITY_DESCRIPTOR ParentDescriptor,
      PSECURITY_DESCRIPTOR CreatorDescriptor,
     PSECURITY_DESCRIPTOR * NewDescriptor,
      BOOL IsDirectoryObject,
      HANDLE Token,
      PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityEx(
      PSECURITY_DESCRIPTOR ParentDescriptor,
      PSECURITY_DESCRIPTOR CreatorDescriptor,
     PSECURITY_DESCRIPTOR * NewDescriptor,
      GUID * ObjectType,
      BOOL IsContainerObject,
      ULONG AutoInheritFlags,
      HANDLE Token,
      PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreatePrivateObjectSecurityWithMultipleInheritance(
      PSECURITY_DESCRIPTOR ParentDescriptor,
      PSECURITY_DESCRIPTOR CreatorDescriptor,
     PSECURITY_DESCRIPTOR * NewDescriptor,
      GUID ** ObjectTypes,
      ULONG GuidCount,
      BOOL IsContainerObject,
      ULONG AutoInheritFlags,
      HANDLE Token,
      PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
CreateRestrictedToken(
      HANDLE ExistingTokenHandle,
      DWORD Flags,
      DWORD DisableSidCount,
      PSID_AND_ATTRIBUTES SidsToDisable,
      DWORD DeletePrivilegeCount,
      PLUID_AND_ATTRIBUTES PrivilegesToDelete,
      DWORD RestrictedSidCount,
      PSID_AND_ATTRIBUTES SidsToRestrict,
     PHANDLE NewTokenHandle
    );





__declspec(dllimport)
 
BOOL
__stdcall
CreateWellKnownSid(
      WELL_KNOWN_SID_TYPE WellKnownSidType,
      PSID DomainSid,
      PSID pSid,
      DWORD * cbSid
    );


__declspec(dllimport)
 
BOOL
__stdcall
EqualDomainSid(
      PSID pSid1,
      PSID pSid2,
      BOOL * pfEqual
    );


#line 620 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteAce(
      PACL pAcl,
      DWORD dwAceIndex
    );


__declspec(dllimport)
BOOL
__stdcall
DestroyPrivateObjectSecurity(
        PSECURITY_DESCRIPTOR * ObjectDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateToken(
      HANDLE ExistingTokenHandle,
      SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
     PHANDLE DuplicateTokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
DuplicateTokenEx(
      HANDLE hExistingToken,
      DWORD dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpTokenAttributes,
      SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
      TOKEN_TYPE TokenType,
     PHANDLE phNewToken
    );


__declspec(dllimport)
BOOL
__stdcall
EqualPrefixSid(
      PSID pSid1,
      PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
EqualSid(
      PSID pSid1,
      PSID pSid2
    );


__declspec(dllimport)
BOOL
__stdcall
FindFirstFreeAce(
      PACL pAcl,
     LPVOID * pAce
    );


__declspec(dllimport)
PVOID
__stdcall
FreeSid(
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetAce(
      PACL pAcl,
      DWORD dwAceIndex,
     LPVOID * pAce
    );


__declspec(dllimport)
BOOL
__stdcall
GetAclInformation(
      PACL pAcl,
      LPVOID pAclInformation,
      DWORD nAclInformationLength,
      ACL_INFORMATION_CLASS dwAclInformationClass
    );


__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityW(
      LPCWSTR lpFileName,
      SECURITY_INFORMATION RequestedInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      DWORD nLength,
      LPDWORD lpnLengthNeeded
    );






__declspec(dllimport)
BOOL
__stdcall
GetKernelObjectSecurity(
      HANDLE Handle,
      SECURITY_INFORMATION RequestedInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      DWORD nLength,
      LPDWORD lpnLengthNeeded
    );


__declspec(dllimport)
 
 
DWORD
__stdcall
GetLengthSid(
        PSID pSid
    );


__declspec(dllimport)
 
BOOL
__stdcall
GetPrivateObjectSecurity(
      PSECURITY_DESCRIPTOR ObjectDescriptor,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR ResultantDescriptor,
      DWORD DescriptorLength,
      PDWORD ReturnLength
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorControl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSECURITY_DESCRIPTOR_CONTROL pControl,
      LPDWORD lpdwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorDacl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      LPBOOL lpbDaclPresent,
     PACL * pDacl,
      LPBOOL lpbDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorGroup(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID * pGroup,
      LPBOOL lpbGroupDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorLength(
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorOwner(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
     PSID * pOwner,
      LPBOOL lpbOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
GetSecurityDescriptorRMControl(
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
GetSecurityDescriptorSacl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      LPBOOL lpbSaclPresent,
     PACL * pSacl,
      LPBOOL lpbSaclDefaulted
    );


__declspec(dllimport)
PSID_IDENTIFIER_AUTHORITY
__stdcall
GetSidIdentifierAuthority(
      PSID pSid
    );


__declspec(dllimport)
DWORD
__stdcall
GetSidLengthRequired(
      UCHAR nSubAuthorityCount
    );


__declspec(dllimport)
PDWORD
__stdcall
GetSidSubAuthority(
      PSID pSid,
      DWORD nSubAuthority
    );


__declspec(dllimport)
PUCHAR
__stdcall
GetSidSubAuthorityCount(
      PSID pSid
    );


__declspec(dllimport)
BOOL
__stdcall
GetTokenInformation(
      HANDLE TokenHandle,
      TOKEN_INFORMATION_CLASS TokenInformationClass,
      LPVOID TokenInformation,
      DWORD TokenInformationLength,
      PDWORD ReturnLength
    );





__declspec(dllimport)
 
BOOL
__stdcall
GetWindowsAccountDomainSid(
      PSID pSid,
      PSID pDomainSid,
      DWORD * cbDomainSid
    );


#line 897 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"

__declspec(dllimport)
BOOL
__stdcall
ImpersonateAnonymousToken(
      HANDLE ThreadHandle
    );


 
__declspec(dllimport)
BOOL
__stdcall
ImpersonateLoggedOnUser(
      HANDLE hToken
    );


 
__declspec(dllimport)
BOOL
__stdcall
ImpersonateSelf(
      SECURITY_IMPERSONATION_LEVEL ImpersonationLevel
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeAcl(
      PACL pAcl,
      DWORD nAclLength,
      DWORD dwAclRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSecurityDescriptor(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      DWORD dwRevision
    );


__declspec(dllimport)
BOOL
__stdcall
InitializeSid(
      PSID Sid,
      PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
      BYTE nSubAuthorityCount
    );


__declspec(dllimport)
BOOL
__stdcall
IsTokenRestricted(
      HANDLE TokenHandle
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidAcl(
      PACL pAcl
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSecurityDescriptor(
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
IsValidSid(
      PSID pSid
    );





__declspec(dllimport)
BOOL
__stdcall
IsWellKnownSid(
      PSID pSid,
      WELL_KNOWN_SID_TYPE WellKnownSidType
    );


#line 998 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"

__declspec(dllimport)
 
BOOL
__stdcall
MakeAbsoluteSD(
      PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
      PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
      LPDWORD lpdwAbsoluteSecurityDescriptorSize,
      PACL pDacl,
      LPDWORD lpdwDaclSize,
      PACL pSacl,
      LPDWORD lpdwSaclSize,
      PSID pOwner,
      LPDWORD lpdwOwnerSize,
      PSID pPrimaryGroup,
      LPDWORD lpdwPrimaryGroupSize
    );


__declspec(dllimport)
 
BOOL
__stdcall
MakeSelfRelativeSD(
      PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
      PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
      LPDWORD lpdwBufferLength
    );


__declspec(dllimport)
void
__stdcall
MapGenericMask(
      PDWORD AccessMask,
      PGENERIC_MAPPING GenericMapping
    );


__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      BOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      LPWSTR ObjectTypeName,
      LPWSTR ObjectName,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      DWORD GrantedAccess,
      PPRIVILEGE_SET Privileges,
      BOOL ObjectCreation,
      BOOL AccessGranted,
      LPBOOL GenerateOnClose
    );






__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmW(
      LPCWSTR SubsystemName,
      LPVOID HandleId,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      PPRIVILEGE_SET Privileges,
      BOOL AccessGranted
    );






__declspec(dllimport)
BOOL
__stdcall
PrivilegeCheck(
      HANDLE ClientToken,
      PPRIVILEGE_SET RequiredPrivileges,
      LPBOOL pfResult
    );


__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmW(
      LPCWSTR SubsystemName,
      LPCWSTR ServiceName,
      HANDLE ClientToken,
      PPRIVILEGE_SET Privileges,
      BOOL AccessGranted
    );









__declspec(dllimport)
void
__stdcall
QuerySecurityAccessMask(
      SECURITY_INFORMATION SecurityInformation,
      LPDWORD DesiredAccess
    );


#line 1145 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"

__declspec(dllimport)
BOOL
__stdcall
RevertToSelf(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
SetAclInformation(
      PACL pAcl,
      LPVOID pAclInformation,
      DWORD nAclInformationLength,
      ACL_INFORMATION_CLASS dwAclInformationClass
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityW(
      LPCWSTR lpFileName,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );





__declspec(dllimport)
BOOL
__stdcall
SetKernelObjectSecurity(
      HANDLE Handle,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR SecurityDescriptor
    );


__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurity(
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR ModificationDescriptor,
      PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor,
      PGENERIC_MAPPING GenericMapping,
      HANDLE Token
    );


__declspec(dllimport)
BOOL
__stdcall
SetPrivateObjectSecurityEx(
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR ModificationDescriptor,
      PSECURITY_DESCRIPTOR * ObjectsSecurityDescriptor,
      ULONG AutoInheritFlags,
      PGENERIC_MAPPING GenericMapping,
      HANDLE Token
    );





__declspec(dllimport)
void
__stdcall
SetSecurityAccessMask(
      SECURITY_INFORMATION SecurityInformation,
      LPDWORD DesiredAccess
    );


#line 1226 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorControl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
      SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorDacl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      BOOL bDaclPresent,
      PACL pDacl,
      BOOL bDaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorGroup(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSID pGroup,
      BOOL bGroupDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorOwner(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      PSID pOwner,
      BOOL bOwnerDefaulted
    );


__declspec(dllimport)
DWORD
__stdcall
SetSecurityDescriptorRMControl(
      PSECURITY_DESCRIPTOR SecurityDescriptor,
      PUCHAR RMControl
    );


__declspec(dllimport)
BOOL
__stdcall
SetSecurityDescriptorSacl(
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      BOOL bSaclPresent,
      PACL pSacl,
      BOOL bSaclDefaulted
    );


__declspec(dllimport)
BOOL
__stdcall
SetTokenInformation(
      HANDLE TokenHandle,
      TOKEN_INFORMATION_CLASS TokenInformationClass,
      LPVOID TokenInformation,
      DWORD TokenInformationLength
    );







__declspec(dllimport)
BOOL
__stdcall
SetCachedSigningLevel(
      PHANDLE SourceFiles,
      ULONG SourceFileCount,
      ULONG Flags,
      HANDLE TargetFile
    );


__declspec(dllimport)
BOOL
__stdcall
GetCachedSigningLevel(
      HANDLE File,
      PULONG Flags,
      PULONG SigningLevel,
      PUCHAR Thumbprint,
      PULONG ThumbprintSize,
      PULONG ThumbprintAlgorithm
    );

    
#line 1329 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"

#line 1331 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"
#pragma endregion




}
#line 1338 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"

#line 1340 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securitybaseapi.h"

#line 60 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namespaceapi.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namespaceapi.h"

















#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namespaceapi.h"


extern "C" {
#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namespaceapi.h"

#pragma region Desktop Family





__declspec(dllimport)
HANDLE
__stdcall
CreatePrivateNamespaceW(
      LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
      LPVOID lpBoundaryDescriptor,
      LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
HANDLE
__stdcall
OpenPrivateNamespaceW(
      LPVOID lpBoundaryDescriptor,
      LPCWSTR lpAliasPrefix
    );


__declspec(dllimport)
BOOLEAN
__stdcall
ClosePrivateNamespace(
      HANDLE Handle,
      ULONG Flags
    );


__declspec(dllimport)
HANDLE
__stdcall
CreateBoundaryDescriptorW(
      LPCWSTR Name,
      ULONG Flags
    );


__declspec(dllimport)
BOOL
__stdcall
AddSIDToBoundaryDescriptor(
      HANDLE * BoundaryDescriptor,
      PSID RequiredSid
    );


__declspec(dllimport)
void
__stdcall
DeleteBoundaryDescriptor(
      HANDLE BoundaryDescriptor
    );


#line 97 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namespaceapi.h"
#pragma endregion


}
#line 102 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namespaceapi.h"

#line 104 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\namespaceapi.h"
#line 61 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\systemtopologyapi.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\systemtopologyapi.h"

















#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\systemtopologyapi.h"


extern "C" {
#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\systemtopologyapi.h"

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
GetNumaHighestNodeNumber(
      PULONG HighestNodeNumber
    );





__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeProcessorMaskEx(
      USHORT Node,
      PGROUP_AFFINITY ProcessorMask
    );


#line 61 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\systemtopologyapi.h"

#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\systemtopologyapi.h"
#pragma endregion


}
#line 68 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\systemtopologyapi.h"

#line 70 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\systemtopologyapi.h"
#line 62 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"
 
 









#pragma once
#line 14 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"



















#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"


extern "C" {
#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"

#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
GetProcessGroupAffinity(
      HANDLE hProcess,
      PUSHORT GroupCount,
      PUSHORT GroupArray
    );


#line 57 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"

#line 59 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"
#pragma endregion


#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
GetThreadGroupAffinity(
      HANDLE hThread,
      PGROUP_AFFINITY GroupAffinity
    );


__declspec(dllimport)
BOOL
__stdcall
SetThreadGroupAffinity(
      HANDLE hThread,
      const GROUP_AFFINITY * GroupAffinity,
      PGROUP_AFFINITY PreviousGroupAffinity
    );


#line 89 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"

#line 91 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"
#pragma endregion


}
#line 96 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"

#line 98 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\processtopologyapi.h"
#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securityappcontainer.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securityappcontainer.h"



















#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securityappcontainer.h"

#pragma region Desktop Family




extern "C" {
#line 41 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securityappcontainer.h"








BOOL
__stdcall
GetAppContainerNamedObjectPath(
      HANDLE Token,
      PSID AppContainerSid,
      ULONG ObjectPathLength,
      LPWSTR ObjectPath,
      PULONG ReturnLength
    );


#line 61 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securityappcontainer.h"


}
#line 65 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securityappcontainer.h"

#line 67 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securityappcontainer.h"
#pragma endregion

#line 70 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\securityappcontainer.h"
#line 64 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"
















#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"


extern "C" {
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"

#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
QueryThreadCycleTime(
      HANDLE ThreadHandle,
      PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryProcessCycleTime(
      HANDLE ProcessHandle,
      PULONG64 CycleTime
    );


__declspec(dllimport)
BOOL
__stdcall
QueryIdleProcessorCycleTime(
      PULONG BufferLength,
      PULONG64 ProcessorIdleCycleTime
    );


#line 70 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"




__declspec(dllimport)
BOOL
__stdcall
QueryIdleProcessorCycleTimeEx(
      USHORT Group,
      PULONG BufferLength,
      PULONG64 ProcessorIdleCycleTime
    );

    
#line 85 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"

#line 87 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"
#pragma endregion

#pragma region Application Family






__declspec(dllimport)
BOOL
__stdcall
QueryUnbiasedInterruptTime(
      PULONGLONG UnbiasedTime
    );


#line 105 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"

#line 107 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"
#pragma endregion


}
#line 112 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"

#line 114 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\realtimeapiset.h"
#line 65 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


extern "C" {
#line 69 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#pragma region Application Family












#line 84 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




#line 92 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family






















































#line 150 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




































#line 187 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"














#line 202 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 204 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"











#line 216 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 218 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"






























































typedef void (__stdcall *PFIBER_START_ROUTINE)(
    LPVOID lpFiberParameter
    );
typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

typedef LPVOID (__stdcall *PFIBER_CALLOUT_ROUTINE)(
    LPVOID lpParameter
    );
#line 289 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"









typedef PLDT_ENTRY LPLDT_ENTRY;


#line 302 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





































































































typedef struct _COMMPROP {
    WORD wPacketLength;
    WORD wPacketVersion;
    DWORD dwServiceMask;
    DWORD dwReserved1;
    DWORD dwMaxTxQueue;
    DWORD dwMaxRxQueue;
    DWORD dwMaxBaud;
    DWORD dwProvSubType;
    DWORD dwProvCapabilities;
    DWORD dwSettableParams;
    DWORD dwSettableBaud;
    WORD wSettableData;
    WORD wSettableStopParity;
    DWORD dwCurrentTxQueue;
    DWORD dwCurrentRxQueue;
    DWORD dwProvSpec1;
    DWORD dwProvSpec2;
    WCHAR wcProvChar[1];
} COMMPROP,*LPCOMMPROP;







typedef struct _COMSTAT {
    DWORD fCtsHold : 1;
    DWORD fDsrHold : 1;
    DWORD fRlsdHold : 1;
    DWORD fXoffHold : 1;
    DWORD fXoffSent : 1;
    DWORD fEof : 1;
    DWORD fTxim : 1;
    DWORD fReserved : 25;
    DWORD cbInQue;
    DWORD cbOutQue;
} COMSTAT, *LPCOMSTAT;
















typedef struct _DCB {
    DWORD DCBlength;      
    DWORD BaudRate;       
    DWORD fBinary: 1;     
    DWORD fParity: 1;     
    DWORD fOutxCtsFlow:1; 
    DWORD fOutxDsrFlow:1; 
    DWORD fDtrControl:2;  
    DWORD fDsrSensitivity:1; 
    DWORD fTXContinueOnXoff: 1; 
    DWORD fOutX: 1;       
    DWORD fInX: 1;        
    DWORD fErrorChar: 1;  
    DWORD fNull: 1;       
    DWORD fRtsControl:2;  
    DWORD fAbortOnError:1; 
    DWORD fDummy2:17;     
    WORD wReserved;       
    WORD XonLim;          
    WORD XoffLim;         
    BYTE ByteSize;        
    BYTE Parity;          
    BYTE StopBits;        
    char XonChar;         
    char XoffChar;        
    char ErrorChar;       
    char EofChar;         
    char EvtChar;         
    WORD wReserved1;      
} DCB, *LPDCB;

typedef struct _COMMTIMEOUTS {
    DWORD ReadIntervalTimeout;          
    DWORD ReadTotalTimeoutMultiplier;   
    DWORD ReadTotalTimeoutConstant;     
    DWORD WriteTotalTimeoutMultiplier;  
    DWORD WriteTotalTimeoutConstant;    
} COMMTIMEOUTS,*LPCOMMTIMEOUTS;

typedef struct _COMMCONFIG {
    DWORD dwSize;               
    WORD wVersion;              
    WORD wReserved;             
    DCB dcb;                    
    DWORD dwProviderSubType;    

    DWORD dwProviderOffset;     

    DWORD dwProviderSize;       
    WCHAR wcProviderData[1];    
} COMMCONFIG,*LPCOMMCONFIG;




































typedef struct _MEMORYSTATUS {
    DWORD dwLength;
    DWORD dwMemoryLoad;
    SIZE_T dwTotalPhys;
    SIZE_T dwAvailPhys;
    SIZE_T dwTotalPageFile;
    SIZE_T dwAvailPageFile;
    SIZE_T dwTotalVirtual;
    SIZE_T dwAvailVirtual;
} MEMORYSTATUS, *LPMEMORYSTATUS;



























































































typedef struct _JIT_DEBUG_INFO {
    DWORD dwSize;
    DWORD dwProcessorArchitecture;
    DWORD dwThreadID;
    DWORD dwReserved0;
    ULONG64 lpExceptionAddress;
    ULONG64 lpExceptionRecord;
    ULONG64 lpContextRecord;
} JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;

typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;


typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;
#line 663 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"














#line 678 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





































































































































































































typedef struct _OFSTRUCT {
    BYTE cBytes;
    BYTE fFixedDisk;
    WORD nErrCode;
    WORD Reserved1;
    WORD Reserved2;
    CHAR szPathName[128];
} OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;






#line 890 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


int



#line 900 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
__stdcall
#line 902 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


#line 905 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
WinMain (
      HINSTANCE hInstance,
      HINSTANCE hPrevInstance,
      LPSTR lpCmdLine,
      int nShowCmd
    );

int


#line 916 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
__stdcall
#line 918 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
wWinMain(
      HINSTANCE hInstance,
      HINSTANCE hPrevInstance,
      LPWSTR lpCmdLine,
      int nShowCmd
    );

__declspec(dllimport)
 
 
HGLOBAL
__stdcall
GlobalAlloc(
      UINT uFlags,
      SIZE_T dwBytes
    );

__declspec(dllimport)
   
HGLOBAL
__stdcall
GlobalReAlloc (
      HGLOBAL hMem,
      SIZE_T dwBytes,
      UINT uFlags
    );

__declspec(dllimport)
SIZE_T
__stdcall
GlobalSize (
      HGLOBAL hMem
    );

__declspec(dllimport)
UINT
__stdcall
GlobalFlags (
      HGLOBAL hMem
    );

__declspec(dllimport)
 
LPVOID
__stdcall
GlobalLock (
      HGLOBAL hMem
    );

__declspec(dllimport)
 
HGLOBAL
__stdcall
GlobalHandle (
      LPCVOID pMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnlock(
      HGLOBAL hMem
    );

__declspec(dllimport)
 
 
HGLOBAL
__stdcall
GlobalFree(
      HGLOBAL hMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
GlobalCompact(
      DWORD dwMinFree
    );

__declspec(dllimport)
void
__stdcall
GlobalFix(
      HGLOBAL hMem
    );

__declspec(dllimport)
void
__stdcall
GlobalUnfix(
      HGLOBAL hMem
    );

__declspec(dllimport)
LPVOID
__stdcall
GlobalWire(
      HGLOBAL hMem
    );

__declspec(dllimport)
BOOL
__stdcall
GlobalUnWire(
      HGLOBAL hMem
    );

 
__declspec(dllimport)
void
__stdcall
GlobalMemoryStatus(
      LPMEMORYSTATUS lpBuffer
    );

__declspec(dllimport)
 
 
HLOCAL
__stdcall
LocalAlloc(
      UINT uFlags,
      SIZE_T uBytes
    );

__declspec(dllimport)
   
HLOCAL
__stdcall
LocalReAlloc(
      HLOCAL hMem,
      SIZE_T uBytes,
      UINT uFlags
    );

__declspec(dllimport)
 
LPVOID
__stdcall
LocalLock(
      HLOCAL hMem
    );

__declspec(dllimport)
 
HLOCAL
__stdcall
LocalHandle(
      LPCVOID pMem
    );

__declspec(dllimport)
BOOL
__stdcall
LocalUnlock(
      HLOCAL hMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalSize(
      HLOCAL hMem
    );

__declspec(dllimport)
UINT
__stdcall
LocalFlags(
      HLOCAL hMem
    );

__declspec(dllimport)
 
 
HLOCAL
__stdcall
LocalFree(
      HLOCAL hMem
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalShrink(
      HLOCAL hMem,
      UINT cbNewSize
    );

__declspec(dllimport)
SIZE_T
__stdcall
LocalCompact(
      UINT uMinFree
    );



__declspec(dllimport)
BOOL
__stdcall
GetProcessorSystemCycleTime (
      USHORT Group,
      PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer,
      PDWORD ReturnedLength
    );

#line 1127 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"













#line 1141 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 1143 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeA(
       LPCSTR lpApplicationName,
      LPDWORD  lpBinaryType
    );
__declspec(dllimport)
BOOL
__stdcall
GetBinaryTypeW(
       LPCWSTR lpApplicationName,
      LPDWORD  lpBinaryType
    );




#line 1163 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetShortPathNameA(
      LPCSTR lpszLongPath,
      LPSTR  lpszShortPath,
      DWORD cchBuffer
    );


#line 1176 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
 
DWORD
__stdcall
GetLongPathNameTransactedA(
          LPCSTR lpszShortPath,
      LPSTR  lpszLongPath,
          DWORD cchBuffer,
          HANDLE hTransaction
    );
__declspec(dllimport)
 
DWORD
__stdcall
GetLongPathNameTransactedW(
          LPCWSTR lpszShortPath,
      LPWSTR  lpszLongPath,
          DWORD cchBuffer,
          HANDLE hTransaction
    );




#line 1204 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 1206 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetProcessAffinityMask(
       HANDLE hProcess,
      PDWORD_PTR lpProcessAffinityMask,
      PDWORD_PTR lpSystemAffinityMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessAffinityMask(
      HANDLE hProcess,
      DWORD_PTR dwProcessAffinityMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessIoCounters(
       HANDLE hProcess,
      PIO_COUNTERS lpIoCounters
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessWorkingSetSize(
       HANDLE hProcess,
      PSIZE_T lpMinimumWorkingSetSize,
      PSIZE_T lpMaximumWorkingSetSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessWorkingSetSize(
      HANDLE hProcess,
      SIZE_T dwMinimumWorkingSetSize,
      SIZE_T dwMaximumWorkingSetSize
    );

__declspec(dllimport)

void
__stdcall
FatalExit(
      int ExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
SetEnvironmentStringsA(
         LPCH NewEnvironment
    );


#line 1267 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 1269 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
void
__stdcall
RaiseFailFastException(
      PEXCEPTION_RECORD pExceptionRecord,
      PCONTEXT pContextRecord,
      DWORD dwFlags
    );

#line 1284 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion







#pragma region Application Family




__declspec(dllimport)
void
__stdcall
SwitchToFiber(
      LPVOID lpFiber
    );

__declspec(dllimport)
void
__stdcall
DeleteFiber(
      LPVOID lpFiber
    );



__declspec(dllimport)
BOOL
__stdcall
ConvertFiberToThread(
    void
    );

#line 1321 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
 
PVOID
__stdcall
CalloutOnFiberStack(
      PVOID lpFiber,
      PFIBER_CALLOUT_ROUTINE lpStartAddress,
      PVOID lpParameter
    );

#line 1335 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
LPVOID
__stdcall
CreateFiberEx(
          SIZE_T dwStackCommitSize,
          SIZE_T dwStackReserveSize,
          DWORD dwFlags,
          LPFIBER_START_ROUTINE lpStartAddress,
      LPVOID lpParameter
    );

__declspec(dllimport)
 
LPVOID
__stdcall
ConvertThreadToFiberEx(
      LPVOID lpParameter,
          DWORD dwFlags
    );

#line 1358 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
 
LPVOID
__stdcall
CreateFiber(
          SIZE_T dwStackSize,
          LPFIBER_START_ROUTINE lpStartAddress,
      LPVOID lpParameter
    );

__declspec(dllimport)
 
LPVOID
__stdcall
ConvertThreadToFiber(
      LPVOID lpParameter
    );

#line 1382 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion









#pragma region Desktop Family






typedef void *PUMS_CONTEXT;

typedef void *PUMS_COMPLETION_LIST;

typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;

typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;

typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;

typedef struct _UMS_SCHEDULER_STARTUP_INFO {

    
    
    
    ULONG UmsVersion;

    
    
    
    PUMS_COMPLETION_LIST CompletionList;

    
    
    
    
    PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;

    
    
    
    PVOID SchedulerParam;

} UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;

typedef struct _UMS_SYSTEM_THREAD_INFORMATION {
    ULONG UmsVersion;
    union {
        struct {
            ULONG IsUmsSchedulerThread : 1;
            ULONG IsUmsWorkerThread : 1;
        } ;
        ULONG ThreadUmsFlags;
    } ;
} UMS_SYSTEM_THREAD_INFORMATION, *PUMS_SYSTEM_THREAD_INFORMATION;

 
__declspec(dllimport)
BOOL
__stdcall
CreateUmsCompletionList(
     PUMS_COMPLETION_LIST* UmsCompletionList
    );

__declspec(dllimport)
BOOL
__stdcall
DequeueUmsCompletionListItems(
      PUMS_COMPLETION_LIST UmsCompletionList,
      DWORD WaitTimeOut,
      PUMS_CONTEXT* UmsThreadList
    );

__declspec(dllimport)
BOOL
__stdcall
GetUmsCompletionListEvent(
      PUMS_COMPLETION_LIST UmsCompletionList,
      PHANDLE UmsCompletionEvent
    );

__declspec(dllimport)
BOOL
__stdcall
ExecuteUmsThread(
      PUMS_CONTEXT UmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
UmsThreadYield(
      PVOID SchedulerParam
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteUmsCompletionList(
      PUMS_COMPLETION_LIST UmsCompletionList
    );

__declspec(dllimport)
PUMS_CONTEXT
__stdcall
GetCurrentUmsThread(
    void
    );

__declspec(dllimport)
PUMS_CONTEXT
__stdcall
GetNextUmsListItem(
      PUMS_CONTEXT UmsContext
    );

__declspec(dllimport)
BOOL
__stdcall
QueryUmsThreadInformation(
      PUMS_CONTEXT UmsThread,
      UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
      PVOID UmsThreadInformation,
      ULONG UmsThreadInformationLength,
      PULONG ReturnLength
    );

__declspec(dllimport)
BOOL
__stdcall
SetUmsThreadInformation(
      PUMS_CONTEXT UmsThread,
      UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
      PVOID UmsThreadInformation,
      ULONG UmsThreadInformationLength
    );

__declspec(dllimport)
BOOL
__stdcall
DeleteUmsThreadContext(
      PUMS_CONTEXT UmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
CreateUmsThreadContext(
     PUMS_CONTEXT *lpUmsThread
    );

__declspec(dllimport)
BOOL
__stdcall
EnterUmsSchedulingMode(
      PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo
    );

__declspec(dllimport)
BOOL
__stdcall
GetUmsSystemThreadInformation(
      HANDLE ThreadHandle,
      PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo
    );

#line 1556 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 1558 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion





#line 1565 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#pragma region Desktop Family


__declspec(dllimport)
DWORD_PTR
__stdcall
SetThreadAffinityMask(
      HANDLE hThread,
      DWORD_PTR dwThreadAffinityMask
    );
#line 1577 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
DWORD
__stdcall
SetThreadIdealProcessor(
      HANDLE hThread,
      DWORD dwIdealProcessor
    );
#line 1590 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1591 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family






typedef enum _PROCESS_INFORMATION_CLASS {
    ProcessMemoryPriority,
    ProcessInformationClassMax
} PROCESS_INFORMATION_CLASS;



__declspec(dllimport)
BOOL
__stdcall
GetProcessInformation (
      HANDLE hProcess,
      PROCESS_INFORMATION_CLASS ProcessInformationClass,
      LPVOID ProcessInformation,
      DWORD ProcessInformationSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetProcessInformation (
      HANDLE hProcess,
      PROCESS_INFORMATION_CLASS ProcessInformationClass,
      LPVOID ProcessInformation,
      DWORD ProcessInformationSize
    );

#line 1628 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"






__declspec(dllimport)
BOOL
__stdcall
SetProcessDEPPolicy(
      DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
GetProcessDEPPolicy(
      HANDLE hProcess,
      LPDWORD lpFlags,
      PBOOL lpPermanent
    );

#line 1651 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
RequestWakeupLatency(
      LATENCY_TIME latency
    );

__declspec(dllimport)
BOOL
__stdcall
IsSystemResumeAutomatic(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
GetThreadSelectorEntry(
       HANDLE hThread,
       DWORD dwSelector,
      LPLDT_ENTRY lpSelectorEntry
    );

__declspec(dllimport)
EXECUTION_STATE
__stdcall
SetThreadExecutionState(
      EXECUTION_STATE esFlags
    );







typedef REASON_CONTEXT POWER_REQUEST_CONTEXT, *PPOWER_REQUEST_CONTEXT, *LPPOWER_REQUEST_CONTEXT;

__declspec(dllimport)
HANDLE
__stdcall
PowerCreateRequest (
      PREASON_CONTEXT Context
    );

__declspec(dllimport)
BOOL
__stdcall
PowerSetRequest (
      HANDLE PowerRequest,
      POWER_REQUEST_TYPE RequestType
    );

__declspec(dllimport)
BOOL
__stdcall
PowerClearRequest (
      HANDLE PowerRequest,
      POWER_REQUEST_TYPE RequestType
    );

#line 1714 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 1716 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family






#line 1726 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


















#line 1748 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1749 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





















__declspec(dllimport)
BOOL
__stdcall
SetFileCompletionNotificationModes(
      HANDLE FileHandle,
      UCHAR Flags
    );

#line 1779 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"










__declspec(dllimport)
DWORD
__stdcall
GetThreadErrorMode(
    void
    );

__declspec(dllimport)
BOOL
__stdcall
SetThreadErrorMode(
      DWORD dwNewMode,
      LPDWORD lpOldMode
    );





__declspec(dllimport)
BOOL
__stdcall
Wow64GetThreadContext(
         HANDLE hThread,
      PWOW64_CONTEXT lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
Wow64SetThreadContext(
      HANDLE hThread,
      const WOW64_CONTEXT *lpContext
    );

#line 1825 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
Wow64GetThreadSelectorEntry(
      HANDLE hThread,
      DWORD dwSelector,
      PWOW64_LDT_ENTRY lpSelectorEntry
    );

#line 1838 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 1840 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
DWORD
__stdcall
Wow64SuspendThread(
      HANDLE hThread
    );

#line 1851 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DebugSetProcessKillOnExit(
      BOOL KillOnExit
    );

__declspec(dllimport)
BOOL
__stdcall
DebugBreakProcess (
      HANDLE Process
    );

#line 1867 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family




#line 1875 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 1877 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
PulseEvent(
      HANDLE hEvent
    );

__declspec(dllimport)
DWORD
__stdcall
WaitForMultipleObjects(
      DWORD nCount,
      const HANDLE *lpHandles,
      BOOL bWaitAll,
      DWORD dwMilliseconds
    );

__declspec(dllimport)
ATOM
__stdcall
GlobalDeleteAtom(
      ATOM nAtom
    );

__declspec(dllimport)
BOOL
__stdcall
InitAtomTable(
      DWORD nSize
    );

__declspec(dllimport)
ATOM
__stdcall
DeleteAtom(
      ATOM nAtom
    );

__declspec(dllimport)
UINT
__stdcall
SetHandleCount(
      UINT uNumber
    );

__declspec(dllimport)
BOOL
__stdcall
RequestDeviceWakeup(
      HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
CancelDeviceWakeupRequest(
      HANDLE hDevice
    );

__declspec(dllimport)
BOOL
__stdcall
GetDevicePowerState(
       HANDLE hDevice,
      BOOL *pfOn
    );

__declspec(dllimport)
BOOL
__stdcall
SetMessageWaitingIndicator(
      HANDLE hMsgIndicator,
      ULONG ulMsgCount
    );


__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameA(
      HANDLE hFile,
      LPCSTR lpShortName
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileShortNameW(
      HANDLE hFile,
      LPCWSTR lpShortName
    );




#line 1977 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"






__declspec(dllimport)
DWORD
__stdcall
LoadModule(
      LPCSTR lpModuleName,
      LPVOID lpParameterBlock
    );


 
__declspec(dllimport)
UINT
__stdcall
WinExec(
      LPCSTR lpCmdLine,
      UINT uCmdShow
    );

__declspec(dllimport)
BOOL
__stdcall
ClearCommBreak(
      HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
ClearCommError(
           HANDLE hFile,
      LPDWORD lpErrors,
      LPCOMSTAT lpStat
    );

__declspec(dllimport)
BOOL
__stdcall
SetupComm(
      HANDLE hFile,
      DWORD dwInQueue,
      DWORD dwOutQueue
    );

__declspec(dllimport)
BOOL
__stdcall
EscapeCommFunction(
      HANDLE hFile,
      DWORD dwFunc
    );

__declspec(dllimport)
 
BOOL
__stdcall
GetCommConfig(
           HANDLE hCommDev,
      LPCOMMCONFIG lpCC,
        LPDWORD lpdwSize
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommMask(
       HANDLE hFile,
      LPDWORD lpEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommProperties(
         HANDLE hFile,
      LPCOMMPROP lpCommProp
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommModemStatus(
       HANDLE hFile,
      LPDWORD lpModemStat
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommState(
       HANDLE hFile,
      LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
GetCommTimeouts(
       HANDLE hFile,
      LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
PurgeComm(
      HANDLE hFile,
      DWORD dwFlags
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommBreak(
      HANDLE hFile
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommConfig(
      HANDLE hCommDev,
      LPCOMMCONFIG lpCC,
      DWORD dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommMask(
      HANDLE hFile,
      DWORD dwEvtMask
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommState(
      HANDLE hFile,
      LPDCB lpDCB
    );

__declspec(dllimport)
BOOL
__stdcall
SetCommTimeouts(
      HANDLE hFile,
      LPCOMMTIMEOUTS lpCommTimeouts
    );

__declspec(dllimport)
BOOL
__stdcall
TransmitCommChar(
      HANDLE hFile,
      char cChar
    );

__declspec(dllimport)
BOOL
__stdcall
WaitCommEvent(
             HANDLE hFile,
          LPDWORD lpEvtMask,
      LPOVERLAPPED lpOverlapped
    );


__declspec(dllimport)
DWORD
__stdcall
SetTapePosition(
      HANDLE hDevice,
      DWORD dwPositionMethod,
      DWORD dwPartition,
      DWORD dwOffsetLow,
      DWORD dwOffsetHigh,
      BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapePosition(
       HANDLE hDevice,
       DWORD dwPositionType,
      LPDWORD lpdwPartition,
      LPDWORD lpdwOffsetLow,
      LPDWORD lpdwOffsetHigh
    );

__declspec(dllimport)
DWORD
__stdcall
PrepareTape(
      HANDLE hDevice,
      DWORD dwOperation,
      BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
EraseTape(
      HANDLE hDevice,
      DWORD dwEraseType,
      BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
CreateTapePartition(
      HANDLE hDevice,
      DWORD dwPartitionMethod,
      DWORD dwCount,
      DWORD dwSize
    );

__declspec(dllimport)
DWORD
__stdcall
WriteTapemark(
      HANDLE hDevice,
      DWORD dwTapemarkType,
      DWORD dwTapemarkCount,
      BOOL bImmediate
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeStatus(
      HANDLE hDevice
    );

__declspec(dllimport)
DWORD
__stdcall
GetTapeParameters(
         HANDLE hDevice,
         DWORD dwOperation,
      LPDWORD lpdwSize,
      LPVOID lpTapeInformation
    );




__declspec(dllimport)
DWORD
__stdcall
SetTapeParameters(
      HANDLE hDevice,
      DWORD dwOperation,
      LPVOID lpTapeInformation
    );




#line 2244 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
int
__stdcall
MulDiv(
      int nNumber,
      int nNumerator,
      int nDenominator
    );

#line 2259 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


typedef enum _DEP_SYSTEM_POLICY_TYPE {
    DEPPolicyAlwaysOff = 0,
    DEPPolicyAlwaysOn,
    DEPPolicyOptIn,
    DEPPolicyOptOut,
    DEPTotalPolicyCount
} DEP_SYSTEM_POLICY_TYPE;



__declspec(dllimport)
DEP_SYSTEM_POLICY_TYPE
__stdcall
GetSystemDEPPolicy(
    void
    );

#line 2282 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetSystemRegistryQuota(
      PDWORD pdwQuotaAllowed,
      PDWORD pdwQuotaUsed
    );

#line 2294 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





__declspec(dllimport)
BOOL
__stdcall
FileTimeToDosDateTime(
       const FILETIME *lpFileTime,
      LPWORD lpFatDate,
      LPWORD lpFatTime
    );

__declspec(dllimport)
BOOL
__stdcall
DosDateTimeToFileTime(
       WORD wFatDate,
       WORD wFatTime,
      LPFILETIME lpFileTime
    );

#line 2318 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion


#pragma region Application Family



__declspec(dllimport)
 
DWORD
__stdcall
FormatMessageA(
          DWORD dwFlags,
      LPCVOID lpSource,
          DWORD dwMessageId,
          DWORD dwLanguageId,
         LPSTR lpBuffer,
          DWORD nSize,
      va_list *Arguments
    );
__declspec(dllimport)
 
DWORD
__stdcall
FormatMessageW(
          DWORD dwFlags,
      LPCVOID lpSource,
          DWORD dwMessageId,
          DWORD dwLanguageId,
         LPWSTR lpBuffer,
          DWORD nSize,
      va_list *Arguments
    );




#line 2356 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





























#line 2386 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 2387 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"








#line 2396 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family










__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeInfo(
           HANDLE hNamedPipe,
      LPDWORD lpFlags,
      LPDWORD lpOutBufferSize,
      LPDWORD lpInBufferSize,
      LPDWORD lpMaxInstances
    );

__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotA(
          LPCSTR lpName,
          DWORD nMaxMessageSize,
          DWORD lReadTimeout,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateMailslotW(
          LPCWSTR lpName,
          DWORD nMaxMessageSize,
          DWORD lReadTimeout,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 2443 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetMailslotInfo(
           HANDLE hMailslot,
      LPDWORD lpMaxMessageSize,
      LPDWORD lpNextSize,
      LPDWORD lpMessageCount,
      LPDWORD lpReadTimeout
    );

__declspec(dllimport)
BOOL
__stdcall
SetMailslotInfo(
      HANDLE hMailslot,
      DWORD lReadTimeout
    );





__declspec(dllimport)
BOOL
__stdcall
EncryptFileA(
      LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
EncryptFileW(
      LPCWSTR lpFileName
    );




#line 2484 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DecryptFileA(
            LPCSTR lpFileName,
      DWORD dwReserved
    );
__declspec(dllimport)
BOOL
__stdcall
DecryptFileW(
            LPCWSTR lpFileName,
      DWORD dwReserved
    );




#line 2504 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
















__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusA(
       LPCSTR lpFileName,
      LPDWORD  lpStatus
    );
__declspec(dllimport)
BOOL
__stdcall
FileEncryptionStatusW(
       LPCWSTR lpFileName,
      LPDWORD  lpStatus
    );




#line 2539 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"







typedef
DWORD
(__stdcall *PFE_EXPORT_FUNC)(
      PBYTE pbData,
      PVOID pvCallbackContext,
          ULONG ulLength
    );

typedef
DWORD
(__stdcall *PFE_IMPORT_FUNC)(
      PBYTE pbData,
      PVOID pvCallbackContext,
       PULONG ulLength
    );












__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawA(
             LPCSTR lpFileName,
             ULONG    ulFlags,
     PVOID   *pvContext
    );
__declspec(dllimport)
DWORD
__stdcall
OpenEncryptedFileRawW(
             LPCWSTR lpFileName,
             ULONG    ulFlags,
     PVOID   *pvContext
    );




#line 2594 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
ReadEncryptedFileRaw(
          PFE_EXPORT_FUNC pfExportCallback,
      PVOID           pvCallbackContext,
          PVOID           pvContext
    );

__declspec(dllimport)
DWORD
__stdcall
WriteEncryptedFileRaw(
          PFE_IMPORT_FUNC pfImportCallback,
      PVOID           pvCallbackContext,
          PVOID           pvContext
    );

__declspec(dllimport)
void
__stdcall
CloseEncryptedFileRaw(
      PVOID           pvContext
    );





__declspec(dllimport)
int
__stdcall
lstrcmpA(
      LPCSTR lpString1,
      LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpW(
      LPCWSTR lpString1,
      LPCWSTR lpString2
    );




#line 2643 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
int
__stdcall
lstrcmpiA(
      LPCSTR lpString1,
      LPCSTR lpString2
    );
__declspec(dllimport)
int
__stdcall
lstrcmpiW(
      LPCWSTR lpString1,
      LPCWSTR lpString2
    );




#line 2663 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
 
 
 
LPSTR
__stdcall
lstrcpynA(
      LPSTR lpString1,
      LPCSTR lpString2,
      int iMaxLength
    );
__declspec(dllimport)
 
 
 
 
LPWSTR
__stdcall
lstrcpynW(
      LPWSTR lpString1,
      LPCWSTR lpString2,
      int iMaxLength
    );




#line 2693 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


#pragma warning(push)
#pragma warning(disable:4995)
#line 2698 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
LPSTR
__stdcall
lstrcpyA(
      LPSTR lpString1, 
       LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcpyW(
      LPWSTR lpString1, 
       LPCWSTR lpString2
    );




#line 2718 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
LPSTR
__stdcall
lstrcatA(
      LPSTR lpString1, 
         LPCSTR lpString2
    );
__declspec(dllimport)
LPWSTR
__stdcall
lstrcatW(
      LPWSTR lpString1, 
         LPCWSTR lpString2
    );




#line 2738 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


#pragma warning(pop)
#line 2742 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
int
__stdcall
lstrlenA(
      LPCSTR lpString
    );
__declspec(dllimport)
int
__stdcall
lstrlenW(
      LPCWSTR lpString
    );




#line 2760 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
HFILE
__stdcall
OpenFile(
         LPCSTR lpFileName,
      LPOFSTRUCT lpReOpenBuff,
         UINT uStyle
    );

__declspec(dllimport)
HFILE
__stdcall
_lopen(
      LPCSTR lpPathName,
      int iReadWrite
    );

__declspec(dllimport)
HFILE
__stdcall
_lcreat(
      LPCSTR lpPathName,
      int  iAttribute
    );

__declspec(dllimport)
UINT
__stdcall
_lread(
      HFILE hFile,
      LPVOID lpBuffer,
      UINT uBytes
    );

__declspec(dllimport)
UINT
__stdcall
_lwrite(
      HFILE hFile,
      LPCCH lpBuffer,
      UINT uBytes
    );

__declspec(dllimport)
long
__stdcall
_hread(
      HFILE hFile,
      LPVOID lpBuffer,
      long lBytes
    );

__declspec(dllimport)
long
__stdcall
_hwrite(
      HFILE hFile,
      LPCCH lpBuffer,
      long lBytes
    );

__declspec(dllimport)
HFILE
__stdcall
_lclose(
      HFILE hFile
    );

__declspec(dllimport)
LONG
__stdcall
_llseek(
      HFILE hFile,
      LONG lOffset,
      int iOrigin
    );

__declspec(dllimport)
BOOL
__stdcall
IsTextUnicode(
      const void* lpv,
             int iSize,
      LPINT lpiResult
    );


__declspec(dllimport)
DWORD
__stdcall
SignalObjectAndWait(
      HANDLE hObjectToSignal,
      HANDLE hObjectToWaitOn,
      DWORD dwMilliseconds,
      BOOL bAlertable
    );
#line 2858 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BackupRead(
         HANDLE hFile,
      LPBYTE lpBuffer,
         DWORD nNumberOfBytesToRead,
        LPDWORD lpNumberOfBytesRead,
         BOOL bAbort,
         BOOL bProcessSecurity,
      LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupSeek(
         HANDLE hFile,
         DWORD  dwLowBytesToSeek,
         DWORD  dwHighBytesToSeek,
        LPDWORD lpdwLowByteSeeked,
        LPDWORD lpdwHighByteSeeked,
      LPVOID *lpContext
    );

__declspec(dllimport)
BOOL
__stdcall
BackupWrite(
         HANDLE hFile,
      LPBYTE lpBuffer,
         DWORD nNumberOfBytesToWrite,
        LPDWORD lpNumberOfBytesWritten,
         BOOL bAbort,
         BOOL bProcessSecurity,
      LPVOID *lpContext
    );




typedef struct _WIN32_STREAM_ID {
        DWORD          dwStreamId ;
        DWORD          dwStreamAttributes ;
        LARGE_INTEGER  Size ;
        DWORD          dwStreamNameSize ;
        WCHAR          cStreamName[ 1 ] ;
} WIN32_STREAM_ID, *LPWIN32_STREAM_ID ;
















































#line 2956 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



typedef struct _STARTUPINFOEXA {
    STARTUPINFOA StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXA, *LPSTARTUPINFOEXA;
typedef struct _STARTUPINFOEXW {
    STARTUPINFOW StartupInfo;
    LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
} STARTUPINFOEXW, *LPSTARTUPINFOEXW;




typedef STARTUPINFOEXA STARTUPINFOEX;
typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX;
#line 2974 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 2976 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



#line 2980 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
 
HANDLE
__stdcall
OpenMutexA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );


#line 2997 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
CreateSemaphoreA(
      LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
          LONG lInitialCount,
          LONG lMaximumCount,
      LPCSTR lpName
    );
__declspec(dllimport)
 
HANDLE
__stdcall
CreateSemaphoreW(
      LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
          LONG lInitialCount,
          LONG lMaximumCount,
      LPCWSTR lpName
    );




#line 3023 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenSemaphoreA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );


#line 3036 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
 
HANDLE
__stdcall
CreateWaitableTimerA(
      LPSECURITY_ATTRIBUTES lpTimerAttributes,
          BOOL bManualReset,
      LPCSTR lpTimerName
    );
__declspec(dllimport)
 
HANDLE
__stdcall
CreateWaitableTimerW(
      LPSECURITY_ATTRIBUTES lpTimerAttributes,
          BOOL bManualReset,
      LPCWSTR lpTimerName
    );




#line 3062 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenWaitableTimerA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpTimerName
    );


#line 3075 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
 
HANDLE
__stdcall
CreateSemaphoreExA(
         LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
             LONG lInitialCount,
             LONG lMaximumCount,
         LPCSTR lpName,
       DWORD dwFlags,
             DWORD dwDesiredAccess
    );


#line 3093 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
CreateWaitableTimerExA(
      LPSECURITY_ATTRIBUTES lpTimerAttributes,
      LPCSTR lpTimerName,
          DWORD dwFlags,
          DWORD dwDesiredAccess
    );


#line 3107 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 3109 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 3111 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingA(
          HANDLE hFile,
      LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
          DWORD flProtect,
          DWORD dwMaximumSizeHigh,
          DWORD dwMaximumSizeLow,
      LPCSTR lpName
    );


#line 3127 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
 
HANDLE
__stdcall
CreateFileMappingNumaA(
          HANDLE hFile,
      LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
          DWORD flProtect,
          DWORD dwMaximumSizeHigh,
          DWORD dwMaximumSizeLow,
      LPCSTR lpName,
          DWORD nndPreferred
    );



#line 3147 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 3149 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
OpenFileMappingA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );


#line 3161 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetLogicalDriveStringsA(
      DWORD nBufferLength,
      LPSTR lpBuffer
    );


#line 3173 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


__declspec(dllimport)
 
HMODULE
__stdcall
LoadLibraryA(
      LPCSTR lpLibFileName
    );
__declspec(dllimport)
 
HMODULE
__stdcall
LoadLibraryW(
      LPCWSTR lpLibFileName
    );




#line 3194 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 3196 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family




__declspec(dllimport)
 
HMODULE
__stdcall
LoadPackagedLibrary (
            LPCWSTR lpwLibFileName,
      DWORD Reserved
    );

#line 3213 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 3215 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameA(
      HANDLE hProcess,
      DWORD dwFlags,
      LPSTR lpExeName,
      PDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
QueryFullProcessImageNameW(
      HANDLE hProcess,
      DWORD dwFlags,
      LPWSTR lpExeName,
      PDWORD lpdwSize
    );




#line 3247 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 3249 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
















typedef enum _PROC_THREAD_ATTRIBUTE_NUM {
    ProcThreadAttributeParentProcess        = 0,
    ProcThreadAttributeHandleList           = 2,

    ProcThreadAttributeGroupAffinity        = 3,
    ProcThreadAttributePreferredNode        = 4,
    ProcThreadAttributeIdealProcessor       = 5,
    ProcThreadAttributeUmsThread            = 6,
    ProcThreadAttributeMitigationPolicy     = 7,
#line 3275 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

    ProcThreadAttributeSecurityCapabilities = 9,
#line 3278 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
    ProcThreadAttributeProtectionLevel      = 11,
} PROC_THREAD_ATTRIBUTE_NUM;
#line 3281 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"












#line 3294 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"












#line 3307 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




#line 3312 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"













#line 3326 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

















































































































#line 3440 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 3441 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
GetProcessShutdownParameters(
      LPDWORD lpdwLevel,
      LPDWORD lpdwFlags
    );

__declspec(dllimport)
void
__stdcall
FatalAppExitA(
      UINT uAction,
      LPCSTR lpMessageText
    );
__declspec(dllimport)
void
__stdcall
FatalAppExitW(
      UINT uAction,
      LPCWSTR lpMessageText
    );




#line 3470 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
void
__stdcall
GetStartupInfoA(
      LPSTARTUPINFOA lpStartupInfo
    );


#line 3480 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

































#line 3514 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



















#line 3534 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableA(
      LPCSTR lpName,
      LPCSTR lpGuid,
      PVOID pBuffer,
      DWORD    nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableW(
      LPCWSTR lpName,
      LPCWSTR lpGuid,
      PVOID pBuffer,
      DWORD    nSize
    );




#line 3558 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableExA(
      LPCSTR lpName,
      LPCSTR lpGuid,
      PVOID pBuffer,
      DWORD    nSize,
      PDWORD pdwAttribubutes
    );
__declspec(dllimport)
DWORD
__stdcall
GetFirmwareEnvironmentVariableExW(
      LPCWSTR lpName,
      LPCWSTR lpGuid,
      PVOID pBuffer,
      DWORD    nSize,
      PDWORD pdwAttribubutes
    );




#line 3586 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 3588 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableA(
      LPCSTR lpName,
      LPCSTR lpGuid,
      PVOID pValue,
      DWORD    nSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableW(
      LPCWSTR lpName,
      LPCWSTR lpGuid,
      PVOID pValue,
      DWORD    nSize
    );




#line 3612 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableExA(
      LPCSTR lpName,
      LPCSTR lpGuid,
      PVOID pValue,
      DWORD    nSize,
      DWORD    dwAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
SetFirmwareEnvironmentVariableExW(
      LPCWSTR lpName,
      LPCWSTR lpGuid,
      PVOID pValue,
      DWORD    nSize,
      DWORD    dwAttributes
    );




#line 3640 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 3642 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetFirmwareType (
      PFIRMWARE_TYPE FirmwareType
    );


__declspec(dllimport)
BOOL
__stdcall
IsNativeVhdBoot (
      PBOOL NativeVhdBoot
    );

#line 3661 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
HRSRC
__stdcall
FindResourceA(
      HMODULE hModule,
          LPCSTR lpName,
          LPCSTR lpType
    );
__declspec(dllimport)
 
HRSRC
__stdcall
FindResourceW(
      HMODULE hModule,
          LPCWSTR lpName,
          LPCWSTR lpType
    );




#line 3685 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
HRSRC
__stdcall
FindResourceExA(
      HMODULE hModule,
          LPCSTR lpType,
          LPCSTR lpName,
          WORD    wLanguage
    );


#line 3699 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesA(
      HMODULE hModule,
          ENUMRESTYPEPROCA lpEnumFunc,
          LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceTypesW(
      HMODULE hModule,
          ENUMRESTYPEPROCW lpEnumFunc,
          LONG_PTR lParam
    );




#line 3721 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesA(
      HMODULE hModule,
          LPCSTR lpType,
          ENUMRESNAMEPROCA lpEnumFunc,
          LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceNamesW(
      HMODULE hModule,
          LPCWSTR lpType,
          ENUMRESNAMEPROCW lpEnumFunc,
          LONG_PTR lParam
    );




#line 3745 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesA(
      HMODULE hModule,
          LPCSTR lpType,
          LPCSTR lpName,
          ENUMRESLANGPROCA lpEnumFunc,
          LONG_PTR lParam
    );
__declspec(dllimport)
BOOL
__stdcall
EnumResourceLanguagesW(
      HMODULE hModule,
          LPCWSTR lpType,
          LPCWSTR lpName,
          ENUMRESLANGPROCW lpEnumFunc,
          LONG_PTR lParam
    );




#line 3771 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceA(
      LPCSTR pFileName,
      BOOL bDeleteExistingResources
    );
__declspec(dllimport)
HANDLE
__stdcall
BeginUpdateResourceW(
      LPCWSTR pFileName,
      BOOL bDeleteExistingResources
    );




#line 3791 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
UpdateResourceA(
      HANDLE hUpdate,
      LPCSTR lpType,
      LPCSTR lpName,
      WORD wLanguage,
      LPVOID lpData,
      DWORD cb
    );
__declspec(dllimport)
BOOL
__stdcall
UpdateResourceW(
      HANDLE hUpdate,
      LPCWSTR lpType,
      LPCWSTR lpName,
      WORD wLanguage,
      LPVOID lpData,
      DWORD cb
    );




#line 3819 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceA(
      HANDLE hUpdate,
      BOOL   fDiscard
    );
__declspec(dllimport)
BOOL
__stdcall
EndUpdateResourceW(
      HANDLE hUpdate,
      BOOL   fDiscard
    );




#line 3839 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomA(
      LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomW(
      LPCWSTR lpString
    );




#line 3859 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExA(
      LPCSTR lpString,
      DWORD Flags
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalAddAtomExW(
      LPCWSTR lpString,
      DWORD Flags
    );




#line 3879 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomA(
      LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
GlobalFindAtomW(
      LPCWSTR lpString
    );




#line 3897 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameA(
      ATOM nAtom,
      LPSTR lpBuffer,
      int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GlobalGetAtomNameW(
      ATOM nAtom,
      LPWSTR lpBuffer,
      int nSize
    );




#line 3919 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
AddAtomA(
      LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
AddAtomW(
      LPCWSTR lpString
    );




#line 3937 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
ATOM
__stdcall
FindAtomA(
      LPCSTR lpString
    );
__declspec(dllimport)
ATOM
__stdcall
FindAtomW(
      LPCWSTR lpString
    );




#line 3955 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetAtomNameA(
      ATOM nAtom,
      LPSTR lpBuffer,
      int nSize
    );
__declspec(dllimport)
UINT
__stdcall
GetAtomNameW(
      ATOM nAtom,
      LPWSTR lpBuffer,
      int nSize
    );




#line 3977 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetProfileIntA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      INT nDefault
    );
__declspec(dllimport)
UINT
__stdcall
GetProfileIntW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      INT nDefault
    );




#line 3999 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetProfileStringA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      LPCSTR lpDefault,
      LPSTR lpReturnedString,
          DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileStringW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      LPCWSTR lpDefault,
      LPWSTR lpReturnedString,
          DWORD nSize
    );




#line 4025 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileStringW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      LPCWSTR lpString
    );




#line 4047 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionA(
      LPCSTR lpAppName,
      LPSTR lpReturnedString,
      DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetProfileSectionW(
      LPCWSTR lpAppName,
      LPWSTR lpReturnedString,
      DWORD nSize
    );




#line 4069 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionA(
      LPCSTR lpAppName,
      LPCSTR lpString
    );
__declspec(dllimport)
BOOL
__stdcall
WriteProfileSectionW(
      LPCWSTR lpAppName,
      LPCWSTR lpString
    );




#line 4089 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntA(
          LPCSTR lpAppName,
          LPCSTR lpKeyName,
          INT nDefault,
      LPCSTR lpFileName
    );
__declspec(dllimport)
UINT
__stdcall
GetPrivateProfileIntW(
          LPCWSTR lpAppName,
          LPCWSTR lpKeyName,
          INT nDefault,
      LPCWSTR lpFileName
    );




#line 4113 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"























#line 4137 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      LPCSTR lpDefault,
      LPSTR lpReturnedString,
          DWORD nSize,
      LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileStringW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      LPCWSTR lpDefault,
      LPWSTR lpReturnedString,
          DWORD nSize,
      LPCWSTR lpFileName
    );




#line 4165 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



























#line 4193 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringA(
      LPCSTR lpAppName,
      LPCSTR lpKeyName,
      LPCSTR lpString,
      LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStringW(
      LPCWSTR lpAppName,
      LPCWSTR lpKeyName,
      LPCWSTR lpString,
      LPCWSTR lpFileName
    );




#line 4217 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionA(
          LPCSTR lpAppName,
      LPSTR lpReturnedString,
          DWORD nSize,
      LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionW(
          LPCWSTR lpAppName,
      LPWSTR lpReturnedString,
          DWORD nSize,
      LPCWSTR lpFileName
    );




#line 4241 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"























#line 4265 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionA(
      LPCSTR lpAppName,
      LPCSTR lpString,
      LPCSTR lpFileName
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileSectionW(
      LPCWSTR lpAppName,
      LPCWSTR lpString,
      LPCWSTR lpFileName
    );




#line 4287 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesA(
      LPSTR lpszReturnBuffer,
          DWORD nSize,
      LPCSTR lpFileName
    );
__declspec(dllimport)
DWORD
__stdcall
GetPrivateProfileSectionNamesW(
      LPWSTR lpszReturnBuffer,
          DWORD nSize,
      LPCWSTR lpFileName
    );




#line 4310 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





















#line 4332 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructA(
          LPCSTR lpszSection,
          LPCSTR lpszKey,
      LPVOID   lpStruct,
          UINT     uSizeStruct,
      LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
GetPrivateProfileStructW(
          LPCWSTR lpszSection,
          LPCWSTR lpszKey,
      LPVOID   lpStruct,
          UINT     uSizeStruct,
      LPCWSTR szFile
    );




#line 4358 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

























#line 4384 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructA(
          LPCSTR lpszSection,
          LPCSTR lpszKey,
      LPVOID lpStruct,
          UINT     uSizeStruct,
      LPCSTR szFile
    );
__declspec(dllimport)
BOOL
__stdcall
WritePrivateProfileStructW(
          LPCWSTR lpszSection,
          LPCWSTR lpszKey,
      LPVOID lpStruct,
          UINT     uSizeStruct,
      LPCWSTR szFile
    );




#line 4410 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetTempPathA(
      DWORD nBufferLength,
      LPSTR lpBuffer
    );


#line 4421 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
UINT
__stdcall
GetTempFileNameA(
      LPCSTR lpPathName,
      LPCSTR lpPrefixString,
      UINT uUnique,
      LPSTR lpTempFileName
    );


#line 4434 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"























#line 4458 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




__declspec(dllimport)
 
UINT
__stdcall
GetSystemWow64DirectoryA(
      LPSTR lpBuffer,
      UINT uSize
    );
__declspec(dllimport)
 
UINT
__stdcall
GetSystemWow64DirectoryW(
      LPWSTR lpBuffer,
      UINT uSize
    );




#line 4483 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOLEAN
__stdcall
Wow64EnableWow64FsRedirection (
      BOOLEAN Wow64FsEnableRedirection
    );




typedef UINT (__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_A)(  LPSTR lpBuffer,   UINT uSize);
typedef UINT (__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_W)(  LPWSTR lpBuffer,   UINT uSize);





















#line 4518 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4520 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 4521 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

















#line 4539 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



















#line 4559 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryA(
      LPCSTR lpPathName
    );
__declspec(dllimport)
BOOL
__stdcall
SetDllDirectoryW(
      LPCWSTR lpPathName
    );




#line 4579 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetDllDirectoryA(
      DWORD nBufferLength,
      LPSTR lpBuffer
    );
__declspec(dllimport)
 
DWORD
__stdcall
GetDllDirectoryW(
      DWORD nBufferLength,
      LPWSTR lpBuffer
    );




#line 4601 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4603 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"






__declspec(dllimport)
BOOL
__stdcall
SetSearchPathMode (
      DWORD Flags
    );

#line 4617 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family




















#line 4641 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4643 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExA(
          LPCSTR lpTemplateDirectory,
          LPCSTR lpNewDirectory,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryExW(
          LPCWSTR lpTemplateDirectory,
          LPCWSTR lpNewDirectory,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 4669 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedA(
      LPCSTR lpTemplateDirectory,
          LPCSTR lpNewDirectory,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateDirectoryTransactedW(
      LPCWSTR lpTemplateDirectory,
          LPCWSTR lpNewDirectory,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
          HANDLE hTransaction
    );




#line 4695 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedA(
      LPCSTR lpPathName,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
RemoveDirectoryTransactedW(
      LPCWSTR lpPathName,
          HANDLE hTransaction
    );




#line 4715 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
DWORD
__stdcall
GetFullPathNameTransactedA(
                 LPCSTR lpFileName,
                 DWORD nBufferLength,
      LPSTR lpBuffer,
     LPSTR *lpFilePart,
                 HANDLE hTransaction
    );
__declspec(dllimport)
 
DWORD
__stdcall
GetFullPathNameTransactedW(
                 LPCWSTR lpFileName,
                 DWORD nBufferLength,
      LPWSTR lpBuffer,
     LPWSTR *lpFilePart,
                 HANDLE hTransaction
    );




#line 4743 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4745 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"







__declspec(dllimport)
BOOL
__stdcall
DefineDosDeviceA(
          DWORD dwFlags,
          LPCSTR lpDeviceName,
      LPCSTR lpTargetPath
    );


#line 4763 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
QueryDosDeviceA(
      LPCSTR lpDeviceName,
      LPSTR lpTargetPath,
          DWORD ucchMax
    );


#line 4775 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedA(
            LPCSTR lpFileName,
            DWORD dwDesiredAccess,
            DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            DWORD dwCreationDisposition,
            DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile,
            HANDLE hTransaction,
        PUSHORT pusMiniVersion,
      PVOID  lpExtendedParameter
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateFileTransactedW(
            LPCWSTR lpFileName,
            DWORD dwDesiredAccess,
            DWORD dwShareMode,
        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            DWORD dwCreationDisposition,
            DWORD dwFlagsAndAttributes,
        HANDLE hTemplateFile,
            HANDLE hTransaction,
        PUSHORT pusMiniVersion,
      PVOID  lpExtendedParameter
    );




#line 4815 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4817 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




__declspec(dllimport)
HANDLE
__stdcall
ReOpenFile(
      HANDLE  hOriginalFile,
      DWORD   dwDesiredAccess,
      DWORD   dwShareMode,
      DWORD   dwFlagsAndAttributes
    );

#line 4832 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedA(
          LPCSTR lpFileName,
          DWORD dwFileAttributes,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
SetFileAttributesTransactedW(
          LPCWSTR lpFileName,
          DWORD dwFileAttributes,
          HANDLE hTransaction
    );




#line 4857 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedA(
       LPCSTR lpFileName,
       GET_FILEEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFileInformation,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
GetFileAttributesTransactedW(
       LPCWSTR lpFileName,
       GET_FILEEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFileInformation,
          HANDLE hTransaction
    );




#line 4881 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedA(
           LPCSTR lpFileName,
      LPDWORD  lpFileSizeHigh,
           HANDLE hTransaction
    );
__declspec(dllimport)
DWORD
__stdcall
GetCompressedFileSizeTransactedW(
           LPCWSTR lpFileName,
      LPDWORD  lpFileSizeHigh,
           HANDLE hTransaction
    );




#line 4903 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedA(
          LPCSTR lpFileName,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
DeleteFileTransactedW(
          LPCWSTR lpFileName,
          HANDLE hTransaction
    );




#line 4923 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4925 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4927 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


















#line 4949 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4951 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3A(
           LPCSTR lpName,
      LPSTR lpOemName,
           DWORD OemNameSize,
      PBOOL pbNameContainsSpaces ,
          PBOOL pbNameLegal
    );
__declspec(dllimport)
BOOL
__stdcall
CheckNameLegalDOS8Dot3W(
           LPCWSTR lpName,
      LPSTR lpOemName,
           DWORD OemNameSize,
      PBOOL pbNameContainsSpaces ,
          PBOOL pbNameLegal
    );




#line 4983 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4985 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 4987 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family




__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedA(
            LPCSTR lpFileName,
            FINDEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFindFileData,
            FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
            DWORD dwAdditionalFlags,
            HANDLE hTransaction
    );
__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileTransactedW(
            LPCWSTR lpFileName,
            FINDEX_INFO_LEVELS fInfoLevelId,
      LPVOID lpFindFileData,
            FINDEX_SEARCH_OPS fSearchOp,
      LPVOID lpSearchFilter,
            DWORD dwAdditionalFlags,
            HANDLE hTransaction
    );




#line 5025 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5027 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5029 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#line 5032 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
CopyFileA(
      LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName,
      BOOL bFailIfExists
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileW(
      LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName,
      BOOL bFailIfExists
    );




#line 5058 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





















#line 5080 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5082 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family


typedef
DWORD
(__stdcall *LPPROGRESS_ROUTINE)(
          LARGE_INTEGER TotalFileSize,
          LARGE_INTEGER TotalBytesTransferred,
          LARGE_INTEGER StreamSize,
          LARGE_INTEGER StreamBytesTransferred,
          DWORD dwStreamNumber,
          DWORD dwCallbackReason,
          HANDLE hSourceFile,
          HANDLE hDestinationFile,
      LPVOID lpData
    );

__declspec(dllimport)
BOOL
__stdcall
CopyFileExA(
             LPCSTR lpExistingFileName,
             LPCSTR lpNewFileName,
         LPPROGRESS_ROUTINE lpProgressRoutine,
         LPVOID lpData,
    
      LPBOOL pbCancel,
             DWORD dwCopyFlags
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileExW(
             LPCWSTR lpExistingFileName,
             LPCWSTR lpNewFileName,
         LPPROGRESS_ROUTINE lpProgressRoutine,
         LPVOID lpData,
    
      LPBOOL pbCancel,
             DWORD dwCopyFlags
    );




#line 5132 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedA(
          LPCSTR lpExistingFileName,
          LPCSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
      LPBOOL pbCancel,
          DWORD dwCopyFlags,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CopyFileTransactedW(
          LPCWSTR lpExistingFileName,
          LPCWSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
      LPBOOL pbCancel,
          DWORD dwCopyFlags,
          HANDLE hTransaction
    );




#line 5164 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5166 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family








typedef enum _COPYFILE2_MESSAGE_TYPE {
     COPYFILE2_CALLBACK_NONE = 0,
     COPYFILE2_CALLBACK_CHUNK_STARTED,
     COPYFILE2_CALLBACK_CHUNK_FINISHED,
     COPYFILE2_CALLBACK_STREAM_STARTED,
     COPYFILE2_CALLBACK_STREAM_FINISHED,
     COPYFILE2_CALLBACK_POLL_CONTINUE,
     COPYFILE2_CALLBACK_ERROR,
     COPYFILE2_CALLBACK_MAX,
} COPYFILE2_MESSAGE_TYPE;

typedef enum _COPYFILE2_MESSAGE_ACTION {
    COPYFILE2_PROGRESS_CONTINUE = 0,
    COPYFILE2_PROGRESS_CANCEL,
    COPYFILE2_PROGRESS_STOP,
    COPYFILE2_PROGRESS_QUIET,
    COPYFILE2_PROGRESS_PAUSE,
} COPYFILE2_MESSAGE_ACTION;

typedef enum _COPYFILE2_COPY_PHASE {
    COPYFILE2_PHASE_NONE = 0,
    COPYFILE2_PHASE_PREPARE_SOURCE,
    COPYFILE2_PHASE_PREPARE_DEST,
    COPYFILE2_PHASE_READ_SOURCE,
    COPYFILE2_PHASE_WRITE_DESTINATION,
    COPYFILE2_PHASE_SERVER_COPY,
    COPYFILE2_PHASE_NAMEGRAFT_COPY,
    
    COPYFILE2_PHASE_MAX,
} COPYFILE2_COPY_PHASE;



typedef struct COPYFILE2_MESSAGE {

    COPYFILE2_MESSAGE_TYPE  Type;
    DWORD                   dwPadding;

    union {

        struct {
            DWORD           dwStreamNumber; 
            DWORD           dwReserved;
            HANDLE           hSourceFile; 
            HANDLE           hDestinationFile; 
            ULARGE_INTEGER  uliChunkNumber; 
            ULARGE_INTEGER  uliChunkSize;  
            ULARGE_INTEGER  uliStreamSize; 
            ULARGE_INTEGER  uliTotalFileSize; 
        } ChunkStarted;

        struct {
            DWORD           dwStreamNumber; 
            DWORD           dwFlags;
            HANDLE           hSourceFile; 
            HANDLE           hDestinationFile; 
            ULARGE_INTEGER  uliChunkNumber; 
            ULARGE_INTEGER  uliChunkSize;  
            ULARGE_INTEGER  uliStreamSize; 
            ULARGE_INTEGER  uliStreamBytesTransferred; 
            ULARGE_INTEGER  uliTotalFileSize; 
            ULARGE_INTEGER  uliTotalBytesTransferred; 
        } ChunkFinished;

        struct {
            DWORD           dwStreamNumber;
            DWORD           dwReserved;
            HANDLE           hSourceFile; 
            HANDLE           hDestinationFile; 
            ULARGE_INTEGER  uliStreamSize; 
            ULARGE_INTEGER  uliTotalFileSize; 
        } StreamStarted;

        struct {
            DWORD           dwStreamNumber;
            DWORD           dwReserved;
            HANDLE           hSourceFile; 
            HANDLE           hDestinationFile; 
            ULARGE_INTEGER  uliStreamSize;
            ULARGE_INTEGER  uliStreamBytesTransferred;
            ULARGE_INTEGER  uliTotalFileSize;
            ULARGE_INTEGER  uliTotalBytesTransferred;
        } StreamFinished;

        struct {
            DWORD           dwReserved;
        } PollContinue;

        struct {
            COPYFILE2_COPY_PHASE    CopyPhase;
            DWORD                   dwStreamNumber;
            HRESULT                 hrFailure;
            DWORD                   dwReserved;
            ULARGE_INTEGER          uliChunkNumber;
            ULARGE_INTEGER          uliStreamSize;
            ULARGE_INTEGER          uliStreamBytesTransferred;
            ULARGE_INTEGER          uliTotalFileSize;
            ULARGE_INTEGER          uliTotalBytesTransferred;
        } Error;

    } Info;

} COPYFILE2_MESSAGE;

typedef
COPYFILE2_MESSAGE_ACTION (__stdcall *PCOPYFILE2_PROGRESS_ROUTINE)(
         const COPYFILE2_MESSAGE     *pMessage,
     PVOID                       pvCallbackContext
);

typedef struct COPYFILE2_EXTENDED_PARAMETERS {
  DWORD                         dwSize;
  DWORD                         dwCopyFlags;
  BOOL                          *pfCancel;
  PCOPYFILE2_PROGRESS_ROUTINE   pProgressRoutine;
  PVOID                         pvCallbackContext;
} COPYFILE2_EXTENDED_PARAMETERS;

__declspec(dllimport)
HRESULT
__stdcall
CopyFile2(
         PCWSTR                          pwszExistingFileName,
         PCWSTR                          pwszNewFileName,
     COPYFILE2_EXTENDED_PARAMETERS   *pExtendedParameters
);

#line 5307 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5309 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#line 5312 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
MoveFileA(
      LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileW(
      LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName
    );




#line 5335 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



















#line 5355 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5357 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
BOOL
__stdcall
MoveFileExA(
          LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName,
          DWORD    dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileExW(
          LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName,
          DWORD    dwFlags
    );




#line 5383 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5385 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressA(
          LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
          DWORD dwFlags
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileWithProgressW(
          LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
          DWORD dwFlags
    );




#line 5416 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 5417 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedA(
          LPCSTR lpExistingFileName,
      LPCSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
          DWORD dwFlags,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
MoveFileTransactedW(
          LPCWSTR lpExistingFileName,
      LPCWSTR lpNewFileName,
      LPPROGRESS_ROUTINE lpProgressRoutine,
      LPVOID lpData,
          DWORD dwFlags,
          HANDLE hTransaction
    );




#line 5446 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 5447 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5449 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family









#line 5462 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5464 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family





__declspec(dllimport)
BOOL
__stdcall
ReplaceFileA(
            LPCSTR lpReplacedFileName,
            LPCSTR lpReplacementFileName,
        LPCSTR lpBackupFileName,
            DWORD    dwReplaceFlags,
      LPVOID   lpExclude,
      LPVOID  lpReserved
    );
__declspec(dllimport)
BOOL
__stdcall
ReplaceFileW(
            LPCWSTR lpReplacedFileName,
            LPCWSTR lpReplacementFileName,
        LPCWSTR lpBackupFileName,
            DWORD    dwReplaceFlags,
      LPVOID   lpExclude,
      LPVOID  lpReserved
    );




#line 5499 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 5500 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"







__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkA(
            LPCSTR lpFileName,
            LPCSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkW(
            LPCWSTR lpFileName,
            LPCWSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 5528 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5530 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"






__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedA(
            LPCSTR lpFileName,
            LPCSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            HANDLE hTransaction
    );
__declspec(dllimport)
BOOL
__stdcall
CreateHardLinkTransactedW(
            LPCWSTR lpFileName,
            LPCWSTR lpExistingFileName,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
            HANDLE hTransaction
    );




#line 5559 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 5561 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"








typedef enum _STREAM_INFO_LEVELS {

    FindStreamInfoStandard,
    FindStreamInfoMaxInfoLevel

} STREAM_INFO_LEVELS;

typedef struct _WIN32_FIND_STREAM_DATA {

    LARGE_INTEGER StreamSize;
    WCHAR cStreamName[ 260 + 36 ];

} WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;

__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamW(
            LPCWSTR lpFileName,
            STREAM_INFO_LEVELS InfoLevel,
      LPVOID lpFindStreamData,
      DWORD dwFlags
    );


__declspec(dllimport)
HANDLE
__stdcall
FindFirstStreamTransactedW (
            LPCWSTR lpFileName,
            STREAM_INFO_LEVELS InfoLevel,
      LPVOID lpFindStreamData,
      DWORD dwFlags,
            HANDLE hTransaction
    );
#line 5605 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextStreamW(
       HANDLE hFindStream,
      LPVOID lpFindStreamData
    );
#line 5614 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameW (
         LPCWSTR lpFileName,
         DWORD dwFlags,
      LPDWORD StringLength,
      PWSTR LinkName
    );

__declspec(dllimport)
BOOL
__stdcall
FindNextFileNameW (
         HANDLE hFindStream,
      LPDWORD StringLength,
      PWSTR LinkName
    );

__declspec(dllimport)
HANDLE
__stdcall
FindFirstFileNameTransactedW (
          LPCWSTR lpFileName,
          DWORD dwFlags,
       LPDWORD StringLength,
      PWSTR LinkName,
      HANDLE hTransaction
    );

#line 5648 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
CreateNamedPipeA(
          LPCSTR lpName,
          DWORD dwOpenMode,
          DWORD dwPipeMode,
          DWORD nMaxInstances,
          DWORD nOutBufferSize,
          DWORD nInBufferSize,
          DWORD nDefaultTimeOut,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );


#line 5665 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateA(
           HANDLE hNamedPipe,
      LPDWORD lpState,
      LPDWORD lpCurInstances,
      LPDWORD lpMaxCollectionCount,
      LPDWORD lpCollectDataTimeout,
      LPSTR lpUserName,
           DWORD nMaxUserNameSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeHandleStateW(
           HANDLE hNamedPipe,
      LPDWORD lpState,
      LPDWORD lpCurInstances,
      LPDWORD lpMaxCollectionCount,
      LPDWORD lpCollectDataTimeout,
      LPWSTR lpUserName,
           DWORD nMaxUserNameSize
    );




#line 5695 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeA(
       LPCSTR lpNamedPipeName,
      LPVOID lpInBuffer,
       DWORD nInBufferSize,
      LPVOID lpOutBuffer,
       DWORD nOutBufferSize,
      LPDWORD lpBytesRead,
       DWORD nTimeOut
    );
__declspec(dllimport)
BOOL
__stdcall
CallNamedPipeW(
       LPCWSTR lpNamedPipeName,
      LPVOID lpInBuffer,
       DWORD nInBufferSize,
      LPVOID lpOutBuffer,
       DWORD nOutBufferSize,
      LPDWORD lpBytesRead,
       DWORD nTimeOut
    );




#line 5725 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
WaitNamedPipeA(
      LPCSTR lpNamedPipeName,
      DWORD nTimeOut
    );


#line 5736 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientComputerNameA(
      HANDLE Pipe,
       LPSTR ClientComputerName,
      ULONG ClientComputerNameLength
    );



#line 5752 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientProcessId(
      HANDLE Pipe,
      PULONG ClientProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeClientSessionId(
      HANDLE Pipe,
      PULONG ClientSessionId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerProcessId(
      HANDLE Pipe,
      PULONG ServerProcessId
    );

__declspec(dllimport)
BOOL
__stdcall
GetNamedPipeServerSessionId(
      HANDLE Pipe,
      PULONG ServerSessionId
    );

#line 5786 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelA(
      LPCSTR lpRootPathName,
      LPCSTR lpVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeLabelW(
      LPCWSTR lpRootPathName,
      LPCWSTR lpVolumeName
    );




#line 5806 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
void
__stdcall
SetFileApisToOEM( void );

__declspec(dllimport)
void
__stdcall
SetFileApisToANSI( void );

__declspec(dllimport)
BOOL
__stdcall
AreFileApisANSI( void );

__declspec(dllimport)
BOOL
__stdcall
GetVolumeInformationA(
       LPCSTR lpRootPathName,
      LPSTR lpVolumeNameBuffer,
           DWORD nVolumeNameSize,
      LPDWORD lpVolumeSerialNumber,
      LPDWORD lpMaximumComponentLength,
      LPDWORD lpFileSystemFlags,
      LPSTR lpFileSystemNameBuffer,
           DWORD nFileSystemNameSize
    );



#line 5839 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
SetFileBandwidthReservation(
       HANDLE  hFile,
       DWORD   nPeriodMilliseconds,
       DWORD   nBytesPerPeriod,
       BOOL    bDiscardable,
      LPDWORD lpTransferSize,
      LPDWORD lpNumOutstandingRequests
    );

__declspec(dllimport)
BOOL
__stdcall
GetFileBandwidthReservation(
       HANDLE  hFile,
      LPDWORD lpPeriodMilliseconds,
      LPDWORD lpBytesPerPeriod,
      LPBOOL  pDiscardable,
      LPDWORD lpTransferSize,
      LPDWORD lpNumOutstandingRequests
    );

#line 5867 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





__declspec(dllimport)
BOOL
__stdcall
ClearEventLogA (
          HANDLE hEventLog,
      LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
ClearEventLogW (
          HANDLE hEventLog,
      LPCWSTR lpBackupFileName
    );




#line 5891 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BackupEventLogA (
      HANDLE hEventLog,
      LPCSTR lpBackupFileName
    );
__declspec(dllimport)
BOOL
__stdcall
BackupEventLogW (
      HANDLE hEventLog,
      LPCWSTR lpBackupFileName
    );




#line 5911 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CloseEventLog (
      HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
DeregisterEventSource (
      HANDLE hEventLog
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyChangeEventLog(
      HANDLE  hEventLog,
      HANDLE  hEvent
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfEventLogRecords (
       HANDLE hEventLog,
      PDWORD NumberOfRecords
    );

__declspec(dllimport)
BOOL
__stdcall
GetOldestEventLogRecord (
       HANDLE hEventLog,
      PDWORD OldestRecord
    );

__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogA (
      LPCSTR lpUNCServerName,
          LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenEventLogW (
      LPCWSTR lpUNCServerName,
          LPCWSTR lpSourceName
    );




#line 5969 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceA (
      LPCSTR lpUNCServerName,
          LPCSTR lpSourceName
    );
__declspec(dllimport)
HANDLE
__stdcall
RegisterEventSourceW (
      LPCWSTR lpUNCServerName,
          LPCWSTR lpSourceName
    );




#line 5989 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogA (
      LPCSTR lpUNCServerName,
          LPCSTR lpFileName
    );
__declspec(dllimport)
HANDLE
__stdcall
OpenBackupEventLogW (
      LPCWSTR lpUNCServerName,
          LPCWSTR lpFileName
    );




#line 6009 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ReadEventLogA (
       HANDLE     hEventLog,
       DWORD      dwReadFlags,
       DWORD      dwRecordOffset,
      LPVOID     lpBuffer,
       DWORD      nNumberOfBytesToRead,
      DWORD      *pnBytesRead,
      DWORD      *pnMinNumberOfBytesNeeded
    );
__declspec(dllimport)
BOOL
__stdcall
ReadEventLogW (
       HANDLE     hEventLog,
       DWORD      dwReadFlags,
       DWORD      dwRecordOffset,
      LPVOID     lpBuffer,
       DWORD      nNumberOfBytesToRead,
      DWORD      *pnBytesRead,
      DWORD      *pnMinNumberOfBytesNeeded
    );




#line 6039 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ReportEventA (
          HANDLE     hEventLog,
          WORD       wType,
          WORD       wCategory,
          DWORD      dwEventID,
      PSID       lpUserSid,
          WORD       wNumStrings,
          DWORD      dwDataSize,
      LPCSTR *lpStrings,
      LPVOID lpRawData
    );
__declspec(dllimport)
BOOL
__stdcall
ReportEventW (
          HANDLE     hEventLog,
          WORD       wType,
          WORD       wCategory,
          DWORD      dwEventID,
      PSID       lpUserSid,
          WORD       wNumStrings,
          DWORD      dwDataSize,
      LPCWSTR *lpStrings,
      LPVOID lpRawData
    );




#line 6073 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




typedef struct _EVENTLOG_FULL_INFORMATION
{
    DWORD    dwFull;
}
EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;

__declspec(dllimport)
BOOL
__stdcall
GetEventLogInformation (
       HANDLE     hEventLog,
       DWORD      dwInfoLevel,
      LPVOID lpBuffer,
       DWORD      cbBufSize,
      LPDWORD    pcbBytesNeeded
    );








typedef ULONG OPERATION_ID;





typedef struct _OPERATION_START_PARAMETERS {
    ULONG Version;
    OPERATION_ID OperationId;
    ULONG Flags;
} OPERATION_START_PARAMETERS, *POPERATION_START_PARAMETERS;







typedef struct _OPERATION_END_PARAMETERS {
    ULONG Version;
    OPERATION_ID OperationId;
    ULONG Flags;
} OPERATION_END_PARAMETERS, *POPERATION_END_PARAMETERS;



__declspec(dllimport)
BOOL
__stdcall
OperationStart (
      OPERATION_START_PARAMETERS* OperationStartParams
    );

__declspec(dllimport)
BOOL
__stdcall
OperationEnd (
      OPERATION_END_PARAMETERS* OperationEndParams
    );

#line 6142 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"







__declspec(dllimport)
BOOL
__stdcall
AccessCheckAndAuditAlarmA (
          LPCSTR SubsystemName,
      LPVOID HandleId,
          LPSTR ObjectTypeName,
      LPSTR ObjectName,
          PSECURITY_DESCRIPTOR SecurityDescriptor,
          DWORD DesiredAccess,
          PGENERIC_MAPPING GenericMapping,
          BOOL ObjectCreation,
         LPDWORD GrantedAccess,
         LPBOOL AccessStatus,
         LPBOOL pfGenerateOnClose
    );


#line 6168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeAndAuditAlarmA (
          LPCSTR SubsystemName,
          LPVOID HandleId,
          LPCSTR ObjectTypeName,
      LPCSTR ObjectName,
          PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
          DWORD DesiredAccess,
          AUDIT_EVENT_TYPE AuditType,
          DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
          DWORD ObjectTypeListLength,
          PGENERIC_MAPPING GenericMapping,
          BOOL ObjectCreation,
         LPDWORD GrantedAccess,
         LPBOOL AccessStatus,
         LPBOOL pfGenerateOnClose
    );


#line 6195 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmA (
          LPCSTR SubsystemName,
          LPVOID HandleId,
          LPCSTR ObjectTypeName,
      LPCSTR ObjectName,
          PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
          DWORD DesiredAccess,
          AUDIT_EVENT_TYPE AuditType,
          DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
          DWORD ObjectTypeListLength,
          PGENERIC_MAPPING GenericMapping,
          BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPDWORD AccessStatusList,
         LPBOOL pfGenerateOnClose
    );


#line 6220 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AccessCheckByTypeResultListAndAuditAlarmByHandleA (
          LPCSTR SubsystemName,
          LPVOID HandleId,
          HANDLE ClientToken,
          LPCSTR ObjectTypeName,
      LPCSTR ObjectName,
          PSECURITY_DESCRIPTOR SecurityDescriptor,
      PSID PrincipalSelfSid,
          DWORD DesiredAccess,
          AUDIT_EVENT_TYPE AuditType,
          DWORD Flags,
      POBJECT_TYPE_LIST ObjectTypeList,
          DWORD ObjectTypeListLength,
          PGENERIC_MAPPING GenericMapping,
          BOOL ObjectCreation,
            LPDWORD GrantedAccess,
            LPDWORD AccessStatusList,
         LPBOOL pfGenerateOnClose
    );


#line 6246 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 6247 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectOpenAuditAlarmA (
          LPCSTR SubsystemName,
          LPVOID HandleId,
          LPSTR ObjectTypeName,
      LPSTR ObjectName,
          PSECURITY_DESCRIPTOR pSecurityDescriptor,
          HANDLE ClientToken,
          DWORD DesiredAccess,
          DWORD GrantedAccess,
      PPRIVILEGE_SET Privileges,
          BOOL ObjectCreation,
          BOOL AccessGranted,
         LPBOOL GenerateOnClose
    );


#line 6268 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectPrivilegeAuditAlarmA (
      LPCSTR SubsystemName,
      LPVOID HandleId,
      HANDLE ClientToken,
      DWORD DesiredAccess,
      PPRIVILEGE_SET Privileges,
      BOOL AccessGranted
    );


#line 6283 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectCloseAuditAlarmA (
      LPCSTR SubsystemName,
      LPVOID HandleId,
      BOOL GenerateOnClose
    );


#line 6295 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
ObjectDeleteAuditAlarmA (
      LPCSTR SubsystemName,
      LPVOID HandleId,
      BOOL GenerateOnClose
    );


#line 6307 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
PrivilegedServiceAuditAlarmA (
      LPCSTR SubsystemName,
      LPCSTR ServiceName,
      HANDLE ClientToken,
      PPRIVILEGE_SET Privileges,
      BOOL AccessGranted
    );


#line 6321 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
AddConditionalAce (
      PACL pAcl,
         DWORD dwAceRevision,
         DWORD AceFlags,
         UCHAR AceType,
         DWORD AccessMask,
         PSID pSid,
        PWCHAR ConditionStr,
      DWORD *ReturnLength
    );
#line 6337 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetFileSecurityA (
      LPCSTR lpFileName,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


#line 6349 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetFileSecurityA (
       LPCSTR lpFileName,
       SECURITY_INFORMATION RequestedInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
       DWORD nLength,
      LPDWORD lpnLengthNeeded
    );


#line 6363 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
ReadDirectoryChangesW(
             HANDLE hDirectory,
      LPVOID lpBuffer,
             DWORD nBufferLength,
             BOOL bWatchSubtree,
             DWORD dwNotifyFilter,
        LPDWORD lpBytesReturned,
      LPOVERLAPPED lpOverlapped,
         LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine
    );
#line 6379 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
  
LPVOID
__stdcall
MapViewOfFileExNuma(
          HANDLE hFileMappingObject,
          DWORD dwDesiredAccess,
          DWORD dwFileOffsetHigh,
          DWORD dwFileOffsetLow,
          SIZE_T dwNumberOfBytesToMap,
      LPVOID lpBaseAddress,
          DWORD nndPreferred
    );

#line 6397 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
IsBadReadPtr(
      const void *lp,
          UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadWritePtr(
      LPVOID lp,
          UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeReadPtr(
      const void *lp,
          UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadHugeWritePtr(
      LPVOID lp,
          UINT_PTR ucb
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadCodePtr(
      FARPROC lpfn
    );

__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrA(
      LPCSTR lpsz,
          UINT_PTR ucchMax
    );
__declspec(dllimport)
BOOL
__stdcall
IsBadStringPtrW(
      LPCWSTR lpsz,
          UINT_PTR ucchMax
    );




#line 6456 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
  BOOL
__stdcall
LookupAccountSidA(
      LPCSTR lpSystemName,
      PSID Sid,
      LPSTR Name,
       LPDWORD cchName,
      LPSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
      PSID_NAME_USE peUse
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupAccountSidW(
      LPCWSTR lpSystemName,
      PSID Sid,
      LPWSTR Name,
       LPDWORD cchName,
      LPWSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
      PSID_NAME_USE peUse
    );




#line 6486 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
  BOOL
__stdcall
LookupAccountNameA(
      LPCSTR lpSystemName,
          LPCSTR lpAccountName,
      PSID Sid,
       LPDWORD cbSid,
      LPSTR ReferencedDomainName,
       LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupAccountNameW(
      LPCWSTR lpSystemName,
          LPCWSTR lpAccountName,
      PSID Sid,
       LPDWORD cbSid,
      LPWSTR ReferencedDomainName,
       LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );




#line 6516 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
  BOOL
__stdcall
LookupAccountNameLocalA(
          LPCSTR lpAccountName,
      PSID Sid,
       LPDWORD cbSid,
      LPSTR ReferencedDomainName,
       LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupAccountNameLocalW(
          LPCWSTR lpAccountName,
      PSID Sid,
       LPDWORD cbSid,
      LPWSTR ReferencedDomainName,
       LPDWORD cchReferencedDomainName,
         PSID_NAME_USE peUse
    );




#line 6546 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
  BOOL
__stdcall
LookupAccountSidLocalA(
      PSID Sid,
      LPSTR Name,
       LPDWORD cchName,
      LPSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
      PSID_NAME_USE peUse
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupAccountSidLocalW(
      PSID Sid,
      LPWSTR Name,
       LPDWORD cchName,
      LPWSTR ReferencedDomainName,
      LPDWORD cchReferencedDomainName,
      PSID_NAME_USE peUse
    );




#line 6574 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"























#line 6598 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueA(
      LPCSTR lpSystemName,
          LPCSTR lpName,
         PLUID   lpLuid
    );
__declspec(dllimport)
BOOL
__stdcall
LookupPrivilegeValueW(
      LPCWSTR lpSystemName,
          LPCWSTR lpName,
         PLUID   lpLuid
    );




#line 6620 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
  BOOL
__stdcall
LookupPrivilegeNameA(
      LPCSTR lpSystemName,
          PLUID   lpLuid,
      LPSTR lpName,
       LPDWORD cchName
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupPrivilegeNameW(
      LPCWSTR lpSystemName,
          PLUID   lpLuid,
      LPWSTR lpName,
       LPDWORD cchName
    );




#line 6644 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
  BOOL
__stdcall
LookupPrivilegeDisplayNameA(
      LPCSTR lpSystemName,
          LPCSTR lpName,
      LPSTR lpDisplayName,
       LPDWORD cchDisplayName,
         LPDWORD lpLanguageId
    );
__declspec(dllimport)
  BOOL
__stdcall
LookupPrivilegeDisplayNameW(
      LPCWSTR lpSystemName,
          LPCWSTR lpName,
      LPWSTR lpDisplayName,
       LPDWORD cchDisplayName,
         LPDWORD lpLanguageId
    );




#line 6670 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBA(
       LPCSTR lpDef,
      LPDCB lpDCB
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBW(
       LPCWSTR lpDef,
      LPDCB lpDCB
    );




#line 6690 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsA(
       LPCSTR lpDef,
      LPDCB lpDCB,
      LPCOMMTIMEOUTS lpCommTimeouts
    );
__declspec(dllimport)
BOOL
__stdcall
BuildCommDCBAndTimeoutsW(
       LPCWSTR lpDef,
      LPDCB lpDCB,
      LPCOMMTIMEOUTS lpCommTimeouts
    );




#line 6712 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogA(
          LPCSTR lpszName,
      HWND hWnd,
       LPCOMMCONFIG lpCC
    );
__declspec(dllimport)
BOOL
__stdcall
CommConfigDialogW(
          LPCWSTR lpszName,
      HWND hWnd,
       LPCOMMCONFIG lpCC
    );




#line 6734 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigA(
         LPCSTR lpszName,
      LPCOMMCONFIG lpCC,
      LPDWORD lpdwSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetDefaultCommConfigW(
         LPCWSTR lpszName,
      LPCOMMCONFIG lpCC,
      LPDWORD lpdwSize
    );




#line 6756 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigA(
      LPCSTR lpszName,
      LPCOMMCONFIG lpCC,
      DWORD dwSize
    );
__declspec(dllimport)
BOOL
__stdcall
SetDefaultCommConfigW(
      LPCWSTR lpszName,
      LPCOMMCONFIG lpCC,
      DWORD dwSize
    );




#line 6778 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





#line 6784 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
BOOL
__stdcall
GetComputerNameA (
      LPSTR lpBuffer,
      LPDWORD nSize
    );
__declspec(dllimport)
 
BOOL
__stdcall
GetComputerNameW (
      LPWSTR lpBuffer,
      LPDWORD nSize
    );




#line 6806 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
SetComputerNameA (
      LPCSTR lpComputerName
    );
__declspec(dllimport)
BOOL
__stdcall
SetComputerNameW (
      LPCWSTR lpComputerName
    );




#line 6824 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




__declspec(dllimport)
BOOL
__stdcall
SetComputerNameExA (
      COMPUTER_NAME_FORMAT NameType,
      LPCSTR lpBuffer
    );


#line 6838 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


__declspec(dllimport)
 
BOOL
__stdcall
DnsHostnameToComputerNameA (
         LPCSTR Hostname,
      LPSTR ComputerName,
      LPDWORD nSize
    );
__declspec(dllimport)
 
BOOL
__stdcall
DnsHostnameToComputerNameW (
         LPCWSTR Hostname,
      LPWSTR ComputerName,
      LPDWORD nSize
    );




#line 6863 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 6865 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetUserNameA (
      LPSTR lpBuffer,
      LPDWORD pcbBuffer
    );
__declspec(dllimport)
BOOL
__stdcall
GetUserNameW (
      LPWSTR lpBuffer,
      LPDWORD pcbBuffer
    );




#line 6885 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"













#line 6899 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





#line 6905 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


#line 6908 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


#line 6911 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
LogonUserA (
             LPCSTR lpszUsername,
         LPCSTR lpszDomain,
         LPCSTR lpszPassword,
             DWORD dwLogonType,
             DWORD dwLogonProvider,
     PHANDLE phToken
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserW (
             LPCWSTR lpszUsername,
         LPCWSTR lpszDomain,
         LPCWSTR lpszPassword,
             DWORD dwLogonType,
             DWORD dwLogonProvider,
     PHANDLE phToken
    );




#line 6941 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
LogonUserExA (
                 LPCSTR lpszUsername,
             LPCSTR lpszDomain,
             LPCSTR lpszPassword,
                 DWORD dwLogonType,
                 DWORD dwLogonProvider,
     PHANDLE phToken,
     PSID  *ppLogonSid,
     PVOID *ppProfileBuffer,
            LPDWORD pdwProfileLength,
            PQUOTA_LIMITS pQuotaLimits
    );
__declspec(dllimport)
BOOL
__stdcall
LogonUserExW (
                 LPCWSTR lpszUsername,
             LPCWSTR lpszDomain,
             LPCWSTR lpszPassword,
                 DWORD dwLogonType,
                 DWORD dwLogonProvider,
     PHANDLE phToken,
     PSID  *ppLogonSid,
     PVOID *ppProfileBuffer,
            LPDWORD pdwProfileLength,
            PQUOTA_LIMITS pQuotaLimits
    );




#line 6977 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





#line 6983 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
CreateProcessAsUserA (
         HANDLE hToken,
         LPCSTR lpApplicationName,
      LPSTR lpCommandLine,
         LPSECURITY_ATTRIBUTES lpProcessAttributes,
         LPSECURITY_ATTRIBUTES lpThreadAttributes,
             BOOL bInheritHandles,
             DWORD dwCreationFlags,
         LPVOID lpEnvironment,
         LPCSTR lpCurrentDirectory,
             LPSTARTUPINFOA lpStartupInfo,
            LPPROCESS_INFORMATION lpProcessInformation
    );


#line 7003 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"











__declspec(dllimport)
  BOOL
__stdcall
CreateProcessWithLogonW(
             LPCWSTR lpUsername,
         LPCWSTR lpDomain,
             LPCWSTR lpPassword,
             DWORD dwLogonFlags,
         LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
             DWORD dwCreationFlags,
         LPVOID lpEnvironment,
         LPCWSTR lpCurrentDirectory,
             LPSTARTUPINFOW lpStartupInfo,
            LPPROCESS_INFORMATION lpProcessInformation
      );

__declspec(dllimport)
  BOOL
__stdcall
CreateProcessWithTokenW(
             HANDLE hToken,
             DWORD dwLogonFlags,
         LPCWSTR lpApplicationName,
      LPWSTR lpCommandLine,
             DWORD dwCreationFlags,
         LPVOID lpEnvironment,
         LPCWSTR lpCurrentDirectory,
             LPSTARTUPINFOW lpStartupInfo,
            LPPROCESS_INFORMATION lpProcessInformation
      );

#line 7047 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
IsTokenUntrusted(
      HANDLE TokenHandle
    );







__declspec(dllimport)
BOOL
__stdcall
RegisterWaitForSingleObject(
     PHANDLE phNewWaitObject,
             HANDLE hObject,
             WAITORTIMERCALLBACK Callback,
         PVOID Context,
             ULONG dwMilliseconds,
             ULONG dwFlags
    );

__declspec(dllimport)
 
BOOL
__stdcall
UnregisterWait(
      HANDLE WaitHandle
    );

__declspec(dllimport)
BOOL
__stdcall
BindIoCompletionCallback (
      HANDLE FileHandle,
      LPOVERLAPPED_COMPLETION_ROUTINE Function,
      ULONG Flags
    );

__declspec(dllimport)
HANDLE
__stdcall
SetTimerQueueTimer(
      HANDLE TimerQueue,
          WAITORTIMERCALLBACK Callback,
      PVOID Parameter,
          DWORD DueTime,
          DWORD Period,
          BOOL PreferIo
    );

__declspec(dllimport)
 
BOOL
__stdcall
CancelTimerQueueTimer(
      HANDLE TimerQueue,
          HANDLE Timer
    );

__declspec(dllimport)
 
BOOL
__stdcall
DeleteTimerQueue(
      HANDLE TimerQueue
    );





__forceinline
void
InitializeThreadpoolEnvironment(
      PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpInitializeCallbackEnviron(pcbe);
}

__forceinline
void
SetThreadpoolCallbackPool(
      PTP_CALLBACK_ENVIRON pcbe,
         PTP_POOL             ptpp
    )
{
    TpSetCallbackThreadpool(pcbe, ptpp);
}

__forceinline
void
SetThreadpoolCallbackCleanupGroup(
       PTP_CALLBACK_ENVIRON              pcbe,
          PTP_CLEANUP_GROUP                 ptpcg,
      PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng
    )
{
    TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
}

__forceinline
void
SetThreadpoolCallbackRunsLong(
      PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackLongFunction(pcbe);
}

__forceinline
void
SetThreadpoolCallbackLibrary(
      PTP_CALLBACK_ENVIRON pcbe,
         PVOID                mod
    )
{
    TpSetCallbackRaceWithDll(pcbe, mod);
}



__forceinline
void
SetThreadpoolCallbackPriority(
      PTP_CALLBACK_ENVIRON pcbe,
         TP_CALLBACK_PRIORITY Priority
    )
{
    TpSetCallbackPriority(pcbe, Priority);
}

#line 7185 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__forceinline
void
SetThreadpoolCallbackPersistent(
      PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpSetCallbackPersistent(pcbe);
}

__forceinline
void
DestroyThreadpoolEnvironment(
      PTP_CALLBACK_ENVIRON pcbe
    )
{
    TpDestroyCallbackEnviron(pcbe);
}

#line 7205 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





__declspec(dllimport)
 
HANDLE
__stdcall
CreatePrivateNamespaceA(
      LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
          LPVOID lpBoundaryDescriptor,
          LPCSTR lpAliasPrefix
    );





#line 7225 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenPrivateNamespaceA(
          LPVOID lpBoundaryDescriptor,
          LPCSTR lpAliasPrefix
    );





#line 7240 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"






__declspec(dllimport)
 
HANDLE
__stdcall
CreateBoundaryDescriptorA(
      LPCSTR Name,
      ULONG Flags
    );





#line 7260 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
AddIntegrityLabelToBoundaryDescriptor(
      HANDLE * BoundaryDescriptor,
      PSID IntegrityLabel
    );


#line 7272 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 7274 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
















typedef struct tagHW_PROFILE_INFOA {
    DWORD  dwDockInfo;
    CHAR   szHwProfileGuid[39];
    CHAR   szHwProfileName[80];
} HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
typedef struct tagHW_PROFILE_INFOW {
    DWORD  dwDockInfo;
    WCHAR  szHwProfileGuid[39];
    WCHAR  szHwProfileName[80];
} HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;




typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;
#line 7307 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileA (
      LPHW_PROFILE_INFOA  lpHwProfileInfo
    );
__declspec(dllimport)
BOOL
__stdcall
GetCurrentHwProfileW (
      LPHW_PROFILE_INFOW  lpHwProfileInfo
    );




#line 7326 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 7327 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoA(
      LPOSVERSIONINFOEXA lpVersionInformation,
         DWORD dwTypeMask,
         DWORDLONG dwlConditionMask
    );
__declspec(dllimport)
BOOL
__stdcall
VerifyVersionInfoW(
      LPOSVERSIONINFOEXW lpVersionInformation,
         DWORD dwTypeMask,
         DWORDLONG dwlConditionMask
    );




#line 7349 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


#line 7352 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion





#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winerror.h"












#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winerror.h"
























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 22152 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winerror.h"














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 26295 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winerror.h"


__forceinline HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (7 << 16) | 0x80000000);}


#line 26301 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winerror.h"










































#line 26344 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winerror.h"


























































































































































































#line 26531 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winerror.h"





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 
 
 
 
 









































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 45639 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winerror.h"














































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 54710 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\winerror.h"

#line 7359 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"
 










#pragma once
#line 14 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"

















#line 32 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"


extern "C" {
#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"



#pragma region Application Family







typedef struct _TIME_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
} TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

typedef struct _TIME_DYNAMIC_ZONE_INFORMATION {
    LONG Bias;
    WCHAR StandardName[ 32 ];
    SYSTEMTIME StandardDate;
    LONG StandardBias;
    WCHAR DaylightName[ 32 ];
    SYSTEMTIME DaylightDate;
    LONG DaylightBias;
    WCHAR TimeZoneKeyName[ 128 ];
    BOOLEAN DynamicDaylightTimeDisabled;
} DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;

__declspec(dllimport)
 
BOOL
__stdcall
SystemTimeToTzSpecificLocalTime(
      const TIME_ZONE_INFORMATION * lpTimeZoneInformation,
      const SYSTEMTIME * lpUniversalTime,
      LPSYSTEMTIME lpLocalTime
    );


__declspec(dllimport)
 
BOOL
__stdcall
TzSpecificLocalTimeToSystemTime(
      const TIME_ZONE_INFORMATION * lpTimeZoneInformation,
      const SYSTEMTIME * lpLocalTime,
      LPSYSTEMTIME lpUniversalTime
    );


__declspec(dllimport)
 
BOOL
__stdcall
FileTimeToSystemTime(
      const FILETIME * lpFileTime,
      LPSYSTEMTIME lpSystemTime
    );


__declspec(dllimport)
 
BOOL
__stdcall
SystemTimeToFileTime(
      const SYSTEMTIME * lpSystemTime,
      LPFILETIME lpFileTime
    );


__declspec(dllimport)
 
DWORD
__stdcall
GetTimeZoneInformation(
      LPTIME_ZONE_INFORMATION lpTimeZoneInformation
    );


#line 121 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"
#pragma endregion

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
SetTimeZoneInformation(
      const TIME_ZONE_INFORMATION * lpTimeZoneInformation
    );





__declspec(dllimport)
BOOL
__stdcall
SetDynamicTimeZoneInformation(
      const DYNAMIC_TIME_ZONE_INFORMATION * lpTimeZoneInformation
    );


#line 147 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"

#line 149 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"
#pragma endregion

#pragma region Application Family






__declspec(dllimport)
 
DWORD
__stdcall
GetDynamicTimeZoneInformation(
      PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation
    );


#line 168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"




 
BOOL
__stdcall
GetTimeZoneInformationForYear(
      USHORT wYear,
      PDYNAMIC_TIME_ZONE_INFORMATION pdtzi,
      LPTIME_ZONE_INFORMATION ptzi
    );


#line 183 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"






__declspec(dllimport)
 
DWORD
__stdcall
EnumDynamicTimeZoneInformation(
      const DWORD dwIndex,
      PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation
    );


__declspec(dllimport)
 
DWORD
__stdcall
GetDynamicTimeZoneInformationEffectiveYears(
      const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation,
      LPDWORD FirstYear,
      LPDWORD LastYear
    );


__declspec(dllimport)
 
BOOL
__stdcall
SystemTimeToTzSpecificLocalTimeEx(
      const DYNAMIC_TIME_ZONE_INFORMATION * lpTimeZoneInformation,
      const SYSTEMTIME * lpUniversalTime,
      LPSYSTEMTIME lpLocalTime
    );


__declspec(dllimport)
 
BOOL
__stdcall
TzSpecificLocalTimeToSystemTimeEx(
      const DYNAMIC_TIME_ZONE_INFORMATION * lpTimeZoneInformation,
      const SYSTEMTIME * lpLocalTime,
      LPSYSTEMTIME lpUniversalTime
    );


#line 233 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"

#line 235 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"
#pragma endregion




}
#line 242 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"

#line 244 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\timezoneapi.h"

#line 7360 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#pragma region Desktop Family






























typedef struct _SYSTEM_POWER_STATUS {
    BYTE ACLineStatus;
    BYTE BatteryFlag;
    BYTE BatteryLifePercent;
    BYTE Reserved1;
    DWORD BatteryLifeTime;
    DWORD BatteryFullLifeTime;
}   SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

__declspec(dllimport)
BOOL
__stdcall
GetSystemPowerStatus(
      LPSYSTEM_POWER_STATUS lpSystemPowerStatus
    );

__declspec(dllimport)
BOOL
__stdcall
SetSystemPowerState(
      BOOL fSuspend,
      BOOL fForce
    );

#line 7417 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"






__declspec(dllimport)
BOOL
__stdcall
MapUserPhysicalPagesScatter(
      PVOID *VirtualAddresses,
      ULONG_PTR NumberOfPages,
      PULONG_PTR PageArray
    );

__declspec(dllimport)
 
HANDLE
__stdcall
CreateJobObjectA(
      LPSECURITY_ATTRIBUTES lpJobAttributes,
      LPCSTR lpName
    );
__declspec(dllimport)
 
HANDLE
__stdcall
CreateJobObjectW(
      LPSECURITY_ATTRIBUTES lpJobAttributes,
      LPCWSTR lpName
    );




#line 7453 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
 
HANDLE
__stdcall
OpenJobObjectA(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCSTR lpName
    );
__declspec(dllimport)
 
HANDLE
__stdcall
OpenJobObjectW(
      DWORD dwDesiredAccess,
      BOOL bInheritHandle,
      LPCWSTR lpName
    );




#line 7477 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
AssignProcessToJobObject(
      HANDLE hJob,
      HANDLE hProcess
    );

__declspec(dllimport)
BOOL
__stdcall
TerminateJobObject(
      HANDLE hJob,
      UINT uExitCode
    );

__declspec(dllimport)
BOOL
__stdcall
QueryInformationJobObject(
       HANDLE hJob,
           JOBOBJECTINFOCLASS JobObjectInformationClass,
      LPVOID lpJobObjectInformation,
           DWORD cbJobObjectInformationLength,
      LPDWORD lpReturnLength
    );

__declspec(dllimport)
BOOL
__stdcall
SetInformationJobObject(
      HANDLE hJob,
      JOBOBJECTINFOCLASS JobObjectInformationClass,
      LPVOID lpJobObjectInformation,
      DWORD cbJobObjectInformationLength
    );

__declspec(dllimport)
BOOL
__stdcall
CreateJobSet (
      ULONG NumJob,
      PJOB_SET_ARRAY UserJobSet,
      ULONG Flags);

__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeA(
      LPSTR lpszVolumeName,
      DWORD cchBufferLength
    );


#line 7533 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeA(
      HANDLE hFindVolume,
      LPSTR lpszVolumeName,
         DWORD cchBufferLength
    );


#line 7545 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeMountPointA(
      LPCSTR lpszRootPathName,
      LPSTR lpszVolumeMountPoint,
      DWORD cchBufferLength
    );
__declspec(dllimport)
HANDLE
__stdcall
FindFirstVolumeMountPointW(
      LPCWSTR lpszRootPathName,
      LPWSTR lpszVolumeMountPoint,
      DWORD cchBufferLength
    );




#line 7567 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointA(
      HANDLE hFindVolumeMountPoint,
      LPSTR lpszVolumeMountPoint,
      DWORD cchBufferLength
    );
__declspec(dllimport)
BOOL
__stdcall
FindNextVolumeMountPointW(
      HANDLE hFindVolumeMountPoint,
      LPWSTR lpszVolumeMountPoint,
      DWORD cchBufferLength
    );




#line 7589 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindVolumeMountPointClose(
      HANDLE hFindVolumeMountPoint
    );

__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointA(
      LPCSTR lpszVolumeMountPoint,
      LPCSTR lpszVolumeName
    );
__declspec(dllimport)
BOOL
__stdcall
SetVolumeMountPointW(
      LPCWSTR lpszVolumeMountPoint,
      LPCWSTR lpszVolumeName
    );




#line 7616 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteVolumeMountPointA(
      LPCSTR lpszVolumeMountPoint
    );


#line 7626 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetVolumeNameForVolumeMountPointA(
      LPCSTR lpszVolumeMountPoint,
      LPSTR lpszVolumeName,
      DWORD cchBufferLength
    );


#line 7638 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNameA(
      LPCSTR lpszFileName,
      LPSTR lpszVolumePathName,
      DWORD cchBufferLength
    );


#line 7650 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 7652 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetVolumePathNamesForVolumeNameA(
       LPCSTR lpszVolumeName,
         LPCH lpszVolumePathNames,
       DWORD cchBufferLength,
      PDWORD lpcchReturnLength
    );



#line 7668 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 7670 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"












typedef struct tagACTCTXA {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCSTR      lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCSTR      lpAssemblyDirectory;
    LPCSTR      lpResourceName;
    LPCSTR      lpApplicationName;
    HMODULE     hModule;
} ACTCTXA, *PACTCTXA;
typedef struct tagACTCTXW {
    ULONG       cbSize;
    DWORD       dwFlags;
    LPCWSTR     lpSource;
    USHORT      wProcessorArchitecture;
    LANGID      wLangId;
    LPCWSTR     lpAssemblyDirectory;
    LPCWSTR     lpResourceName;
    LPCWSTR     lpApplicationName;
    HMODULE     hModule;
} ACTCTXW, *PACTCTXW;




typedef ACTCTXA ACTCTX;
typedef PACTCTXA PACTCTX;
#line 7711 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

typedef const ACTCTXA *PCACTCTXA;
typedef const ACTCTXW *PCACTCTXW;



typedef PCACTCTXA PCACTCTX;
#line 7719 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
HANDLE
__stdcall
CreateActCtxA(
      PCACTCTXA pActCtx
    );
__declspec(dllimport)
HANDLE
__stdcall
CreateActCtxW(
      PCACTCTXW pActCtx
    );




#line 7739 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
void
__stdcall
AddRefActCtx(
      HANDLE hActCtx
    );


__declspec(dllimport)
void
__stdcall
ReleaseActCtx(
      HANDLE hActCtx
    );

__declspec(dllimport)
BOOL
__stdcall
ZombifyActCtx(
      HANDLE hActCtx
    );


 
__declspec(dllimport)
BOOL
__stdcall
ActivateActCtx(
      HANDLE hActCtx,
        ULONG_PTR *lpCookie
    );




 
__declspec(dllimport)
BOOL
__stdcall
DeactivateActCtx(
      DWORD dwFlags,
      ULONG_PTR ulCookie
    );

__declspec(dllimport)
BOOL
__stdcall
GetCurrentActCtx(
     HANDLE *lphActCtx);


typedef struct tagACTCTX_SECTION_KEYED_DATA_2600 {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;
} ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
typedef const ACTCTX_SECTION_KEYED_DATA_2600 * PCACTCTX_SECTION_KEYED_DATA_2600;

typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA {
    PVOID lpInformation;
    PVOID lpSectionBase;
    ULONG ulSectionLength;
    PVOID lpSectionGlobalDataBase;
    ULONG ulSectionGlobalDataLength;
} ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA *PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

typedef struct tagACTCTX_SECTION_KEYED_DATA {
    ULONG cbSize;
    ULONG ulDataFormatVersion;
    PVOID lpData;
    ULONG ulLength;
    PVOID lpSectionGlobalData;
    ULONG ulSectionGlobalDataLength;
    PVOID lpSectionBase;
    ULONG ulSectionTotalLength;
    HANDLE hActCtx;
    ULONG ulAssemblyRosterIndex;

    ULONG ulFlags;
    ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
} ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
typedef const ACTCTX_SECTION_KEYED_DATA * PCACTCTX_SECTION_KEYED_DATA;







 
__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringA(
            DWORD dwFlags,
      const GUID *lpExtensionGuid,
            ULONG ulSectionId,
            LPCSTR lpStringToFind,
           PACTCTX_SECTION_KEYED_DATA ReturnedData
    );
 
__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionStringW(
            DWORD dwFlags,
      const GUID *lpExtensionGuid,
            ULONG ulSectionId,
            LPCWSTR lpStringToFind,
           PACTCTX_SECTION_KEYED_DATA ReturnedData
    );




#line 7864 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
FindActCtxSectionGuid(
            DWORD dwFlags,
      const GUID *lpExtensionGuid,
            ULONG ulSectionId,
        const GUID *lpGuidToFind,
           PACTCTX_SECTION_KEYED_DATA ReturnedData
    );





typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION {
    HANDLE  hActCtx;
    DWORD   dwFlags;
} ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;

typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION *PCACTIVATION_CONTEXT_BASIC_INFORMATION;



#line 7890 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 7891 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




































 
__declspec(dllimport)
BOOL
__stdcall
QueryActCtxW(
           DWORD dwFlags,
           HANDLE hActCtx,
       PVOID pvSubInstance,
           ULONG ulInfoClass,
      PVOID pvBuffer,
           SIZE_T cbBuffer,
      SIZE_T *pcbWrittenOrRequired
    );

typedef   BOOL (__stdcall * PQUERYACTCTXW_FUNC)(
           DWORD dwFlags,
           HANDLE hActCtx,
       PVOID pvSubInstance,
           ULONG ulInfoClass,
      PVOID pvBuffer,
           SIZE_T cbBuffer,
      SIZE_T *pcbWrittenOrRequired
    );

#line 7952 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




__declspec(dllimport)
DWORD
__stdcall
WTSGetActiveConsoleSessionId(
    void
    );

#line 7964 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
WORD
__stdcall
GetActiveProcessorGroupCount(
    void
    );

__declspec(dllimport)
WORD
__stdcall
GetMaximumProcessorGroupCount(
    void
    );

__declspec(dllimport)
DWORD
__stdcall
GetActiveProcessorCount(
      WORD GroupNumber
    );

__declspec(dllimport)
DWORD
__stdcall
GetMaximumProcessorCount(
      WORD GroupNumber
    );

#line 7996 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





__declspec(dllimport)
BOOL
__stdcall
GetNumaProcessorNode(
       UCHAR Processor,
      PUCHAR NodeNumber
    );



__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeNumberFromHandle(
       HANDLE hFile,
      PUSHORT NodeNumber
    );

#line 8020 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetNumaProcessorNodeEx(
       PPROCESSOR_NUMBER Processor,
      PUSHORT NodeNumber
    );

#line 8032 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOL
__stdcall
GetNumaNodeProcessorMask(
       UCHAR Node,
      PULONGLONG ProcessorMask
    );

__declspec(dllimport)
BOOL
__stdcall
GetNumaAvailableMemoryNode(
       UCHAR Node,
      PULONGLONG AvailableBytes
    );



__declspec(dllimport)
BOOL
__stdcall
GetNumaAvailableMemoryNodeEx(
       USHORT Node,
      PULONGLONG AvailableBytes
    );

#line 8060 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetNumaProximityNode(
       ULONG ProximityId,
      PUCHAR NodeNumber
    );

#line 8072 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
GetNumaProximityNodeEx(
       ULONG ProximityId,
      PUSHORT NodeNumber
    );

#line 8084 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




typedef DWORD (__stdcall *APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);































__declspec(dllimport)
HRESULT
__stdcall
RegisterApplicationRecoveryCallback(
       APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
       PVOID pvParameter,
      DWORD dwPingInterval,
      DWORD dwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
UnregisterApplicationRecoveryCallback(void);

__declspec(dllimport)
HRESULT
__stdcall
RegisterApplicationRestart(
      PCWSTR pwzCommandline,
      DWORD dwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
UnregisterApplicationRestart(void);

__declspec(dllimport)
HRESULT
__stdcall
GetApplicationRecoveryCallback(
       HANDLE hProcess,
      APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback,
     PVOID* ppvParameter,
      PDWORD pdwPingInterval,
      PDWORD pdwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
GetApplicationRestartSettings(
      HANDLE hProcess,
      PWSTR pwzCommandline,
      PDWORD pcchSize,
      PDWORD pdwFlags
    );

__declspec(dllimport)
HRESULT
__stdcall
ApplicationRecoveryInProgress(
      PBOOL pbCancelled
    );

__declspec(dllimport)
void
__stdcall
ApplicationRecoveryFinished(
      BOOL bSuccess
    );

#line 8184 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 8186 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion



#pragma region Application Family


typedef struct _FILE_BASIC_INFO {
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    DWORD FileAttributes;
} FILE_BASIC_INFO, *PFILE_BASIC_INFO;

typedef struct _FILE_STANDARD_INFO {
    LARGE_INTEGER AllocationSize;
    LARGE_INTEGER EndOfFile;
    DWORD NumberOfLinks;
    BOOLEAN DeletePending;
    BOOLEAN Directory;
} FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;

typedef struct _FILE_NAME_INFO {
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_NAME_INFO, *PFILE_NAME_INFO;

typedef struct _FILE_RENAME_INFO {
    BOOLEAN ReplaceIfExists;
    HANDLE RootDirectory;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FILE_RENAME_INFO, *PFILE_RENAME_INFO;

typedef struct _FILE_ALLOCATION_INFO {
    LARGE_INTEGER AllocationSize;
} FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;

typedef struct _FILE_END_OF_FILE_INFO {
    LARGE_INTEGER EndOfFile;
} FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;

typedef struct _FILE_STREAM_INFO {
    DWORD NextEntryOffset;
    DWORD StreamNameLength;
    LARGE_INTEGER StreamSize;
    LARGE_INTEGER StreamAllocationSize;
    WCHAR StreamName[1];
} FILE_STREAM_INFO, *PFILE_STREAM_INFO;

typedef struct _FILE_COMPRESSION_INFO {
    LARGE_INTEGER CompressedFileSize;
    WORD CompressionFormat;
    UCHAR CompressionUnitShift;
    UCHAR ChunkShift;
    UCHAR ClusterShift;
    UCHAR Reserved[3];
} FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;

typedef struct _FILE_ATTRIBUTE_TAG_INFO {
    DWORD FileAttributes;
    DWORD ReparseTag;
} FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;

typedef struct _FILE_DISPOSITION_INFO {
    BOOLEAN DeleteFileA;
} FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;

typedef struct _FILE_ID_BOTH_DIR_INFO {
    DWORD NextEntryOffset;
    DWORD FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    DWORD FileAttributes;
    DWORD FileNameLength;
    DWORD EaSize;
    CCHAR ShortNameLength;
    WCHAR ShortName[12];
    LARGE_INTEGER FileId;
    WCHAR FileName[1];
} FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;

typedef struct _FILE_FULL_DIR_INFO {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    WCHAR FileName[1];
} FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;

typedef enum _PRIORITY_HINT {
      IoPriorityHintVeryLow = 0,
      IoPriorityHintLow,
      IoPriorityHintNormal,
      MaximumIoPriorityHintType
} PRIORITY_HINT;

typedef struct _FILE_IO_PRIORITY_HINT_INFO {
    PRIORITY_HINT PriorityHint;
} FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;





typedef struct _FILE_ALIGNMENT_INFO {
    ULONG AlignmentRequirement;
} FILE_ALIGNMENT_INFO, *PFILE_ALIGNMENT_INFO;




















typedef struct _FILE_STORAGE_INFO {
    ULONG LogicalBytesPerSector;
    ULONG PhysicalBytesPerSectorForAtomicity;
    ULONG PhysicalBytesPerSectorForPerformance;
    ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
    ULONG Flags;
    ULONG ByteOffsetForSectorAlignment;
    ULONG ByteOffsetForPartitionAlignment;
} FILE_STORAGE_INFO, *PFILE_STORAGE_INFO;




typedef struct _FILE_ID_INFO {
    ULONGLONG VolumeSerialNumber;
    FILE_ID_128 FileId;
} FILE_ID_INFO, *PFILE_ID_INFO;




typedef struct _FILE_ID_EXTD_DIR_INFO {
    ULONG NextEntryOffset;
    ULONG FileIndex;
    LARGE_INTEGER CreationTime;
    LARGE_INTEGER LastAccessTime;
    LARGE_INTEGER LastWriteTime;
    LARGE_INTEGER ChangeTime;
    LARGE_INTEGER EndOfFile;
    LARGE_INTEGER AllocationSize;
    ULONG FileAttributes;
    ULONG FileNameLength;
    ULONG EaSize;
    ULONG ReparsePointTag;
    FILE_ID_128 FileId;
    WCHAR FileName[1];
} FILE_ID_EXTD_DIR_INFO, *PFILE_ID_EXTD_DIR_INFO;

#line 8365 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"












#line 8378 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"









#line 8388 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"










#line 8399 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

typedef struct _FILE_REMOTE_PROTOCOL_INFO
{
    
    USHORT StructureVersion;     
    USHORT StructureSize;        

    ULONG  Protocol;             

    
    USHORT ProtocolMajorVersion;
    USHORT ProtocolMinorVersion;
    USHORT ProtocolRevision;

    USHORT Reserved;

    
    ULONG  Flags;

    struct {
        ULONG Reserved[8];
    } GenericReserved;

    





#line 8429 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
    union {

        struct {

            struct {
                ULONG Capabilities;
            } Server;

            struct {
                ULONG Capabilities;
                ULONG CachingFlags;
            } Share;

        } Smb2;

        ULONG Reserved[16];

    } ProtocolSpecific;

#line 8449 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

} FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetFileInformationByHandleEx(
       HANDLE hFile,
       FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
      LPVOID lpFileInformation,
       DWORD dwBufferSize
);

#line 8463 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


typedef enum _FILE_ID_TYPE {
      FileIdType,
      ObjectIdType,
      ExtendedFileIdType,
      MaximumFileIdType
} FILE_ID_TYPE, *PFILE_ID_TYPE;

typedef struct FILE_ID_DESCRIPTOR {
    DWORD dwSize;  
    FILE_ID_TYPE Type; 
    union {
        LARGE_INTEGER FileId;
        GUID ObjectId;

        FILE_ID_128 ExtendedFileId;
#line 8484 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
    } ;
} FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;

__declspec(dllimport)
HANDLE
__stdcall
OpenFileById (
          HANDLE hVolumeHint,
          LPFILE_ID_DESCRIPTOR lpFileId,
          DWORD dwDesiredAccess,
          DWORD dwShareMode,
      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
          DWORD dwFlagsAndAttributes
    );

#line 8500 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#line 8503 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#pragma region Desktop Family












__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkA (
      LPCSTR lpSymlinkFileName,
      LPCSTR lpTargetFileName,
      DWORD dwFlags
    );
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkW (
      LPCWSTR lpSymlinkFileName,
      LPCWSTR lpTargetFileName,
      DWORD dwFlags
    );




#line 8538 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkTransactedA (
          LPCSTR lpSymlinkFileName,
          LPCSTR lpTargetFileName,
          DWORD dwFlags,
          HANDLE hTransaction
    );
__declspec(dllimport)
BOOLEAN
__stdcall
CreateSymbolicLinkTransactedW (
          LPCWSTR lpSymlinkFileName,
          LPCWSTR lpTargetFileName,
          DWORD dwFlags,
          HANDLE hTransaction
    );




#line 8562 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 8564 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




__declspec(dllimport)
BOOL
__stdcall
QueryActCtxSettingsW(
           DWORD dwFlags,
           HANDLE hActCtx,
           PCWSTR settingsNameSpace,
               PCWSTR settingName,
      PWSTR pvBuffer,
           SIZE_T dwBuffer,
      SIZE_T *pdwWrittenOrRequired
    );

#line 8582 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__declspec(dllimport)
BOOL
__stdcall
ReplacePartitionUnit (
      PWSTR TargetPartition,
      PWSTR SparePartition,
      ULONG Flags
    );

#line 8595 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




__declspec(dllimport)
BOOL
__stdcall
AddSecureMemoryCacheCallback(
       PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

__declspec(dllimport)
BOOL
__stdcall
RemoveSecureMemoryCacheCallback(
       PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack
    );

#line 8614 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 8616 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion



#pragma region Desktop Family


 
__declspec(dllimport)
BOOL
__stdcall
CopyContext(
      PCONTEXT Destination,
      DWORD ContextFlags,
      PCONTEXT Source
    );

#line 8634 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Application Family


 
__declspec(dllimport)
BOOL
__stdcall
InitializeContext(
      PVOID Buffer,
      DWORD ContextFlags,
      PCONTEXT* Context,
      PDWORD ContextLength
    );
#line 8650 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion



#pragma region Application Family


__declspec(dllimport)
DWORD64
__stdcall
GetEnabledXStateFeatures(
    void
    );

 
__declspec(dllimport)
BOOL
__stdcall
GetXStateFeaturesMask(
      PCONTEXT Context,
      PDWORD64 FeatureMask
    );

 
__declspec(dllimport)
PVOID
__stdcall
LocateXStateFeature(
      PCONTEXT Context,
      DWORD FeatureId,
      PDWORD Length
    );

#line 8684 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#pragma region Desktop Family


 
__declspec(dllimport)
BOOL
__stdcall
SetXStateFeaturesMask(
      PCONTEXT Context,
      DWORD64 FeatureMask
    );

#line 8699 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#line 8702 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 8704 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
EnableThreadProfiling(
      HANDLE ThreadHandle,
      DWORD Flags,
      DWORD64 HardwareCounters,
      HANDLE *PerformanceDataHandle
    );

__declspec(dllimport)
DWORD
__stdcall
DisableThreadProfiling(
      HANDLE PerformanceDataHandle
    );

__declspec(dllimport)
DWORD
__stdcall
QueryThreadProfiling(
      HANDLE ThreadHandle,
      PBOOLEAN Enabled
    );

__declspec(dllimport)
DWORD
__stdcall
ReadThreadProfilingData(
      HANDLE PerformanceDataHandle,
      DWORD Flags,
      PPERFORMANCE_DATA PerformanceData
    );

#line 8745 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#pragma endregion

#line 8748 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"






#line 8755 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 8756 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"


}
#line 8760 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



#pragma warning(pop)




#line 8769 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 8770 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



#line 8774 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




























#pragma once
#line 8804 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"










#line 8815 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"





extern "C++" {

__forceinline
unsigned
_InterlockedIncrement(
       unsigned volatile *Addend
    )
{
    return (unsigned) _InterlockedIncrement((volatile long*) Addend);
}

__forceinline
unsigned long
_InterlockedIncrement(
       unsigned long volatile *Addend
    )
{
    return (unsigned long) _InterlockedIncrement((volatile long*) Addend);
}



__forceinline
unsigned __int64
_InterlockedIncrement(
       unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) _InterlockedIncrement64((volatile long long*) Addend);
}

#line 8852 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__forceinline
unsigned
_InterlockedDecrement(
       unsigned volatile *Addend
    )
{
    return (unsigned long) _InterlockedDecrement((volatile long*) Addend);
}

__forceinline
unsigned long
_InterlockedDecrement(
       unsigned long volatile *Addend
    )
{
    return (unsigned long) _InterlockedDecrement((volatile long*) Addend);
}



__forceinline
unsigned __int64
_InterlockedDecrement(
       unsigned __int64 volatile *Addend
    )
{
    return (unsigned __int64) _InterlockedDecrement64((volatile long long*) Addend);
}

#line 8883 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"



__forceinline
unsigned
_InterlockedExchange(
       unsigned volatile *Target,
      unsigned Value
    )
{
    return (unsigned) _InterlockedExchange((volatile long*) Target, (long) Value);
}

__forceinline
unsigned long
_InterlockedExchange(
       unsigned long volatile *Target,
      unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchange((volatile long*) Target, (long) Value);
}



__forceinline
unsigned __int64
_InterlockedExchange(
       unsigned __int64 volatile *Target,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchange64((volatile long long*) Target, (long long) Value);
}

#line 8919 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__forceinline
unsigned
_InterlockedExchangeAdd(
       unsigned volatile *Addend,
      unsigned Value
    )
{
    return (unsigned) _InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

__forceinline
unsigned
InterlockedExchangeSubtract(
       unsigned volatile *Addend,
      unsigned Value
    )
{
    return (unsigned) _InterlockedExchangeAdd((volatile long*) Addend,  - (long) Value);
}

__forceinline
unsigned long
_InterlockedExchangeAdd(
       unsigned long volatile *Addend,
      unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchangeAdd((volatile long*) Addend, (long) Value);
}

__forceinline
unsigned long
InterlockedExchangeSubtract(
       unsigned long volatile *Addend,
      unsigned long Value
    )
{
    return (unsigned long) _InterlockedExchangeAdd((volatile long*) Addend,  - (long) Value);
}



__forceinline
unsigned __int64
_InterlockedExchangeAdd(
       unsigned __int64 volatile *Addend,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchangeAdd64((volatile long long*) Addend,  (long long) Value);
}

__forceinline
unsigned __int64
InterlockedExchangeSubtract(
       unsigned __int64 volatile *Addend,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedExchangeAdd64((volatile long long*) Addend,  - (long long) Value);
}

#line 8983 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

__forceinline
unsigned
_InterlockedCompareExchange(
       unsigned volatile *Destination,
      unsigned Exchange,
      unsigned Comperand
    )
{
    return (unsigned) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}

__forceinline
unsigned long
_InterlockedCompareExchange(
       unsigned long volatile *Destination,
      unsigned long Exchange,
      unsigned long Comperand
    )
{
    return (unsigned long) _InterlockedCompareExchange((volatile long*) Destination, (long) Exchange, (long) Comperand);
}



__forceinline
unsigned __int64
_InterlockedCompareExchange(
       unsigned __int64 volatile *Destination,
      unsigned __int64 Exchange,
      unsigned __int64 Comperand
    )
{
    return (unsigned __int64) _InterlockedCompareExchange64((volatile long long*) Destination, (long long) Exchange, (long long) Comperand);
}

__forceinline
unsigned __int64
_InterlockedAnd(
       unsigned __int64 volatile *Destination,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedAnd64((volatile long long*) Destination, (long long) Value);
}

__forceinline
unsigned __int64
_InterlockedOr(
       unsigned __int64 volatile *Destination,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedOr64((volatile long long*) Destination, (long long) Value);
}

__forceinline
unsigned __int64
_InterlockedXor(
       unsigned __int64 volatile *Destination,
      unsigned __int64 Value
    )
{
    return (unsigned __int64) _InterlockedXor64((volatile long long*) Destination, (long long) Value);
}

#line 9050 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 9052 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

} 
#line 9055 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 9057 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"




#line 9062 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 9063 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 9064 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 9065 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 9066 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"
#line 9067 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winbase.h"

#line 166 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"














#pragma once


#pragma warning(push)
#pragma warning(disable: 4201)      
#line 21 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"














#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"









#line 46 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


extern "C" {
#line 50 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
















































#line 99 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"





#line 105 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"






#line 112 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"






























#line 143 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"













#line 157 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

















#line 175 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
















#line 192 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


#line 195 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


#line 198 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"














































































#line 277 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"








#pragma region Desktop Family



typedef struct _DRAWPATRECT {
        POINT ptPosition;
        POINT ptSize;
        WORD wStyle;
        WORD wPattern;
} DRAWPATRECT, *PDRAWPATRECT;
#line 296 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 298 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 301 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"





































































































#line 403 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"











#pragma region Desktop Family






typedef struct _PSINJECTDATA {

    DWORD   DataBytes;      
    WORD    InjectionPoint; 
    WORD    PageNumber;     

    

} PSINJECTDATA, *PPSINJECTDATA;

#line 432 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion



































































#line 501 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family






typedef struct _PSFEATURE_OUTPUT {

    BOOL bPageIndependent;
    BOOL bSetPageDevice;

} PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;





typedef struct _PSFEATURE_CUSTPAPER {

    LONG lOrientation;
    LONG lWidth;
    LONG lHeight;
    LONG lWidthOffset;
    LONG lHeightOffset;

} PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;

#line 531 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion



















































#pragma region Application Family


typedef struct  tagXFORM
  {
    FLOAT   eM11;
    FLOAT   eM12;
    FLOAT   eM21;
    FLOAT   eM22;
    FLOAT   eDx;
    FLOAT   eDy;
  } XFORM, *PXFORM,  *LPXFORM;


typedef struct tagBITMAP
  {
    LONG        bmType;
    LONG        bmWidth;
    LONG        bmHeight;
    LONG        bmWidthBytes;
    WORD        bmPlanes;
    WORD        bmBitsPixel;
    LPVOID      bmBits;
  } BITMAP, *PBITMAP,  *NPBITMAP,  *LPBITMAP;

#line 609 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack1.h"























#pragma warning(disable:4103)

#pragma pack(push,1)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack1.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack1.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack1.h"
#line 612 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagRGBTRIPLE {
        BYTE    rgbtBlue;
        BYTE    rgbtGreen;
        BYTE    rgbtRed;
} RGBTRIPLE, *PRGBTRIPLE,  *NPRGBTRIPLE,  *LPRGBTRIPLE;

#line 623 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 626 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagRGBQUAD {
        BYTE    rgbBlue;
        BYTE    rgbGreen;
        BYTE    rgbRed;
        BYTE    rgbReserved;
} RGBQUAD;

#line 638 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef RGBQUAD * LPRGBQUAD;

#line 646 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion


















#pragma region Application Family


typedef LONG   LCSCSTYPE;



typedef LONG    LCSGAMUTMATCH;



























typedef long            FXPT16DOT16,  *LPFXPT16DOT16;
typedef long            FXPT2DOT30,  *LPFXPT2DOT30;




typedef struct tagCIEXYZ
{
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
} CIEXYZ;

#line 714 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef CIEXYZ   *LPCIEXYZ;

#line 722 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagICEXYZTRIPLE
{
        CIEXYZ  ciexyzRed;
        CIEXYZ  ciexyzGreen;
        CIEXYZ  ciexyzBlue;
} CIEXYZTRIPLE;

#line 735 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef CIEXYZTRIPLE     *LPCIEXYZTRIPLE;

#line 743 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family







typedef struct tagLOGCOLORSPACEA {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    CHAR   lcsFilename[260];
} LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
typedef struct tagLOGCOLORSPACEW {
    DWORD lcsSignature;
    DWORD lcsVersion;
    DWORD lcsSize;
    LCSCSTYPE lcsCSType;
    LCSGAMUTMATCH lcsIntent;
    CIEXYZTRIPLE lcsEndpoints;
    DWORD lcsGammaRed;
    DWORD lcsGammaGreen;
    DWORD lcsGammaBlue;
    WCHAR  lcsFilename[260];
} LOGCOLORSPACEW, *LPLOGCOLORSPACEW;




typedef LOGCOLORSPACEA LOGCOLORSPACE;
typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE;
#line 784 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 786 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 789 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family



typedef struct tagBITMAPCOREHEADER {
        DWORD   bcSize;                 
        WORD    bcWidth;
        WORD    bcHeight;
        WORD    bcPlanes;
        WORD    bcBitCount;
} BITMAPCOREHEADER,  *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;

#line 803 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagBITMAPINFOHEADER{
        DWORD      biSize;
        LONG       biWidth;
        LONG       biHeight;
        WORD       biPlanes;
        WORD       biBitCount;
        DWORD      biCompression;
        DWORD      biSizeImage;
        LONG       biXPelsPerMeter;
        LONG       biYPelsPerMeter;
        DWORD      biClrUsed;
        DWORD      biClrImportant;
} BITMAPINFOHEADER,  *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;

#line 823 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


typedef struct {
        DWORD        bV4Size;
        LONG         bV4Width;
        LONG         bV4Height;
        WORD         bV4Planes;
        WORD         bV4BitCount;
        DWORD        bV4V4Compression;
        DWORD        bV4SizeImage;
        LONG         bV4XPelsPerMeter;
        LONG         bV4YPelsPerMeter;
        DWORD        bV4ClrUsed;
        DWORD        bV4ClrImportant;
        DWORD        bV4RedMask;
        DWORD        bV4GreenMask;
        DWORD        bV4BlueMask;
        DWORD        bV4AlphaMask;
        DWORD        bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD        bV4GammaRed;
        DWORD        bV4GammaGreen;
        DWORD        bV4GammaBlue;
} BITMAPV4HEADER,  *LPBITMAPV4HEADER, *PBITMAPV4HEADER;

#line 854 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion
#line 856 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



#pragma region Desktop Family

typedef struct {
        DWORD        bV5Size;
        LONG         bV5Width;
        LONG         bV5Height;
        WORD         bV5Planes;
        WORD         bV5BitCount;
        DWORD        bV5Compression;
        DWORD        bV5SizeImage;
        LONG         bV5XPelsPerMeter;
        LONG         bV5YPelsPerMeter;
        DWORD        bV5ClrUsed;
        DWORD        bV5ClrImportant;
        DWORD        bV5RedMask;
        DWORD        bV5GreenMask;
        DWORD        bV5BlueMask;
        DWORD        bV5AlphaMask;
        DWORD        bV5CSType;
        CIEXYZTRIPLE bV5Endpoints;
        DWORD        bV5GammaRed;
        DWORD        bV5GammaGreen;
        DWORD        bV5GammaBlue;
        DWORD        bV5Intent;
        DWORD        bV5ProfileData;
        DWORD        bV5ProfileSize;
        DWORD        bV5Reserved;
} BITMAPV5HEADER,  *LPBITMAPV5HEADER, *PBITMAPV5HEADER;

#line 889 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion




#line 895 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"









#line 905 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagBITMAPINFO {
    BITMAPINFOHEADER    bmiHeader;
    RGBQUAD             bmiColors[1];
} BITMAPINFO,  *LPBITMAPINFO, *PBITMAPINFO;

#line 915 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagBITMAPCOREINFO {
    BITMAPCOREHEADER    bmciHeader;
    RGBTRIPLE           bmciColors[1];
} BITMAPCOREINFO,  *LPBITMAPCOREINFO, *PBITMAPCOREINFO;

#line 926 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 929 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct tagBITMAPFILEHEADER {
        WORD    bfType;
        DWORD   bfSize;
        WORD    bfReserved1;
        WORD    bfReserved2;
        DWORD   bfOffBits;
} BITMAPFILEHEADER,  *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;

#line 942 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 945 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"






#pragma region Desktop Family


typedef struct tagFONTSIGNATURE
{
    DWORD fsUsb[4];
    DWORD fsCsb[2];
} FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;

typedef struct tagCHARSETINFO
{
    UINT ciCharset;
    UINT ciACP;
    FONTSIGNATURE fs;
} CHARSETINFO, *PCHARSETINFO,  *NPCHARSETINFO,  *LPCHARSETINFO;

#line 968 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion






#line 976 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagLOCALESIGNATURE
{
    DWORD lsUsb[4];
    DWORD lsCsbDefault[2];
    DWORD lsCsbSupported[2];
} LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;

#line 988 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 991 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#line 992 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



#pragma region Application Family




typedef struct tagHANDLETABLE
  {
    HGDIOBJ     objectHandle[1];
  } HANDLETABLE, *PHANDLETABLE,  *LPHANDLETABLE;

typedef struct tagMETARECORD
  {
    DWORD       rdSize;
    WORD        rdFunction;
    WORD        rdParm[1];
  } METARECORD;

#line 1013 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagMETARECORD  *PMETARECORD;

#line 1021 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagMETARECORD   *LPMETARECORD;

typedef struct tagMETAFILEPICT
  {
    LONG        mm;
    LONG        xExt;
    LONG        yExt;
    HMETAFILE   hMF;
  } METAFILEPICT,  *LPMETAFILEPICT;

#line 1037 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 1040 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct tagMETAHEADER
{
    WORD        mtType;
    WORD        mtHeaderSize;
    WORD        mtVersion;
    DWORD       mtSize;
    WORD        mtNoObjects;
    DWORD       mtMaxRecord;
    WORD        mtNoParameters;
} METAHEADER;
typedef struct tagMETAHEADER  *PMETAHEADER;
typedef struct tagMETAHEADER   *LPMETAHEADER;

#line 1058 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 1061 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Application Family



typedef struct tagENHMETARECORD
{
    DWORD   iType;              
    DWORD   nSize;              
    DWORD   dParm[1];           
} ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;

typedef struct tagENHMETAHEADER
{
    DWORD   iType;              
    DWORD   nSize;              
                                
    RECTL   rclBounds;          
    RECTL   rclFrame;           
    DWORD   dSignature;         
    DWORD   nVersion;           
    DWORD   nBytes;             
    DWORD   nRecords;           
    WORD    nHandles;           
                                
    WORD    sReserved;          
    DWORD   nDescription;       
                                
    DWORD   offDescription;     
                                
    DWORD   nPalEntries;        
    SIZEL   szlDevice;          
    SIZEL   szlMillimeters;     

    DWORD   cbPixelFormat;      
                                
    DWORD   offPixelFormat;     
                                
    DWORD   bOpenGL;            
                                
#line 1102 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

    SIZEL   szlMicrometers;     
#line 1105 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

} ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;

#line 1109 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 1112 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"









#pragma region Desktop Family








    typedef BYTE BCHAR;
#line 1132 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 1134 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion



#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 1139 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICA, *PTEXTMETRICA,  *NPTEXTMETRICA,  *LPTEXTMETRICA;
typedef struct tagTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
} TEXTMETRICW, *PTEXTMETRICW,  *NPTEXTMETRICW,  *LPTEXTMETRICW;






typedef TEXTMETRICA TEXTMETRIC;
typedef PTEXTMETRICA PTEXTMETRIC;
typedef NPTEXTMETRICA NPTEXTMETRIC;
typedef LPTEXTMETRICA LPTEXTMETRIC;
#line 1200 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 1202 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 1205 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#line 1206 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"















#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"























#pragma warning(disable:4103)

#pragma pack(push,4)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack4.h"
#line 1222 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct tagNEWTEXTMETRICA
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    BYTE        tmFirstChar;
    BYTE        tmLastChar;
    BYTE        tmDefaultChar;
    BYTE        tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICA, *PNEWTEXTMETRICA,  *NPNEWTEXTMETRICA,  *LPNEWTEXTMETRICA;
typedef struct tagNEWTEXTMETRICW
{
    LONG        tmHeight;
    LONG        tmAscent;
    LONG        tmDescent;
    LONG        tmInternalLeading;
    LONG        tmExternalLeading;
    LONG        tmAveCharWidth;
    LONG        tmMaxCharWidth;
    LONG        tmWeight;
    LONG        tmOverhang;
    LONG        tmDigitizedAspectX;
    LONG        tmDigitizedAspectY;
    WCHAR       tmFirstChar;
    WCHAR       tmLastChar;
    WCHAR       tmDefaultChar;
    WCHAR       tmBreakChar;
    BYTE        tmItalic;
    BYTE        tmUnderlined;
    BYTE        tmStruckOut;
    BYTE        tmPitchAndFamily;
    BYTE        tmCharSet;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRICW, *PNEWTEXTMETRICW,  *NPNEWTEXTMETRICW,  *LPNEWTEXTMETRICW;






typedef NEWTEXTMETRICA NEWTEXTMETRIC;
typedef PNEWTEXTMETRICA PNEWTEXTMETRIC;
typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC;
typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC;
#line 1291 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 1293 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 1296 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



#pragma region Desktop Family


typedef struct tagNEWTEXTMETRICEXA
{
    NEWTEXTMETRICA  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXA;
typedef struct tagNEWTEXTMETRICEXW
{
    NEWTEXTMETRICW  ntmTm;
    FONTSIGNATURE   ntmFontSig;
}NEWTEXTMETRICEXW;



typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;
#line 1317 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 1319 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion
#line 1321 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 1323 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



#pragma region Desktop Family


typedef struct tagPELARRAY
  {
    LONG        paXCount;
    LONG        paYCount;
    LONG        paXExt;
    LONG        paYExt;
    BYTE        paRGBs;
  } PELARRAY, *PPELARRAY,  *NPPELARRAY,  *LPPELARRAY;

#line 1339 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family



typedef struct tagLOGBRUSH
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    ULONG_PTR   lbHatch;
  } LOGBRUSH, *PLOGBRUSH,  *NPLOGBRUSH,  *LPLOGBRUSH;

typedef struct tagLOGBRUSH32
  {
    UINT        lbStyle;
    COLORREF    lbColor;
    ULONG       lbHatch;
  } LOGBRUSH32, *PLOGBRUSH32,  *NPLOGBRUSH32,  *LPLOGBRUSH32;

#line 1360 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef LOGBRUSH            PATTERN;
typedef PATTERN             *PPATTERN;
typedef PATTERN         *NPPATTERN;
typedef PATTERN          *LPPATTERN;

#line 1371 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family



typedef struct tagLOGPEN
  {
    UINT        lopnStyle;
    POINT       lopnWidth;
    COLORREF    lopnColor;
  } LOGPEN, *PLOGPEN,  *NPLOGPEN,  *LPLOGPEN;

#line 1385 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct tagEXTLOGPEN {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    ULONG_PTR   elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN, *PEXTLOGPEN,  *NPEXTLOGPEN,  *LPEXTLOGPEN;

#line 1401 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct tagEXTLOGPEN32 {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    ULONG       elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN32, *PEXTLOGPEN32,  *NPEXTLOGPEN32,  *LPEXTLOGPEN32;



typedef struct tagPALETTEENTRY {
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *PPALETTEENTRY,  *LPPALETTEENTRY;
#line 1425 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




typedef struct tagLOGPALETTE {
    WORD        palVersion;
    WORD        palNumEntries;
      PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *PLOGPALETTE,  *NPLOGPALETTE,  *LPLOGPALETTE;
#line 1435 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"





typedef struct tagLOGFONTA
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    CHAR      lfFaceName[32];
} LOGFONTA, *PLOGFONTA,  *NPLOGFONTA,  *LPLOGFONTA;
typedef struct tagLOGFONTW
{
    LONG      lfHeight;
    LONG      lfWidth;
    LONG      lfEscapement;
    LONG      lfOrientation;
    LONG      lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    WCHAR     lfFaceName[32];
} LOGFONTW, *PLOGFONTW,  *NPLOGFONTW,  *LPLOGFONTW;






typedef LOGFONTA LOGFONT;
typedef PLOGFONTA PLOGFONT;
typedef NPLOGFONTA NPLOGFONT;
typedef LPLOGFONTA LPLOGFONT;
#line 1485 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 1487 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family



typedef struct tagENUMLOGFONTA
{
    LOGFONTA elfLogFont;
    BYTE     elfFullName[64];
    BYTE     elfStyle[32];
} ENUMLOGFONTA, * LPENUMLOGFONTA;

typedef struct tagENUMLOGFONTW
{
    LOGFONTW elfLogFont;
    WCHAR    elfFullName[64];
    WCHAR    elfStyle[32];
} ENUMLOGFONTW, * LPENUMLOGFONTW;




typedef ENUMLOGFONTA ENUMLOGFONT;
typedef LPENUMLOGFONTA LPENUMLOGFONT;
#line 1515 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


typedef struct tagENUMLOGFONTEXA
{
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[64];
    BYTE        elfStyle[32];
    BYTE        elfScript[32];
} ENUMLOGFONTEXA,  *LPENUMLOGFONTEXA;
typedef struct tagENUMLOGFONTEXW
{
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[64];
    WCHAR       elfStyle[32];
    WCHAR       elfScript[32];
} ENUMLOGFONTEXW,  *LPENUMLOGFONTEXW;




typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;
#line 1538 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#line 1539 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 1541 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion





















#line 1564 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"








#line 1573 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




#line 1578 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"






#line 1585 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"








































#line 1626 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




                                    

                                    

                                    



































#pragma region Application Family


typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, * LPPANOSE;

















































































































typedef struct tagEXTLOGFONTA {
    LOGFONTA    elfLogFont;
    BYTE        elfFullName[64];
    BYTE        elfStyle[32];
    DWORD       elfVersion;     
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[4];
    DWORD       elfCulture;     
    PANOSE      elfPanose;
} EXTLOGFONTA, *PEXTLOGFONTA,  *NPEXTLOGFONTA,  *LPEXTLOGFONTA;
typedef struct tagEXTLOGFONTW {
    LOGFONTW    elfLogFont;
    WCHAR       elfFullName[64];
    WCHAR       elfStyle[32];
    DWORD       elfVersion;     
    DWORD       elfStyleSize;
    DWORD       elfMatch;
    DWORD       elfReserved;
    BYTE        elfVendorId[4];
    DWORD       elfCulture;     
    PANOSE      elfPanose;
} EXTLOGFONTW, *PEXTLOGFONTW,  *NPEXTLOGFONTW,  *LPEXTLOGFONTW;






typedef EXTLOGFONTA EXTLOGFONT;
typedef PEXTLOGFONTA PEXTLOGFONT;
typedef NPEXTLOGFONTA NPEXTLOGFONT;
typedef LPEXTLOGFONTA LPEXTLOGFONT;
#line 1834 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 1836 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion
















































































#line 1918 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




#line 1923 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"







#line 1931 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


































































































                             

                             

                             





#line 2040 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"










































































#line 2115 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"





































#line 2153 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




























#pragma region Application Family



typedef struct _devicemodeA {
    BYTE   dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      };
      
      struct {
        POINTL dmPosition;
        DWORD  dmDisplayOrientation;
        DWORD  dmDisplayFixedOutput;
      };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    BYTE   dmFormName[32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    union {
        DWORD  dmDisplayFlags;
        DWORD  dmNup;
    };
    DWORD  dmDisplayFrequency;

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
#line 2237 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#line 2238 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
} DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
typedef struct _devicemodeW {
    WCHAR  dmDeviceName[32];
    WORD dmSpecVersion;
    WORD dmDriverVersion;
    WORD dmSize;
    WORD dmDriverExtra;
    DWORD dmFields;
    union {
      
      struct {
        short dmOrientation;
        short dmPaperSize;
        short dmPaperLength;
        short dmPaperWidth;
        short dmScale;
        short dmCopies;
        short dmDefaultSource;
        short dmPrintQuality;
      };
      
      struct {
        POINTL dmPosition;
        DWORD  dmDisplayOrientation;
        DWORD  dmDisplayFixedOutput;
      };
    };
    short dmColor;
    short dmDuplex;
    short dmYResolution;
    short dmTTOption;
    short dmCollate;
    WCHAR  dmFormName[32];
    WORD   dmLogPixels;
    DWORD  dmBitsPerPel;
    DWORD  dmPelsWidth;
    DWORD  dmPelsHeight;
    union {
        DWORD  dmDisplayFlags;
        DWORD  dmNup;
    };
    DWORD  dmDisplayFrequency;

    DWORD  dmICMMethod;
    DWORD  dmICMIntent;
    DWORD  dmMediaType;
    DWORD  dmDitherType;
    DWORD  dmReserved1;
    DWORD  dmReserved2;

    DWORD  dmPanningWidth;
    DWORD  dmPanningHeight;
#line 2291 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#line 2292 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
} DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;






typedef DEVMODEA DEVMODE;
typedef PDEVMODEA PDEVMODE;
typedef NPDEVMODEA NPDEVMODE;
typedef LPDEVMODEA LPDEVMODE;
#line 2304 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"












































































































#line 2413 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 2415 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion








#line 2425 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"










#line 2436 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


#line 2439 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"






















#line 2462 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


#line 2465 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"













































































#line 2543 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




















































#line 2596 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"







#line 2604 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"












































#line 2649 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
















#line 2666 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

















































#line 2716 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Application Family


typedef struct _DISPLAY_DEVICEA {
    DWORD  cb;
    CHAR   DeviceName[32];
    CHAR   DeviceString[128];
    DWORD  StateFlags;
    CHAR   DeviceID[128];
    CHAR   DeviceKey[128];
} DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
typedef struct _DISPLAY_DEVICEW {
    DWORD  cb;
    WCHAR  DeviceName[32];
    WCHAR  DeviceString[128];
    DWORD  StateFlags;
    WCHAR  DeviceID[128];
    WCHAR  DeviceKey[128];
} DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;





typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;
#line 2745 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 2747 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion








#line 2757 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


#line 2760 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




#line 2765 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



#line 2769 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"





#line 2775 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




                                          
                                          

#pragma region Application Family


typedef struct DISPLAYCONFIG_RATIONAL
{
    UINT32    Numerator;
    UINT32    Denominator;
} DISPLAYCONFIG_RATIONAL;

typedef enum
{
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER                   = -1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15                    =  0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO                  =  1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO         =  2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO         =  3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI                     =  4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI                    =  5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS                    =  6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN                   =  8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI                     =  9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL    = 10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED    = 11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL            = 12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED            = 13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE              = 14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST                = 15,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL                = 0x80000000,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32            = 0xFFFFFFFF
} DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY;

typedef enum
{
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED                 = 0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE                 = 1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED                  = 2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST  = DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST  = 3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32                = 0xFFFFFFFF
} DISPLAYCONFIG_SCANLINE_ORDERING;

typedef struct DISPLAYCONFIG_2DREGION
{
    UINT32 cx;
    UINT32 cy;
} DISPLAYCONFIG_2DREGION;

typedef struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO
{
    UINT64                          pixelRate;
    DISPLAYCONFIG_RATIONAL          hSyncFreq;
    DISPLAYCONFIG_RATIONAL          vSyncFreq;
    DISPLAYCONFIG_2DREGION          activeSize;
    DISPLAYCONFIG_2DREGION          totalSize;

    union
    {
        struct
        {
            UINT32 videoStandard : 16;

            
            UINT32 vSyncFreqDivider : 6;

            UINT32 reserved : 10;
        } AdditionalSignalInfo;

        UINT32 videoStandard;
    };

    
    DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
} DISPLAYCONFIG_VIDEO_SIGNAL_INFO;

typedef enum
{
    DISPLAYCONFIG_SCALING_IDENTITY                  = 1,
    DISPLAYCONFIG_SCALING_CENTERED                  = 2,
    DISPLAYCONFIG_SCALING_STRETCHED                 = 3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX    = 4,
    DISPLAYCONFIG_SCALING_CUSTOM                    = 5,
    DISPLAYCONFIG_SCALING_PREFERRED                 = 128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32              = 0xFFFFFFFF
} DISPLAYCONFIG_SCALING;

typedef enum
{
    DISPLAYCONFIG_ROTATION_IDENTITY     = 1,
    DISPLAYCONFIG_ROTATION_ROTATE90     = 2,
    DISPLAYCONFIG_ROTATION_ROTATE180    = 3,
    DISPLAYCONFIG_ROTATION_ROTATE270    = 4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_ROTATION;

typedef enum
{
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = 0xFFFFFFFF
} DISPLAYCONFIG_MODE_INFO_TYPE;

typedef enum
{
    DISPLAYCONFIG_PIXELFORMAT_8BPP          = 1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP         = 2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP         = 3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP         = 4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI        = 5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32  = 0xffffffff
} DISPLAYCONFIG_PIXELFORMAT;

typedef struct DISPLAYCONFIG_SOURCE_MODE
{
    UINT32                      width;
    UINT32                      height;
    DISPLAYCONFIG_PIXELFORMAT   pixelFormat;
    POINTL                      position;
} DISPLAYCONFIG_SOURCE_MODE;

typedef struct DISPLAYCONFIG_TARGET_MODE
{
    DISPLAYCONFIG_VIDEO_SIGNAL_INFO   targetVideoSignalInfo;
} DISPLAYCONFIG_TARGET_MODE;

typedef struct DISPLAYCONFIG_MODE_INFO
{
    DISPLAYCONFIG_MODE_INFO_TYPE    infoType;
    UINT32                          id;
    LUID                            adapterId;
    union
    {
        DISPLAYCONFIG_TARGET_MODE   targetMode;
        DISPLAYCONFIG_SOURCE_MODE   sourceMode;
    };
} DISPLAYCONFIG_MODE_INFO;



typedef struct DISPLAYCONFIG_PATH_SOURCE_INFO
{
    LUID    adapterId;
    UINT32  id;
    UINT32  modeInfoIdx;
    UINT32  statusFlags;
} DISPLAYCONFIG_PATH_SOURCE_INFO;







typedef struct DISPLAYCONFIG_PATH_TARGET_INFO
{
    LUID                                    adapterId;
    UINT32                                  id;
    UINT32                                  modeInfoIdx;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY   outputTechnology;
    DISPLAYCONFIG_ROTATION                  rotation;
    DISPLAYCONFIG_SCALING                   scaling;
    DISPLAYCONFIG_RATIONAL                  refreshRate;
    DISPLAYCONFIG_SCANLINE_ORDERING         scanLineOrdering;
    BOOL                                    targetAvailable;
    UINT32                                  statusFlags;
} DISPLAYCONFIG_PATH_TARGET_INFO;










typedef struct DISPLAYCONFIG_PATH_INFO
{
    DISPLAYCONFIG_PATH_SOURCE_INFO  sourceInfo;
    DISPLAYCONFIG_PATH_TARGET_INFO  targetInfo;
    UINT32                          flags;
} DISPLAYCONFIG_PATH_INFO;







typedef enum
{
      DISPLAYCONFIG_TOPOLOGY_INTERNAL       = 0x00000001,
      DISPLAYCONFIG_TOPOLOGY_CLONE          = 0x00000002,
      DISPLAYCONFIG_TOPOLOGY_EXTEND         = 0x00000004,
      DISPLAYCONFIG_TOPOLOGY_EXTERNAL       = 0x00000008,
      DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32   = 0xFFFFFFFF
} DISPLAYCONFIG_TOPOLOGY_ID;


typedef enum
{
      DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME             = 1,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME             = 2,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE   = 3,
      DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME            = 4,
      DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE      = 5,
      DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE        = 6,
      DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32                = 0xFFFFFFFF
} DISPLAYCONFIG_DEVICE_INFO_TYPE;

#line 2992 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion


#pragma region Application Family


typedef struct DISPLAYCONFIG_DEVICE_INFO_HEADER
{
    DISPLAYCONFIG_DEVICE_INFO_TYPE  type;
    UINT32                          size;
    LUID                            adapterId;
    UINT32                          id;
} DISPLAYCONFIG_DEVICE_INFO_HEADER;

#line 3007 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct DISPLAYCONFIG_SOURCE_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER            header;
    WCHAR                                       viewGdiDeviceName[32];
} DISPLAYCONFIG_SOURCE_DEVICE_NAME;

typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS
{
    union
    {
        struct
        {
            UINT32  friendlyNameFromEdid : 1;
            UINT32  friendlyNameForced : 1;
            UINT32  edidIdsValid : 1;
            UINT32  reserved : 29;
        };
        UINT32  value;
    };
} DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;

typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER            header;
    DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS      flags;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY       outputTechnology;
    UINT16                                      edidManufactureId;
    UINT16                                      edidProductCodeId;
    UINT32                                      connectorInstance;
    WCHAR                                       monitorFriendlyDeviceName[64];
    WCHAR                                       monitorDevicePath[128];
} DISPLAYCONFIG_TARGET_DEVICE_NAME;

typedef struct DISPLAYCONFIG_TARGET_PREFERRED_MODE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    UINT32                              width;
    UINT32                              height;
    DISPLAYCONFIG_TARGET_MODE           targetMode;
} DISPLAYCONFIG_TARGET_PREFERRED_MODE;

typedef struct DISPLAYCONFIG_ADAPTER_NAME
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    WCHAR                               adapterDevicePath[128];
} DISPLAYCONFIG_ADAPTER_NAME;

typedef struct DISPLAYCONFIG_TARGET_BASE_TYPE {
    DISPLAYCONFIG_DEVICE_INFO_HEADER      header;
    DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY baseOutputTechnology;
} DISPLAYCONFIG_TARGET_BASE_TYPE;

typedef struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE
{
    DISPLAYCONFIG_DEVICE_INFO_HEADER    header;
    union
    {
        struct
        {
            UINT32 bootPersistenceOn    : 1;
            UINT32 reserved             : 31;
        };
        UINT32 value;
    };
} DISPLAYCONFIG_SET_TARGET_PERSISTENCE;

#line 3079 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion
































#line 3113 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"





#pragma region Application Family


typedef struct _RGNDATAHEADER {
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nCount;
    DWORD   nRgnSize;
    RECT    rcBound;
} RGNDATAHEADER, *PRGNDATAHEADER;

typedef struct _RGNDATA {
    RGNDATAHEADER   rdh;
    char            Buffer[1];
} RGNDATA, *PRGNDATA,  *NPRGNDATA,  *LPRGNDATA;

#line 3135 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion






#pragma region Desktop Family


typedef struct _ABC {
    int     abcA;
    UINT    abcB;
    int     abcC;
} ABC, *PABC,  *NPABC,  *LPABC;

typedef struct _ABCFLOAT {
    FLOAT   abcfA;
    FLOAT   abcfB;
    FLOAT   abcfC;
} ABCFLOAT, *PABCFLOAT,  *NPABCFLOAT,  *LPABCFLOAT;

#line 3158 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion







#pragma region Desktop Family


typedef struct _OUTLINETEXTMETRICA {
    UINT    otmSize;
    TEXTMETRICA otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA,  *NPOUTLINETEXTMETRICA,  *LPOUTLINETEXTMETRICA;
typedef struct _OUTLINETEXTMETRICW {
    UINT    otmSize;
    TEXTMETRICW otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
     int    otmsCharSlopeRise;
     int    otmsCharSlopeRun;
     int    otmItalicAngle;
    UINT    otmEMSquare;
     int    otmAscent;
     int    otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
     int    otmMacAscent;
     int    otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
     int    otmsStrikeoutPosition;
     int    otmsUnderscoreSize;
     int    otmsUnderscorePosition;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW,  *NPOUTLINETEXTMETRICW,  *LPOUTLINETEXTMETRICW;






typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC;
typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC;
typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC;
typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC;
#line 3248 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 3250 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion





#line 3257 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Application Family


typedef struct tagPOLYTEXTA
{
    int       x;
    int       y;
    UINT      n;
    LPCSTR    lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTA, *PPOLYTEXTA,  *NPPOLYTEXTA,  *LPPOLYTEXTA;
typedef struct tagPOLYTEXTW
{
    int       x;
    int       y;
    UINT      n;
    LPCWSTR   lpstr;
    UINT      uiFlags;
    RECT      rcl;
    int      *pdx;
} POLYTEXTW, *PPOLYTEXTW,  *NPPOLYTEXTW,  *LPPOLYTEXTW;






typedef POLYTEXTA POLYTEXT;
typedef PPOLYTEXTA PPOLYTEXT;
typedef NPPOLYTEXTA NPPOLYTEXT;
typedef LPPOLYTEXTA LPPOLYTEXT;
#line 3292 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 3294 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct _FIXED {

    WORD    fract;
    short   value;



#line 3307 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
} FIXED;


typedef struct _MAT2 {
     FIXED  eM11;
     FIXED  eM12;
     FIXED  eM21;
     FIXED  eM22;
} MAT2,  *LPMAT2;



typedef struct _GLYPHMETRICS {
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    short   gmCellIncX;
    short   gmCellIncY;
} GLYPHMETRICS,  *LPGLYPHMETRICS;

#line 3328 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion













#line 3343 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



#line 3347 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"







#pragma region Desktop Family


typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, * LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    WORD    wType;
    WORD    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, * LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, * LPTTPOLYGONHEADER;

#line 3378 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion













































#pragma region Desktop Family


typedef struct tagGCP_RESULTSA
    {
    DWORD   lStructSize;
    LPSTR     lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSA, * LPGCP_RESULTSA;
typedef struct tagGCP_RESULTSW
    {
    DWORD   lStructSize;
    LPWSTR    lpOutString;
    UINT  *lpOrder;
    int   *lpDx;
    int   *lpCaretPos;
    LPSTR   lpClass;
    LPWSTR  lpGlyphs;
    UINT    nGlyphs;
    int     nMaxFit;
    } GCP_RESULTSW, * LPGCP_RESULTSW;




typedef GCP_RESULTSA GCP_RESULTS;
typedef LPGCP_RESULTSA LPGCP_RESULTS;
#line 3458 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 3460 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion
#line 3462 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family


typedef struct _RASTERIZER_STATUS {
    short   nSize;
    short   wFlags;
    short   nLanguageID;
} RASTERIZER_STATUS,  *LPRASTERIZER_STATUS;

#line 3473 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion





#pragma region Application Family



typedef struct tagPIXELFORMATDESCRIPTOR
{
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerType;
    BYTE  bReserved;
    DWORD dwLayerMask;
    DWORD dwVisibleMask;
    DWORD dwDamageMask;
} PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR,  *LPPIXELFORMATDESCRIPTOR;

#line 3514 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion


































#pragma region Desktop Family





typedef int (__stdcall* OLDFONTENUMPROCA)(const LOGFONTA *, const TEXTMETRICA *, DWORD, LPARAM);
typedef int (__stdcall* OLDFONTENUMPROCW)(const LOGFONTW *, const TEXTMETRICW *, DWORD, LPARAM);




#line 3562 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"








#line 3571 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

typedef OLDFONTENUMPROCA    FONTENUMPROCA;
typedef OLDFONTENUMPROCW    FONTENUMPROCW;



typedef FONTENUMPROCA FONTENUMPROC;
#line 3579 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

typedef int (__stdcall* GOBJENUMPROC)(LPVOID, LPARAM);
typedef void (__stdcall* LINEDDAPROC)(int, int, LPARAM);











#line 3594 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 3596 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


__declspec(dllimport) int __stdcall AddFontResourceA(  LPCSTR);
__declspec(dllimport) int __stdcall AddFontResourceW(  LPCWSTR);




#line 3610 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

 __declspec(dllimport) BOOL  __stdcall AnimatePalette(   HPALETTE hPal,   UINT iStartIndex,    UINT cEntries,   const PALETTEENTRY * ppe);
 __declspec(dllimport) BOOL  __stdcall Arc(   HDC hdc,   int x1,   int y1,   int x2,   int y2,   int x3,   int y3,   int x4,   int y4);
 __declspec(dllimport) BOOL  __stdcall BitBlt(   HDC hdc,   int x,   int y,   int cx,   int cy,   HDC hdcSrc,   int x1,   int y1,   DWORD rop);
__declspec(dllimport) BOOL  __stdcall CancelDC(   HDC hdc);
 __declspec(dllimport) BOOL  __stdcall Chord(   HDC hdc,   int x1,   int y1,   int x2,   int y2,   int x3,   int y3,   int x4,   int y4);
__declspec(dllimport) int   __stdcall ChoosePixelFormat(   HDC hdc,   const PIXELFORMATDESCRIPTOR *ppfd);
__declspec(dllimport) HMETAFILE  __stdcall CloseMetaFile(   HDC hdc);
__declspec(dllimport) int     __stdcall CombineRgn(   HRGN hrgnDst,   HRGN hrgnSrc1,   HRGN hrgnSrc2,   int iMode);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileA(   HMETAFILE,   LPCSTR);
__declspec(dllimport) HMETAFILE __stdcall CopyMetaFileW(   HMETAFILE,   LPCWSTR);




#line 3626 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
 __declspec(dllimport) HBITMAP __stdcall CreateBitmap(   int nWidth,   int nHeight,   UINT nPlanes,   UINT nBitCount,   const void *lpBits);
 __declspec(dllimport) HBITMAP __stdcall CreateBitmapIndirect(   const BITMAP *pbm);
 __declspec(dllimport) HBRUSH  __stdcall CreateBrushIndirect(   const LOGBRUSH *plbrush);
__declspec(dllimport) HBITMAP __stdcall CreateCompatibleBitmap(   HDC hdc,   int cx,   int cy);
__declspec(dllimport) HBITMAP __stdcall CreateDiscardableBitmap(   HDC hdc,   int cx,   int cy);
__declspec(dllimport) HDC     __stdcall CreateCompatibleDC(   HDC hdc);
__declspec(dllimport) HDC     __stdcall CreateDCA(   LPCSTR pwszDriver,   LPCSTR pwszDevice,   LPCSTR pszPort,   const DEVMODEA * pdm);
__declspec(dllimport) HDC     __stdcall CreateDCW(   LPCWSTR pwszDriver,   LPCWSTR pwszDevice,   LPCWSTR pszPort,   const DEVMODEW * pdm);




#line 3639 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) HBITMAP __stdcall CreateDIBitmap(   HDC hdc,   const BITMAPINFOHEADER *pbmih,   DWORD flInit,   const void *pjBits,   const BITMAPINFO *pbmi,   UINT iUsage);
__declspec(dllimport) HBRUSH  __stdcall CreateDIBPatternBrush(   HGLOBAL h,   UINT iUsage);
 __declspec(dllimport) HBRUSH  __stdcall CreateDIBPatternBrushPt(   const void *lpPackedDIB,   UINT iUsage);
__declspec(dllimport) HRGN    __stdcall CreateEllipticRgn(   int x1,   int y1,   int x2,   int y2);
__declspec(dllimport) HRGN    __stdcall CreateEllipticRgnIndirect(   const RECT *lprect);
 __declspec(dllimport) HFONT   __stdcall CreateFontIndirectA(   const LOGFONTA *lplf);
 __declspec(dllimport) HFONT   __stdcall CreateFontIndirectW(   const LOGFONTW *lplf);




#line 3651 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) HFONT   __stdcall CreateFontA(   int cHeight,   int cWidth,   int cEscapement,   int cOrientation,   int cWeight,   DWORD bItalic,
                               DWORD bUnderline,   DWORD bStrikeOut,   DWORD iCharSet,   DWORD iOutPrecision,   DWORD iClipPrecision,
                               DWORD iQuality,   DWORD iPitchAndFamily,   LPCSTR pszFaceName);
__declspec(dllimport) HFONT   __stdcall CreateFontW(   int cHeight,   int cWidth,   int cEscapement,   int cOrientation,   int cWeight,   DWORD bItalic,
                               DWORD bUnderline,   DWORD bStrikeOut,   DWORD iCharSet,   DWORD iOutPrecision,   DWORD iClipPrecision,
                               DWORD iQuality,   DWORD iPitchAndFamily,   LPCWSTR pszFaceName);




#line 3662 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) HBRUSH  __stdcall CreateHatchBrush(   int iHatch,   COLORREF color);
__declspec(dllimport) HDC     __stdcall CreateICA(   LPCSTR pszDriver,   LPCSTR pszDevice,   LPCSTR pszPort,   const DEVMODEA * pdm);
__declspec(dllimport) HDC     __stdcall CreateICW(   LPCWSTR pszDriver,   LPCWSTR pszDevice,   LPCWSTR pszPort,   const DEVMODEW * pdm);




#line 3671 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) HDC     __stdcall CreateMetaFileA(   LPCSTR pszFile);
__declspec(dllimport) HDC     __stdcall CreateMetaFileW(   LPCWSTR pszFile);




#line 3678 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
 __declspec(dllimport) HPALETTE __stdcall CreatePalette(   const LOGPALETTE * plpal);
__declspec(dllimport) HPEN    __stdcall CreatePen(   int iStyle,   int cWidth,   COLORREF color);
 __declspec(dllimport) HPEN    __stdcall CreatePenIndirect(   const LOGPEN *plpen);
__declspec(dllimport) HRGN    __stdcall CreatePolyPolygonRgn(    const POINT *pptl,
                                                  const INT  *pc,
                                                  int cPoly,
                                                  int iMode);
 __declspec(dllimport) HBRUSH  __stdcall CreatePatternBrush(   HBITMAP hbm);
__declspec(dllimport) HRGN    __stdcall CreateRectRgn(   int x1,   int y1,   int x2,   int y2);
__declspec(dllimport) HRGN    __stdcall CreateRectRgnIndirect(   const RECT *lprect);
__declspec(dllimport) HRGN    __stdcall CreateRoundRectRgn(   int x1,   int y1,   int x2,   int y2,   int w,   int h);
__declspec(dllimport) BOOL    __stdcall CreateScalableFontResourceA(   DWORD fdwHidden,   LPCSTR lpszFont,   LPCSTR lpszFile,   LPCSTR lpszPath);
__declspec(dllimport) BOOL    __stdcall CreateScalableFontResourceW(   DWORD fdwHidden,   LPCWSTR lpszFont,   LPCWSTR lpszFile,   LPCWSTR lpszPath);




#line 3696 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) HBRUSH  __stdcall CreateSolidBrush(   COLORREF color);

__declspec(dllimport) BOOL __stdcall DeleteDC(   HDC hdc);
__declspec(dllimport) BOOL __stdcall DeleteMetaFile(   HMETAFILE hmf);
 __declspec(dllimport) BOOL __stdcall DeleteObject(   HGDIOBJ ho);
__declspec(dllimport) int  __stdcall DescribePixelFormat(    HDC hdc,
                                              int iPixelFormat,
                                              UINT nBytes,
                                              LPPIXELFORMATDESCRIPTOR ppfd);





typedef UINT   (__stdcall* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

typedef DWORD  (__stdcall* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);

#line 3715 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion






































#line 3755 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


















#line 3774 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#line 3775 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

















#line 3793 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesA(
                     LPCSTR         pDevice,
                 LPCSTR         pPort,
                     WORD             fwCapability,
      LPSTR          pOutput,
                 const DEVMODEA   *pDevMode
    );
__declspec(dllimport)
int
__stdcall
DeviceCapabilitiesW(
                     LPCWSTR         pDevice,
                 LPCWSTR         pPort,
                     WORD             fwCapability,
      LPWSTR          pOutput,
                 const DEVMODEW   *pDevMode
    );




#line 3822 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) int  __stdcall DrawEscape(     HDC    hdc,
                                      int    iEscape,
                                      int    cjIn,
                                      LPCSTR lpIn);

 __declspec(dllimport) BOOL __stdcall Ellipse(   HDC hdc,   int left,   int top,    int right,   int bottom);


__declspec(dllimport) int  __stdcall EnumFontFamiliesExA(   HDC hdc,   LPLOGFONTA lpLogfont,   FONTENUMPROCA lpProc,   LPARAM lParam,   DWORD dwFlags);
__declspec(dllimport) int  __stdcall EnumFontFamiliesExW(   HDC hdc,   LPLOGFONTW lpLogfont,   FONTENUMPROCW lpProc,   LPARAM lParam,   DWORD dwFlags);




#line 3838 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#line 3839 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) int  __stdcall EnumFontFamiliesA(   HDC hdc,   LPCSTR lpLogfont,   FONTENUMPROCA lpProc,   LPARAM lParam);
__declspec(dllimport) int  __stdcall EnumFontFamiliesW(   HDC hdc,   LPCWSTR lpLogfont,   FONTENUMPROCW lpProc,   LPARAM lParam);




#line 3847 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) int  __stdcall EnumFontsA(   HDC hdc,   LPCSTR lpLogfont,    FONTENUMPROCA lpProc,   LPARAM lParam);
__declspec(dllimport) int  __stdcall EnumFontsW(   HDC hdc,   LPCWSTR lpLogfont,    FONTENUMPROCW lpProc,   LPARAM lParam);




#line 3854 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


__declspec(dllimport) int  __stdcall EnumObjects(   HDC hdc,   int nType,   GOBJENUMPROC lpFunc,   LPARAM lParam);


#line 3860 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


__declspec(dllimport) BOOL __stdcall EqualRgn(   HRGN hrgn1,   HRGN hrgn2);
 __declspec(dllimport) int  __stdcall Escape(     HDC hdc,
                                  int iEscape,
                                  int cjIn,
                                  LPCSTR pvIn,
                                  LPVOID pvOut);
__declspec(dllimport) int  __stdcall ExtEscape(      HDC hdc,
                                      int iEscape,
                                      int cjInput,
                                      LPCSTR lpInData,
                                      int cjOutput,
                                      LPSTR lpOutData);
 __declspec(dllimport) int  __stdcall ExcludeClipRect(   HDC hdc,   int left,   int top,   int right,   int bottom);
 __declspec(dllimport) HRGN __stdcall ExtCreateRegion(   const XFORM * lpx,   DWORD nCount,   const RGNDATA * lpData);
 __declspec(dllimport) BOOL __stdcall ExtFloodFill(   HDC hdc,   int x,   int y,   COLORREF color,   UINT type);
 __declspec(dllimport) BOOL __stdcall FillRgn(   HDC hdc,   HRGN hrgn,   HBRUSH hbr);
 __declspec(dllimport) BOOL __stdcall FloodFill(   HDC hdc,   int x,   int y,   COLORREF color);
 __declspec(dllimport) BOOL __stdcall FrameRgn(   HDC hdc,   HRGN hrgn,   HBRUSH hbr,   int w,   int h);
__declspec(dllimport) int  __stdcall GetROP2(   HDC hdc);
__declspec(dllimport) BOOL __stdcall GetAspectRatioFilterEx(   HDC hdc,   LPSIZE lpsize);
__declspec(dllimport) COLORREF __stdcall GetBkColor(   HDC hdc);


__declspec(dllimport) COLORREF __stdcall GetDCBrushColor(   HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetDCPenColor(   HDC hdc);
#line 3888 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport)
int
__stdcall
GetBkMode(
      HDC hdc
    );

__declspec(dllimport)
LONG
__stdcall
GetBitmapBits(
      HBITMAP hbit,
      LONG cb,
      LPVOID lpvBits
    );

__declspec(dllimport) BOOL  __stdcall GetBitmapDimensionEx(   HBITMAP hbit,   LPSIZE lpsize);
__declspec(dllimport) UINT  __stdcall GetBoundsRect(   HDC hdc,   LPRECT lprect,   UINT flags);

__declspec(dllimport) BOOL  __stdcall GetBrushOrgEx(   HDC hdc,   LPPOINT lppt);

__declspec(dllimport) BOOL  __stdcall GetCharWidthA(   HDC hdc,   UINT iFirst,   UINT iLast,   LPINT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidthW(   HDC hdc,   UINT iFirst,   UINT iLast,   LPINT lpBuffer);




#line 3917 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetCharWidth32A(   HDC hdc,   UINT iFirst,   UINT iLast,    LPINT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidth32W(   HDC hdc,   UINT iFirst,   UINT iLast,    LPINT lpBuffer);




#line 3924 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetCharWidthFloatA(   HDC hdc,   UINT iFirst,   UINT iLast,   PFLOAT lpBuffer);
__declspec(dllimport) BOOL  __stdcall GetCharWidthFloatW(   HDC hdc,   UINT iFirst,   UINT iLast,   PFLOAT lpBuffer);




#line 3931 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsA(   HDC hdc,
                                              UINT wFirst,
                                              UINT wLast,
                                              LPABC lpABC);
__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsW(   HDC hdc,
                                              UINT wFirst,
                                              UINT wLast,
                                              LPABC lpABC);




#line 3945 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsFloatA(   HDC hdc,   UINT iFirst,   UINT iLast,   LPABCFLOAT lpABC);
__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsFloatW(   HDC hdc,   UINT iFirst,   UINT iLast,   LPABCFLOAT lpABC);




#line 3953 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) int   __stdcall GetClipBox(   HDC hdc,    LPRECT lprect);
__declspec(dllimport) int   __stdcall GetClipRgn(   HDC hdc,   HRGN hrgn);
__declspec(dllimport) int   __stdcall GetMetaRgn(   HDC hdc,   HRGN hrgn);
__declspec(dllimport) HGDIOBJ __stdcall GetCurrentObject(   HDC hdc,   UINT type);
__declspec(dllimport) BOOL  __stdcall GetCurrentPositionEx(   HDC hdc,    LPPOINT lppt);
__declspec(dllimport) int   __stdcall GetDeviceCaps(   HDC hdc,   int index);
__declspec(dllimport) int   __stdcall GetDIBits(   HDC hdc,   HBITMAP hbm,   UINT start,   UINT cLines,
      LPVOID lpvBits,  LPBITMAPINFO lpbmi,   UINT usage);  

 
__declspec(dllimport) DWORD __stdcall GetFontData (      HDC     hdc,
                                          DWORD   dwTable,
                                          DWORD   dwOffset,
                                          PVOID pvBuffer,
                                          DWORD   cjBuffer
                                        );

__declspec(dllimport) DWORD __stdcall GetGlyphOutlineA(      HDC hdc,
                                              UINT uChar,
                                              UINT fuFormat,
                                              LPGLYPHMETRICS lpgm,
                                              DWORD cjBuffer,
                                              LPVOID pvBuffer,
                                              const MAT2 *lpmat2
                                        );
__declspec(dllimport) DWORD __stdcall GetGlyphOutlineW(      HDC hdc,
                                              UINT uChar,
                                              UINT fuFormat,
                                              LPGLYPHMETRICS lpgm,
                                              DWORD cjBuffer,
                                              LPVOID pvBuffer,
                                              const MAT2 *lpmat2
                                        );




#line 3991 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) int   __stdcall GetGraphicsMode(   HDC hdc);
__declspec(dllimport) int   __stdcall GetMapMode(   HDC hdc);
__declspec(dllimport) UINT  __stdcall GetMetaFileBitsEx(  HMETAFILE hMF,   UINT cbBuffer,   LPVOID lpData);
__declspec(dllimport) HMETAFILE   __stdcall GetMetaFileA(   LPCSTR lpName);
__declspec(dllimport) HMETAFILE   __stdcall GetMetaFileW(   LPCWSTR lpName);




#line 4002 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) COLORREF __stdcall GetNearestColor(   HDC hdc,   COLORREF color);
__declspec(dllimport) UINT  __stdcall GetNearestPaletteIndex(   HPALETTE h,   COLORREF color);
__declspec(dllimport) DWORD __stdcall GetObjectType(   HGDIOBJ h);



__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsA(   HDC hdc,
                                                  UINT cjCopy,
                                                  LPOUTLINETEXTMETRICA potm);
__declspec(dllimport) UINT __stdcall GetOutlineTextMetricsW(   HDC hdc,
                                                  UINT cjCopy,
                                                  LPOUTLINETEXTMETRICW potm);




#line 4019 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 4021 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

 
__declspec(dllimport) UINT  __stdcall GetPaletteEntries(     HPALETTE hpal,
                                              UINT iStart,
                                              UINT cEntries,
                                              LPPALETTEENTRY pPalEntries);
__declspec(dllimport) COLORREF __stdcall GetPixel(   HDC hdc,   int x,   int y);
__declspec(dllimport) int   __stdcall GetPixelFormat(   HDC hdc);
__declspec(dllimport) int   __stdcall GetPolyFillMode(   HDC hdc);
__declspec(dllimport) BOOL  __stdcall GetRasterizerCaps(     LPRASTERIZER_STATUS lpraststat,
                                              UINT cjBytes);

__declspec(dllimport) int   __stdcall GetRandomRgn (  HDC hdc,   HRGN hrgn,   INT i);
__declspec(dllimport) DWORD __stdcall GetRegionData(     HRGN hrgn,
                                          DWORD nCount,
                                          LPRGNDATA lpRgnData);
__declspec(dllimport) int   __stdcall GetRgnBox(   HRGN hrgn,    LPRECT lprc);
__declspec(dllimport) HGDIOBJ __stdcall GetStockObject(   int i);
__declspec(dllimport) int   __stdcall GetStretchBltMode(  HDC hdc);
__declspec(dllimport)
UINT
__stdcall
GetSystemPaletteEntries(
      HDC  hdc,
      UINT iStart,
      UINT cEntries,
      LPPALETTEENTRY pPalEntries
    );

__declspec(dllimport) UINT  __stdcall GetSystemPaletteUse(  HDC hdc);
__declspec(dllimport) int   __stdcall GetTextCharacterExtra(  HDC hdc);
__declspec(dllimport) UINT  __stdcall GetTextAlign(  HDC hdc);
__declspec(dllimport) COLORREF __stdcall GetTextColor(  HDC hdc);

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointA(
      HDC hdc,
      LPCSTR lpString,
      int c,
      LPSIZE lpsz
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPointW(
      HDC hdc,
      LPCWSTR lpString,
      int c,
      LPSIZE lpsz
    );




#line 4078 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32A(
      HDC hdc,
      LPCSTR lpString,
      int c,
      LPSIZE psizl
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentPoint32W(
      HDC hdc,
      LPCWSTR lpString,
      int c,
      LPSIZE psizl
    );




#line 4102 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointA(
      HDC hdc,
      LPCSTR lpszString,
      int cchString,
      int nMaxExtent,
      LPINT lpnFit,
      LPINT lpnDx,
      LPSIZE lpSize
    );
__declspec(dllimport)
BOOL
__stdcall
GetTextExtentExPointW(
      HDC hdc,
      LPCWSTR lpszString,
      int cchString,
      int nMaxExtent,
      LPINT lpnFit,
      LPINT lpnDx,
      LPSIZE lpSize
    );




#line 4132 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


__declspec(dllimport) int __stdcall GetTextCharset(   HDC hdc);
__declspec(dllimport) int __stdcall GetTextCharsetInfo(   HDC hdc,   LPFONTSIGNATURE lpSig,   DWORD dwFlags);
__declspec(dllimport) BOOL __stdcall TranslateCharsetInfo(   DWORD  *lpSrc,    LPCHARSETINFO lpCs,   DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetFontLanguageInfo(   HDC hdc);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementA(    HDC hdc,   LPCSTR lpString,   int nCount,   int nMexExtent,   LPGCP_RESULTSA lpResults,   DWORD dwFlags);
__declspec(dllimport) DWORD __stdcall GetCharacterPlacementW(    HDC hdc,   LPCWSTR lpString,   int nCount,   int nMexExtent,   LPGCP_RESULTSW lpResults,   DWORD dwFlags);




#line 4145 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#line 4146 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 4148 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagWCRANGE
{
    WCHAR  wcLow;
    USHORT cGlyphs;
} WCRANGE, *PWCRANGE, *LPWCRANGE;


typedef struct tagGLYPHSET
{
    DWORD    cbThis;
    DWORD    flAccel;
    DWORD    cGlyphsSupported;
    DWORD    cRanges;
    WCRANGE  ranges[1];
} GLYPHSET, *PGLYPHSET,  *LPGLYPHSET;









__declspec(dllimport) DWORD __stdcall GetFontUnicodeRanges(   HDC hdc,   LPGLYPHSET lpgs);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesA(   HDC hdc,   LPCSTR lpstr,   int c,   LPWORD pgi,   DWORD fl);
__declspec(dllimport) DWORD __stdcall GetGlyphIndicesW(   HDC hdc,   LPCWSTR lpstr,   int c,   LPWORD pgi,   DWORD fl);




#line 4187 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall GetTextExtentPointI(  HDC hdc,   LPWORD pgiIn,   int cgi,   LPSIZE psize);
__declspec(dllimport) BOOL  __stdcall GetTextExtentExPointI (    HDC hdc,
                                                  LPWORD lpwszString,
                                                  int cwchString,
                                                  int nMaxExtent,
                                                  LPINT lpnFit,
                                                  LPINT lpnDx,
                                                  LPSIZE lpSize
                                                );

__declspec(dllimport) BOOL  __stdcall GetCharWidthI(     HDC hdc,
                                          UINT giFirst,
                                          UINT cgi,
                                          LPWORD pgi,
                                          LPINT piWidths
                                        );

__declspec(dllimport) BOOL  __stdcall GetCharABCWidthsI(     HDC    hdc,
                                              UINT   giFirst,
                                              UINT   cgi,
                                              LPWORD pgi,
                                              LPABC  pabc
                                        );








typedef struct tagDESIGNVECTOR
{
    DWORD  dvReserved;
    DWORD  dvNumAxes;
    LONG   dvValues[16];
} DESIGNVECTOR, *PDESIGNVECTOR,  *LPDESIGNVECTOR;

__declspec(dllimport) int  __stdcall AddFontResourceExA(   LPCSTR name,   DWORD fl,   PVOID res);
__declspec(dllimport) int  __stdcall AddFontResourceExW(   LPCWSTR name,   DWORD fl,   PVOID res);




#line 4232 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExA(   LPCSTR name,   DWORD fl,   PVOID pdv);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceExW(   LPCWSTR name,   DWORD fl,   PVOID pdv);




#line 4239 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) HANDLE __stdcall AddFontMemResourceEx(     PVOID pFileView,
                                                  DWORD cjSize,
                                                  PVOID pvResrved,
                                                  DWORD* pNumFonts);

__declspec(dllimport) BOOL __stdcall RemoveFontMemResourceEx(   HANDLE h);









typedef struct tagAXISINFOA
{
    LONG   axMinValue;
    LONG   axMaxValue;
    BYTE   axAxisName[16];
} AXISINFOA, *PAXISINFOA,  *LPAXISINFOA;
typedef struct tagAXISINFOW
{
    LONG   axMinValue;
    LONG   axMaxValue;
    WCHAR  axAxisName[16];
} AXISINFOW, *PAXISINFOW,  *LPAXISINFOW;





typedef AXISINFOA AXISINFO;
typedef PAXISINFOA PAXISINFO;
typedef LPAXISINFOA LPAXISINFO;
#line 4275 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

typedef struct tagAXESLISTA
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOA axlAxisInfo[16];
} AXESLISTA, *PAXESLISTA,  *LPAXESLISTA;
typedef struct tagAXESLISTW
{
    DWORD     axlReserved;
    DWORD     axlNumAxes;
    AXISINFOW axlAxisInfo[16];
} AXESLISTW, *PAXESLISTW,  *LPAXESLISTW;





typedef AXESLISTA AXESLIST;
typedef PAXESLISTA PAXESLIST;
typedef LPAXESLISTA LPAXESLIST;
#line 4297 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"





typedef struct tagENUMLOGFONTEXDVA
{
    ENUMLOGFONTEXA elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA,  *LPENUMLOGFONTEXDVA;
typedef struct tagENUMLOGFONTEXDVW
{
    ENUMLOGFONTEXW elfEnumLogfontEx;
    DESIGNVECTOR   elfDesignVector;
} ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW,  *LPENUMLOGFONTEXDVW;





typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV;
typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV;
typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV;
#line 4321 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) HFONT  __stdcall CreateFontIndirectExA(   const ENUMLOGFONTEXDVA *);
__declspec(dllimport) HFONT  __stdcall CreateFontIndirectExW(   const ENUMLOGFONTEXDVW *);




#line 4329 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


typedef struct tagENUMTEXTMETRICA
{
    NEWTEXTMETRICEXA etmNewTextMetricEx;
    AXESLISTA        etmAxesList;
} ENUMTEXTMETRICA, *PENUMTEXTMETRICA,  *LPENUMTEXTMETRICA;
typedef struct tagENUMTEXTMETRICW
{
    NEWTEXTMETRICEXW etmNewTextMetricEx;
    AXESLISTW        etmAxesList;
} ENUMTEXTMETRICW, *PENUMTEXTMETRICW,  *LPENUMTEXTMETRICW;





typedef ENUMTEXTMETRICA ENUMTEXTMETRIC;
typedef PENUMTEXTMETRICA PENUMTEXTMETRIC;
typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC;
#line 4350 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#line 4351 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 4353 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 4356 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family


__declspec(dllimport) BOOL  __stdcall GetViewportExtEx(   HDC hdc,   LPSIZE lpsize);
__declspec(dllimport) BOOL  __stdcall GetViewportOrgEx(   HDC hdc,   LPPOINT lppoint);
__declspec(dllimport) BOOL  __stdcall GetWindowExtEx(   HDC hdc,   LPSIZE lpsize);
__declspec(dllimport) BOOL  __stdcall GetWindowOrgEx(   HDC hdc,   LPPOINT lppoint);

 __declspec(dllimport) int  __stdcall IntersectClipRect(   HDC hdc,   int left,   int top,   int right,   int bottom);
 __declspec(dllimport) BOOL __stdcall InvertRgn(   HDC hdc,   HRGN hrgn);
__declspec(dllimport) BOOL __stdcall LineDDA(   int xStart,   int yStart,   int xEnd,   int yEnd,   LINEDDAPROC lpProc,   LPARAM data);
 __declspec(dllimport) BOOL __stdcall LineTo(   HDC hdc,   int x,   int y);
__declspec(dllimport) BOOL __stdcall MaskBlt(   HDC hdcDest,   int xDest,   int yDest,   int width,   int height,
                HDC hdcSrc,   int xSrc,   int ySrc,   HBITMAP hbmMask,   int xMask,   int yMask,   DWORD rop);
__declspec(dllimport) BOOL __stdcall PlgBlt(   HDC hdcDest,   const POINT * lpPoint,   HDC hdcSrc,   int xSrc,   int ySrc,   int width,
                       int height,   HBITMAP hbmMask,   int xMask,   int yMask);

 __declspec(dllimport) int  __stdcall OffsetClipRgn(  HDC hdc,   int x,   int y);
__declspec(dllimport) int  __stdcall OffsetRgn(  HRGN hrgn,   int x,   int y);
 __declspec(dllimport) BOOL __stdcall PatBlt(  HDC hdc,   int x,   int y,   int w,   int h,   DWORD rop);
 __declspec(dllimport) BOOL __stdcall Pie(  HDC hdc,   int left,   int top,   int right,   int bottom,   int xr1,   int yr1,   int xr2,   int yr2);
__declspec(dllimport) BOOL __stdcall PlayMetaFile(  HDC hdc,   HMETAFILE hmf);
 __declspec(dllimport) BOOL __stdcall PaintRgn(  HDC hdc,   HRGN hrgn);
 __declspec(dllimport) BOOL __stdcall PolyPolygon(  HDC hdc,    const POINT *apt,    const INT *asz,    int csz);
__declspec(dllimport) BOOL __stdcall PtInRegion(  HRGN hrgn,   int x,   int y);
__declspec(dllimport) BOOL __stdcall PtVisible(  HDC hdc,   int x,   int y);
__declspec(dllimport) BOOL __stdcall RectInRegion(  HRGN hrgn,   const RECT * lprect);
__declspec(dllimport) BOOL __stdcall RectVisible(  HDC hdc,   const RECT * lprect);
 __declspec(dllimport) BOOL __stdcall Rectangle(  HDC hdc,   int left,   int top,   int right,   int bottom);
 __declspec(dllimport) BOOL __stdcall RestoreDC(  HDC hdc,   int nSavedDC);
 __declspec(dllimport) HDC  __stdcall ResetDCA(  HDC hdc,   const DEVMODEA * lpdm);
 __declspec(dllimport) HDC  __stdcall ResetDCW(  HDC hdc,   const DEVMODEW * lpdm);




#line 4394 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
 __declspec(dllimport) UINT __stdcall RealizePalette(  HDC hdc);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceA(  LPCSTR lpFileName);
__declspec(dllimport) BOOL __stdcall RemoveFontResourceW(  LPCWSTR lpFileName);




#line 4402 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
 __declspec(dllimport) BOOL  __stdcall RoundRect(  HDC hdc,   int left,   int top,   int right,   int bottom,   int width,   int height);
 __declspec(dllimport) BOOL __stdcall ResizePalette(  HPALETTE hpal,   UINT n);

 __declspec(dllimport) int  __stdcall SaveDC(  HDC hdc);
 __declspec(dllimport) int  __stdcall SelectClipRgn(  HDC hdc,   HRGN hrgn);
__declspec(dllimport) int  __stdcall ExtSelectClipRgn(  HDC hdc,   HRGN hrgn,   int mode);
__declspec(dllimport) int  __stdcall SetMetaRgn(  HDC hdc);
 __declspec(dllimport) HGDIOBJ __stdcall SelectObject(  HDC hdc,   HGDIOBJ h);
 __declspec(dllimport) HPALETTE __stdcall SelectPalette(  HDC hdc,   HPALETTE hPal,   BOOL bForceBkgd);
 __declspec(dllimport) COLORREF __stdcall SetBkColor(  HDC hdc,   COLORREF color);


__declspec(dllimport) COLORREF __stdcall SetDCBrushColor(  HDC hdc,   COLORREF color);
__declspec(dllimport) COLORREF __stdcall SetDCPenColor(  HDC hdc,   COLORREF color);
#line 4417 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

 __declspec(dllimport) int   __stdcall SetBkMode(  HDC hdc,   int mode);

__declspec(dllimport)
LONG __stdcall
SetBitmapBits(
      HBITMAP hbm,
      DWORD cb,
      const void *pvBits);

__declspec(dllimport) UINT  __stdcall SetBoundsRect(  HDC hdc,   const RECT * lprect,   UINT flags);
__declspec(dllimport) int   __stdcall SetDIBits(  HDC hdc,   HBITMAP hbm,   UINT start,   UINT cLines,   const void *lpBits,   const BITMAPINFO * lpbmi,   UINT ColorUse);
 __declspec(dllimport) int   __stdcall SetDIBitsToDevice(  HDC hdc,   int xDest,   int yDest,   DWORD w,   DWORD h,   int xSrc,
          int ySrc,   UINT StartScan,   UINT cLines,   const void * lpvBits,   const BITMAPINFO * lpbmi,   UINT ColorUse);
 __declspec(dllimport) DWORD __stdcall SetMapperFlags(  HDC hdc,   DWORD flags);
__declspec(dllimport) int   __stdcall SetGraphicsMode(  HDC hdc,   int iMode);
 __declspec(dllimport) int   __stdcall SetMapMode(  HDC hdc,   int iMode);


 __declspec(dllimport) DWORD __stdcall SetLayout(  HDC hdc,   DWORD l);
__declspec(dllimport) DWORD __stdcall GetLayout(  HDC hdc);
#line 4439 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) HMETAFILE   __stdcall SetMetaFileBitsEx(  UINT cbBuffer,   const BYTE *lpData);
 __declspec(dllimport) UINT  __stdcall SetPaletteEntries(     HPALETTE hpal,
                                              UINT iStart,
                                              UINT cEntries,
                                              const PALETTEENTRY *pPalEntries);
 __declspec(dllimport) COLORREF __stdcall SetPixel(  HDC hdc,   int x,   int y,   COLORREF color);
__declspec(dllimport) BOOL   __stdcall SetPixelV(  HDC hdc,   int x,   int y,   COLORREF color);
__declspec(dllimport) BOOL  __stdcall SetPixelFormat(  HDC hdc,   int format,   const PIXELFORMATDESCRIPTOR * ppfd);
 __declspec(dllimport) int   __stdcall SetPolyFillMode(  HDC hdc,   int mode);
 __declspec(dllimport) BOOL  __stdcall StretchBlt(  HDC hdcDest,   int xDest,   int yDest,   int wDest,   int hDest,   HDC hdcSrc,   int xSrc,   int ySrc,   int wSrc,   int hSrc,   DWORD rop);
__declspec(dllimport) BOOL   __stdcall SetRectRgn(  HRGN hrgn,   int left,   int top,   int right,   int bottom);
 __declspec(dllimport) int   __stdcall StretchDIBits(  HDC hdc,   int xDest,   int yDest,   int DestWidth,   int DestHeight,   int xSrc,   int ySrc,   int SrcWidth,   int SrcHeight,
          const void * lpBits,   const BITMAPINFO * lpbmi,   UINT iUsage,   DWORD rop);
 __declspec(dllimport) int   __stdcall SetROP2(  HDC hdc,   int rop2);
 __declspec(dllimport) int   __stdcall SetStretchBltMode(  HDC hdc,   int mode);
__declspec(dllimport) UINT  __stdcall SetSystemPaletteUse(  HDC hdc,   UINT use);
 __declspec(dllimport) int   __stdcall SetTextCharacterExtra(  HDC hdc,   int extra);
 __declspec(dllimport) COLORREF __stdcall SetTextColor(  HDC hdc,   COLORREF color);
 __declspec(dllimport) UINT  __stdcall SetTextAlign(  HDC hdc,   UINT align);
 __declspec(dllimport) BOOL  __stdcall SetTextJustification(  HDC hdc,   int extra,   int count);
__declspec(dllimport) BOOL  __stdcall UpdateColors(  HDC hdc);

#line 4463 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion












































#pragma region Application Family


typedef USHORT COLOR16;

typedef struct _TRIVERTEX
{
    LONG    x;
    LONG    y;
    COLOR16 Red;
    COLOR16 Green;
    COLOR16 Blue;
    COLOR16 Alpha;
}TRIVERTEX,*PTRIVERTEX,*LPTRIVERTEX;

#line 4524 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family


typedef struct _GRADIENT_TRIANGLE
{
    ULONG Vertex1;
    ULONG Vertex2;
    ULONG Vertex3;
} GRADIENT_TRIANGLE,*PGRADIENT_TRIANGLE,*LPGRADIENT_TRIANGLE;

typedef struct _GRADIENT_RECT
{
    ULONG UpperLeft;
    ULONG LowerRight;
}GRADIENT_RECT,*PGRADIENT_RECT,*LPGRADIENT_RECT;

#line 4543 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Application Family


typedef struct _BLENDFUNCTION
{
    BYTE   BlendOp;
    BYTE   BlendFlags;
    BYTE   SourceConstantAlpha;
    BYTE   AlphaFormat;
}BLENDFUNCTION,*PBLENDFUNCTION;

#line 4557 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#pragma region Desktop Family















__declspec(dllimport) BOOL __stdcall AlphaBlend(
      HDC hdcDest,
      int xoriginDest,
      int yoriginDest,
      int wDest,
      int hDest,
      HDC hdcSrc,
      int xoriginSrc,
      int yoriginSrc,
      int wSrc,
      int hSrc,
      BLENDFUNCTION ftn);

__declspec(dllimport) BOOL __stdcall TransparentBlt(
      HDC hdcDest,
      int xoriginDest,
      int yoriginDest,
      int wDest,
      int hDest,
      HDC hdcSrc,
      int xoriginSrc,
      int yoriginSrc,
      int wSrc,
      int hSrc,
      UINT crTransparent);











__declspec(dllimport)
BOOL
__stdcall
GradientFill(
      HDC hdc,
      PTRIVERTEX pVertex,
      ULONG nVertex,
      PVOID pMesh,
      ULONG nMesh,
      ULONG ulMode
    );

#line 4624 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 4627 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family





__declspec(dllimport) BOOL  __stdcall GdiAlphaBlend(  HDC hdcDest,   int xoriginDest,   int yoriginDest,   int wDest,   int hDest,   HDC hdcSrc,   int xoriginSrc,   int yoriginSrc,   int wSrc,   int hSrc,   BLENDFUNCTION ftn);

__declspec(dllimport) BOOL  __stdcall GdiTransparentBlt(  HDC hdcDest,  int xoriginDest,   int yoriginDest,   int wDest,   int hDest,   HDC hdcSrc,
                                             int xoriginSrc,   int yoriginSrc,   int wSrc,   int hSrc,   UINT crTransparent);

__declspec(dllimport) BOOL  __stdcall GdiGradientFill(   HDC hdc,
                                          PTRIVERTEX pVertex,
                                          ULONG nVertex,
                                          PVOID pMesh,
                                          ULONG nCount,
                                          ULONG ulMode);

#line 4647 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"





__declspec(dllimport) BOOL  __stdcall PlayMetaFileRecord(    HDC hdc,
                                              LPHANDLETABLE lpHandleTable,
                                              LPMETARECORD lpMR,
                                              UINT noObjs);

typedef int (__stdcall* MFENUMPROC)(   HDC hdc,   HANDLETABLE * lpht,   METARECORD * lpMR,   int nObj,   LPARAM param);
__declspec(dllimport) BOOL  __stdcall EnumMetaFile(   HDC hdc,   HMETAFILE hmf,   MFENUMPROC proc,   LPARAM param);

typedef int (__stdcall* ENHMFENUMPROC)(  HDC hdc,   HANDLETABLE * lpht,   const ENHMETARECORD * lpmr,   int nHandles,   LPARAM data);



__declspec(dllimport) HENHMETAFILE __stdcall CloseEnhMetaFile(   HDC hdc);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileA(   HENHMETAFILE hEnh,   LPCSTR lpFileName);
__declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileW(   HENHMETAFILE hEnh,   LPCWSTR lpFileName);




#line 4672 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) HDC   __stdcall CreateEnhMetaFileA(   HDC hdc,   LPCSTR lpFilename,   const RECT *lprc,   LPCSTR lpDesc);
__declspec(dllimport) HDC   __stdcall CreateEnhMetaFileW(   HDC hdc,   LPCWSTR lpFilename,   const RECT *lprc,   LPCWSTR lpDesc);




#line 4679 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall DeleteEnhMetaFile(   HENHMETAFILE hmf);
__declspec(dllimport) BOOL  __stdcall EnumEnhMetaFile(   HDC hdc,   HENHMETAFILE hmf,   ENHMFENUMPROC proc,
                                          LPVOID param,   const RECT * lpRect);
__declspec(dllimport) HENHMETAFILE  __stdcall GetEnhMetaFileA(   LPCSTR lpName);
__declspec(dllimport) HENHMETAFILE  __stdcall GetEnhMetaFileW(   LPCWSTR lpName);




#line 4689 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileBits(    HENHMETAFILE hEMF,
                                              UINT nSize,
                                              LPBYTE lpData);
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileDescriptionA(    HENHMETAFILE hemf,
                                                      UINT cchBuffer,
                                                      LPSTR lpDescription);
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileDescriptionW(    HENHMETAFILE hemf,
                                                      UINT cchBuffer,
                                                      LPWSTR lpDescription);




#line 4703 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) UINT  __stdcall GetEnhMetaFileHeader(      HENHMETAFILE hemf,
                                                  UINT nSize,
                                                  LPENHMETAHEADER lpEnhMetaHeader);
__declspec(dllimport) UINT  __stdcall GetEnhMetaFilePaletteEntries(  HENHMETAFILE hemf,
                                                      UINT nNumEntries,
                                                      LPPALETTEENTRY lpPaletteEntries);

__declspec(dllimport) UINT  __stdcall GetEnhMetaFilePixelFormat(     HENHMETAFILE hemf,
                                                      UINT cbBuffer,
                                                      PIXELFORMATDESCRIPTOR *ppfd);
__declspec(dllimport) UINT  __stdcall GetWinMetaFileBits(    HENHMETAFILE hemf,
                                              UINT cbData16,
                                              LPBYTE pData16,
                                              INT iMapMode,
                                              HDC hdcRef);
__declspec(dllimport) BOOL  __stdcall PlayEnhMetaFile(   HDC hdc,   HENHMETAFILE hmf,   const RECT * lprect);
__declspec(dllimport) BOOL  __stdcall PlayEnhMetaFileRecord(     HDC hdc,
                                                  LPHANDLETABLE pht,
                                                  const ENHMETARECORD *pmr,
                                                  UINT cht);

__declspec(dllimport) HENHMETAFILE  __stdcall SetEnhMetaFileBits(    UINT nSize,
                                                      const BYTE * pb);

__declspec(dllimport) HENHMETAFILE  __stdcall SetWinMetaFileBits(    UINT nSize,
                                                      const BYTE *lpMeta16Data,
                                                      HDC hdcRef,
                                                      const METAFILEPICT *lpMFP);
__declspec(dllimport) BOOL  __stdcall GdiComment(  HDC hdc,   UINT nSize,   const BYTE *lpData);

#line 4734 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



__declspec(dllimport) BOOL __stdcall GetTextMetricsA(   HDC hdc,   LPTEXTMETRICA lptm);
__declspec(dllimport) BOOL __stdcall GetTextMetricsW(   HDC hdc,   LPTEXTMETRICW lptm);




#line 4744 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



















#line 4764 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 4766 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



typedef struct tagDIBSECTION {
    BITMAP       dsBm;
    BITMAPINFOHEADER    dsBmih;
    DWORD               dsBitfields[3];
    HANDLE              dshSection;
    DWORD               dsOffset;
} DIBSECTION,  *LPDIBSECTION, *PDIBSECTION;


__declspec(dllimport) BOOL __stdcall AngleArc(   HDC hdc,   int x,   int y,   DWORD r,   FLOAT StartAngle,   FLOAT SweepAngle);
__declspec(dllimport) BOOL __stdcall PolyPolyline(  HDC hdc,   const POINT *apt,   const DWORD *asz,   DWORD csz);
__declspec(dllimport) BOOL __stdcall GetWorldTransform(   HDC hdc,   LPXFORM lpxf);
__declspec(dllimport) BOOL __stdcall SetWorldTransform(   HDC hdc,   const XFORM * lpxf);
__declspec(dllimport) BOOL __stdcall ModifyWorldTransform(   HDC hdc,   const XFORM * lpxf,   DWORD mode);
__declspec(dllimport) BOOL __stdcall CombineTransform(   LPXFORM lpxfOut,   const XFORM *lpxf1,   const XFORM *lpxf2);






__declspec(dllimport)   HBITMAP __stdcall CreateDIBSection(
             HDC               hdc,
                 const BITMAPINFO *pbmi,
                 UINT              usage,
    
    
                    void            **ppvBits,
             HANDLE            hSection,
                 DWORD             offset);


 
__declspec(dllimport) UINT __stdcall GetDIBColorTable(   HDC  hdc,
                                          UINT iStart,
                                          UINT cEntries,
                                          RGBQUAD *prgbq);
__declspec(dllimport) UINT __stdcall SetDIBColorTable(   HDC  hdc,
                                          UINT iStart,
                                          UINT cEntries,
                                          const RGBQUAD *prgbq);




































typedef struct  tagCOLORADJUSTMENT {
    WORD   caSize;
    WORD   caFlags;
    WORD   caIlluminantIndex;
    WORD   caRedGamma;
    WORD   caGreenGamma;
    WORD   caBlueGamma;
    WORD   caReferenceBlack;
    WORD   caReferenceWhite;
    SHORT  caContrast;
    SHORT  caBrightness;
    SHORT  caColorfulness;
    SHORT  caRedGreenTint;
} COLORADJUSTMENT, *PCOLORADJUSTMENT,  *LPCOLORADJUSTMENT;

__declspec(dllimport) BOOL __stdcall SetColorAdjustment(   HDC hdc,   const COLORADJUSTMENT *lpca);
__declspec(dllimport) BOOL __stdcall GetColorAdjustment(   HDC hdc,   LPCOLORADJUSTMENT lpca);
__declspec(dllimport) HPALETTE __stdcall CreateHalftonePalette(   HDC hdc);


typedef BOOL (__stdcall* ABORTPROC)(   HDC,   int);


#line 4870 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

typedef struct _DOCINFOA {
    int     cbSize;
    LPCSTR   lpszDocName;
    LPCSTR   lpszOutput;

    LPCSTR   lpszDatatype;
    DWORD    fwType;
#line 4879 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
} DOCINFOA, *LPDOCINFOA;
typedef struct _DOCINFOW {
    int     cbSize;
    LPCWSTR  lpszDocName;
    LPCWSTR  lpszOutput;

    LPCWSTR  lpszDatatype;
    DWORD    fwType;
#line 4888 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
} DOCINFOW, *LPDOCINFOW;




typedef DOCINFOA DOCINFO;
typedef LPDOCINFOA LPDOCINFO;
#line 4896 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




#line 4901 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

 __declspec(dllimport) int __stdcall StartDocA(  HDC hdc,   const DOCINFOA *lpdi);
 __declspec(dllimport) int __stdcall StartDocW(  HDC hdc,   const DOCINFOW *lpdi);




#line 4909 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
 __declspec(dllimport) int __stdcall EndDoc(  HDC hdc);
 __declspec(dllimport) int __stdcall StartPage(  HDC hdc);
 __declspec(dllimport) int __stdcall EndPage(  HDC hdc);
 __declspec(dllimport) int __stdcall AbortDoc(  HDC hdc);
__declspec(dllimport) int __stdcall SetAbortProc(  HDC hdc,   ABORTPROC proc);

__declspec(dllimport) BOOL __stdcall AbortPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall ArcTo(  HDC hdc,   int left,   int top,   int right,   int bottom,   int xr1,   int yr1,   int xr2,   int yr2);
__declspec(dllimport) BOOL __stdcall BeginPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall CloseFigure(  HDC hdc);
__declspec(dllimport) BOOL __stdcall EndPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall FillPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall FlattenPath(  HDC hdc);
__declspec(dllimport) int  __stdcall GetPath(  HDC hdc,   LPPOINT apt,   LPBYTE aj, int cpt);
__declspec(dllimport) HRGN __stdcall PathToRegion(  HDC hdc);
__declspec(dllimport) BOOL __stdcall PolyDraw(  HDC hdc,   const POINT * apt,   const BYTE * aj,   int cpt);
__declspec(dllimport) BOOL __stdcall SelectClipPath(  HDC hdc,   int mode);
__declspec(dllimport) int  __stdcall SetArcDirection(  HDC hdc,   int dir);
__declspec(dllimport) BOOL __stdcall SetMiterLimit(  HDC hdc,   FLOAT limit,   PFLOAT old);
__declspec(dllimport) BOOL __stdcall StrokeAndFillPath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall StrokePath(  HDC hdc);
__declspec(dllimport) BOOL __stdcall WidenPath(  HDC hdc);
__declspec(dllimport) HPEN __stdcall ExtCreatePen(   DWORD iPenStyle,
                                      DWORD cWidth,
                                      const LOGBRUSH *plbrush,
                                      DWORD cStyle,
                                      const DWORD *pstyle);
__declspec(dllimport) BOOL __stdcall GetMiterLimit(  HDC hdc,   PFLOAT plimit);
__declspec(dllimport) int  __stdcall GetArcDirection(  HDC hdc);

__declspec(dllimport) int   __stdcall GetObjectA(  HANDLE h,   int c,   LPVOID pv);
__declspec(dllimport) int   __stdcall GetObjectW(  HANDLE h,   int c,   LPVOID pv);




#line 4946 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




















#line 4967 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


 __declspec(dllimport) BOOL  __stdcall MoveToEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall TextOutA(   HDC hdc,   int x,   int y,   LPCSTR lpString,   int c);
 __declspec(dllimport) BOOL  __stdcall TextOutW(   HDC hdc,   int x,   int y,   LPCWSTR lpString,   int c);




#line 4977 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
 __declspec(dllimport) BOOL  __stdcall ExtTextOutA(   HDC hdc,   int x,   int y,   UINT options,   const RECT * lprect,   LPCSTR lpString,   UINT c,   const INT * lpDx);
 __declspec(dllimport) BOOL  __stdcall ExtTextOutW(   HDC hdc,   int x,   int y,   UINT options,   const RECT * lprect,   LPCWSTR lpString,   UINT c,   const INT * lpDx);




#line 4984 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall PolyTextOutA(  HDC hdc,   const POLYTEXTA * ppt,   int nstrings);
__declspec(dllimport) BOOL  __stdcall PolyTextOutW(  HDC hdc,   const POLYTEXTW * ppt,   int nstrings);




#line 4991 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) HRGN  __stdcall CreatePolygonRgn(      const POINT *pptl,
                                              int cPoint,
                                              int iMode);
__declspec(dllimport) BOOL  __stdcall DPtoLP(   HDC hdc,   LPPOINT lppt,   int c);
__declspec(dllimport) BOOL  __stdcall LPtoDP(   HDC hdc,   LPPOINT lppt,   int c);
 __declspec(dllimport) BOOL  __stdcall Polygon(  HDC hdc,   const POINT *apt,   int cpt);
 __declspec(dllimport) BOOL  __stdcall Polyline(  HDC hdc,   const POINT *apt,   int cpt);

__declspec(dllimport) BOOL  __stdcall PolyBezier(  HDC hdc,   const POINT * apt,   DWORD cpt);
__declspec(dllimport) BOOL  __stdcall PolyBezierTo(  HDC hdc,   const POINT * apt,   DWORD cpt);
__declspec(dllimport) BOOL  __stdcall PolylineTo(  HDC hdc,   const POINT * apt,   DWORD cpt);

 __declspec(dllimport) BOOL  __stdcall SetViewportExtEx(   HDC hdc,   int x,   int y,   LPSIZE lpsz);
 __declspec(dllimport) BOOL  __stdcall SetViewportOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall SetWindowExtEx(   HDC hdc,   int x,   int y,   LPSIZE lpsz);
 __declspec(dllimport) BOOL  __stdcall SetWindowOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);

 __declspec(dllimport) BOOL  __stdcall OffsetViewportOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall OffsetWindowOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);
 __declspec(dllimport) BOOL  __stdcall ScaleViewportExtEx(   HDC hdc,   int xn,   int dx,   int yn,   int yd,   LPSIZE lpsz);
 __declspec(dllimport) BOOL  __stdcall ScaleWindowExtEx(   HDC hdc,   int xn,   int xd,   int yn,   int yd,   LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetBitmapDimensionEx(   HBITMAP hbm,   int w,   int h,   LPSIZE lpsz);
__declspec(dllimport) BOOL  __stdcall SetBrushOrgEx(   HDC hdc,   int x,   int y,   LPPOINT lppt);

__declspec(dllimport) int   __stdcall GetTextFaceA(   HDC hdc,   int c,    LPSTR lpName);
__declspec(dllimport) int   __stdcall GetTextFaceW(   HDC hdc,   int c,    LPWSTR lpName);




#line 5023 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



typedef struct tagKERNINGPAIR {
   WORD wFirst;
   WORD wSecond;
   int  iKernAmount;
} KERNINGPAIR, *LPKERNINGPAIR;

__declspec(dllimport) DWORD __stdcall GetKerningPairsA(      HDC hdc,
                                              DWORD nPairs,
                                              LPKERNINGPAIR   lpKernPair);
__declspec(dllimport) DWORD __stdcall GetKerningPairsW(      HDC hdc,
                                              DWORD nPairs,
                                              LPKERNINGPAIR   lpKernPair);




#line 5043 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


__declspec(dllimport) BOOL  __stdcall GetDCOrgEx(   HDC hdc,   LPPOINT lppt);
__declspec(dllimport) BOOL  __stdcall FixBrushOrgEx(   HDC hdc,   int x,   int y,    LPPOINT ptl);
__declspec(dllimport) BOOL  __stdcall UnrealizeObject(   HGDIOBJ h);

__declspec(dllimport) BOOL  __stdcall GdiFlush(void);
__declspec(dllimport) DWORD __stdcall GdiSetBatchLimit(   DWORD dw);
__declspec(dllimport) DWORD __stdcall GdiGetBatchLimit(void);








typedef int (__stdcall* ICMENUMPROCA)(LPSTR, LPARAM);
typedef int (__stdcall* ICMENUMPROCW)(LPWSTR, LPARAM);




#line 5067 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) int         __stdcall SetICMMode(   HDC hdc,   int mode);
__declspec(dllimport) BOOL        __stdcall CheckColorsInGamut(      HDC hdc,
                                                      LPRGBTRIPLE lpRGBTriple,
                                                      LPVOID dlpBuffer,
                                                      DWORD nCount);

__declspec(dllimport) HCOLORSPACE __stdcall GetColorSpace(   HDC hdc);
__declspec(dllimport) BOOL        __stdcall GetLogColorSpaceA(   HCOLORSPACE hColorSpace,
                                                  LPLOGCOLORSPACEA lpBuffer,
                                                  DWORD nSize);
__declspec(dllimport) BOOL        __stdcall GetLogColorSpaceW(   HCOLORSPACE hColorSpace,
                                                  LPLOGCOLORSPACEW lpBuffer,
                                                  DWORD nSize);




#line 5086 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceA(   LPLOGCOLORSPACEA lplcs);
__declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceW(   LPLOGCOLORSPACEW lplcs);




#line 5094 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) HCOLORSPACE __stdcall SetColorSpace(   HDC hdc,   HCOLORSPACE hcs);
__declspec(dllimport) BOOL        __stdcall DeleteColorSpace(   HCOLORSPACE hcs);
__declspec(dllimport) BOOL        __stdcall GetICMProfileA(      HDC hdc,
                                                  LPDWORD pBufSize,
                                                  LPSTR pszFilename);
__declspec(dllimport) BOOL        __stdcall GetICMProfileW(      HDC hdc,
                                                  LPDWORD pBufSize,
                                                  LPWSTR pszFilename);




#line 5107 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) BOOL        __stdcall SetICMProfileA(   HDC hdc,   LPSTR lpFileName);
__declspec(dllimport) BOOL        __stdcall SetICMProfileW(   HDC hdc,   LPWSTR lpFileName);




#line 5115 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) BOOL        __stdcall GetDeviceGammaRamp(   HDC hdc,   LPVOID lpRamp);
__declspec(dllimport) BOOL        __stdcall SetDeviceGammaRamp(   HDC hdc,    LPVOID lpRamp);
__declspec(dllimport) BOOL        __stdcall ColorMatchToTarget(   HDC hdc,   HDC hdcTarget,   DWORD action);
__declspec(dllimport) int         __stdcall EnumICMProfilesA(   HDC hdc,   ICMENUMPROCA proc,   LPARAM param);
__declspec(dllimport) int         __stdcall EnumICMProfilesW(   HDC hdc,   ICMENUMPROCW proc,   LPARAM param);




#line 5125 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

__declspec(dllimport) BOOL        __stdcall UpdateICMRegKeyA(   DWORD reserved,   LPSTR lpszCMID,   LPSTR lpszFileName,   UINT command);

__declspec(dllimport) BOOL        __stdcall UpdateICMRegKeyW(   DWORD reserved,   LPWSTR lpszCMID,   LPWSTR lpszFileName,   UINT command);




#line 5134 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma deprecated (UpdateICMRegKeyW)
#pragma deprecated (UpdateICMRegKeyA)

#line 5138 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


__declspec(dllimport) BOOL        __stdcall ColorCorrectPalette(   HDC hdc,   HPALETTE hPal,   DWORD deFirst,   DWORD num);
#line 5142 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"









#line 5152 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




















































































































#line 5269 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
















#line 5286 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"





#line 5292 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"









#line 5302 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



typedef struct tagEMR
{
    DWORD   iType;              
    DWORD   nSize;              
                                
} EMR, *PEMR;



typedef struct tagEMRTEXT
{
    POINTL  ptlReference;
    DWORD   nChars;
    DWORD   offString;          
    DWORD   fOptions;
    RECTL   rcl;
    DWORD   offDx;              
                                
} EMRTEXT, *PEMRTEXT;



typedef struct tagABORTPATH
{
    EMR     emr;
} EMRABORTPATH,      *PEMRABORTPATH,
  EMRBEGINPATH,      *PEMRBEGINPATH,
  EMRENDPATH,        *PEMRENDPATH,
  EMRCLOSEFIGURE,    *PEMRCLOSEFIGURE,
  EMRFLATTENPATH,    *PEMRFLATTENPATH,
  EMRWIDENPATH,      *PEMRWIDENPATH,
  EMRSETMETARGN,     *PEMRSETMETARGN,
  EMRSAVEDC,         *PEMRSAVEDC,
  EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;

typedef struct tagEMRSELECTCLIPPATH
{
    EMR     emr;
    DWORD   iMode;
} EMRSELECTCLIPPATH,    *PEMRSELECTCLIPPATH,
  EMRSETBKMODE,         *PEMRSETBKMODE,
  EMRSETMAPMODE,        *PEMRSETMAPMODE,

  EMRSETLAYOUT,         *PEMRSETLAYOUT,
#line 5350 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
  EMRSETPOLYFILLMODE,   *PEMRSETPOLYFILLMODE,
  EMRSETROP2,           *PEMRSETROP2,
  EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE,
  EMRSETICMMODE,        *PEMRSETICMMODE,
  EMRSETTEXTALIGN,      *PEMRSETTEXTALIGN;

typedef struct tagEMRSETMITERLIMIT
{
    EMR     emr;
    FLOAT   eMiterLimit;
} EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;

typedef struct tagEMRRESTOREDC
{
    EMR     emr;
    LONG    iRelative;          
} EMRRESTOREDC, *PEMRRESTOREDC;

typedef struct tagEMRSETARCDIRECTION
{
    EMR     emr;
    DWORD   iArcDirection;      
                                
} EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;

typedef struct tagEMRSETMAPPERFLAGS
{
    EMR     emr;
    DWORD   dwFlags;
} EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;

typedef struct tagEMRSETTEXTCOLOR
{
    EMR     emr;
    COLORREF crColor;
} EMRSETBKCOLOR,   *PEMRSETBKCOLOR,
  EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;

typedef struct tagEMRSELECTOBJECT
{
    EMR     emr;
    DWORD   ihObject;           
} EMRSELECTOBJECT, *PEMRSELECTOBJECT,
  EMRDELETEOBJECT, *PEMRDELETEOBJECT;

typedef struct tagEMRSELECTPALETTE
{
    EMR     emr;
    DWORD   ihPal;              
} EMRSELECTPALETTE, *PEMRSELECTPALETTE;

typedef struct tagEMRRESIZEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              
    DWORD   cEntries;
} EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;

typedef struct tagEMRSETPALETTEENTRIES
{
    EMR     emr;
    DWORD   ihPal;              
    DWORD   iStart;
    DWORD   cEntries;
    PALETTEENTRY aPalEntries[1];
} EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;

typedef struct tagEMRSETCOLORADJUSTMENT
{
    EMR     emr;
    COLORADJUSTMENT ColorAdjustment;
} EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;

typedef struct tagEMRGDICOMMENT
{
    EMR     emr;
    DWORD   cbData;             
    BYTE    Data[1];
} EMRGDICOMMENT, *PEMRGDICOMMENT;

typedef struct tagEMREOF
{
    EMR     emr;
    DWORD   nPalEntries;        
    DWORD   offPalEntries;      
    DWORD   nSizeLast;          
                                
                                
} EMREOF, *PEMREOF;

typedef struct tagEMRLINETO
{
    EMR     emr;
    POINTL  ptl;
} EMRLINETO,   *PEMRLINETO,
  EMRMOVETOEX, *PEMRMOVETOEX;

typedef struct tagEMROFFSETCLIPRGN
{
    EMR     emr;
    POINTL  ptlOffset;
} EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;

typedef struct tagEMRFILLPATH
{
    EMR     emr;
    RECTL   rclBounds;          
} EMRFILLPATH,          *PEMRFILLPATH,
  EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH,
  EMRSTROKEPATH,        *PEMRSTROKEPATH;

typedef struct tagEMREXCLUDECLIPRECT
{
    EMR     emr;
    RECTL   rclClip;
} EMREXCLUDECLIPRECT,   *PEMREXCLUDECLIPRECT,
  EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;

typedef struct tagEMRSETVIEWPORTORGEX
{
    EMR     emr;
    POINTL  ptlOrigin;
} EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX,
  EMRSETWINDOWORGEX,   *PEMRSETWINDOWORGEX,
  EMRSETBRUSHORGEX,    *PEMRSETBRUSHORGEX;

typedef struct tagEMRSETVIEWPORTEXTEX
{
    EMR     emr;
    SIZEL   szlExtent;
} EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX,
  EMRSETWINDOWEXTEX,   *PEMRSETWINDOWEXTEX;

typedef struct tagEMRSCALEVIEWPORTEXTEX
{
    EMR     emr;
    LONG    xNum;
    LONG    xDenom;
    LONG    yNum;
    LONG    yDenom;
} EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX,
  EMRSCALEWINDOWEXTEX,   *PEMRSCALEWINDOWEXTEX;

typedef struct tagEMRSETWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
} EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;

typedef struct tagEMRMODIFYWORLDTRANSFORM
{
    EMR     emr;
    XFORM   xform;
    DWORD   iMode;
} EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;

typedef struct tagEMRSETPIXELV
{
    EMR     emr;
    POINTL  ptlPixel;
    COLORREF crColor;
} EMRSETPIXELV, *PEMRSETPIXELV;

typedef struct tagEMREXTFLOODFILL
{
    EMR     emr;
    POINTL  ptlStart;
    COLORREF crColor;
    DWORD   iMode;
} EMREXTFLOODFILL, *PEMREXTFLOODFILL;

typedef struct tagEMRELLIPSE
{
    EMR     emr;
    RECTL   rclBox;             
} EMRELLIPSE,  *PEMRELLIPSE,
  EMRRECTANGLE, *PEMRRECTANGLE;


typedef struct tagEMRROUNDRECT
{
    EMR     emr;
    RECTL   rclBox;             
    SIZEL   szlCorner;
} EMRROUNDRECT, *PEMRROUNDRECT;

typedef struct tagEMRARC
{
    EMR     emr;
    RECTL   rclBox;             
    POINTL  ptlStart;
    POINTL  ptlEnd;
} EMRARC,   *PEMRARC,
  EMRARCTO, *PEMRARCTO,
  EMRCHORD, *PEMRCHORD,
  EMRPIE,   *PEMRPIE;

typedef struct tagEMRANGLEARC
{
    EMR     emr;
    POINTL  ptlCenter;
    DWORD   nRadius;
    FLOAT   eStartAngle;
    FLOAT   eSweepAngle;
} EMRANGLEARC, *PEMRANGLEARC;

typedef struct tagEMRPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cptl;
    POINTL  aptl[1];
} EMRPOLYLINE,     *PEMRPOLYLINE,
  EMRPOLYBEZIER,   *PEMRPOLYBEZIER,
  EMRPOLYGON,      *PEMRPOLYGON,
  EMRPOLYBEZIERTO, *PEMRPOLYBEZIERTO,
  EMRPOLYLINETO,   *PEMRPOLYLINETO;

typedef struct tagEMRPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cpts;
    POINTS  apts[1];
} EMRPOLYLINE16,     *PEMRPOLYLINE16,
  EMRPOLYBEZIER16,   *PEMRPOLYBEZIER16,
  EMRPOLYGON16,      *PEMRPOLYGON16,
  EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16,
  EMRPOLYLINETO16,   *PEMRPOLYLINETO16;

typedef struct tagEMRPOLYDRAW
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cptl;               
    POINTL  aptl[1];            
    BYTE    abTypes[1];         
} EMRPOLYDRAW, *PEMRPOLYDRAW;

typedef struct tagEMRPOLYDRAW16
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cpts;               
    POINTS  apts[1];            
    BYTE    abTypes[1];         
} EMRPOLYDRAW16, *PEMRPOLYDRAW16;

typedef struct tagEMRPOLYPOLYLINE
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   nPolys;             
    DWORD   cptl;               
    DWORD   aPolyCounts[1];     
    POINTL  aptl[1];            
} EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE,
  EMRPOLYPOLYGON,  *PEMRPOLYPOLYGON;

typedef struct tagEMRPOLYPOLYLINE16
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   nPolys;             
    DWORD   cpts;               
    DWORD   aPolyCounts[1];     
    POINTS  apts[1];            
} EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16,
  EMRPOLYPOLYGON16,  *PEMRPOLYPOLYGON16;

typedef struct tagEMRINVERTRGN
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbRgnData;          
    BYTE    RgnData[1];
} EMRINVERTRGN, *PEMRINVERTRGN,
  EMRPAINTRGN,  *PEMRPAINTRGN;

typedef struct tagEMRFILLRGN
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbRgnData;          
    DWORD   ihBrush;            
    BYTE    RgnData[1];
} EMRFILLRGN, *PEMRFILLRGN;

typedef struct tagEMRFRAMERGN
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbRgnData;          
    DWORD   ihBrush;            
    SIZEL   szlStroke;
    BYTE    RgnData[1];
} EMRFRAMERGN, *PEMRFRAMERGN;

typedef struct tagEMREXTSELECTCLIPRGN
{
    EMR     emr;
    DWORD   cbRgnData;          
    DWORD   iMode;
    BYTE    RgnData[1];
} EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;

typedef struct tagEMREXTTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   iGraphicsMode;      
    FLOAT   exScale;            
    FLOAT   eyScale;            
    EMRTEXT emrtext;            
                                
} EMREXTTEXTOUTA, *PEMREXTTEXTOUTA,
  EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;

typedef struct tagEMRPOLYTEXTOUTA
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   iGraphicsMode;      
    FLOAT   exScale;            
    FLOAT   eyScale;            
    LONG    cStrings;
    EMRTEXT aemrtext[1];        
                                
} EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA,
  EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;

typedef struct tagEMRBITBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
} EMRBITBLT, *PEMRBITBLT;

typedef struct tagEMRSTRETCHBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    cxSrc;
    LONG    cySrc;
} EMRSTRETCHBLT, *PEMRSTRETCHBLT;

typedef struct tagEMRMASKBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         
    DWORD   offBmiMask;         
    DWORD   cbBmiMask;          
    DWORD   offBitsMask;        
    DWORD   cbBitsMask;         
} EMRMASKBLT, *PEMRMASKBLT;

typedef struct tagEMRPLGBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    POINTL  aptlDest[3];
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    xMask;
    LONG    yMask;
    DWORD   iUsageMask;         
    DWORD   offBmiMask;         
    DWORD   cbBmiMask;          
    DWORD   offBitsMask;        
    DWORD   cbBitsMask;         
} EMRPLGBLT, *PEMRPLGBLT;

typedef struct tagEMRSETDIBITSTODEVICE
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    DWORD   iUsageSrc;          
    DWORD   iStartScan;
    DWORD   cScans;
} EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;

typedef struct tagEMRSTRETCHDIBITS
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    xSrc;
    LONG    ySrc;
    LONG    cxSrc;
    LONG    cySrc;
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    DWORD   iUsageSrc;          
    DWORD   dwRop;
    LONG    cxDest;
    LONG    cyDest;
} EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;

typedef struct tagEMREXTCREATEFONTINDIRECTW
{
    EMR     emr;
    DWORD   ihFont;             
    EXTLOGFONTW elfw;
} EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;

typedef struct tagEMRCREATEPALETTE
{
    EMR     emr;
    DWORD   ihPal;              
    LOGPALETTE lgpl;            
                                
} EMRCREATEPALETTE, *PEMRCREATEPALETTE;

typedef struct tagEMRCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              
    LOGPEN  lopn;
} EMRCREATEPEN, *PEMRCREATEPEN;

typedef struct tagEMREXTCREATEPEN
{
    EMR     emr;
    DWORD   ihPen;              
    DWORD   offBmi;             
    DWORD   cbBmi;              
                                
                                
    DWORD   offBits;            
    DWORD   cbBits;             
    EXTLOGPEN32 elp;            
} EMREXTCREATEPEN, *PEMREXTCREATEPEN;

typedef struct tagEMRCREATEBRUSHINDIRECT
{
    EMR        emr;
    DWORD      ihBrush;          
    LOGBRUSH32 lb;               
                                 
} EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;

typedef struct tagEMRCREATEMONOBRUSH
{
    EMR     emr;
    DWORD   ihBrush;            
    DWORD   iUsage;             
    DWORD   offBmi;             
    DWORD   cbBmi;              
    DWORD   offBits;            
    DWORD   cbBits;             
} EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;

typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    EMR     emr;
    DWORD   ihBrush;            
    DWORD   iUsage;             
    DWORD   offBmi;             
    DWORD   cbBmi;              
                                
                                
    DWORD   offBits;            
    DWORD   cbBits;             
} EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;

typedef struct tagEMRFORMAT
{
    DWORD   dSignature;         
    DWORD   nVersion;           
    DWORD   cbData;             
    DWORD   offData;            
                                
} EMRFORMAT, *PEMRFORMAT;



typedef struct tagEMRGLSRECORD
{
    EMR     emr;
    DWORD   cbData;             
    BYTE    Data[1];
} EMRGLSRECORD, *PEMRGLSRECORD;

typedef struct tagEMRGLSBOUNDEDRECORD
{
    EMR     emr;
    RECTL   rclBounds;          
    DWORD   cbData;             
    BYTE    Data[1];
} EMRGLSBOUNDEDRECORD, *PEMRGLSBOUNDEDRECORD;

typedef struct tagEMRPIXELFORMAT
{
    EMR     emr;
    PIXELFORMATDESCRIPTOR pfd;
} EMRPIXELFORMAT, *PEMRPIXELFORMAT;

typedef struct tagEMRCREATECOLORSPACE
{
    EMR             emr;
    DWORD           ihCS;       
    LOGCOLORSPACEA  lcs;        
} EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;

typedef struct tagEMRSETCOLORSPACE
{
    EMR     emr;
    DWORD   ihCS;               
} EMRSETCOLORSPACE,    *PEMRSETCOLORSPACE,
  EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE,
  EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;

#line 5933 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"



typedef struct tagEMREXTESCAPE
{
    EMR     emr;
    INT     iEscape;            
    INT     cbEscData;          
    BYTE    EscData[1];         
} EMREXTESCAPE,  *PEMREXTESCAPE,
  EMRDRAWESCAPE, *PEMRDRAWESCAPE;

typedef struct tagEMRNAMEDESCAPE
{
    EMR     emr;
    INT     iEscape;            
    INT     cbDriver;           
    INT     cbEscData;          
    BYTE    EscData[1];         
} EMRNAMEDESCAPE, *PEMRNAMEDESCAPE;



typedef struct tagEMRSETICMPROFILE
{
    EMR     emr;
    DWORD   dwFlags;            
    DWORD   cbName;             
    DWORD   cbData;             
    BYTE    Data[1];            
} EMRSETICMPROFILE,  *PEMRSETICMPROFILE,
  EMRSETICMPROFILEA, *PEMRSETICMPROFILEA,
  EMRSETICMPROFILEW, *PEMRSETICMPROFILEW;



typedef struct tagEMRCREATECOLORSPACEW
{
    EMR             emr;
    DWORD           ihCS;       
    LOGCOLORSPACEW  lcs;        
    DWORD           dwFlags;    
    DWORD           cbData;     
    BYTE            Data[1];    
} EMRCREATECOLORSPACEW, *PEMRCREATECOLORSPACEW;



typedef struct tagCOLORMATCHTOTARGET
{
    EMR     emr;
    DWORD   dwAction;           
    DWORD   dwFlags;            
    DWORD   cbName;             
    DWORD   cbData;             
    BYTE    Data[1];            
} EMRCOLORMATCHTOTARGET, *PEMRCOLORMATCHTOTARGET;

typedef struct tagCOLORCORRECTPALETTE
{
    EMR     emr;
    DWORD   ihPalette;          
    DWORD   nFirstEntry;        
    DWORD   nPalEntries;        
    DWORD   nReserved;          
} EMRCOLORCORRECTPALETTE, *PEMRCOLORCORRECTPALETTE;

typedef struct tagEMRALPHABLEND
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    cxSrc;
    LONG    cySrc;
} EMRALPHABLEND, *PEMRALPHABLEND;

typedef struct tagEMRGRADIENTFILL
{
    EMR       emr;
    RECTL     rclBounds;          
    DWORD     nVer;
    DWORD     nTri;
    ULONG     ulMode;
    TRIVERTEX Ver[1];
}EMRGRADIENTFILL,*PEMRGRADIENTFILL;

typedef struct tagEMRTRANSPARENTBLT
{
    EMR     emr;
    RECTL   rclBounds;          
    LONG    xDest;
    LONG    yDest;
    LONG    cxDest;
    LONG    cyDest;
    DWORD   dwRop;
    LONG    xSrc;
    LONG    ySrc;
    XFORM   xformSrc;           
    COLORREF crBkColorSrc;      
    DWORD   iUsageSrc;          
                                
    DWORD   offBmiSrc;          
    DWORD   cbBmiSrc;           
    DWORD   offBitsSrc;         
    DWORD   cbBitsSrc;          
    LONG    cxSrc;
    LONG    cySrc;
} EMRTRANSPARENTBLT, *PEMRTRANSPARENTBLT;


#line 6058 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"










#line 6069 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"




__declspec(dllimport) BOOL  __stdcall wglCopyContext(HGLRC, HGLRC, UINT);
__declspec(dllimport) HGLRC __stdcall wglCreateContext(HDC);
__declspec(dllimport) HGLRC __stdcall wglCreateLayerContext(HDC, int);
__declspec(dllimport) BOOL  __stdcall wglDeleteContext(HGLRC);
__declspec(dllimport) HGLRC __stdcall wglGetCurrentContext(void);
__declspec(dllimport) HDC   __stdcall wglGetCurrentDC(void);
__declspec(dllimport) PROC  __stdcall wglGetProcAddress(LPCSTR);
__declspec(dllimport) BOOL  __stdcall wglMakeCurrent(HDC, HGLRC);
__declspec(dllimport) BOOL  __stdcall wglShareLists(HGLRC, HGLRC);
__declspec(dllimport) BOOL  __stdcall wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
__declspec(dllimport) BOOL  __stdcall wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);




#line 6089 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
__declspec(dllimport) BOOL  __stdcall SwapBuffers(HDC);

typedef struct _POINTFLOAT {
    FLOAT   x;
    FLOAT   y;
} POINTFLOAT, *PPOINTFLOAT;

typedef struct _GLYPHMETRICSFLOAT {
    FLOAT       gmfBlackBoxX;
    FLOAT       gmfBlackBoxY;
    POINTFLOAT  gmfptGlyphOrigin;
    FLOAT       gmfCellIncX;
    FLOAT       gmfCellIncY;
} GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT,  *LPGLYPHMETRICSFLOAT;



__declspec(dllimport) BOOL  __stdcall wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);
__declspec(dllimport) BOOL  __stdcall wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT,
                                           FLOAT, int, LPGLYPHMETRICSFLOAT);




#line 6115 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


typedef struct tagLAYERPLANEDESCRIPTOR { 
    WORD  nSize;
    WORD  nVersion;
    DWORD dwFlags;
    BYTE  iPixelType;
    BYTE  cColorBits;
    BYTE  cRedBits;
    BYTE  cRedShift;
    BYTE  cGreenBits;
    BYTE  cGreenShift;
    BYTE  cBlueBits;
    BYTE  cBlueShift;
    BYTE  cAlphaBits;
    BYTE  cAlphaShift;
    BYTE  cAccumBits;
    BYTE  cAccumRedBits;
    BYTE  cAccumGreenBits;
    BYTE  cAccumBlueBits;
    BYTE  cAccumAlphaBits;
    BYTE  cDepthBits;
    BYTE  cStencilBits;
    BYTE  cAuxBuffers;
    BYTE  iLayerPlane;
    BYTE  bReserved;
    COLORREF crTransparent;
} LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR,  *LPLAYERPLANEDESCRIPTOR;

















































__declspec(dllimport) BOOL  __stdcall wglDescribeLayerPlane(HDC, int, int, UINT,
                                             LPLAYERPLANEDESCRIPTOR);
__declspec(dllimport) int   __stdcall wglSetLayerPaletteEntries(HDC, int, int, int,
                                                 const COLORREF *);
__declspec(dllimport) int   __stdcall wglGetLayerPaletteEntries(HDC, int, int, int,
                                                 COLORREF *);
__declspec(dllimport) BOOL  __stdcall wglRealizeLayerPalette(HDC, int, BOOL);
__declspec(dllimport) BOOL  __stdcall wglSwapLayerBuffers(HDC, UINT);



typedef struct _WGLSWAP
{
    HDC hdc;
    UINT uiFlags;
} WGLSWAP, *PWGLSWAP,  *LPWGLSWAP;



__declspec(dllimport) DWORD __stdcall wglSwapMultipleBuffers(UINT, const WGLSWAP *);

#line 6214 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 6216 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion

#line 6219 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#pragma region Desktop Family



#line 6225 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"
#pragma endregion


}
#line 6230 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


#pragma warning(pop)
#line 6234 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"

#line 6236 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wingdi.h"


#line 167 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

















#pragma once










#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






extern "C" {
#line 46 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 56 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family


typedef HANDLE HDWP;
typedef void MENUTEMPLATEA;
typedef void MENUTEMPLATEW;



typedef MENUTEMPLATEA MENUTEMPLATE;
#line 70 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
typedef PVOID LPMENUTEMPLATEA;
typedef PVOID LPMENUTEMPLATEW;



typedef LPMENUTEMPLATEA LPMENUTEMPLATE;
#line 77 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

typedef LRESULT (__stdcall* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

#line 81 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Application Family


typedef INT_PTR (__stdcall* DLGPROC)(HWND, UINT, WPARAM, LPARAM);

#line 91 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef void (__stdcall* TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
typedef BOOL (__stdcall* GRAYSTRINGPROC)(HDC, LPARAM, int);
typedef BOOL (__stdcall* WNDENUMPROC)(HWND, LPARAM);
typedef LRESULT (__stdcall* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
typedef void (__stdcall* SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);

typedef BOOL (__stdcall* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
typedef BOOL (__stdcall* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);

typedef BOOL (__stdcall* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
typedef BOOL (__stdcall* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);

typedef int (__stdcall* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
typedef int (__stdcall* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);


typedef BOOL (__stdcall* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);
#line 114 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 117 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion





































#line 156 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family







typedef PROPENUMPROCA        PROPENUMPROC;
typedef PROPENUMPROCEXA      PROPENUMPROCEX;
typedef EDITWORDBREAKPROCA   EDITWORDBREAKPROC;
#line 169 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



typedef BOOL (__stdcall* NAMEENUMPROCA)(LPSTR, LPARAM);
typedef BOOL (__stdcall* NAMEENUMPROCW)(LPWSTR, LPARAM);

typedef NAMEENUMPROCA   WINSTAENUMPROCA;
typedef NAMEENUMPROCA   DESKTOPENUMPROCA;
typedef NAMEENUMPROCW   WINSTAENUMPROCW;
typedef NAMEENUMPROCW   DESKTOPENUMPROCW;












#line 192 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







typedef WINSTAENUMPROCA     WINSTAENUMPROC;
typedef DESKTOPENUMPROCA    DESKTOPENUMPROC;

#line 203 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 205 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








#line 215 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




























#line 244 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"















#line 260 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 263 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma warning(push)
#pragma warning(disable:4995)
#line 268 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
wvsprintfA(
      LPSTR,
        LPCSTR,
      va_list arglist);
__declspec(dllimport)
int
__stdcall
wvsprintfW(
      LPWSTR,
        LPCWSTR,
      va_list arglist);




#line 291 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__cdecl
wsprintfA(
      LPSTR,
        LPCSTR,
    ...);
__declspec(dllimport)
int
__cdecl
wsprintfW(
      LPWSTR,
        LPCWSTR,
    ...);




#line 311 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma warning(pop)
#line 315 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 317 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




































#line 355 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










































#line 398 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"















#line 414 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


























#line 441 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"








































































































































































#line 610 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









































#line 652 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 659 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





































#line 697 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


















#line 716 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 722 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 727 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 734 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 737 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





























#pragma region Desktop Family





typedef struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDA, *LPCBT_CREATEWNDA;



typedef struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW *lpcs;
    HWND           hwndInsertAfter;
} CBT_CREATEWNDW, *LPCBT_CREATEWNDW;




typedef CBT_CREATEWNDA CBT_CREATEWND;
typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;
#line 792 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;

#line 803 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family





typedef struct tagWTSSESSION_NOTIFICATION
{
    DWORD cbSize;
    DWORD dwSessionId;

} WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;

#line 821 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

















#line 840 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



























#line 868 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 872 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 877 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 882 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





























































#line 944 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 948 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"











#line 960 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


typedef struct
{
    HWND    hwnd;
    RECT    rc;
} SHELLHOOKINFO, *LPSHELLHOOKINFO;




typedef struct tagEVENTMSG {
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD    time;
    HWND     hwnd;
} EVENTMSG, *PEVENTMSGMSG,  *NPEVENTMSGMSG,  *LPEVENTMSGMSG;

typedef struct tagEVENTMSG *PEVENTMSG,  *NPEVENTMSG,  *LPEVENTMSG;




typedef struct tagCWPSTRUCT {
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, *PCWPSTRUCT,  *NPCWPSTRUCT,  *LPCWPSTRUCT;





typedef struct tagCWPRETSTRUCT {
    LRESULT lResult;
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPRETSTRUCT, *PCWPRETSTRUCT,  *NPCWPRETSTRUCT,  *LPCWPRETSTRUCT;

#line 1006 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 1008 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion
















#pragma region Desktop Family





typedef struct tagKBDLLHOOKSTRUCT {
    DWORD   vkCode;
    DWORD   scanCode;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KBDLLHOOKSTRUCT,  *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;




typedef struct tagMSLLHOOKSTRUCT {
    POINT   pt;
    DWORD   mouseData;
    DWORD   flags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MSLLHOOKSTRUCT,  *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;

#line 1051 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 1054 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family





typedef struct tagDEBUGHOOKINFO
{
    DWORD   idThread;
    DWORD   idThreadInstaller;
    LPARAM  lParam;
    WPARAM  wParam;
    int     code;
} DEBUGHOOKINFO, *PDEBUGHOOKINFO,  *NPDEBUGHOOKINFO, * LPDEBUGHOOKINFO;




typedef struct tagMOUSEHOOKSTRUCT {
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    ULONG_PTR dwExtraInfo;
} MOUSEHOOKSTRUCT,  *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;



typedef struct tagMOUSEHOOKSTRUCTEX : public tagMOUSEHOOKSTRUCT
{
    DWORD   mouseData;
} MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;






#line 1093 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 1094 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





typedef struct tagHARDWAREHOOKSTRUCT {
    HWND    hwnd;
    UINT    message;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT,  *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;
#line 1106 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 1108 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 1111 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"














#line 1126 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 1131 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 1141 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#pragma region Desktop Family


__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutA(
      LPCSTR pwszKLID,
      UINT Flags);
__declspec(dllimport)
HKL
__stdcall
LoadKeyboardLayoutW(
      LPCWSTR pwszKLID,
      UINT Flags);




#line 1167 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
HKL
__stdcall
ActivateKeyboardLayout(
      HKL hkl,
      UINT Flags);







#line 1184 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
int
__stdcall
ToUnicodeEx(
      UINT wVirtKey,
      UINT wScanCode,
      const BYTE *lpKeyState,
      LPWSTR pwszBuff,
      int cchBuff,
      UINT wFlags,
      HKL dwhkl);
#line 1198 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnloadKeyboardLayout(
      HKL hkl);

__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameA(
      LPSTR pwszKLID);
__declspec(dllimport)
BOOL
__stdcall
GetKeyboardLayoutNameW(
      LPWSTR pwszKLID);




#line 1220 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
int
__stdcall
GetKeyboardLayoutList(
      int nBuff,
      HKL  *lpList);

__declspec(dllimport)
HKL
__stdcall
GetKeyboardLayout(
      DWORD idThread);

#line 1236 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 1239 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagMOUSEMOVEPOINT {
    int   x;
    int   y;
    DWORD time;
    ULONG_PTR dwExtraInfo;
} MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, * LPMOUSEMOVEPOINT;

#line 1254 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
GetMouseMovePointsEx(
      UINT cbSize,
      LPMOUSEMOVEPOINT lppt,
      LPMOUSEMOVEPOINT lpptBuf,
      int nBufPoints,
      DWORD resolution);

#line 1276 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 1279 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"























#pragma region Desktop Family


__declspec(dllimport)
HDESK
__stdcall
CreateDesktopA(
      LPCSTR lpszDesktop,
      LPCSTR lpszDevice,
      DEVMODEA* pDevmode,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopW(
      LPCWSTR lpszDesktop,
      LPCWSTR lpszDevice,
      DEVMODEW* pDevmode,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa);




#line 1330 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HDESK
__stdcall
CreateDesktopExA(
      LPCSTR lpszDesktop,
      LPCSTR lpszDevice,
      DEVMODEA* pDevmode,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa,
      ULONG ulHeapSize,
      PVOID pvoid);
__declspec(dllimport)
HDESK
__stdcall
CreateDesktopExW(
      LPCWSTR lpszDesktop,
      LPCWSTR lpszDevice,
      DEVMODEW* pDevmode,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa,
      ULONG ulHeapSize,
      PVOID pvoid);




#line 1360 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 1362 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 1365 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 1366 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
HDESK
__stdcall
OpenDesktopA(
      LPCSTR lpszDesktop,
      DWORD dwFlags,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HDESK
__stdcall
OpenDesktopW(
      LPCWSTR lpszDesktop,
      DWORD dwFlags,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);




#line 1391 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HDESK
__stdcall
OpenInputDesktop(
      DWORD dwFlags,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);


__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsA(
      HWINSTA hwinsta,
      DESKTOPENUMPROCA lpEnumFunc,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumDesktopsW(
      HWINSTA hwinsta,
      DESKTOPENUMPROCW lpEnumFunc,
      LPARAM lParam);




#line 1420 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EnumDesktopWindows(
      HDESK hDesktop,
      WNDENUMPROC lpfn,
      LPARAM lParam);


__declspec(dllimport)
BOOL
__stdcall
SwitchDesktop(
      HDESK hDesktop);


__declspec(dllimport)
BOOL
__stdcall
SetThreadDesktop(
       HDESK hDesktop);

__declspec(dllimport)
BOOL
__stdcall
CloseDesktop(
      HDESK hDesktop);

__declspec(dllimport)
HDESK
__stdcall
GetThreadDesktop(
      DWORD dwThreadId);

#line 1456 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 1459 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





























#pragma region Desktop Family


__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationA(
      LPCSTR lpwinsta,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa);
__declspec(dllimport)
HWINSTA
__stdcall
CreateWindowStationW(
      LPCWSTR lpwinsta,
      DWORD dwFlags,
      ACCESS_MASK dwDesiredAccess,
      LPSECURITY_ATTRIBUTES lpsa);




#line 1512 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationA(
      LPCSTR lpszWinSta,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);
__declspec(dllimport)
HWINSTA
__stdcall
OpenWindowStationW(
      LPCWSTR lpszWinSta,
      BOOL fInherit,
      ACCESS_MASK dwDesiredAccess);




#line 1532 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsA(
      WINSTAENUMPROCA lpEnumFunc,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumWindowStationsW(
      WINSTAENUMPROCW lpEnumFunc,
      LPARAM lParam);




#line 1550 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CloseWindowStation(
      HWINSTA hWinSta);

__declspec(dllimport)
BOOL
__stdcall
SetProcessWindowStation(
      HWINSTA hWinSta);

__declspec(dllimport)
HWINSTA
__stdcall
GetProcessWindowStation(
    void);

#line 1570 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 1573 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetUserObjectSecurity(
      HANDLE hObj,
      PSECURITY_INFORMATION pSIRequested,
      PSECURITY_DESCRIPTOR pSID);

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectSecurity(
      HANDLE hObj,
      PSECURITY_INFORMATION pSIRequested,
      PSECURITY_DESCRIPTOR pSID,
      DWORD nLength,
      LPDWORD lpnLengthNeeded);

#line 1598 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








#line 1608 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagUSEROBJECTFLAGS {
    BOOL fInherit;
    BOOL fReserved;
    DWORD dwFlags;
} USEROBJECTFLAGS, *PUSEROBJECTFLAGS;

__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationA(
      HANDLE hObj,
      int nIndex,
      PVOID pvInfo,
      DWORD nLength,
      LPDWORD lpnLengthNeeded);
__declspec(dllimport)
BOOL
__stdcall
GetUserObjectInformationW(
      HANDLE hObj,
      int nIndex,
      PVOID pvInfo,
      DWORD nLength,
      LPDWORD lpnLengthNeeded);




#line 1641 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationA(
      HANDLE hObj,
      int nIndex,
      PVOID pvInfo,
      DWORD nLength);
__declspec(dllimport)
BOOL
__stdcall
SetUserObjectInformationW(
      HANDLE hObj,
      int nIndex,
      PVOID pvInfo,
      DWORD nLength);




#line 1663 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 1665 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 1668 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family



typedef struct tagWNDCLASSEXA {
    UINT        cbSize;
    
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
    
    HICON       hIconSm;
} WNDCLASSEXA, *PWNDCLASSEXA,  *NPWNDCLASSEXA,  *LPWNDCLASSEXA;
typedef struct tagWNDCLASSEXW {
    UINT        cbSize;
    
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
    
    HICON       hIconSm;
} WNDCLASSEXW, *PWNDCLASSEXW,  *NPWNDCLASSEXW,  *LPWNDCLASSEXW;






typedef WNDCLASSEXA WNDCLASSEX;
typedef PWNDCLASSEXA PWNDCLASSEX;
typedef NPWNDCLASSEXA NPWNDCLASSEX;
typedef LPWNDCLASSEXA LPWNDCLASSEX;
#line 1716 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 1717 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

typedef struct tagWNDCLASSA {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCSTR      lpszMenuName;
    LPCSTR      lpszClassName;
} WNDCLASSA, *PWNDCLASSA,  *NPWNDCLASSA,  *LPWNDCLASSA;
typedef struct tagWNDCLASSW {
    UINT        style;
    WNDPROC     lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE   hInstance;
    HICON       hIcon;
    HCURSOR     hCursor;
    HBRUSH      hbrBackground;
    LPCWSTR     lpszMenuName;
    LPCWSTR     lpszClassName;
} WNDCLASSW, *PWNDCLASSW,  *NPWNDCLASSW,  *LPWNDCLASSW;






typedef WNDCLASSA WNDCLASS;
typedef PWNDCLASSA PWNDCLASS;
typedef NPWNDCLASSA NPWNDCLASS;
typedef LPWNDCLASSA LPWNDCLASS;
#line 1753 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsHungAppWindow(
      HWND hwnd);



__declspec(dllimport)
void
__stdcall
DisableProcessWindowsGhosting(
    void);
#line 1768 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 1770 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




#pragma region Application Family





typedef struct tagMSG {
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    POINT       pt;



} MSG, *PMSG,  *NPMSG,  *LPMSG;

#line 1794 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion











#line 1807 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"













































#line 1853 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





















#line 1875 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



































#line 1911 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 1919 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"














#pragma region Desktop Family





typedef struct tagMINMAXINFO {
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;

#line 1948 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



















#line 1969 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 1970 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



















#pragma region Desktop Family





typedef struct tagCOPYDATASTRUCT {
    ULONG_PTR dwData;
    DWORD cbData;
      PVOID lpData;
} COPYDATASTRUCT, *PCOPYDATASTRUCT;


typedef struct tagMDINEXTMENU
{
    HMENU   hmenuIn;
    HMENU   hmenuNext;
    HWND    hwndNext;
} MDINEXTMENU, * PMDINEXTMENU,  * LPMDINEXTMENU;
#line 2009 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 2011 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion






















#line 2035 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










#line 2046 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

















#line 2064 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 2069 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2073 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
















#line 2090 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 2097 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"












#line 2110 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"































#line 2142 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 2143 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 2144 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 2146 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 2147 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"























#line 2171 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 2176 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 2179 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 2189 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 2199 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










#line 2210 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










#line 2221 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

































#pragma region Desktop Family


typedef struct {
    GUID PowerSetting;
    DWORD DataLength;
    UCHAR Data[1];
} POWERBROADCAST_SETTING, *PPOWERBROADCAST_SETTING;


#line 2265 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 2268 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 2270 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 2271 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 2273 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2277 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"























#line 2301 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 2306 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
















#line 2323 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 2333 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 2336 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2340 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 2345 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2349 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 2356 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2360 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
























#line 2385 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2389 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2393 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 2398 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 2405 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 2410 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 2415 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"








#line 2424 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 2432 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




















#line 2453 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




































#line 2490 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










#line 2501 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 2504 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 2506 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 2508 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
















#line 2525 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageA(
      LPCSTR lpString);
__declspec(dllimport)
UINT
__stdcall
RegisterWindowMessageW(
      LPCWSTR lpString);




#line 2545 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 2547 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion





















#pragma region Desktop Family





typedef struct tagWINDOWPOS {
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;




typedef struct tagNCCALCSIZE_PARAMS {
    RECT       rgrc[3];
    PWINDOWPOS lppos;
} NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;

#line 2594 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




























#line 2624 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 2626 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 2636 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 2642 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family


typedef struct tagTRACKMOUSEEVENT {
    DWORD cbSize;
    DWORD dwFlags;
    HWND  hwndTrack;
    DWORD dwHoverTime;
} TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

__declspec(dllimport)
BOOL
__stdcall
TrackMouseEvent(
      LPTRACKMOUSEEVENT lpEventTrack);

#line 2662 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 2665 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2669 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 2670 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 2673 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


































































#line 2740 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

















#line 2758 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 2763 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 2768 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2772 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2776 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2780 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 2783 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




















#line 2804 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 2808 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"























































#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawEdge(
      HDC hdc,
      LPRECT qrc,
      UINT edge,
      UINT grfFlags);

#line 2876 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion









#line 2887 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

































#line 2921 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawFrameControl(
      HDC,
      LPRECT,
      UINT,
      UINT);


#line 2940 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion










#line 2952 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 2955 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawCaption(
      HWND hwnd,
      HDC hdc,
      const RECT * lprect,
      UINT flags);


#line 2970 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawAnimatedRects(
      HWND hwnd,
      int idAni,
      const RECT *lprcFrom,
      const RECT *lprcTo);

#line 2988 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 2991 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
























#line 3016 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 3019 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 3027 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




















#line 3048 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










#pragma region Desktop Family


typedef struct tagACCEL {

    BYTE   fVirt;               
    WORD   key;
    WORD   cmd;




#line 3071 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
} ACCEL, *LPACCEL;

typedef struct tagPAINTSTRUCT {
    HDC         hdc;
    BOOL        fErase;
    RECT        rcPaint;
    BOOL        fRestore;
    BOOL        fIncUpdate;
    BYTE        rgbReserved[32];
} PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

typedef struct tagCREATESTRUCTA {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCSTR      lpszName;
    LPCSTR      lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTA, *LPCREATESTRUCTA;
typedef struct tagCREATESTRUCTW {
    LPVOID      lpCreateParams;
    HINSTANCE   hInstance;
    HMENU       hMenu;
    HWND        hwndParent;
    int         cy;
    int         cx;
    int         y;
    int         x;
    LONG        style;
    LPCWSTR     lpszName;
    LPCWSTR     lpszClass;
    DWORD       dwExStyle;
} CREATESTRUCTW, *LPCREATESTRUCTW;




typedef CREATESTRUCTA CREATESTRUCT;
typedef LPCREATESTRUCTA LPCREATESTRUCT;
#line 3117 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

typedef struct tagWINDOWPLACEMENT {
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;



} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;





#line 3136 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 3138 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Application Family


typedef struct tagNMHDR
{
    HWND      hwndFrom;
    UINT_PTR  idFrom;
    UINT      code;         
}   NMHDR;

#line 3153 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef NMHDR  * LPNMHDR;

typedef struct tagSTYLESTRUCT
{
    DWORD   styleOld;
    DWORD   styleNew;
} STYLESTRUCT, * LPSTYLESTRUCT;

#line 3167 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion
#line 3169 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"











#line 3181 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



















#line 3201 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 3208 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 3209 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family





typedef struct tagMEASUREITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    UINT       itemWidth;
    UINT       itemHeight;
    ULONG_PTR  itemData;
} MEASUREITEMSTRUCT,  *PMEASUREITEMSTRUCT,  *LPMEASUREITEMSTRUCT;




typedef struct tagDRAWITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND        hwndItem;
    HDC         hDC;
    RECT        rcItem;
    ULONG_PTR   itemData;
} DRAWITEMSTRUCT,  *PDRAWITEMSTRUCT,  *LPDRAWITEMSTRUCT;




typedef struct tagDELETEITEMSTRUCT {
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    ULONG_PTR  itemData;
} DELETEITEMSTRUCT,  *PDELETEITEMSTRUCT,  *LPDELETEITEMSTRUCT;




typedef struct tagCOMPAREITEMSTRUCT {
    UINT        CtlType;
    UINT        CtlID;
    HWND        hwndItem;
    UINT        itemID1;
    ULONG_PTR   itemData1;
    UINT        itemID2;
    ULONG_PTR   itemData2;
    DWORD       dwLocaleId;
} COMPAREITEMSTRUCT,  *PCOMPAREITEMSTRUCT,  *LPCOMPAREITEMSTRUCT;

#line 3266 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
GetMessageA(
      LPMSG lpMsg,
      HWND hWnd,
      UINT wMsgFilterMin,
      UINT wMsgFilterMax);
__declspec(dllimport)
BOOL
__stdcall
GetMessageW(
      LPMSG lpMsg,
      HWND hWnd,
      UINT wMsgFilterMin,
      UINT wMsgFilterMax);




#line 3298 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"























#line 3322 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
TranslateMessage(
      const MSG *lpMsg);

__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageA(
      const MSG *lpMsg);
__declspec(dllimport)
LRESULT
__stdcall
DispatchMessageW(
      const MSG *lpMsg);




#line 3345 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

















#line 3363 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetMessageQueue(
      int cMessagesMax);

__declspec(dllimport)
BOOL
__stdcall
PeekMessageA(
      LPMSG lpMsg,
      HWND hWnd,
      UINT wMsgFilterMin,
      UINT wMsgFilterMax,
      UINT wRemoveMsg);
__declspec(dllimport)
BOOL
__stdcall
PeekMessageW(
      LPMSG lpMsg,
      HWND hWnd,
      UINT wMsgFilterMin,
      UINT wMsgFilterMax,
      UINT wRemoveMsg);




#line 3393 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 3395 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion












#line 3409 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 3412 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
RegisterHotKey(
      HWND hWnd,
      int id,
      UINT fsModifiers,
      UINT vk);

__declspec(dllimport)
BOOL
__stdcall
UnregisterHotKey(
      HWND hWnd,
      int id);

#line 3433 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion







#line 3442 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"















#line 3458 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 3462 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 3465 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 3468 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"








#line 3477 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 3481 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#pragma region Desktop Family





#line 3493 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
__declspec(dllimport)
BOOL
__stdcall
ExitWindowsEx(
      UINT uFlags,
      DWORD dwReason);

__declspec(dllimport)
BOOL
__stdcall
SwapMouseButton(
      BOOL fSwap);

__declspec(dllimport)
DWORD
__stdcall
GetMessagePos(
    void);

__declspec(dllimport)
LONG
__stdcall
GetMessageTime(
    void);

__declspec(dllimport)
LPARAM
__stdcall
GetMessageExtraInfo(
    void);


__declspec(dllimport)
DWORD
__stdcall
GetUnpredictedMessagePos(
    void);
#line 3531 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
IsWow64Message(
    void);
#line 3539 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
LPARAM
__stdcall
SetMessageExtraInfo(
      LPARAM lParam);
#line 3547 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
LRESULT
__stdcall
SendMessageA(
      HWND hWnd,
      UINT Msg,
        WPARAM wParam,
        LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageW(
      HWND hWnd,
      UINT Msg,
        WPARAM wParam,
        LPARAM lParam);




#line 3569 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"























#line 3593 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      UINT fuFlags,
      UINT uTimeout,
      PDWORD_PTR lpdwResult);
__declspec(dllimport)
LRESULT
__stdcall
SendMessageTimeoutW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      UINT fuFlags,
      UINT uTimeout,
      PDWORD_PTR lpdwResult);




#line 3623 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
SendNotifyMessageW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 3645 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      SENDASYNCPROC lpResultCallBack,
      ULONG_PTR dwData);
__declspec(dllimport)
BOOL
__stdcall
SendMessageCallbackW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      SENDASYNCPROC lpResultCallBack,
      ULONG_PTR dwData);




#line 3671 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


typedef struct {
    UINT  cbSize;
    HDESK hdesk;
    HWND  hwnd;
    LUID  luid;
} BSMINFO, *PBSMINFO;

__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageExA(
      DWORD flags,
      LPDWORD lpInfo,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      PBSMINFO pbsmInfo);
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageExW(
      DWORD flags,
      LPDWORD lpInfo,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam,
      PBSMINFO pbsmInfo);




#line 3705 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 3706 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 3708 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family



__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageA(
      DWORD flags,
      LPDWORD lpInfo,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
long
__stdcall
BroadcastSystemMessageW(
      DWORD flags,
      LPDWORD lpInfo,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 3739 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"












#line 3752 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 3754 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




















#line 3776 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 3780 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 3783 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family



typedef  PVOID           HDEVNOTIFY;
typedef  HDEVNOTIFY     *PHDEVNOTIFY;





#line 3798 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationA(
      HANDLE hRecipient,
      LPVOID NotificationFilter,
      DWORD Flags);
__declspec(dllimport)
HDEVNOTIFY
__stdcall
RegisterDeviceNotificationW(
      HANDLE hRecipient,
      LPVOID NotificationFilter,
      DWORD Flags);




#line 3818 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnregisterDeviceNotification(
      HDEVNOTIFY Handle
    );







typedef  PVOID           HPOWERNOTIFY;
typedef  HPOWERNOTIFY   *PHPOWERNOTIFY;

#line 3836 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HPOWERNOTIFY
__stdcall
RegisterPowerSettingNotification(
     HANDLE hRecipient,
     LPCGUID PowerSettingGuid,
     DWORD Flags
    );

__declspec(dllimport)
BOOL
__stdcall
UnregisterPowerSettingNotification(
     HPOWERNOTIFY Handle
    );

__declspec(dllimport)
HPOWERNOTIFY
__stdcall
RegisterSuspendResumeNotification (
     HANDLE hRecipient,
     DWORD Flags
    );

__declspec(dllimport)
BOOL
__stdcall
UnregisterSuspendResumeNotification (
     HPOWERNOTIFY Handle
    );


#line 3870 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 3871 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 3873 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
PostMessageA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostMessageW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 3899 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageA(
      DWORD idThread,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
BOOL
__stdcall
PostThreadMessageW(
      DWORD idThread,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 3921 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 3923 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion









#line 3934 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"








#line 3943 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
AttachThreadInput(
      DWORD idAttach,
      DWORD idAttachTo,
      BOOL fAttach);


__declspec(dllimport)
BOOL
__stdcall
ReplyMessage(
      LRESULT lResult);

__declspec(dllimport)
BOOL
__stdcall
WaitMessage(
    void);


#line 3970 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
DWORD
__stdcall
WaitForInputIdle(
      HANDLE hProcess,
      DWORD dwMilliseconds);

__declspec(dllimport)

LRESULT
__stdcall



#line 3987 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
DefWindowProcA(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 4000 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
DefWindowProcW(
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 4010 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
void
__stdcall
PostQuitMessage(
      int nExitCode);



__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcA(
      WNDPROC lpPrevWndFunc,
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
CallWindowProcW(
      WNDPROC lpPrevWndFunc,
      HWND hWnd,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 4042 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



























#line 4070 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
InSendMessage(
    void);

#line 4078 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
InSendMessageEx(
      LPVOID lpReserved);

#line 4092 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion









#line 4103 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
GetDoubleClickTime(
    void);

__declspec(dllimport)
BOOL
__stdcall
SetDoubleClickTime(
      UINT);

__declspec(dllimport)
ATOM
__stdcall
RegisterClassA(
      const WNDCLASSA *lpWndClass);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassW(
      const WNDCLASSW *lpWndClass);




#line 4135 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnregisterClassA(
      LPCSTR lpClassName,
      HINSTANCE hInstance);
__declspec(dllimport)
BOOL
__stdcall
UnregisterClassW(
      LPCWSTR lpClassName,
      HINSTANCE hInstance);




#line 4153 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

 
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoA(
      HINSTANCE hInstance,
      LPCSTR lpClassName,
      LPWNDCLASSA lpWndClass);
 
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoW(
      HINSTANCE hInstance,
      LPCWSTR lpClassName,
      LPWNDCLASSW lpWndClass);




#line 4175 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
ATOM
__stdcall
RegisterClassExA(
      const WNDCLASSEXA *);
__declspec(dllimport)
ATOM
__stdcall
RegisterClassExW(
      const WNDCLASSEXW *);




#line 4192 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

 
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExA(
      HINSTANCE hInstance,
      LPCSTR lpszClass,
      LPWNDCLASSEXA lpwcx);
 
__declspec(dllimport)
BOOL
__stdcall
GetClassInfoExW(
      HINSTANCE hInstance,
      LPCWSTR lpszClass,
      LPWNDCLASSEXW lpwcx);




#line 4214 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 4216 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 4218 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family



typedef BOOLEAN (__stdcall * PREGISTERCLASSNAMEW)(LPCWSTR);
#line 4233 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
CreateWindowExA(
      DWORD dwExStyle,
      LPCSTR lpClassName,
      LPCSTR lpWindowName,
      DWORD dwStyle,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      HWND hWndParent,
      HMENU hMenu,
      HINSTANCE hInstance,
      LPVOID lpParam);
__declspec(dllimport)
HWND
__stdcall
CreateWindowExW(
      DWORD dwExStyle,
      LPCWSTR lpClassName,
      LPCWSTR lpWindowName,
      DWORD dwStyle,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      HWND hWndParent,
      HMENU hMenu,
      HINSTANCE hInstance,
      LPVOID lpParam);




#line 4271 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 4273 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion













#line 4288 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
IsWindow(
      HWND hWnd);


__declspec(dllimport)
BOOL
__stdcall
IsMenu(
      HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
IsChild(
      HWND hWndParent,
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
DestroyWindow(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ShowWindow(
      HWND hWnd,
      int nCmdShow);


__declspec(dllimport)
BOOL
__stdcall
AnimateWindow(
      HWND hWnd,
      DWORD dwTime,
      DWORD dwFlags);
#line 4335 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 4337 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindow(
      HWND hWnd,
      HDC hdcDst,
      POINT* pptDst,
      SIZE* psize,
      HDC hdcSrc,
      POINT* pptSrc,
      COLORREF crKey,
      BLENDFUNCTION* pblend,
      DWORD dwFlags);




typedef struct tagUPDATELAYEREDWINDOWINFO
{
    DWORD cbSize;
    HDC hdcDst;
    const POINT* pptDst;
    const SIZE* psize;
    HDC hdcSrc;
    const POINT* pptSrc;
    COLORREF crKey;
    const BLENDFUNCTION* pblend;
    DWORD dwFlags;
    const RECT* prcDirty;
} UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;




#line 4380 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
__declspec(dllimport)
BOOL
__stdcall
UpdateLayeredWindowIndirect(
      HWND hWnd,
      const UPDATELAYEREDWINDOWINFO* pULWInfo);

#line 4388 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 4391 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetLayeredWindowAttributes(
      HWND hwnd,
      COLORREF* pcrKey,
      BYTE* pbAlpha,
      DWORD* pdwFlags);





#line 4411 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
PrintWindow(
      HWND hwnd,
      HDC hdcBlt,
      UINT nFlags);

#line 4422 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 4425 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetLayeredWindowAttributes(
      HWND hwnd,
      COLORREF crKey,
      BYTE bAlpha,
      DWORD dwFlags);

#line 4439 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion











#line 4452 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
ShowWindowAsync(
       HWND hWnd,
       int nCmdShow);
#line 4466 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
FlashWindow(
       HWND hWnd,
       BOOL bInvert);


typedef struct {
    UINT  cbSize;
    HWND  hwnd;
    DWORD dwFlags;
    UINT  uCount;
    DWORD dwTimeout;
} FLASHWINFO, *PFLASHWINFO;

__declspec(dllimport)
BOOL
__stdcall
FlashWindowEx(
      PFLASHWINFO pfwi);








#line 4497 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
ShowOwnedPopups(
       HWND hWnd,
       BOOL fShow);

__declspec(dllimport)
BOOL
__stdcall
OpenIcon(
       HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
CloseWindow(
       HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
MoveWindow(
      HWND hWnd,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      BOOL bRepaint);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPos(
      HWND hWnd,
      HWND hWndInsertAfter,
      int X,
      int Y,
      int cx,
      int cy,
      UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
GetWindowPlacement(
      HWND hWnd,
      WINDOWPLACEMENT *lpwndpl);

__declspec(dllimport)
BOOL
__stdcall
SetWindowPlacement(
      HWND hWnd,
      const WINDOWPLACEMENT *lpwndpl);






__declspec(dllimport)
BOOL
__stdcall
GetWindowDisplayAffinity(
      HWND hWnd,
      DWORD* pdwAffinity);

__declspec(dllimport)
BOOL
__stdcall
SetWindowDisplayAffinity(
      HWND hWnd,
      DWORD dwAffinity);

#line 4574 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 4576 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


__declspec(dllimport)
HDWP
__stdcall
BeginDeferWindowPos(
      int nNumWindows);

__declspec(dllimport)
HDWP
__stdcall
DeferWindowPos(
      HDWP hWinPosInfo,
      HWND hWnd,
      HWND hWndInsertAfter,
      int x,
      int y,
      int cx,
      int cy,
      UINT uFlags);


__declspec(dllimport)
BOOL
__stdcall
EndDeferWindowPos(
      HDWP hWinPosInfo);

#line 4610 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 4613 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
IsWindowVisible(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsIconic(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
AnyPopup(
    void);

__declspec(dllimport)
BOOL
__stdcall
BringWindowToTop(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
IsZoomed(
      HWND hWnd);

#line 4648 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion






















#line 4672 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"














#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"























#pragma warning(disable:4103)

#pragma pack(push,2)


#line 30 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\pshpack2.h"
#line 4687 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Application Family





typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    WORD cdit;
    short x;
    short y;
    short cx;
    short cy;
} DLGTEMPLATE;

#line 4705 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family


typedef DLGTEMPLATE *LPDLGTEMPLATEA;
typedef DLGTEMPLATE *LPDLGTEMPLATEW;



typedef LPDLGTEMPLATEA LPDLGTEMPLATE;
#line 4717 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 4719 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#pragma region Application Family


typedef const DLGTEMPLATE *LPCDLGTEMPLATEA;
typedef const DLGTEMPLATE *LPCDLGTEMPLATEW;



typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;
#line 4731 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 4733 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family





typedef struct {
    DWORD style;
    DWORD dwExtendedStyle;
    short x;
    short y;
    short cx;
    short cy;
    WORD id;
} DLGITEMTEMPLATE;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *PDLGITEMTEMPLATEW;



typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;
#line 4758 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEA;
typedef DLGITEMTEMPLATE *LPDLGITEMTEMPLATEW;



typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;
#line 4765 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 4767 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


























#pragma warning(disable:4103)

#pragma pack(pop)


#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"


#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 37 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\poppack.h"
#line 4771 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
CreateDialogParamA(
      HINSTANCE hInstance,
      LPCSTR lpTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogParamW(
      HINSTANCE hInstance,
      LPCWSTR lpTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);




#line 4798 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamA(
      HINSTANCE hInstance,
      LPCDLGTEMPLATEA lpTemplate,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);
__declspec(dllimport)
HWND
__stdcall
CreateDialogIndirectParamW(
      HINSTANCE hInstance,
      LPCDLGTEMPLATEW lpTemplate,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);




#line 4822 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 4832 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 4842 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamA(
      HINSTANCE hInstance,
      LPCSTR lpTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxParamW(
      HINSTANCE hInstance,
      LPCWSTR lpTemplateName,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);




#line 4866 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamA(
      HINSTANCE hInstance,
      LPCDLGTEMPLATEA hDialogTemplate,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);
__declspec(dllimport)
INT_PTR
__stdcall
DialogBoxIndirectParamW(
      HINSTANCE hInstance,
      LPCDLGTEMPLATEW hDialogTemplate,
      HWND hWndParent,
      DLGPROC lpDialogFunc,
      LPARAM dwInitParam);




#line 4890 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 4900 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 4910 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EndDialog(
      HWND hDlg,
      INT_PTR nResult);

__declspec(dllimport)
HWND
__stdcall
GetDlgItem(
      HWND hDlg,
      int nIDDlgItem);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemInt(
      HWND hDlg,
      int nIDDlgItem,
      UINT uValue,
      BOOL bSigned);

__declspec(dllimport)
UINT
__stdcall
GetDlgItemInt(
      HWND hDlg,
      int nIDDlgItem,
      BOOL *lpTranslated,
      BOOL bSigned);

__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextA(
      HWND hDlg,
      int nIDDlgItem,
      LPCSTR lpString);
__declspec(dllimport)
BOOL
__stdcall
SetDlgItemTextW(
      HWND hDlg,
      int nIDDlgItem,
      LPCWSTR lpString);




#line 4962 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

 
__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextA(
      HWND hDlg,
      int nIDDlgItem,
      LPSTR lpString,
      int cchMax);
 
__declspec(dllimport)
UINT
__stdcall
GetDlgItemTextW(
      HWND hDlg,
      int nIDDlgItem,
      LPWSTR lpString,
      int cchMax);




#line 4986 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CheckDlgButton(
      HWND hDlg,
      int nIDButton,
      UINT uCheck);

__declspec(dllimport)
BOOL
__stdcall
CheckRadioButton(
      HWND hDlg,
      int nIDFirstButton,
      int nIDLastButton,
      int nIDCheckButton);

__declspec(dllimport)
UINT
__stdcall
IsDlgButtonChecked(
      HWND hDlg,
      int nIDButton);

__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageA(
      HWND hDlg,
      int nIDDlgItem,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
SendDlgItemMessageW(
      HWND hDlg,
      int nIDDlgItem,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 5034 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetNextDlgGroupItem(
      HWND hDlg,
      HWND hCtl,
      BOOL bPrevious);

__declspec(dllimport)
HWND
__stdcall
GetNextDlgTabItem(
      HWND hDlg,
      HWND hCtl,
      BOOL bPrevious);

__declspec(dllimport)
int
__stdcall
GetDlgCtrlID(
      HWND hWnd);

__declspec(dllimport)
long
__stdcall
GetDialogBaseUnits(void);

__declspec(dllimport)

LRESULT
__stdcall



#line 5070 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
DefDlgProcA(
      HWND hDlg,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 5083 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
DefDlgProcW(
      HWND hDlg,
      UINT Msg,
      WPARAM wParam,
      LPARAM lParam);




#line 5093 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 5095 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








#line 5105 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 5107 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterA(
      LPMSG lpMsg,
      int nCode);
__declspec(dllimport)
BOOL
__stdcall
CallMsgFilterW(
      LPMSG lpMsg,
      int nCode);




#line 5130 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 5132 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







__declspec(dllimport)
BOOL
__stdcall
OpenClipboard(
      HWND hWndNewOwner);

__declspec(dllimport)
BOOL
__stdcall
CloseClipboard(
    void);




__declspec(dllimport)
DWORD
__stdcall
GetClipboardSequenceNumber(
    void);

#line 5161 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetClipboardOwner(
    void);

__declspec(dllimport)
HWND
__stdcall
SetClipboardViewer(
      HWND hWndNewViewer);

__declspec(dllimport)
HWND
__stdcall
GetClipboardViewer(
    void);

__declspec(dllimport)
BOOL
__stdcall
ChangeClipboardChain(
      HWND hWndRemove,
      HWND hWndNewNext);

__declspec(dllimport)
HANDLE
__stdcall
SetClipboardData(
      UINT uFormat,
      HANDLE hMem);

__declspec(dllimport)
HANDLE
__stdcall
GetClipboardData(
      UINT uFormat);

__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatA(
      LPCSTR lpszFormat);
__declspec(dllimport)
UINT
__stdcall
RegisterClipboardFormatW(
      LPCWSTR lpszFormat);




#line 5215 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
CountClipboardFormats(
    void);

__declspec(dllimport)
UINT
__stdcall
EnumClipboardFormats(
      UINT format);

__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameA(
      UINT format,
      LPSTR lpszFormatName,
      int cchMaxCount);
__declspec(dllimport)
int
__stdcall
GetClipboardFormatNameW(
      UINT format,
      LPWSTR lpszFormatName,
      int cchMaxCount);




#line 5247 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
EmptyClipboard(
    void);

__declspec(dllimport)
BOOL
__stdcall
IsClipboardFormatAvailable(
      UINT format);

__declspec(dllimport)
int
__stdcall
GetPriorityClipboardFormat(
      UINT *paFormatPriorityList,
      int cFormats);

__declspec(dllimport)
HWND
__stdcall
GetOpenClipboardWindow(
    void);


__declspec(dllimport)
BOOL
__stdcall
AddClipboardFormatListener(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
RemoveClipboardFormatListener(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
GetUpdatedClipboardFormats(
      PUINT lpuiFormats,
      UINT cFormats,
      PUINT pcFormatsOut);
#line 5294 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 5296 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
CharToOemA(
      LPCSTR pSrc,
      LPSTR pDst);
__declspec(dllimport)
BOOL
__stdcall
CharToOemW(
      LPCWSTR pSrc,
      LPSTR pDst);




#line 5318 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

 
__declspec(dllimport)
BOOL
__stdcall
OemToCharA(
      LPCSTR pSrc,
      LPSTR pDst);
 
__declspec(dllimport)
BOOL
__stdcall
OemToCharW(
      LPCSTR pSrc,
      LPWSTR pDst);




#line 5338 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffA(
      LPCSTR lpszSrc,
      LPSTR lpszDst,
      DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
CharToOemBuffW(
      LPCWSTR lpszSrc,
      LPSTR lpszDst,
      DWORD cchDstLength);




#line 5358 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffA(
      LPCSTR lpszSrc,
      LPSTR lpszDst,
      DWORD cchDstLength);
__declspec(dllimport)
BOOL
__stdcall
OemToCharBuffW(
      LPCSTR lpszSrc,
      LPWSTR lpszDst,
      DWORD cchDstLength);




#line 5378 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharUpperA(
      LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharUpperW(
      LPWSTR lpsz);




#line 5394 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffA(
      LPSTR lpsz,
      DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharUpperBuffW(
      LPWSTR lpsz,
      DWORD cchLength);




#line 5412 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharLowerA(
      LPSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharLowerW(
      LPWSTR lpsz);




#line 5428 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffA(
      LPSTR lpsz,
      DWORD cchLength);
__declspec(dllimport)
DWORD
__stdcall
CharLowerBuffW(
      LPWSTR lpsz,
      DWORD cchLength);




#line 5446 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharNextA(
      LPCSTR lpsz);
__declspec(dllimport)
LPWSTR
__stdcall
CharNextW(
      LPCWSTR lpsz);




#line 5462 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
LPSTR
__stdcall
CharPrevA(
      LPCSTR lpszStart,
      LPCSTR lpszCurrent);
__declspec(dllimport)
LPWSTR
__stdcall
CharPrevW(
      LPCWSTR lpszStart,
      LPCWSTR lpszCurrent);




#line 5480 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
LPSTR
__stdcall
CharNextExA(
       WORD CodePage,
       LPCSTR lpCurrentChar,
       DWORD dwFlags);

__declspec(dllimport)
LPSTR
__stdcall
CharPrevExA(
       WORD CodePage,
       LPCSTR lpStart,
       LPCSTR lpCurrentChar,
       DWORD dwFlags);
#line 5499 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 5501 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion















#pragma region Desktop Family







__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaA(
      CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaW(
      WCHAR ch);




#line 5540 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericA(
      CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharAlphaNumericW(
      WCHAR ch);




#line 5556 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharUpperA(
      CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharUpperW(
      WCHAR ch);




#line 5572 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
IsCharLowerA(
      CHAR ch);
__declspec(dllimport)
BOOL
__stdcall
IsCharLowerW(
      WCHAR ch);




#line 5588 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 5590 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
SetFocus(
      HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
GetActiveWindow(
    void);

__declspec(dllimport)
HWND
__stdcall
GetFocus(
    void);

__declspec(dllimport)
UINT
__stdcall
GetKBCodePage(
    void);

__declspec(dllimport)
SHORT
__stdcall
GetKeyState(
      int nVirtKey);

__declspec(dllimport)
SHORT
__stdcall
GetAsyncKeyState(
      int vKey);

__declspec(dllimport)
 
BOOL
__stdcall
GetKeyboardState(
      PBYTE lpKeyState);

__declspec(dllimport)
BOOL
__stdcall
SetKeyboardState(
      LPBYTE lpKeyState);

__declspec(dllimport)
int
__stdcall
GetKeyNameTextA(
      LONG lParam,
      LPSTR lpString,
      int cchSize);
__declspec(dllimport)
int
__stdcall
GetKeyNameTextW(
      LONG lParam,
      LPWSTR lpString,
      int cchSize);




#line 5659 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
GetKeyboardType(
      int nTypeFlag);

__declspec(dllimport)
int
__stdcall
ToAscii(
      UINT uVirtKey,
      UINT uScanCode,
      const BYTE *lpKeyState,
      LPWORD lpChar,
      UINT uFlags);


__declspec(dllimport)
int
__stdcall
ToAsciiEx(
      UINT uVirtKey,
      UINT uScanCode,
      const BYTE *lpKeyState,
      LPWORD lpChar,
      UINT uFlags,
      HKL dwhkl);
#line 5688 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
ToUnicode(
      UINT wVirtKey,
      UINT wScanCode,
      const BYTE *lpKeyState,
      LPWSTR pwszBuff,
      int cchBuff,
      UINT wFlags);

__declspec(dllimport)
DWORD
__stdcall
OemKeyScan(
      WORD wOemChar);

__declspec(dllimport)
SHORT
__stdcall
VkKeyScanA(
      CHAR ch);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanW(
      WCHAR ch);




#line 5721 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExA(
      CHAR ch,
      HKL dwhkl);
__declspec(dllimport)
SHORT
__stdcall
VkKeyScanExW(
      WCHAR ch,
      HKL dwhkl);




#line 5740 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 5741 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 5747 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
void
__stdcall
keybd_event(
      BYTE bVk,
      BYTE bScan,
      DWORD dwFlags,
      ULONG_PTR dwExtraInfo);

#line 5758 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion













#line 5773 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 5776 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family


__declspec(dllimport)
void
__stdcall
mouse_event(
      DWORD dwFlags,
      DWORD dx,
      DWORD dy,
      DWORD dwData,
      ULONG_PTR dwExtraInfo);

#line 5793 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagMOUSEINPUT {
    LONG    dx;
    LONG    dy;
    DWORD   mouseData;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} MOUSEINPUT, *PMOUSEINPUT, * LPMOUSEINPUT;

typedef struct tagKEYBDINPUT {
    WORD    wVk;
    WORD    wScan;
    DWORD   dwFlags;
    DWORD   time;
    ULONG_PTR dwExtraInfo;
} KEYBDINPUT, *PKEYBDINPUT, * LPKEYBDINPUT;

typedef struct tagHARDWAREINPUT {
    DWORD   uMsg;
    WORD    wParamL;
    WORD    wParamH;
} HARDWAREINPUT, *PHARDWAREINPUT, * LPHARDWAREINPUT;





typedef struct tagINPUT {
    DWORD   type;

    union
    {
        MOUSEINPUT      mi;
        KEYBDINPUT      ki;
        HARDWAREINPUT   hi;
    };
} INPUT, *PINPUT, * LPINPUT;

__declspec(dllimport)
UINT
__stdcall
SendInput(
      UINT cInputs,                     
      LPINPUT pInputs,  
      int cbSize);                      

#line 5847 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 5850 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family









struct HTOUCHINPUT__{int unused;}; typedef struct HTOUCHINPUT__ *HTOUCHINPUT;

typedef struct tagTOUCHINPUT {
    LONG x;
    LONG y;
    HANDLE hSource;
    DWORD dwID;
    DWORD dwFlags;
    DWORD dwMask;
    DWORD dwTime;
    ULONG_PTR dwExtraInfo;
    DWORD cxContact;
    DWORD cyContact;
} TOUCHINPUT, *PTOUCHINPUT;
typedef TOUCHINPUT const * PCTOUCHINPUT;


#line 5881 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

























#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetTouchInputInfo(
      HTOUCHINPUT hTouchInput,               
      UINT cInputs,                          
      PTOUCHINPUT pInputs,  
      int cbSize);                           

__declspec(dllimport)
BOOL
__stdcall
CloseTouchInputHandle(
      HTOUCHINPUT hTouchInput);                   


#line 5927 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family



#line 5935 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
RegisterTouchWindow(
      HWND hwnd,
      ULONG ulFlags);

__declspec(dllimport)
BOOL
__stdcall
UnregisterTouchWindow(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
IsTouchWindow(
      HWND hwnd,
      PULONG pulFlags);

#line 5967 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 5970 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family


enum tagPOINTER_INPUT_TYPE {
    PT_POINTER  = 0x00000001,   
    PT_TOUCH    = 0x00000002,   
    PT_PEN      = 0x00000003,   
    PT_MOUSE    = 0x00000004,   

    PT_TOUCHPAD = 0x00000005,   
#line 5984 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
};
typedef DWORD POINTER_INPUT_TYPE;

typedef UINT32 POINTER_FLAGS;

#line 5990 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




























#pragma region Desktop Family


typedef enum tagPOINTER_BUTTON_CHANGE_TYPE {
    POINTER_CHANGE_NONE,
    POINTER_CHANGE_FIRSTBUTTON_DOWN,
    POINTER_CHANGE_FIRSTBUTTON_UP,
    POINTER_CHANGE_SECONDBUTTON_DOWN,
    POINTER_CHANGE_SECONDBUTTON_UP,
    POINTER_CHANGE_THIRDBUTTON_DOWN,
    POINTER_CHANGE_THIRDBUTTON_UP,
    POINTER_CHANGE_FOURTHBUTTON_DOWN,
    POINTER_CHANGE_FOURTHBUTTON_UP,
    POINTER_CHANGE_FIFTHBUTTON_DOWN,
    POINTER_CHANGE_FIFTHBUTTON_UP,
} POINTER_BUTTON_CHANGE_TYPE;

typedef struct tagPOINTER_INFO {
    POINTER_INPUT_TYPE    pointerType;
    UINT32          pointerId;
    UINT32          frameId;
    POINTER_FLAGS   pointerFlags;
    HANDLE          sourceDevice;
    HWND            hwndTarget;
    POINT           ptPixelLocation;
    POINT           ptHimetricLocation;
    POINT           ptPixelLocationRaw;
    POINT           ptHimetricLocationRaw;
    DWORD           dwTime;
    UINT32          historyCount;
    INT32           InputData;
    DWORD           dwKeyStates;
    UINT64          PerformanceCount;
    POINTER_BUTTON_CHANGE_TYPE ButtonChangeType;
} POINTER_INFO;


typedef UINT32 TOUCH_FLAGS;


typedef UINT32 TOUCH_MASK;





typedef struct tagPOINTER_TOUCH_INFO {
    POINTER_INFO    pointerInfo;
    TOUCH_FLAGS     touchFlags;
    TOUCH_MASK      touchMask;
    RECT            rcContact;
    RECT            rcContactRaw;
    UINT32          orientation;
    UINT32          pressure;
} POINTER_TOUCH_INFO;

typedef UINT32 PEN_FLAGS;





typedef UINT32 PEN_MASK;






typedef struct tagPOINTER_PEN_INFO {
    POINTER_INFO    pointerInfo;
    PEN_FLAGS       penFlags;
    PEN_MASK        penMask;
    UINT32          pressure;
    UINT32          rotation;
    INT32           tiltX;
    INT32           tiltY;
} POINTER_PEN_INFO;

#line 6099 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion














































#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
InitializeTouchInjection(
      UINT32 maxCount,
      DWORD dwMode);

__declspec(dllimport)
BOOL
__stdcall
InjectTouchInput(
      UINT32 count,
      const POINTER_TOUCH_INFO *contacts);

__declspec(dllimport)
BOOL
__stdcall
GetPointerType(
      UINT32 pointerId,
      POINTER_INPUT_TYPE *pointerType);

__declspec(dllimport)
BOOL
__stdcall
GetPointerCursorId(
      UINT32 pointerId,
      UINT32 *cursorId);

__declspec(dllimport)
BOOL
__stdcall
GetPointerInfo(
      UINT32 pointerId,
      POINTER_INFO *pointerInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      POINTER_INFO *pointerInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFrameInfo(
      UINT32 pointerId,
      UINT32 *pointerCount,
      POINTER_INFO *pointerInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFrameInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      UINT32 *pointerCount,
      POINTER_INFO *pointerInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerTouchInfo(
      UINT32 pointerId,
      POINTER_TOUCH_INFO *touchInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerTouchInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      POINTER_TOUCH_INFO *touchInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFrameTouchInfo(
      UINT32 pointerId,
      UINT32 *pointerCount,
      POINTER_TOUCH_INFO *touchInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFrameTouchInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      UINT32 *pointerCount,
      POINTER_TOUCH_INFO *touchInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerPenInfo(
      UINT32 pointerId,
      POINTER_PEN_INFO *penInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerPenInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      POINTER_PEN_INFO *penInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFramePenInfo(
      UINT32 pointerId,
      UINT32 *pointerCount,
      POINTER_PEN_INFO *penInfo);

__declspec(dllimport)
BOOL
__stdcall
GetPointerFramePenInfoHistory(
      UINT32 pointerId,
      UINT32 *entriesCount,
      UINT32 *pointerCount,
      POINTER_PEN_INFO *penInfo);

__declspec(dllimport)
BOOL
__stdcall
SkipPointerFrameMessages(
      UINT32 pointerId);

__declspec(dllimport)
BOOL
__stdcall
RegisterPointerInputTarget(
      HWND hwnd,
      POINTER_INPUT_TYPE pointerType);

__declspec(dllimport)
BOOL
__stdcall
UnregisterPointerInputTarget(
      HWND hwnd,
      POINTER_INPUT_TYPE pointerType);


__declspec(dllimport)
BOOL
__stdcall
EnableMouseInPointer(
      BOOL fEnable);

__declspec(dllimport)
BOOL
__stdcall
IsMouseInPointerEnabled(
    void);






__declspec(dllimport)
BOOL
__stdcall
RegisterTouchHitTestingWindow(
      HWND hwnd,
      ULONG value);

typedef struct tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION
{
    UINT16 score;
    POINT adjustedPoint;
} TOUCH_HIT_TESTING_PROXIMITY_EVALUATION, *PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;





typedef struct tagTOUCH_HIT_TESTING_INPUT
{
    UINT32 pointerId;
    POINT point;
    RECT boundingBox;
    RECT nonOccludedBoundingBox;
    UINT32 orientation;
} TOUCH_HIT_TESTING_INPUT, *PTOUCH_HIT_TESTING_INPUT;





__declspec(dllimport)
BOOL
__stdcall
EvaluateProximityToRect(
      const RECT *controlBoundingBox,
      const TOUCH_HIT_TESTING_INPUT *pHitTestingInput,
      TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval);

__declspec(dllimport)
BOOL
__stdcall
EvaluateProximityToPolygon(
    UINT32 numVertices,
      const POINT *controlPolygon,
      const TOUCH_HIT_TESTING_INPUT *pHitTestingInput,
      TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval);

__declspec(dllimport)
LRESULT
__stdcall
PackTouchHitTestingProximityEvaluation(
      const TOUCH_HIT_TESTING_INPUT *pHitTestingInput,
      const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION *pProximityEval);

typedef enum tagFEEDBACK_TYPE {
    FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1,
    FEEDBACK_PEN_BARRELVISUALIZATION    = 2,
    FEEDBACK_PEN_TAP                    = 3,
    FEEDBACK_PEN_DOUBLETAP              = 4,
    FEEDBACK_PEN_PRESSANDHOLD           = 5,
    FEEDBACK_PEN_RIGHTTAP               = 6,
    FEEDBACK_TOUCH_TAP                  = 7,
    FEEDBACK_TOUCH_DOUBLETAP            = 8,
    FEEDBACK_TOUCH_PRESSANDHOLD         = 9,
    FEEDBACK_TOUCH_RIGHTTAP             = 10,
    FEEDBACK_GESTURE_PRESSANDTAP        = 11,
    FEEDBACK_MAX                        = 0xFFFFFFFF
} FEEDBACK_TYPE;





__declspec(dllimport)
BOOL
__stdcall
GetWindowFeedbackSetting(
      HWND hwnd,
      FEEDBACK_TYPE feedback,
      DWORD dwFlags,
      UINT32* pSize,
      void* config);

__declspec(dllimport)
BOOL
__stdcall
SetWindowFeedbackSetting(
      HWND hwnd,
      FEEDBACK_TYPE feedback,
      DWORD dwFlags,
      UINT32 size,
      const void* configuration);


#line 6406 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 6409 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family


typedef struct tagINPUT_TRANSFORM {
    union {
        struct {
            float        _11, _12, _13, _14;
            float        _21, _22, _23, _24;
            float        _31, _32, _33, _34;
            float        _41, _42, _43, _44;
        };
        float m[4][4];
    };
} INPUT_TRANSFORM;


__declspec(dllimport)
BOOL
__stdcall
GetPointerInputTransform(
      UINT32 pointerId,
      UINT32 historyCount,
      INPUT_TRANSFORM *inputTransform);

#line 6437 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 6440 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


#line 6445 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#pragma region Desktop Family



typedef struct tagLASTINPUTINFO {
    UINT cbSize;
    DWORD dwTime;
} LASTINPUTINFO, * PLASTINPUTINFO;

__declspec(dllimport)
BOOL
__stdcall
GetLastInputInfo(
      PLASTINPUTINFO plii);
#line 6462 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyA(
      UINT uCode,
      UINT uMapType);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyW(
      UINT uCode,
      UINT uMapType);




#line 6480 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExA(
      UINT uCode,
      UINT uMapType,
      HKL dwhkl);
__declspec(dllimport)
UINT
__stdcall
MapVirtualKeyExW(
      UINT uCode,
      UINT uMapType,
      HKL dwhkl);




#line 6501 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 6507 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 6510 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetInputState(
    void);

__declspec(dllimport)
DWORD
__stdcall
GetQueueStatus(
      UINT flags);


__declspec(dllimport)
HWND
__stdcall
GetCapture(
    void);

__declspec(dllimport)
HWND
__stdcall
SetCapture(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ReleaseCapture(
    void);

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjects(
      DWORD nCount,
      const HANDLE *pHandles,
      BOOL fWaitAll,
      DWORD dwMilliseconds,
      DWORD dwWakeMask);

__declspec(dllimport)
DWORD
__stdcall
MsgWaitForMultipleObjectsEx(
      DWORD nCount,
      const HANDLE *pHandles,
      DWORD dwMilliseconds,
      DWORD dwWakeMask,
      DWORD dwFlags);


#line 6564 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




















#line 6586 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 6592 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





















#line 6614 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


















#pragma region Desktop Family






__declspec(dllimport)
UINT_PTR
__stdcall
SetTimer(
      HWND hWnd,
      UINT_PTR nIDEvent,
      UINT uElapse,
      TIMERPROC lpTimerFunc);









__declspec(dllimport)
UINT_PTR
__stdcall
SetCoalescableTimer(
      HWND hWnd,
      UINT_PTR nIDEvent,
      UINT uElapse,
      TIMERPROC lpTimerFunc,
      ULONG uToleranceDelay);

#line 6667 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
KillTimer(
      HWND hWnd,
      UINT_PTR uIDEvent);

__declspec(dllimport)
BOOL
__stdcall
IsWindowUnicode(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
EnableWindow(
      HWND hWnd,
      BOOL bEnable);

__declspec(dllimport)
BOOL
__stdcall
IsWindowEnabled(
      HWND hWnd);

__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsA(
      HINSTANCE hInstance,
      LPCSTR lpTableName);
__declspec(dllimport)
HACCEL
__stdcall
LoadAcceleratorsW(
      HINSTANCE hInstance,
      LPCWSTR lpTableName);




#line 6711 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableA(
      LPACCEL paccel,
      int cAccel);
__declspec(dllimport)
HACCEL
__stdcall
CreateAcceleratorTableW(
      LPACCEL paccel,
      int cAccel);




#line 6729 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DestroyAcceleratorTable(
      HACCEL hAccel);

__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableA(
      HACCEL hAccelSrc,
      LPACCEL lpAccelDst,
      int cAccelEntries);
__declspec(dllimport)
int
__stdcall
CopyAcceleratorTableW(
      HACCEL hAccelSrc,
      LPACCEL lpAccelDst,
      int cAccelEntries);




#line 6755 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
int
__stdcall
TranslateAcceleratorA(
      HWND hWnd,
      HACCEL hAccTable,
      LPMSG lpMsg);
__declspec(dllimport)
int
__stdcall
TranslateAcceleratorW(
      HWND hWnd,
      HACCEL hAccTable,
      LPMSG lpMsg);




#line 6777 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 6779 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 6781 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

















































































#line 6864 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 6871 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 6875 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 6883 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 6886 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 6890 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 6897 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 6902 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 6908 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 6912 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 6914 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 6916 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 6918 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 6920 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 6928 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 6932 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 6936 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 6941 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 6943 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
GetSystemMetrics(
      int nIndex);


#line 6956 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 6959 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
HMENU
__stdcall
LoadMenuA(
      HINSTANCE hInstance,
      LPCSTR lpMenuName);
__declspec(dllimport)
HMENU
__stdcall
LoadMenuW(
      HINSTANCE hInstance,
      LPCWSTR lpMenuName);




#line 6982 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HMENU
__stdcall
LoadMenuIndirectA(
      const MENUTEMPLATEA *lpMenuTemplate);
__declspec(dllimport)
HMENU
__stdcall
LoadMenuIndirectW(
      const MENUTEMPLATEW *lpMenuTemplate);




#line 6998 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HMENU
__stdcall
GetMenu(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
SetMenu(
      HWND hWnd,
      HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
ChangeMenuA(
      HMENU hMenu,
      UINT cmd,
      LPCSTR lpszNewItem,
      UINT cmdInsert,
      UINT flags);
__declspec(dllimport)
BOOL
__stdcall
ChangeMenuW(
      HMENU hMenu,
      UINT cmd,
      LPCWSTR lpszNewItem,
      UINT cmdInsert,
      UINT flags);




#line 7035 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
HiliteMenuItem(
      HWND hWnd,
      HMENU hMenu,
      UINT uIDHiliteItem,
      UINT uHilite);

__declspec(dllimport)
int
__stdcall
GetMenuStringA(
      HMENU hMenu,
      UINT uIDItem,
      LPSTR lpString,
      int cchMax,
      UINT flags);
__declspec(dllimport)
int
__stdcall
GetMenuStringW(
      HMENU hMenu,
      UINT uIDItem,
      LPWSTR lpString,
      int cchMax,
      UINT flags);




#line 7068 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
GetMenuState(
      HMENU hMenu,
      UINT uId,
      UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
DrawMenuBar(
      HWND hWnd);




#line 7087 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
HMENU
__stdcall
GetSystemMenu(
      HWND hWnd,
      BOOL bRevert);


__declspec(dllimport)
HMENU
__stdcall
CreateMenu(
    void);

__declspec(dllimport)
HMENU
__stdcall
CreatePopupMenu(
    void);

__declspec(dllimport)
BOOL
__stdcall
DestroyMenu(
      HMENU hMenu);

__declspec(dllimport)
DWORD
__stdcall
CheckMenuItem(
      HMENU hMenu,
      UINT uIDCheckItem,
      UINT uCheck);

__declspec(dllimport)
BOOL
__stdcall
EnableMenuItem(
      HMENU hMenu,
      UINT uIDEnableItem,
      UINT uEnable);

__declspec(dllimport)
HMENU
__stdcall
GetSubMenu(
      HMENU hMenu,
      int nPos);

__declspec(dllimport)
UINT
__stdcall
GetMenuItemID(
      HMENU hMenu,
      int nPos);

__declspec(dllimport)
int
__stdcall
GetMenuItemCount(
      HMENU hMenu);

__declspec(dllimport)
BOOL
__stdcall
InsertMenuA(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
InsertMenuW(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCWSTR lpNewItem);




#line 7174 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
AppendMenuA(
      HMENU hMenu,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
AppendMenuW(
      HMENU hMenu,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCWSTR lpNewItem);




#line 7196 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
ModifyMenuA(
      HMENU hMnu,
      UINT uPosition,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCSTR lpNewItem);
__declspec(dllimport)
BOOL
__stdcall
ModifyMenuW(
      HMENU hMnu,
      UINT uPosition,
      UINT uFlags,
      UINT_PTR uIDNewItem,
      LPCWSTR lpNewItem);




#line 7220 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall RemoveMenu(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
DeleteMenu(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags);

__declspec(dllimport)
BOOL
__stdcall
SetMenuItemBitmaps(
      HMENU hMenu,
      UINT uPosition,
      UINT uFlags,
      HBITMAP hBitmapUnchecked,
      HBITMAP hBitmapChecked);

__declspec(dllimport)
LONG
__stdcall
GetMenuCheckMarkDimensions(
    void);

__declspec(dllimport)
BOOL
__stdcall
TrackPopupMenu(
      HMENU hMenu,
      UINT uFlags,
      int x,
      int y,
      int nReserved,
      HWND hWnd,
      const RECT *prcRect);








typedef struct tagTPMPARAMS
{
    UINT    cbSize;     
    RECT    rcExclude;  
}   TPMPARAMS;
typedef TPMPARAMS  *LPTPMPARAMS;

__declspec(dllimport)
BOOL
__stdcall
TrackPopupMenuEx(
      HMENU hMenu,
      UINT uFlags,
      int x,
      int y,
      HWND hwnd,
      LPTPMPARAMS lptpm);
#line 7289 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
CalculatePopupWindowPosition(
      const POINT *anchorPoint,
      const SIZE *windowSize,
      UINT  flags,
      RECT *excludeRect,
      RECT *popupWindowPosition);

#line 7302 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

















typedef struct tagMENUINFO
{
    DWORD   cbSize;
    DWORD   fMask;
    DWORD   dwStyle;
    UINT    cyMax;
    HBRUSH  hbrBack;
    DWORD   dwContextHelpID;
    ULONG_PTR dwMenuData;
}   MENUINFO,  *LPMENUINFO;
typedef MENUINFO const  *LPCMENUINFO;

__declspec(dllimport)
BOOL
__stdcall
GetMenuInfo(
      HMENU,
      LPMENUINFO);

__declspec(dllimport)
BOOL
__stdcall
SetMenuInfo(
      HMENU,
      LPCMENUINFO);

__declspec(dllimport)
BOOL
__stdcall
EndMenu(
        void);







typedef struct tagMENUGETOBJECTINFO
{
    DWORD dwFlags;
    UINT uPos;
    HMENU hmenu;
    PVOID riid;
    PVOID pvObj;
} MENUGETOBJECTINFO, * PMENUGETOBJECTINFO;












#line 7378 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"








#line 7387 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

















#line 7405 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


typedef struct tagMENUITEMINFOA
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         
    UINT     fState;        
    UINT     wID;           
    HMENU    hSubMenu;      
    HBITMAP  hbmpChecked;   
    HBITMAP  hbmpUnchecked; 
    ULONG_PTR dwItemData;   
    LPSTR    dwTypeData;    
    UINT     cch;           

    HBITMAP  hbmpItem;      
#line 7423 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
}   MENUITEMINFOA,  *LPMENUITEMINFOA;
typedef struct tagMENUITEMINFOW
{
    UINT     cbSize;
    UINT     fMask;
    UINT     fType;         
    UINT     fState;        
    UINT     wID;           
    HMENU    hSubMenu;      
    HBITMAP  hbmpChecked;   
    HBITMAP  hbmpUnchecked; 
    ULONG_PTR dwItemData;   
    LPWSTR   dwTypeData;    
    UINT     cch;           

    HBITMAP  hbmpItem;      
#line 7440 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
}   MENUITEMINFOW,  *LPMENUITEMINFOW;




typedef MENUITEMINFOA MENUITEMINFO;
typedef LPMENUITEMINFOA LPMENUITEMINFO;
#line 7448 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
typedef MENUITEMINFOA const  *LPCMENUITEMINFOA;
typedef MENUITEMINFOW const  *LPCMENUITEMINFOW;



typedef LPCMENUITEMINFOA LPCMENUITEMINFO;
#line 7455 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
InsertMenuItemA(
      HMENU hmenu,
      UINT item,
      BOOL fByPosition,
      LPCMENUITEMINFOA lpmi);
__declspec(dllimport)
BOOL
__stdcall
InsertMenuItemW(
      HMENU hmenu,
      UINT item,
      BOOL fByPosition,
      LPCMENUITEMINFOW lpmi);




#line 7478 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetMenuItemInfoA(
      HMENU hmenu,
      UINT item,
      BOOL fByPosition,
      LPMENUITEMINFOA lpmii);
__declspec(dllimport)
BOOL
__stdcall
GetMenuItemInfoW(
      HMENU hmenu,
      UINT item,
      BOOL fByPosition,
      LPMENUITEMINFOW lpmii);




#line 7500 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetMenuItemInfoA(
      HMENU hmenu,
      UINT item,
      BOOL fByPositon,
      LPCMENUITEMINFOA lpmii);
__declspec(dllimport)
BOOL
__stdcall
SetMenuItemInfoW(
      HMENU hmenu,
      UINT item,
      BOOL fByPositon,
      LPCMENUITEMINFOW lpmii);




#line 7522 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





__declspec(dllimport)
UINT
__stdcall
GetMenuDefaultItem(
      HMENU hMenu,
      UINT fByPos,
      UINT gmdiFlags);

__declspec(dllimport)
BOOL
__stdcall
SetMenuDefaultItem(
      HMENU hMenu,
      UINT uItem,
      UINT fByPos);

__declspec(dllimport)
BOOL
__stdcall
GetMenuItemRect(
      HWND hWnd,
      HMENU hMenu,
      UINT uItem,
      LPRECT lprcItem);

__declspec(dllimport)
int
__stdcall
MenuItemFromPoint(
      HWND hWnd,
      HMENU hMenu,
      POINT ptScreen);
#line 7560 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


















#line 7579 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"








#line 7588 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 7591 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 7592 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 7595 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 7598 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 7600 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family






typedef struct tagDROPSTRUCT
{
    HWND    hwndSource;
    HWND    hwndSink;
    DWORD   wFmt;
    ULONG_PTR dwData;
    POINT   ptDrop;
    DWORD   dwControlData;
} DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;

#line 7623 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion











#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
DragObject(
      HWND hwndParent,
      HWND hwndFrom,
      UINT fmt,
      ULONG_PTR data,
      HCURSOR hcur);

__declspec(dllimport)
BOOL
__stdcall
DragDetect(
      HWND hwnd,
      POINT pt);

#line 7656 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 7659 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawIcon(
      HDC hDC,
      int X,
      int Y,
      HICON hIcon);

#line 7673 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


































#line 7709 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 7710 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagDRAWTEXTPARAMS
{
    UINT    cbSize;
    int     iTabLength;
    int     iLeftMargin;
    int     iRightMargin;
    UINT    uiLengthDrawn;
} DRAWTEXTPARAMS,  *LPDRAWTEXTPARAMS;

#line 7724 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 7727 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma region Desktop Family










__declspec(dllimport)
 
int
__stdcall
DrawTextA(
      HDC hdc,
    
    
    LPCSTR lpchText,
      int cchText,
      LPRECT lprc,
      UINT format);
__declspec(dllimport)
 
int
__stdcall
DrawTextW(
      HDC hdc,
    
    
    LPCWSTR lpchText,
      int cchText,
      LPRECT lprc,
      UINT format);




#line 7769 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

























#line 7795 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
 
int
__stdcall
DrawTextExA(
      HDC hdc,
    
    
    
    LPSTR lpchText,
      int cchText,
      LPRECT lprc,
      UINT format,
      LPDRAWTEXTPARAMS lpdtp);
__declspec(dllimport)
 
int
__stdcall
DrawTextExW(
      HDC hdc,
    
    
    
    LPWSTR lpchText,
      int cchText,
      LPRECT lprc,
      UINT format,
      LPDRAWTEXTPARAMS lpdtp);




#line 7831 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 7832 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 7834 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 7837 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GrayStringA(
      HDC hDC,
      HBRUSH hBrush,
      GRAYSTRINGPROC lpOutputFunc,
      LPARAM lpData,
      int nCount,
      int X,
      int Y,
      int nWidth,
      int nHeight);
__declspec(dllimport)
BOOL
__stdcall
GrayStringW(
      HDC hDC,
      HBRUSH hBrush,
      GRAYSTRINGPROC lpOutputFunc,
      LPARAM lpData,
      int nCount,
      int X,
      int Y,
      int nWidth,
      int nHeight);




#line 7872 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 7874 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


















#line 7894 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawStateA(
      HDC hdc,
      HBRUSH hbrFore,
      DRAWSTATEPROC qfnCallBack,
      LPARAM lData,
      WPARAM wData,
      int x,
      int y,
      int cx,
      int cy,
      UINT uFlags);
__declspec(dllimport)
BOOL
__stdcall
DrawStateW(
      HDC hdc,
      HBRUSH hbrFore,
      DRAWSTATEPROC qfnCallBack,
      LPARAM lData,
      WPARAM wData,
      int x,
      int y,
      int cx,
      int cy,
      UINT uFlags);




#line 7932 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 7934 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 7937 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
LONG
__stdcall
TabbedTextOutA(
      HDC hdc,
      int x,
      int y,
      LPCSTR lpString,
      int chCount,
      int nTabPositions,
      const INT *lpnTabStopPositions,
      int nTabOrigin);
__declspec(dllimport)
LONG
__stdcall
TabbedTextOutW(
      HDC hdc,
      int x,
      int y,
      LPCWSTR lpString,
      int chCount,
      int nTabPositions,
      const INT *lpnTabStopPositions,
      int nTabOrigin);




#line 7970 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentA(
      HDC hdc,
      LPCSTR lpString,
      int chCount,
      int nTabPositions,
      const INT *lpnTabStopPositions);
__declspec(dllimport)
DWORD
__stdcall
GetTabbedTextExtentW(
      HDC hdc,
      LPCWSTR lpString,
      int chCount,
      int nTabPositions,
      const INT *lpnTabStopPositions);




#line 7994 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UpdateWindow(
      HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
SetActiveWindow(
      HWND hWnd);


__declspec(dllimport)
HWND
__stdcall
GetForegroundWindow(
    void);


__declspec(dllimport)
BOOL
__stdcall
PaintDesktop(
      HDC hdc);

__declspec(dllimport)
void
__stdcall
SwitchToThisWindow(
      HWND hwnd,
      BOOL fUnknown);
#line 8028 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
SetForegroundWindow(
      HWND hWnd);


__declspec(dllimport)
BOOL
__stdcall
AllowSetForegroundWindow(
      DWORD dwProcessId);



__declspec(dllimport)
BOOL
__stdcall
LockSetForegroundWindow(
      UINT uLockCode);




#line 8055 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
WindowFromDC(
      HDC hDC);

__declspec(dllimport)
HDC
__stdcall
GetDC(
      HWND hWnd);

__declspec(dllimport)
HDC
__stdcall
GetDCEx(
      HWND hWnd,
      HRGN hrgnClip,
      DWORD flags);

#line 8077 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


















#pragma region Desktop Family


__declspec(dllimport)
HDC
__stdcall
GetWindowDC(
      HWND hWnd);

__declspec(dllimport)
int
__stdcall
ReleaseDC(
      HWND hWnd,
      HDC hDC);

__declspec(dllimport)
HDC
__stdcall
BeginPaint(
      HWND hWnd,
      LPPAINTSTRUCT lpPaint);

__declspec(dllimport)
BOOL
__stdcall
EndPaint(
      HWND hWnd,
      const PAINTSTRUCT *lpPaint);

__declspec(dllimport)
BOOL
__stdcall
GetUpdateRect(
      HWND hWnd,
      LPRECT lpRect,
      BOOL bErase);

__declspec(dllimport)
int
__stdcall
GetUpdateRgn(
      HWND hWnd,
      HRGN hRgn,
      BOOL bErase);

__declspec(dllimport)
int
__stdcall
SetWindowRgn(
      HWND hWnd,
      HRGN hRgn,
      BOOL bRedraw);

#line 8151 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
GetWindowRgn(
      HWND hWnd,
      HRGN hRgn);



__declspec(dllimport)
int
__stdcall
GetWindowRgnBox(
      HWND hWnd,
      LPRECT lprc);

#line 8174 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
ExcludeUpdateRgn(
      HDC hDC,
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRect(
      HWND hWnd,
      const RECT *lpRect,
      BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRect(
      HWND hWnd,
      const RECT *lpRect);

__declspec(dllimport)
BOOL
__stdcall
InvalidateRgn(
      HWND hWnd,
      HRGN hRgn,
      BOOL bErase);

__declspec(dllimport)
BOOL
__stdcall
ValidateRgn(
      HWND hWnd,
      HRGN hRgn);


__declspec(dllimport)
BOOL
__stdcall
RedrawWindow(
      HWND hWnd,
      const RECT *lprcUpdate,
      HRGN hrgnUpdate,
      UINT flags);

#line 8223 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion






















#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
LockWindowUpdate(
      HWND hWndLock);

__declspec(dllimport)
BOOL
__stdcall
ScrollWindow(
      HWND hWnd,
      int XAmount,
      int YAmount,
      const RECT *lpRect,
      const RECT *lpClipRect);

__declspec(dllimport)
BOOL
__stdcall
ScrollDC(
      HDC hDC,
      int dx,
      int dy,
      const RECT *lprcScroll,
      const RECT *lprcClip,
      HRGN hrgnUpdate,
      LPRECT lprcUpdate);

__declspec(dllimport)
int
__stdcall
ScrollWindowEx(
      HWND hWnd,
      int dx,
      int dy,
      const RECT *prcScroll,
      const RECT *prcClip,
      HRGN hrgnUpdate,
      LPRECT prcUpdate,
      UINT flags);

#line 8295 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion






#line 8303 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
int
__stdcall
SetScrollPos(
      HWND hWnd,
      int nBar,
      int nPos,
      BOOL bRedraw);

__declspec(dllimport)
int
__stdcall
GetScrollPos(
      HWND hWnd,
      int nBar);

__declspec(dllimport)
BOOL
__stdcall
SetScrollRange(
      HWND hWnd,
      int nBar,
      int nMinPos,
      int nMaxPos,
      BOOL bRedraw);

__declspec(dllimport)
BOOL
__stdcall
GetScrollRange(
      HWND hWnd,
      int nBar,
      LPINT lpMinPos,
      LPINT lpMaxPos);

__declspec(dllimport)
BOOL
__stdcall
ShowScrollBar(
      HWND hWnd,
      int wBar,
      BOOL bShow);

__declspec(dllimport)
BOOL
__stdcall
EnableScrollBar(
      HWND hWnd,
      UINT wSBflags,
      UINT wArrows);


















#line 8378 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetPropA(
      HWND hWnd,
      LPCSTR lpString,
      HANDLE hData);
__declspec(dllimport)
BOOL
__stdcall
SetPropW(
      HWND hWnd,
      LPCWSTR lpString,
      HANDLE hData);




#line 8398 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
GetPropA(
      HWND hWnd,
      LPCSTR lpString);
__declspec(dllimport)
HANDLE
__stdcall
GetPropW(
      HWND hWnd,
      LPCWSTR lpString);




#line 8416 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
RemovePropA(
      HWND hWnd,
      LPCSTR lpString);
__declspec(dllimport)
HANDLE
__stdcall
RemovePropW(
      HWND hWnd,
      LPCWSTR lpString);




#line 8434 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
EnumPropsExA(
      HWND hWnd,
      PROPENUMPROCEXA lpEnumFunc,
      LPARAM lParam);
__declspec(dllimport)
int
__stdcall
EnumPropsExW(
      HWND hWnd,
      PROPENUMPROCEXW lpEnumFunc,
      LPARAM lParam);




#line 8454 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
EnumPropsA(
      HWND hWnd,
      PROPENUMPROCA lpEnumFunc);
__declspec(dllimport)
int
__stdcall
EnumPropsW(
      HWND hWnd,
      PROPENUMPROCW lpEnumFunc);




#line 8472 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetWindowTextA(
      HWND hWnd,
      LPCSTR lpString);
__declspec(dllimport)
BOOL
__stdcall
SetWindowTextW(
      HWND hWnd,
      LPCWSTR lpString);




#line 8490 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

 
__declspec(dllimport)
int
__stdcall
GetWindowTextA(
      HWND hWnd,
      LPSTR lpString,
      int nMaxCount);
 
__declspec(dllimport)
int
__stdcall
GetWindowTextW(
      HWND hWnd,
      LPWSTR lpString,
      int nMaxCount);




#line 8512 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
GetWindowTextLengthA(
      HWND hWnd);
__declspec(dllimport)
int
__stdcall
GetWindowTextLengthW(
      HWND hWnd);




#line 8528 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetClientRect(
      HWND hWnd,
      LPRECT lpRect);

__declspec(dllimport)
BOOL
__stdcall
GetWindowRect(
      HWND hWnd,
      LPRECT lpRect);

__declspec(dllimport)
BOOL
__stdcall
AdjustWindowRect(
      LPRECT lpRect,
      DWORD dwStyle,
      BOOL bMenu);

__declspec(dllimport)
BOOL
__stdcall
AdjustWindowRectEx(
      LPRECT lpRect,
      DWORD dwStyle,
      BOOL bMenu,
      DWORD dwExStyle);


#line 8562 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion





#pragma region Desktop Family


typedef struct tagHELPINFO      
{
    UINT    cbSize;             
    int     iContextType;       
    int     iCtrlId;            
    HANDLE  hItemHandle;        
    DWORD_PTR dwContextId;      
    POINT   MousePos;           
}  HELPINFO,  *LPHELPINFO;

__declspec(dllimport)
BOOL
__stdcall
SetWindowContextHelpId(
      HWND,
      DWORD);

__declspec(dllimport)
DWORD
__stdcall
GetWindowContextHelpId(
      HWND);

__declspec(dllimport)
BOOL
__stdcall
SetMenuContextHelpId(
      HMENU,
      DWORD);

__declspec(dllimport)
DWORD
__stdcall
GetMenuContextHelpId(
      HMENU);

#line 8608 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 8611 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"















#line 8627 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"











#line 8639 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 8649 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 8656 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










#line 8667 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 8674 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 8676 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#pragma region Desktop Family


__declspec(dllimport)
int
__stdcall
MessageBoxA(
      HWND hWnd,
      LPCSTR lpText,
      LPCSTR lpCaption,
      UINT uType);
__declspec(dllimport)
int
__stdcall
MessageBoxW(
      HWND hWnd,
      LPCWSTR lpText,
      LPCWSTR lpCaption,
      UINT uType);




#line 8707 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"























#line 8731 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
MessageBoxExA(
      HWND hWnd,
      LPCSTR lpText,
      LPCSTR lpCaption,
      UINT uType,
      WORD wLanguageId);
__declspec(dllimport)
int
__stdcall
MessageBoxExW(
      HWND hWnd,
      LPCWSTR lpText,
      LPCWSTR lpCaption,
      UINT uType,
      WORD wLanguageId);




#line 8755 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



typedef void (__stdcall *MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

typedef struct tagMSGBOXPARAMSA
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCSTR      lpszText;
    LPCSTR      lpszCaption;
    DWORD       dwStyle;
    LPCSTR      lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
typedef struct tagMSGBOXPARAMSW
{
    UINT        cbSize;
    HWND        hwndOwner;
    HINSTANCE   hInstance;
    LPCWSTR     lpszText;
    LPCWSTR     lpszCaption;
    DWORD       dwStyle;
    LPCWSTR     lpszIcon;
    DWORD_PTR   dwContextHelpId;
    MSGBOXCALLBACK      lpfnMsgBoxCallback;
    DWORD       dwLanguageId;
} MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;





typedef MSGBOXPARAMSA MSGBOXPARAMS;
typedef PMSGBOXPARAMSA PMSGBOXPARAMS;
typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS;
#line 8795 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
MessageBoxIndirectA(
      const MSGBOXPARAMSA * lpmbp);
__declspec(dllimport)
int
__stdcall
MessageBoxIndirectW(
      const MSGBOXPARAMSW * lpmbp);




#line 8811 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 8812 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 8815 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
MessageBeep(
      UINT uType);

#line 8828 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 8831 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family



__declspec(dllimport)
int
__stdcall
ShowCursor(
      BOOL bShow);

__declspec(dllimport)
BOOL
__stdcall
SetCursorPos(
      int X,
      int Y);


__declspec(dllimport)
BOOL
__stdcall
SetPhysicalCursorPos(
      int X,
      int Y);
#line 8857 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
SetCursor(
      HCURSOR hCursor);

__declspec(dllimport)
BOOL
__stdcall
GetCursorPos(
      LPPOINT lpPoint);


__declspec(dllimport)
BOOL
__stdcall
GetPhysicalCursorPos(
      LPPOINT lpPoint);
#line 8877 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
ClipCursor(
      const RECT *lpRect);


__declspec(dllimport)
BOOL
__stdcall
GetClipCursor(
      LPRECT lpRect);

__declspec(dllimport)
HCURSOR
__stdcall
GetCursor(
    void);

__declspec(dllimport)
BOOL
__stdcall
CreateCaret(
      HWND hWnd,
      HBITMAP hBitmap,
      int nWidth,
      int nHeight);

__declspec(dllimport)
UINT
__stdcall
GetCaretBlinkTime(
    void);

__declspec(dllimport)
BOOL
__stdcall
SetCaretBlinkTime(
      UINT uMSeconds);

__declspec(dllimport)
BOOL
__stdcall
DestroyCaret(
    void);

__declspec(dllimport)
BOOL
__stdcall
HideCaret(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
ShowCaret(
      HWND hWnd);

__declspec(dllimport)
BOOL
__stdcall
SetCaretPos(
      int X,
      int Y);

__declspec(dllimport)
BOOL
__stdcall
GetCaretPos(
      LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
ClientToScreen(
      HWND hWnd,
      LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
ScreenToClient(
      HWND hWnd,
      LPPOINT lpPoint);


__declspec(dllimport)
BOOL
__stdcall
LogicalToPhysicalPoint(
      HWND hWnd,
      LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
PhysicalToLogicalPoint(
      HWND hWnd,
      LPPOINT lpPoint);

#line 8979 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
LogicalToPhysicalPointForPerMonitorDPI(
      HWND hWnd,
      LPPOINT lpPoint);

__declspec(dllimport)
BOOL
__stdcall
PhysicalToLogicalPointForPerMonitorDPI(
      HWND hWnd,
      LPPOINT lpPoint);

#line 8996 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
MapWindowPoints(
      HWND hWndFrom,
      HWND hWndTo,
      LPPOINT lpPoints,
      UINT cPoints);

__declspec(dllimport)
HWND
__stdcall
WindowFromPoint(
      POINT Point);


__declspec(dllimport)
HWND
__stdcall
WindowFromPhysicalPoint(
      POINT Point);
#line 9019 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
ChildWindowFromPoint(
      HWND hWndParent,
      POINT Point);

#line 9028 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
ChildWindowFromPointEx(
      HWND hwnd,
      POINT pt,
      UINT flags);

#line 9048 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 9051 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










































#line 9094 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"








#line 9103 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 9104 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"








#line 9113 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma region Desktop Family


__declspec(dllimport)
DWORD
__stdcall
GetSysColor(
      int nIndex);


__declspec(dllimport)
HBRUSH
__stdcall
GetSysColorBrush(
      int nIndex);


#line 9133 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
SetSysColors(
      int cElements,
      const INT * lpaElements,
      const COLORREF * lpaRgbValues);

#line 9143 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 9146 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DrawFocusRect(
      HDC hDC,
      const RECT * lprc);

__declspec(dllimport)
int
__stdcall
FillRect(
      HDC hDC,
      const RECT *lprc,
      HBRUSH hbr);

__declspec(dllimport)
int
__stdcall
FrameRect(
      HDC hDC,
      const RECT *lprc,
      HBRUSH hbr);

__declspec(dllimport)
BOOL
__stdcall
InvertRect(
      HDC hDC,
      const RECT *lprc);

__declspec(dllimport)
BOOL
__stdcall
SetRect(
      LPRECT lprc,
      int xLeft,
      int yTop,
      int xRight,
      int yBottom);

__declspec(dllimport)
BOOL
__stdcall
SetRectEmpty(
      LPRECT lprc);

__declspec(dllimport)
BOOL
__stdcall
CopyRect(
      LPRECT lprcDst,
      const RECT *lprcSrc);

__declspec(dllimport)
BOOL
__stdcall
InflateRect(
      LPRECT lprc,
      int dx,
      int dy);

__declspec(dllimport)
BOOL
__stdcall
IntersectRect(
      LPRECT lprcDst,
      const RECT *lprcSrc1,
      const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
UnionRect(
      LPRECT lprcDst,
      const RECT *lprcSrc1,
      const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
SubtractRect(
      LPRECT lprcDst,
      const RECT *lprcSrc1,
      const RECT *lprcSrc2);

__declspec(dllimport)
BOOL
__stdcall
OffsetRect(
      LPRECT lprc,
      int dx,
      int dy);

__declspec(dllimport)
BOOL
__stdcall
IsRectEmpty(
      const RECT *lprc);

__declspec(dllimport)
BOOL
__stdcall
EqualRect(
      const RECT *lprc1,
      const RECT *lprc2);

__declspec(dllimport)
BOOL
__stdcall
PtInRect(
      const RECT *lprc,
      POINT pt);



__declspec(dllimport)
WORD
__stdcall
GetWindowWord(
      HWND hWnd,
      int nIndex);

__declspec(dllimport)
WORD
__stdcall
SetWindowWord(
      HWND hWnd,
      int nIndex,
      WORD wNewWord);

__declspec(dllimport)
LONG
__stdcall
GetWindowLongA(
      HWND hWnd,
      int nIndex);
__declspec(dllimport)
LONG
__stdcall
GetWindowLongW(
      HWND hWnd,
      int nIndex);




#line 9297 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
LONG
__stdcall
SetWindowLongA(
      HWND hWnd,
      int nIndex,
      LONG dwNewLong);
__declspec(dllimport)
LONG
__stdcall
SetWindowLongW(
      HWND hWnd,
      int nIndex,
      LONG dwNewLong);




#line 9317 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

















































#line 9367 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 9375 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 9377 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
WORD
__stdcall
GetClassWord(
      HWND hWnd,
      int nIndex);

__declspec(dllimport)
WORD
__stdcall
SetClassWord(
      HWND hWnd,
      int nIndex,
      WORD wNewWord);

__declspec(dllimport)
DWORD
__stdcall
GetClassLongA(
      HWND hWnd,
      int nIndex);
__declspec(dllimport)
DWORD
__stdcall
GetClassLongW(
      HWND hWnd,
      int nIndex);




#line 9410 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
DWORD
__stdcall
SetClassLongA(
      HWND hWnd,
      int nIndex,
      LONG dwNewLong);
__declspec(dllimport)
DWORD
__stdcall
SetClassLongW(
      HWND hWnd,
      int nIndex,
      LONG dwNewLong);




#line 9430 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

















































#line 9480 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 9488 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 9490 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 9492 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
GetProcessDefaultLayout(
      DWORD *pdwDefaultLayout);

__declspec(dllimport)
BOOL
__stdcall
SetProcessDefaultLayout(
      DWORD dwDefaultLayout);
#line 9506 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetDesktopWindow(
    void);


__declspec(dllimport)
HWND
__stdcall
GetParent(
      HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
SetParent(
      HWND hWndChild,
      HWND hWndNewParent);

__declspec(dllimport)
BOOL
__stdcall
EnumChildWindows(
      HWND hWndParent,
      WNDENUMPROC lpEnumFunc,
      LPARAM lParam);


__declspec(dllimport)
HWND
__stdcall
FindWindowA(
      LPCSTR lpClassName,
      LPCSTR lpWindowName);
__declspec(dllimport)
HWND
__stdcall
FindWindowW(
      LPCWSTR lpClassName,
      LPCWSTR lpWindowName);




#line 9553 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
HWND
__stdcall
FindWindowExA(
      HWND hWndParent,
      HWND hWndChildAfter,
      LPCSTR lpszClass,
      LPCSTR lpszWindow);
__declspec(dllimport)
HWND
__stdcall
FindWindowExW(
      HWND hWndParent,
      HWND hWndChildAfter,
      LPCWSTR lpszClass,
      LPCWSTR lpszWindow);




#line 9576 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetShellWindow(
    void);

#line 9584 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
BOOL
__stdcall
RegisterShellHookWindow(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
DeregisterShellHookWindow(
      HWND hwnd);

__declspec(dllimport)
BOOL
__stdcall
EnumWindows(
      WNDENUMPROC lpEnumFunc,
      LPARAM lParam);

__declspec(dllimport)
BOOL
__stdcall
EnumThreadWindows(
      DWORD dwThreadId,
      WNDENUMPROC lpfn,
      LPARAM lParam);




__declspec(dllimport)
int
__stdcall
GetClassNameA(
      HWND hWnd,
      LPSTR lpClassName,
      int nMaxCount
    );
__declspec(dllimport)
int
__stdcall
GetClassNameW(
      HWND hWnd,
      LPWSTR lpClassName,
      int nMaxCount
    );




#line 9637 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





















#line 9659 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
HWND
__stdcall
GetTopWindow(
      HWND hWnd);





__declspec(dllimport)
DWORD
__stdcall
GetWindowThreadProcessId(
      HWND hWnd,
      LPDWORD lpdwProcessId);


__declspec(dllimport)
BOOL
__stdcall
IsGUIThread(
      BOOL bConvert);

#line 9687 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





__declspec(dllimport)
HWND
__stdcall
GetLastActivePopup(
      HWND hWnd);












#line 9710 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 9713 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HWND
__stdcall
GetWindow(
      HWND hWnd,
      UINT uCmd);






__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookA(
      int nFilterType,
      HOOKPROC pfnFilterProc);
__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookW(
      int nFilterType,
      HOOKPROC pfnFilterProc);




#line 9743 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





















#line 9765 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnhookWindowsHook(
      int nCode,
      HOOKPROC pfnFilterProc);

__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookExA(
      int idHook,
      HOOKPROC lpfn,
      HINSTANCE hmod,
      DWORD dwThreadId);
__declspec(dllimport)
HHOOK
__stdcall
SetWindowsHookExW(
      int idHook,
      HOOKPROC lpfn,
      HINSTANCE hmod,
      DWORD dwThreadId);




#line 9794 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
UnhookWindowsHookEx(
      HHOOK hhk);

__declspec(dllimport)
LRESULT
__stdcall
CallNextHookEx(
      HHOOK hhk,
      int nCode,
      WPARAM wParam,
      LPARAM lParam);










#line 9820 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 9821 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 9823 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








































#line 9865 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 9870 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 9875 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






















#line 9898 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
CheckMenuRadioItem(
      HMENU hmenu,
      UINT first,
      UINT last,
      UINT check,
      UINT flags);
#line 9915 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




typedef struct {
    WORD versionNumber;
    WORD offset;
} MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;

typedef struct {        
    WORD mtOption;
    WORD mtID;
    WCHAR mtString[1];
} MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;


#line 9932 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 9935 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



























#line 9963 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 9967 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 9977 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#pragma region Desktop Family


__declspec(dllimport)
HBITMAP
__stdcall
LoadBitmapA(
      HINSTANCE hInstance,
      LPCSTR lpBitmapName);
__declspec(dllimport)
HBITMAP
__stdcall
LoadBitmapW(
      HINSTANCE hInstance,
      LPCWSTR lpBitmapName);




#line 10002 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorA(
      HINSTANCE hInstance,
      LPCSTR lpCursorName);
__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorW(
      HINSTANCE hInstance,
      LPCWSTR lpCursorName);




#line 10020 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorFromFileA(
      LPCSTR lpFileName);
__declspec(dllimport)
HCURSOR
__stdcall
LoadCursorFromFileW(
      LPCWSTR lpFileName);




#line 10036 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HCURSOR
__stdcall
CreateCursor(
      HINSTANCE hInst,
      int xHotSpot,
      int yHotSpot,
      int nWidth,
      int nHeight,
      const void *pvANDPlane,
      const void *pvXORPlane);

__declspec(dllimport)
BOOL
__stdcall
DestroyCursor(
      HCURSOR hCursor);









#line 10064 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 10066 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



















#line 10087 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 10091 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetSystemCursor(
      HCURSOR hcur,
      DWORD id);

typedef struct _ICONINFO {
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
} ICONINFO;
typedef ICONINFO *PICONINFO;

__declspec(dllimport)
HICON
__stdcall
LoadIconA(
      HINSTANCE hInstance,
      LPCSTR lpIconName);
__declspec(dllimport)
HICON
__stdcall
LoadIconW(
      HINSTANCE hInstance,
      LPCWSTR lpIconName);




#line 10128 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
UINT
__stdcall
PrivateExtractIconsA(
      LPCSTR szFileName,
      int nIconIndex,
      int cxIcon,
      int cyIcon,
      HICON *phicon,
      UINT *piconid,
      UINT nIcons,
      UINT flags);
__declspec(dllimport)
UINT
__stdcall
PrivateExtractIconsW(
      LPCWSTR szFileName,
      int nIconIndex,
      int cxIcon,
      int cyIcon,
      HICON *phicon,
      UINT *piconid,
      UINT nIcons,
      UINT flags);




#line 10159 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HICON
__stdcall
CreateIcon(
      HINSTANCE hInstance,
      int nWidth,
      int nHeight,
      BYTE cPlanes,
      BYTE cBitsPixel,
      const BYTE *lpbANDbits,
      const BYTE *lpbXORbits);

__declspec(dllimport)
BOOL
__stdcall
DestroyIcon(
      HICON hIcon);

__declspec(dllimport)
int
__stdcall
LookupIconIdFromDirectory(
      PBYTE presbits,
      BOOL fIcon);


__declspec(dllimport)
int
__stdcall
LookupIconIdFromDirectoryEx(
      PBYTE presbits,
      BOOL fIcon,
      int cxDesired,
      int cyDesired,
      UINT Flags);
#line 10196 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HICON
__stdcall
CreateIconFromResource(
      PBYTE presbits,
      DWORD dwResSize,
      BOOL fIcon,
      DWORD dwVer);


__declspec(dllimport)
HICON
__stdcall
CreateIconFromResourceEx(
      PBYTE presbits,
      DWORD dwResSize,
      BOOL fIcon,
      DWORD dwVer,
      int cxDesired,
      int cyDesired,
      UINT Flags);


typedef struct tagCURSORSHAPE
{
    int     xHotSpot;
    int     yHotSpot;
    int     cx;
    int     cy;
    int     cbWidth;
    BYTE    Planes;
    BYTE    BitsPixel;
} CURSORSHAPE,  *LPCURSORSHAPE;
#line 10231 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 10233 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion





















#pragma region Desktop Family


__declspec(dllimport)
HANDLE
__stdcall
LoadImageA(
      HINSTANCE hInst,
      LPCSTR name,
      UINT type,
      int cx,
      int cy,
      UINT fuLoad);
__declspec(dllimport)
HANDLE
__stdcall
LoadImageW(
      HINSTANCE hInst,
      LPCWSTR name,
      UINT type,
      int cx,
      int cy,
      UINT fuLoad);




#line 10283 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
HANDLE
__stdcall
CopyImage(
      HANDLE h,
      UINT type,
      int cx,
      int cy,
      UINT flags);








#line 10302 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport) BOOL __stdcall DrawIconEx(
      HDC hdc,
      int xLeft,
      int yTop,
      HICON hIcon,
      int cxWidth,
      int cyWidth,
      UINT istepIfAniCur,
      HBRUSH hbrFlickerFreeDraw,
      UINT diFlags);

#line 10315 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 10318 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
HICON
__stdcall
CreateIconIndirect(
      PICONINFO piconinfo);

__declspec(dllimport)
HICON
__stdcall
CopyIcon(
      HICON hIcon);

__declspec(dllimport)
BOOL
__stdcall
GetIconInfo(
      HICON hIcon,
      PICONINFO piconinfo);


typedef struct _ICONINFOEXA {
    DWORD   cbSize;
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD    wResID;
    CHAR    szModName[260];
    CHAR    szResName[260];
} ICONINFOEXA, *PICONINFOEXA;
typedef struct _ICONINFOEXW {
    DWORD   cbSize;
    BOOL    fIcon;
    DWORD   xHotspot;
    DWORD   yHotspot;
    HBITMAP hbmMask;
    HBITMAP hbmColor;
    WORD    wResID;
    WCHAR   szModName[260];
    WCHAR   szResName[260];
} ICONINFOEXW, *PICONINFOEXW;




typedef ICONINFOEXA ICONINFOEX;
typedef PICONINFOEXA PICONINFOEX;
#line 10371 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetIconInfoExA(
      HICON hicon,
      PICONINFOEXA piconinfo);
__declspec(dllimport)
BOOL
__stdcall
GetIconInfoExW(
      HICON hicon,
      PICONINFOEXW piconinfo);




#line 10389 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 10390 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 10395 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 10397 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


















































































































#line 10513 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 10516 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 10517 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 10523 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 10526 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
















































#line 10575 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 10580 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 10585 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 10586 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





























#line 10616 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 10619 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
















#line 10636 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 10643 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 10653 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"













































#line 10699 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 10704 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 10707 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









































#line 10749 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
















#line 10766 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"













#line 10780 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 10783 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 10791 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

























#line 10817 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 10820 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"












#line 10833 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
















#line 10850 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 10852 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

























#pragma region Desktop Family








__declspec(dllimport)
BOOL
__stdcall
IsDialogMessageA(
      HWND hDlg,
      LPMSG lpMsg);
__declspec(dllimport)
BOOL
__stdcall
IsDialogMessageW(
      HWND hDlg,
      LPMSG lpMsg);




#line 10903 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 10905 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
MapDialogRect(
      HWND hDlg,
      LPRECT lpRect);

__declspec(dllimport)
int
__stdcall
DlgDirListA(
      HWND hDlg,
      LPSTR lpPathSpec,
      int nIDListBox,
      int nIDStaticPath,
      UINT uFileType);
__declspec(dllimport)
int
__stdcall
DlgDirListW(
      HWND hDlg,
      LPWSTR lpPathSpec,
      int nIDListBox,
      int nIDStaticPath,
      UINT uFileType);




#line 10936 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 10938 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion















#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectExA(
      HWND hwndDlg,
      LPSTR lpString,
      int chCount,
      int idListBox);
__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectExW(
      HWND hwndDlg,
      LPWSTR lpString,
      int chCount,
      int idListBox);




#line 10978 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
int
__stdcall
DlgDirListComboBoxA(
      HWND hDlg,
      LPSTR lpPathSpec,
      int nIDComboBox,
      int nIDStaticPath,
      UINT uFiletype);
__declspec(dllimport)
int
__stdcall
DlgDirListComboBoxW(
      HWND hDlg,
      LPWSTR lpPathSpec,
      int nIDComboBox,
      int nIDStaticPath,
      UINT uFiletype);




#line 11002 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectComboBoxExA(
      HWND hwndDlg,
      LPSTR lpString,
      int cchOut,
      int idComboBox);
__declspec(dllimport)
BOOL
__stdcall
DlgDirSelectComboBoxExW(
      HWND hwndDlg,
      LPWSTR lpString,
      int cchOut,
      int idComboBox);




#line 11024 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 11026 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

























#line 11053 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 11057 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 11065 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


































                                  




























































#line 11161 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 11164 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 11169 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 11179 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 11181 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"























#line 11205 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 11211 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"












































#line 11256 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 11258 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"











































#line 11302 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 11303 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 11307 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#line 11317 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 11318 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




















#line 11339 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 11342 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"














#line 11357 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 11361 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"









#pragma region Desktop Family


typedef struct tagSCROLLINFO
{
    UINT    cbSize;
    UINT    fMask;
    int     nMin;
    int     nMax;
    UINT    nPage;
    int     nPos;
    int     nTrackPos;
}   SCROLLINFO,  *LPSCROLLINFO;
typedef SCROLLINFO const  *LPCSCROLLINFO;

__declspec(dllimport)
int
__stdcall
SetScrollInfo(
      HWND hwnd,
      int nBar,
      LPCSCROLLINFO lpsi,
      BOOL redraw);

__declspec(dllimport)
BOOL
__stdcall
GetScrollInfo(
      HWND hwnd,
      int nBar,
      LPSCROLLINFO lpsi);


#line 11404 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion
#line 11406 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 11408 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 11409 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
















#line 11426 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagMDICREATESTRUCTA {
    LPCSTR   szClass;
    LPCSTR   szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        
} MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
typedef struct tagMDICREATESTRUCTW {
    LPCWSTR  szClass;
    LPCWSTR  szTitle;
    HANDLE hOwner;
    int x;
    int y;
    int cx;
    int cy;
    DWORD style;
    LPARAM lParam;        
} MDICREATESTRUCTW, *LPMDICREATESTRUCTW;




typedef MDICREATESTRUCTA MDICREATESTRUCT;
typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT;
#line 11459 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

typedef struct tagCLIENTCREATESTRUCT {
    HANDLE hWindowMenu;
    UINT idFirstChild;
} CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;

__declspec(dllimport)
LRESULT
__stdcall
DefFrameProcA(
      HWND hWnd,
      HWND hWndMDIClient,
      UINT uMsg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)
LRESULT
__stdcall
DefFrameProcW(
      HWND hWnd,
      HWND hWndMDIClient,
      UINT uMsg,
      WPARAM wParam,
      LPARAM lParam);




#line 11488 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)

LRESULT
__stdcall



#line 11497 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
DefMDIChildProcA(
      HWND hWnd,
      UINT uMsg,
      WPARAM wParam,
      LPARAM lParam);
__declspec(dllimport)

LRESULT
__stdcall



#line 11510 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
DefMDIChildProcW(
      HWND hWnd,
      UINT uMsg,
      WPARAM wParam,
      LPARAM lParam);




#line 11520 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
TranslateMDISysAccel(
      HWND hWndClient,
      LPMSG lpMsg);

#line 11531 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
ArrangeIconicWindows(
      HWND hWnd);

__declspec(dllimport)
HWND
__stdcall
CreateMDIWindowA(
      LPCSTR lpClassName,
      LPCSTR lpWindowName,
      DWORD dwStyle,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      HWND hWndParent,
      HINSTANCE hInstance,
      LPARAM lParam);
__declspec(dllimport)
HWND
__stdcall
CreateMDIWindowW(
      LPCWSTR lpClassName,
      LPCWSTR lpWindowName,
      DWORD dwStyle,
      int X,
      int Y,
      int nWidth,
      int nHeight,
      HWND hWndParent,
      HINSTANCE hInstance,
      LPARAM lParam);




#line 11571 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
WORD
__stdcall
TileWindows(
      HWND hwndParent,
      UINT wHow,
      const RECT * lpRect,
      UINT cKids,
      const HWND  * lpKids);

__declspec(dllimport)
WORD
__stdcall CascadeWindows(
      HWND hwndParent,
      UINT wHow,
      const RECT * lpRect,
      UINT cKids,
      const HWND  * lpKids);

#line 11593 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 11595 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 11598 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 11600 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family




typedef DWORD HELPPOLY;
typedef struct tagMULTIKEYHELPA {

    DWORD  mkSize;


#line 11615 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
    CHAR   mkKeylist;
    CHAR   szKeyphrase[1];
} MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
typedef struct tagMULTIKEYHELPW {

    DWORD  mkSize;


#line 11624 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
    WCHAR  mkKeylist;
    WCHAR  szKeyphrase[1];
} MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;





typedef MULTIKEYHELPA MULTIKEYHELP;
typedef PMULTIKEYHELPA PMULTIKEYHELP;
typedef LPMULTIKEYHELPA LPMULTIKEYHELP;
#line 11636 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

typedef struct tagHELPWININFOA {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    CHAR   rgchMember[2];
} HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
typedef struct tagHELPWININFOW {
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    WCHAR  rgchMember[2];
} HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;





typedef HELPWININFOA HELPWININFO;
typedef PHELPWININFOA PHELPWININFO;
typedef LPHELPWININFOA LPHELPWININFO;
#line 11664 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





































#line 11702 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
WinHelpA(
      HWND hWndMain,
      LPCSTR lpszHelp,
      UINT uCommand,
      ULONG_PTR dwData);
__declspec(dllimport)
BOOL
__stdcall
WinHelpW(
      HWND hWndMain,
      LPCWSTR lpszHelp,
      UINT uCommand,
      ULONG_PTR dwData);




#line 11726 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 11728 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 11730 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion





#line 11737 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 11741 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 11745 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family



__declspec(dllimport)
DWORD
__stdcall
GetGuiResources(
      HANDLE hProcess,
      DWORD uiFlags);
#line 11757 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 11760 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


#pragma region Desktop Family



#line 11768 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




















































































#line 11854 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"















#line 11870 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 11876 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"















#line 11892 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 11896 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 11904 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 11912 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




























#line 11941 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#pragma region Desktop Family


typedef struct tagTouchPredictionParameters
{
    UINT cbSize;
    UINT dwLatency;       
    UINT dwSampleTime;    
    UINT bUseHWTimeStamp; 
} TOUCHPREDICTIONPARAMETERS, *PTOUCHPREDICTIONPARAMETERS;










#line 11966 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion
















#line 11984 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"












































#line 12029 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"













#line 12043 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"








#line 12052 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


































#line 12087 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 12094 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



















#line 12114 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





    
    

#line 12123 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 12125 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"













#pragma region Desktop Family


typedef struct tagNONCLIENTMETRICSA
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTA lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTA lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTA lfMenuFont;
    LOGFONTA lfStatusFont;
    LOGFONTA lfMessageFont;

    int     iPaddedBorderWidth;
#line 12161 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
}   NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, * LPNONCLIENTMETRICSA;
typedef struct tagNONCLIENTMETRICSW
{
    UINT    cbSize;
    int     iBorderWidth;
    int     iScrollWidth;
    int     iScrollHeight;
    int     iCaptionWidth;
    int     iCaptionHeight;
    LOGFONTW lfCaptionFont;
    int     iSmCaptionWidth;
    int     iSmCaptionHeight;
    LOGFONTW lfSmCaptionFont;
    int     iMenuWidth;
    int     iMenuHeight;
    LOGFONTW lfMenuFont;
    LOGFONTW lfStatusFont;
    LOGFONTW lfMessageFont;

    int     iPaddedBorderWidth;
#line 12182 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
}   NONCLIENTMETRICSW, *PNONCLIENTMETRICSW, * LPNONCLIENTMETRICSW;





typedef NONCLIENTMETRICSA NONCLIENTMETRICS;
typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS;
typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS;
#line 12192 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 12194 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 12197 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 12198 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"















#pragma region Desktop Family


typedef struct tagMINIMIZEDMETRICS
{
    UINT    cbSize;
    int     iWidth;
    int     iHorzGap;
    int     iVertGap;
    int     iArrange;
}   MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;



typedef struct tagICONMETRICSA
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTA lfFont;
}   ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
typedef struct tagICONMETRICSW
{
    UINT    cbSize;
    int     iHorzSpacing;
    int     iVertSpacing;
    int     iTitleWrap;
    LOGFONTW lfFont;
}   ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;





typedef ICONMETRICSA ICONMETRICS;
typedef PICONMETRICSA PICONMETRICS;
typedef LPICONMETRICSA LPICONMETRICS;
#line 12252 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 12253 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 12254 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

typedef struct tagANIMATIONINFO
{
    UINT    cbSize;
    int     iMinAnimate;
}   ANIMATIONINFO, *LPANIMATIONINFO;

typedef struct tagSERIALKEYSA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR     lpszActivePort;
    LPSTR     lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSA, *LPSERIALKEYSA;
typedef struct tagSERIALKEYSW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR    lpszActivePort;
    LPWSTR    lpszPort;
    UINT    iBaudRate;
    UINT    iPortState;
    UINT    iActive;
}   SERIALKEYSW, *LPSERIALKEYSW;




typedef SERIALKEYSA SERIALKEYS;
typedef LPSERIALKEYSA LPSERIALKEYS;
#line 12288 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







typedef struct tagHIGHCONTRASTA
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPSTR   lpszDefaultScheme;
}   HIGHCONTRASTA, *LPHIGHCONTRASTA;
typedef struct tagHIGHCONTRASTW
{
    UINT    cbSize;
    DWORD   dwFlags;
    LPWSTR  lpszDefaultScheme;
}   HIGHCONTRASTW, *LPHIGHCONTRASTW;




typedef HIGHCONTRASTA HIGHCONTRAST;
typedef LPHIGHCONTRASTA LPHIGHCONTRAST;
#line 12314 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 12316 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion






















#line 12340 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\tvout.h"











#pragma once
#line 14 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\tvout.h"





#pragma region Desktop Family


typedef struct _VIDEOPARAMETERS {
    GUID  Guid;                         
    ULONG dwOffset;                     
    ULONG dwCommand;                    
    ULONG dwFlags;                      
    ULONG dwMode;                       
    ULONG dwTVStandard;                 
    ULONG dwAvailableModes;             
    ULONG dwAvailableTVStandard;        
    ULONG dwFlickerFilter;              
    ULONG dwOverScanX;                  
    ULONG dwOverScanY;                  
    ULONG dwMaxUnscaledX;               
    ULONG dwMaxUnscaledY;               
    ULONG dwPositionX;                  
    ULONG dwPositionY;                  
    ULONG dwBrightness;                 
    ULONG dwContrast;                   
    ULONG dwCPType;                     
    ULONG dwCPCommand;                  
    ULONG dwCPStandard;                 
    ULONG dwCPKey;
    ULONG bCP_APSTriggerBits;           
    UCHAR bOEMCopyProtection[256];      
} VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;


                                        












































#line 95 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\tvout.h"
#pragma endregion

#line 98 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\tvout.h"
#line 12345 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"











#line 12357 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family





__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsA(
      DEVMODEA* lpDevMode,
      DWORD dwFlags);
__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsW(
      DEVMODEW* lpDevMode,
      DWORD dwFlags);




#line 12381 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsExA(
      LPCSTR lpszDeviceName,
      DEVMODEA* lpDevMode,
      HWND hwnd,
      DWORD dwflags,
      LPVOID lParam);
__declspec(dllimport)
LONG
__stdcall
ChangeDisplaySettingsExW(
      LPCWSTR lpszDeviceName,
      DEVMODEW* lpDevMode,
      HWND hwnd,
      DWORD dwflags,
      LPVOID lParam);




#line 12405 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsA(
      LPCSTR lpszDeviceName,
      DWORD iModeNum,
      DEVMODEA* lpDevMode);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsW(
      LPCWSTR lpszDeviceName,
      DWORD iModeNum,
      DEVMODEW* lpDevMode);




#line 12429 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsExA(
      LPCSTR lpszDeviceName,
      DWORD iModeNum,
      DEVMODEA* lpDevMode,
      DWORD dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplaySettingsExW(
      LPCWSTR lpszDeviceName,
      DWORD iModeNum,
      DEVMODEW* lpDevMode,
      DWORD dwFlags);




#line 12453 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





__declspec(dllimport)
BOOL
__stdcall
EnumDisplayDevicesA(
      LPCSTR lpDevice,
      DWORD iDevNum,
      PDISPLAY_DEVICEA lpDisplayDevice,
      DWORD dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumDisplayDevicesW(
      LPCWSTR lpDevice,
      DWORD iDevNum,
      PDISPLAY_DEVICEW lpDisplayDevice,
      DWORD dwFlags);




#line 12479 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 12484 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
LONG
__stdcall
GetDisplayConfigBufferSizes(
      UINT32 flags,
      UINT32* numPathArrayElements,
      UINT32* numModeInfoArrayElements);

__declspec(dllimport)
LONG
__stdcall
SetDisplayConfig(
      UINT32 numPathArrayElements,
      DISPLAYCONFIG_PATH_INFO* pathArray,
      UINT32 numModeInfoArrayElements,
      DISPLAYCONFIG_MODE_INFO* modeInfoArray,
      UINT32 flags);

__declspec(dllimport)
  LONG
__stdcall
QueryDisplayConfig(
      UINT32 flags,
      UINT32* numPathArrayElements,
      DISPLAYCONFIG_PATH_INFO* pathArray,
      UINT32* numModeInfoArrayElements,
      DISPLAYCONFIG_MODE_INFO* modeInfoArray,
    
    
        DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId);

__declspec(dllimport)
LONG
__stdcall
DisplayConfigGetDeviceInfo(
      DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket);

__declspec(dllimport)
LONG
__stdcall
DisplayConfigSetDeviceInfo(
      DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket);

#line 12531 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 12533 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 12534 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


__declspec(dllimport)
 
BOOL
__stdcall
SystemParametersInfoA(
      UINT uiAction,
      UINT uiParam,
        PVOID pvParam,
      UINT fWinIni);
__declspec(dllimport)
 
BOOL
__stdcall
SystemParametersInfoW(
      UINT uiAction,
      UINT uiParam,
        PVOID pvParam,
      UINT fWinIni);




#line 12559 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 12562 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 12565 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family





typedef struct tagFILTERKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iWaitMSec;            
    DWORD iDelayMSec;           
    DWORD iRepeatMSec;          
    DWORD iBounceMSec;          
} FILTERKEYS, *LPFILTERKEYS;

#line 12583 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion












#pragma region Desktop Family


typedef struct tagSTICKYKEYS
{
    UINT  cbSize;
    DWORD dwFlags;
} STICKYKEYS, *LPSTICKYKEYS;

#line 12606 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion






























#line 12638 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagMOUSEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iMaxSpeed;
    DWORD iTimeToMaxSpeed;
    DWORD iCtrlSpeed;
    DWORD dwReserved1;
    DWORD dwReserved2;
} MOUSEKEYS, *LPMOUSEKEYS;

#line 12654 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


















#line 12674 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


typedef struct tagACCESSTIMEOUT
{
    UINT  cbSize;
    DWORD dwFlags;
    DWORD iTimeOutMSec;
} ACCESSTIMEOUT, *LPACCESSTIMEOUT;

#line 12686 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion
























#pragma region Desktop Family


typedef struct tagSOUNDSENTRYA
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPSTR   lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYA, *LPSOUNDSENTRYA;
typedef struct tagSOUNDSENTRYW
{
    UINT cbSize;
    DWORD dwFlags;
    DWORD iFSTextEffect;
    DWORD iFSTextEffectMSec;
    DWORD iFSTextEffectColorBits;
    DWORD iFSGrafEffect;
    DWORD iFSGrafEffectMSec;
    DWORD iFSGrafEffectColor;
    DWORD iWindowsEffect;
    DWORD iWindowsEffectMSec;
    LPWSTR  lpszWindowsEffectDLL;
    DWORD iWindowsEffectOrdinal;
} SOUNDSENTRYW, *LPSOUNDSENTRYW;




typedef SOUNDSENTRYA SOUNDSENTRY;
typedef LPSOUNDSENTRYA LPSOUNDSENTRY;
#line 12751 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 12753 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
SoundSentry(void);
#line 12771 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

typedef struct tagTOGGLEKEYS
{
    UINT cbSize;
    DWORD dwFlags;
} TOGGLEKEYS, *LPTOGGLEKEYS;

#line 12779 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion











#pragma region Desktop Family



typedef struct tagAUDIODESCRIPTION {
    UINT cbSize;   
    BOOL Enabled;  
    LCID Locale;   
} AUDIODESCRIPTION, *LPAUDIODESCRIPTION;
#line 12801 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






__declspec(dllimport)
void
__stdcall
SetDebugErrorLevel(
      DWORD dwLevel);

#line 12814 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion









#pragma region Desktop Family


__declspec(dllimport)
void
__stdcall
SetLastErrorEx(
      DWORD dwErrCode,
      DWORD dwType);

__declspec(dllimport)
int
__stdcall
InternalGetWindowText(
      HWND hWnd,
      LPWSTR pString,
      int cchMaxCount);










#line 12852 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
CancelShutdown(
    void);

#line 12860 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion












#pragma region Desktop Family


__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromPoint(
      POINT pt,
      DWORD dwFlags);

__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromRect(
      LPCRECT lprc,
      DWORD dwFlags);

__declspec(dllimport)
HMONITOR
__stdcall
MonitorFromWindow(
      HWND hwnd,
      DWORD dwFlags);

#line 12898 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


typedef struct tagMONITORINFO
{
    DWORD   cbSize;
    RECT    rcMonitor;
    RECT    rcWork;
    DWORD   dwFlags;
} MONITORINFO, *LPMONITORINFO;


typedef struct tagMONITORINFOEXA : public tagMONITORINFO
{
    CHAR        szDevice[32];
} MONITORINFOEXA, *LPMONITORINFOEXA;
typedef struct tagMONITORINFOEXW : public tagMONITORINFO
{
    WCHAR       szDevice[32];
} MONITORINFOEXW, *LPMONITORINFOEXW;




typedef MONITORINFOEXA MONITORINFOEX;
typedef LPMONITORINFOEXA LPMONITORINFOEX;
#line 12933 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


















#line 12952 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetMonitorInfoA(
      HMONITOR hMonitor,
      LPMONITORINFO lpmi);
__declspec(dllimport)
BOOL
__stdcall
GetMonitorInfoW(
      HMONITOR hMonitor,
      LPMONITORINFO lpmi);




#line 12970 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

typedef BOOL (__stdcall* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumDisplayMonitors(
      HDC hdc,
      LPCRECT lprcClip,
      MONITORENUMPROC lpfnEnum,
      LPARAM dwData);

#line 12983 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion



#pragma region Desktop Family






__declspec(dllimport)
void
__stdcall
NotifyWinEvent(
      DWORD event,
      HWND  hwnd,
      LONG  idObject,
      LONG  idChild);

typedef void (__stdcall* WINEVENTPROC)(
    HWINEVENTHOOK hWinEventHook,
    DWORD         event,
    HWND          hwnd,
    LONG          idObject,
    LONG          idChild,
    DWORD         idEventThread,
    DWORD         dwmsEventTime);

__declspec(dllimport)
HWINEVENTHOOK
__stdcall
SetWinEventHook(
      DWORD eventMin,
      DWORD eventMax,
      HMODULE hmodWinEventProc,
      WINEVENTPROC pfnWinEventProc,
      DWORD idProcess,
      DWORD idThread,
      DWORD dwFlags);


__declspec(dllimport)
BOOL
__stdcall
IsWinEventHookInstalled(
      DWORD event);
#line 13031 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 13033 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion









#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
UnhookWinEvent(
      HWINEVENTHOOK hWinEventHook);

#line 13053 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion















































































































































































































#line 13262 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
















#line 13279 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"















#line 13295 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"













#line 13309 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"















#line 13325 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 13327 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 13334 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 13338 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






































































































































































































#line 13537 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#line 13541 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










































































#line 13616 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






#line 13623 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"






































#pragma region Desktop Family


typedef struct tagGUITHREADINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HWND    hwndActive;
    HWND    hwndFocus;
    HWND    hwndCapture;
    HWND    hwndMenuOwner;
    HWND    hwndMoveSize;
    HWND    hwndCaret;
    RECT    rcCaret;
} GUITHREADINFO, *PGUITHREADINFO,  * LPGUITHREADINFO;

#line 13678 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion









#line 13689 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 13691 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 13692 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
GetGUIThreadInfo(
      DWORD idThread,
      PGUITHREADINFO pgui);

__declspec(dllimport)
BOOL
__stdcall
BlockInput(
    BOOL fBlockIt);





__declspec(dllimport)
BOOL
__stdcall
SetProcessDPIAware(
    void);

__declspec(dllimport)
BOOL
__stdcall
IsProcessDPIAware(
    void);

#line 13726 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
UINT
__stdcall
GetWindowModuleFileNameA(
      HWND hwnd,
      LPSTR pszFileName,
      UINT cchFileNameMax);
__declspec(dllimport)
UINT
__stdcall
GetWindowModuleFileNameW(
      HWND hwnd,
      LPWSTR pszFileName,
      UINT cchFileNameMax);




#line 13746 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 13748 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


































#line 13784 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#pragma region Desktop Family





typedef struct tagCURSORINFO
{
    DWORD   cbSize;
    DWORD   flags;
    HCURSOR hCursor;
    POINT   ptScreenPos;
} CURSORINFO, *PCURSORINFO, *LPCURSORINFO;




#line 13806 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetCursorInfo(
      PCURSORINFO pci);




typedef struct tagWINDOWINFO
{
    DWORD cbSize;
    RECT rcWindow;
    RECT rcClient;
    DWORD dwStyle;
    DWORD dwExStyle;
    DWORD dwWindowStatus;
    UINT cxWindowBorders;
    UINT cyWindowBorders;
    ATOM atomWindowType;
    WORD wCreatorVersion;
} WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;



__declspec(dllimport)
BOOL
__stdcall
GetWindowInfo(
      HWND hwnd,
      PWINDOWINFO pwi);




typedef struct tagTITLEBARINFO
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
} TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetTitleBarInfo(
      HWND hwnd,
      PTITLEBARINFO pti);


typedef struct tagTITLEBARINFOEX
{
    DWORD cbSize;
    RECT rcTitleBar;
    DWORD rgstate[5 + 1];
    RECT rgrect[5 + 1];
} TITLEBARINFOEX, *PTITLEBARINFOEX, *LPTITLEBARINFOEX;
#line 13865 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




typedef struct tagMENUBARINFO
{
    DWORD cbSize;
    RECT rcBar;          
    HMENU hMenu;         
    HWND hwndMenu;       
    BOOL fBarFocused:1;  
    BOOL fFocused:1;     
} MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetMenuBarInfo(
      HWND hwnd,
      LONG idObject,
      LONG idItem,
      PMENUBARINFO pmbi);




typedef struct tagSCROLLBARINFO
{
    DWORD cbSize;
    RECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
    DWORD rgstate[5 + 1];
} SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;

__declspec(dllimport)
BOOL
__stdcall
GetScrollBarInfo(
      HWND hwnd,
      LONG idObject,
      PSCROLLBARINFO psbi);




typedef struct tagCOMBOBOXINFO
{
    DWORD cbSize;
    RECT rcItem;
    RECT rcButton;
    DWORD stateButton;
    HWND hwndCombo;
    HWND hwndItem;
    HWND hwndList;
} COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

__declspec(dllimport)
BOOL
__stdcall
GetComboBoxInfo(
      HWND hwndCombo,
      PCOMBOBOXINFO pcbi);

#line 13932 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family


__declspec(dllimport)
HWND
__stdcall
GetAncestor(
      HWND hwnd,
      UINT gaFlags);








__declspec(dllimport)
HWND
__stdcall
RealChildWindowFromPoint(
      HWND hwndParent,
      POINT ptParentClientCoords);






__declspec(dllimport)
UINT
__stdcall
RealGetWindowClassA(
      HWND hwnd,
      LPSTR ptszClassName,
      UINT cchClassNameMax);




__declspec(dllimport)
UINT
__stdcall
RealGetWindowClassW(
      HWND hwnd,
      LPWSTR ptszClassName,
      UINT cchClassNameMax);




#line 13993 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




typedef struct tagALTTABINFO
{
    DWORD cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    POINT ptStart;
} ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;

__declspec(dllimport)
BOOL
__stdcall
GetAltTabInfoA(
      HWND hwnd,
      int iItem,
      PALTTABINFO pati,
      LPSTR pszItemText,
      UINT cchItemText);
__declspec(dllimport)
BOOL
__stdcall
GetAltTabInfoW(
      HWND hwnd,
      int iItem,
      PALTTABINFO pati,
      LPWSTR pszItemText,
      UINT cchItemText);




#line 14033 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





__declspec(dllimport)
DWORD
__stdcall
GetListBoxInfo(
      HWND hwnd);

#line 14045 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 14048 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 14049 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family




__declspec(dllimport)
BOOL
__stdcall
LockWorkStation(
    void);
#line 14061 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



__declspec(dllimport)
BOOL
__stdcall
UserHandleGrantAccess(
      HANDLE hUserHandle,
      HANDLE hJob,
      BOOL   bGrant);

#line 14073 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 14075 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion







#pragma region Desktop Family


struct HRAWINPUT__{int unused;}; typedef struct HRAWINPUT__ *HRAWINPUT;

#line 14089 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion























#pragma region Desktop Family





typedef struct tagRAWINPUTHEADER {
    DWORD dwType;
    DWORD dwSize;
    HANDLE hDevice;
    WPARAM wParam;
} RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;

#line 14127 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family





typedef struct tagRAWMOUSE {
    


    USHORT usFlags;

    


    union {
        ULONG ulButtons;
        struct  {
            USHORT  usButtonFlags;
            USHORT  usButtonData;
        };
    };


    


    ULONG ulRawButtons;

    


    LONG lLastX;

    


    LONG lLastY;

    


    ULONG ulExtraInformation;

} RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;

#line 14183 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion







































#line 14224 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family





typedef struct tagRAWKEYBOARD {
    


    USHORT MakeCode;

    



    USHORT Flags;

    USHORT Reserved;

    


    USHORT VKey;
    UINT   Message;

    


    ULONG ExtraInformation;


} RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;

#line 14260 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

















#pragma region Desktop Family





typedef struct tagRAWHID {
    DWORD dwSizeHid;    
    DWORD dwCount;      
    BYTE bRawData[1];
} RAWHID, *PRAWHID, *LPRAWHID;

#line 14291 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion





#pragma region Desktop Family


typedef struct tagRAWINPUT {
    RAWINPUTHEADER header;
    union {
        RAWMOUSE    mouse;
        RAWKEYBOARD keyboard;
        RAWHID      hid;
    } data;
} RAWINPUT, *PRAWINPUT, *LPRAWINPUT;

#line 14310 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion





#line 14317 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
GetRawInputData(
      HRAWINPUT hRawInput,
      UINT uiCommand,
      LPVOID pData,
      PUINT pcbSize,
      UINT cbSizeHeader);

#line 14341 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family


typedef struct tagRID_DEVICE_INFO_MOUSE {
    DWORD dwId;
    DWORD dwNumberOfButtons;
    DWORD dwSampleRate;
    BOOL  fHasHorizontalWheel;
} RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;

typedef struct tagRID_DEVICE_INFO_KEYBOARD {
    DWORD dwType;
    DWORD dwSubType;
    DWORD dwKeyboardMode;
    DWORD dwNumberOfFunctionKeys;
    DWORD dwNumberOfIndicators;
    DWORD dwNumberOfKeysTotal;
} RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;

typedef struct tagRID_DEVICE_INFO_HID {
    DWORD dwVendorId;
    DWORD dwProductId;
    DWORD dwVersionNumber;

    


    USHORT usUsagePage;
    USHORT usUsage;
} RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;

typedef struct tagRID_DEVICE_INFO {
    DWORD cbSize;
    DWORD dwType;
    union {
        RID_DEVICE_INFO_MOUSE mouse;
        RID_DEVICE_INFO_KEYBOARD keyboard;
        RID_DEVICE_INFO_HID hid;
    };
} RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;

__declspec(dllimport)
UINT
__stdcall
GetRawInputDeviceInfoA(
      HANDLE hDevice,
      UINT uiCommand,
      LPVOID pData,
      PUINT pcbSize);
__declspec(dllimport)
UINT
__stdcall
GetRawInputDeviceInfoW(
      HANDLE hDevice,
      UINT uiCommand,
      LPVOID pData,
      PUINT pcbSize);




#line 14412 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





__declspec(dllimport)
UINT
__stdcall
GetRawInputBuffer(
      PRAWINPUT pData,
      PUINT pcbSize,
      UINT cbSizeHeader);




typedef struct tagRAWINPUTDEVICE {
    USHORT usUsagePage; 
    USHORT usUsage;     
    DWORD dwFlags;
    HWND hwndTarget;    
} RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;

typedef const RAWINPUTDEVICE* PCRAWINPUTDEVICE;

#line 14438 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion












#line 14452 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"










#line 14463 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





#line 14469 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
RegisterRawInputDevices(
      PCRAWINPUTDEVICE pRawInputDevices,
      UINT uiNumDevices,
      UINT cbSize);

__declspec(dllimport)
UINT
__stdcall
GetRegisteredRawInputDevices(
      PRAWINPUTDEVICE pRawInputDevices,
      PUINT puiNumDevices,
      UINT cbSize);


typedef struct tagRAWINPUTDEVICELIST {
    HANDLE hDevice;
    DWORD dwType;
} RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;

__declspec(dllimport)
UINT
__stdcall
GetRawInputDeviceList(
      PRAWINPUTDEVICELIST pRawInputDeviceList,
      PUINT puiNumDevices,
      UINT cbSize);

__declspec(dllimport)
LRESULT
__stdcall
DefRawInputProc(
      PRAWINPUT* paRawInput,
      INT nInput,
      UINT cbSizeHeader);

#line 14512 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 14515 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"





















#pragma region Desktop Family


typedef enum tagPOINTER_DEVICE_TYPE {
    POINTER_DEVICE_TYPE_INTEGRATED_PEN = 0x00000001,
    POINTER_DEVICE_TYPE_EXTERNAL_PEN   = 0x00000002,
    POINTER_DEVICE_TYPE_TOUCH          = 0x00000003,

    POINTER_DEVICE_TYPE_TOUCH_PAD      = 0x00000004,
#line 14546 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
    POINTER_DEVICE_TYPE_MAX            = 0xFFFFFFFF
} POINTER_DEVICE_TYPE;

typedef struct tagPOINTER_DEVICE_INFO {
    DWORD displayOrientation;
    HANDLE device;
    POINTER_DEVICE_TYPE pointerDeviceType;
    HMONITOR monitor;
    ULONG startingCursorId;
    USHORT maxActiveContacts;
    WCHAR productString[520];
} POINTER_DEVICE_INFO;

typedef struct tagPOINTER_DEVICE_PROPERTY {
    INT32 logicalMin;
    INT32 logicalMax;
    INT32 physicalMin;
    INT32 physicalMax;
    UINT32 unit;
    UINT32 unitExponent;
    USHORT usagePageId;
    USHORT usageId;
} POINTER_DEVICE_PROPERTY;

typedef enum tagPOINTER_DEVICE_CURSOR_TYPE {
    POINTER_DEVICE_CURSOR_TYPE_UNKNOWN   = 0x00000000,
    POINTER_DEVICE_CURSOR_TYPE_TIP       = 0x00000001,
    POINTER_DEVICE_CURSOR_TYPE_ERASER    = 0x00000002,
    POINTER_DEVICE_CURSOR_TYPE_MAX       = 0xFFFFFFFF
} POINTER_DEVICE_CURSOR_TYPE;

typedef struct tagPOINTER_DEVICE_CURSOR_INFO {
    UINT32 cursorId;
    POINTER_DEVICE_CURSOR_TYPE cursor;
} POINTER_DEVICE_CURSOR_INFO;

__declspec(dllimport)
BOOL
__stdcall
GetPointerDevices(
      UINT32* deviceCount,
      POINTER_DEVICE_INFO *pointerDevices);

__declspec(dllimport)
BOOL
__stdcall
GetPointerDevice(
      HANDLE device,
      POINTER_DEVICE_INFO *pointerDevice);

__declspec(dllimport)
BOOL
__stdcall
GetPointerDeviceProperties(
      HANDLE device,
      UINT32* propertyCount,
      POINTER_DEVICE_PROPERTY *pointerProperties);

__declspec(dllimport)
BOOL
__stdcall
RegisterPointerDeviceNotifications(
      HWND window,
      BOOL notifyRange);

__declspec(dllimport)
BOOL
__stdcall
GetPointerDeviceRects(
      HANDLE device,
      RECT* pointerDeviceRect,
      RECT* displayRect);

__declspec(dllimport)
BOOL
__stdcall
GetPointerDeviceCursors(
      HANDLE device,
      UINT32* cursorCount,
      POINTER_DEVICE_CURSOR_INFO *deviceCursors);

__declspec(dllimport)
BOOL
__stdcall
GetRawPointerDeviceData(
      UINT32 pointerId,
      UINT32 historyCount,
      UINT32 propertiesCount,
      POINTER_DEVICE_PROPERTY* pProperties,
      LONG* pValues);


#line 14639 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 14642 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"











#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
ChangeWindowMessageFilter(
      UINT message,
      DWORD dwFlag);

#line 14664 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 14667 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"











#pragma region Desktop Family


typedef struct tagCHANGEFILTERSTRUCT {
    DWORD cbSize;
    DWORD ExtStatus;
} CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;

#line 14687 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion








#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
ChangeWindowMessageFilterEx(
      HWND hwnd,                                         
      UINT message,                                      
      DWORD action,                                      
      PCHANGEFILTERSTRUCT pChangeFilterStruct);   

#line 14709 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 14712 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


#line 14715 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#pragma region Desktop Family





struct HGESTUREINFO__{int unused;}; typedef struct HGESTUREINFO__ *HGESTUREINFO;

#line 14731 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




















#pragma region Desktop Family










typedef struct tagGESTUREINFO {
    UINT cbSize;                    
    DWORD dwFlags;                  
    DWORD dwID;                     
    HWND hwndTarget;                
    POINTS ptsLocation;             
    DWORD dwInstanceID;             
    DWORD dwSequenceID;             
    ULONGLONG ullArguments;         
    UINT cbExtraArgs;               
} GESTUREINFO, *PGESTUREINFO;
typedef GESTUREINFO const * PCGESTUREINFO;









typedef struct tagGESTURENOTIFYSTRUCT {
    UINT cbSize;                    
    DWORD dwFlags;                  
    HWND hwndTarget;                
    POINTS ptsLocation;             
    DWORD dwInstanceID;             
} GESTURENOTIFYSTRUCT, *PGESTURENOTIFYSTRUCT;













__declspec(dllimport)
BOOL
__stdcall
GetGestureInfo(
      HGESTUREINFO hGestureInfo,
      PGESTUREINFO pGestureInfo);







__declspec(dllimport)
BOOL
__stdcall
GetGestureExtraArgs(
      HGESTUREINFO hGestureInfo,
      UINT cbExtraArgs,
      PBYTE pExtraArgs);











__declspec(dllimport)
BOOL
__stdcall
CloseGestureInfoHandle(
      HGESTUREINFO hGestureInfo);









typedef struct tagGESTURECONFIG {
    DWORD dwID;                     
    DWORD dwWant;                   
    DWORD dwBlock;                  
} GESTURECONFIG, *PGESTURECONFIG;

#line 14856 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion









































                                                        

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetGestureConfig(
      HWND hwnd,                                     
      DWORD dwReserved,                              
      UINT cIDs,                                     
      PGESTURECONFIG pGestureConfig,    
                                                        
      UINT cbSize);                                  



                                                        

__declspec(dllimport)
BOOL
__stdcall
GetGestureConfig(
      HWND hwnd,                                     
      DWORD dwReserved,                              
      DWORD dwFlags,                                 
      PUINT pcIDs,                                   
                                                        
      PGESTURECONFIG pGestureConfig,
                                                        
      UINT cbSize);                                  

#line 14932 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion


#line 14936 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"














#line 14951 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
ShutdownBlockReasonCreate(
      HWND hWnd,
      LPCWSTR pwszReason);

__declspec(dllimport)
BOOL
__stdcall
ShutdownBlockReasonQuery(
      HWND hWnd,
      LPWSTR pwszBuff,
      DWORD *pcchBuff);

__declspec(dllimport)
BOOL
__stdcall
ShutdownBlockReasonDestroy(
      HWND hWnd);

#line 14980 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion




#pragma region Desktop Family





typedef enum tagINPUT_MESSAGE_DEVICE_TYPE  {
     IMDT_UNAVAILABLE = 0x00000000,      
     IMDT_KEYBOARD    = 0x00000001,      
     IMDT_MOUSE       = 0x00000002,      
     IMDT_TOUCH       = 0x00000004,      
     IMDT_PEN         = 0x00000008,      

     IMDT_TOUCHPAD    = 0x00000010,      
#line 15000 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
 } INPUT_MESSAGE_DEVICE_TYPE;

typedef enum tagINPUT_MESSAGE_ORIGIN_ID {
     IMO_UNAVAILABLE = 0x00000000,  
     IMO_HARDWARE    = 0x00000001,  
     IMO_INJECTED    = 0x00000002,  
     IMO_SYSTEM      = 0x00000004,  
} INPUT_MESSAGE_ORIGIN_ID;




 typedef struct tagINPUT_MESSAGE_SOURCE {
     INPUT_MESSAGE_DEVICE_TYPE deviceType;
     INPUT_MESSAGE_ORIGIN_ID   originId;
 } INPUT_MESSAGE_SOURCE;





__declspec(dllimport)
BOOL
__stdcall
GetCurrentInputMessageSource(
      INPUT_MESSAGE_SOURCE *inputMessageSource);

__declspec(dllimport)
BOOL
__stdcall
GetCIMSSM(
      INPUT_MESSAGE_SOURCE *inputMessageSource);

#line 15034 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 15037 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Application Family





typedef enum tagAR_STATE {
    AR_ENABLED        = 0x0,
    AR_DISABLED       = 0x1,
    AR_SUPPRESSED     = 0x2,
    AR_REMOTESESSION  = 0x4,
    AR_MULTIMON       = 0x8,
    AR_NOSENSOR       = 0x10,
    AR_NOT_SUPPORTED  = 0x20,
    AR_DOCKED         = 0x40,
    AR_LAPTOP         = 0x80
} AR_STATE, *PAR_STATE;

#line 15059 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion





extern "C++" { inline AR_STATE operator | (AR_STATE a, AR_STATE b) { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE &operator |= (AR_STATE &a, AR_STATE b) { return (AR_STATE &)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE operator & (AR_STATE a, AR_STATE b) { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE &operator &= (AR_STATE &a, AR_STATE b) { return (AR_STATE &)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE operator ~ (AR_STATE a) { return AR_STATE(~((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a)); } inline AR_STATE operator ^ (AR_STATE a, AR_STATE b) { return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } inline AR_STATE &operator ^= (AR_STATE &a, AR_STATE b) { return (AR_STATE &)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b)); } };
#line 15067 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#pragma region Desktop Family






typedef enum ORIENTATION_PREFERENCE {
    ORIENTATION_PREFERENCE_NONE              = 0x0,
    ORIENTATION_PREFERENCE_LANDSCAPE         = 0x1,
    ORIENTATION_PREFERENCE_PORTRAIT          = 0x2,
    ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 0x4,
    ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED  = 0x8
} ORIENTATION_PREFERENCE;





extern "C++" { inline ORIENTATION_PREFERENCE operator | (ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE &operator |= (ORIENTATION_PREFERENCE &a, ORIENTATION_PREFERENCE b) { return (ORIENTATION_PREFERENCE &)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type &)a) |= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE operator & (ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE &operator &= (ORIENTATION_PREFERENCE &a, ORIENTATION_PREFERENCE b) { return (ORIENTATION_PREFERENCE &)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type &)a) &= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE operator ~ (ORIENTATION_PREFERENCE a) { return ORIENTATION_PREFERENCE(~((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a)); } inline ORIENTATION_PREFERENCE operator ^ (ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) { return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } inline ORIENTATION_PREFERENCE &operator ^= (ORIENTATION_PREFERENCE &a, ORIENTATION_PREFERENCE b) { return (ORIENTATION_PREFERENCE &)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type &)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b)); } };
#line 15089 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

__declspec(dllimport)
BOOL
__stdcall
GetAutoRotationState(
      PAR_STATE pState);

__declspec(dllimport)
BOOL
__stdcall
GetDisplayAutoRotationPreferences(
      ORIENTATION_PREFERENCE *pOrientation);

__declspec(dllimport)
BOOL
__stdcall
GetDisplayAutoRotationPreferencesByProcessId(
      DWORD dwProcessId,
      ORIENTATION_PREFERENCE *pOrientation,
      BOOL *fRotateScreen);

__declspec(dllimport)
BOOL
__stdcall
SetDisplayAutoRotationPreferences(
      ORIENTATION_PREFERENCE orientation);

#line 15117 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 15120 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"



#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
IsImmersiveProcess(
      HANDLE hProcess);

__declspec(dllimport)
BOOL
__stdcall
SetProcessRestrictionExemption(
      BOOL fEnableExemption);

#line 15140 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#pragma endregion

#line 15143 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"







#line 15151 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"
#line 15152 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"


}
#line 15156 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"

#line 15158 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winuser.h"




#line 168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"























extern "C" {
#line 26 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"




#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"
 











#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"



















#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"


extern "C" {
#line 39 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"






#pragma region Desktop Family




__declspec(dllimport)
int
__stdcall
GetDateFormatA(
      LCID Locale,
      DWORD dwFlags,
      const SYSTEMTIME * lpDate,
      LPCSTR lpFormat,
      LPSTR lpDateStr,
      int cchDate
    );


__declspec(dllimport)
int
__stdcall
GetDateFormatW(
      LCID Locale,
      DWORD dwFlags,
      const SYSTEMTIME * lpDate,
      LPCWSTR lpFormat,
      LPWSTR lpDateStr,
      int cchDate
    );





#line 80 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"



__declspec(dllimport)
int
__stdcall
GetTimeFormatA(
      LCID Locale,
      DWORD dwFlags,
      const SYSTEMTIME * lpTime,
      LPCSTR lpFormat,
      LPSTR lpTimeStr,
      int cchTime
    );


__declspec(dllimport)
int
__stdcall
GetTimeFormatW(
      LCID Locale,
      DWORD dwFlags,
      const SYSTEMTIME * lpTime,
      LPCWSTR lpFormat,
      LPWSTR lpTimeStr,
      int cchTime
    );





#line 113 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"

#line 115 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"
#pragma endregion








#pragma region Application Family



__declspec(dllimport)
int
__stdcall
GetTimeFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      const SYSTEMTIME * lpTime,
      LPCWSTR lpFormat,
      LPWSTR lpTimeStr,
      int cchTime
    );


__declspec(dllimport)
int
__stdcall
GetDateFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      const SYSTEMTIME * lpDate,
      LPCWSTR lpFormat,
      LPWSTR lpDateStr,
      int cchDate,
      LPCWSTR lpCalendar
    );


#line 156 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"
#pragma endregion

#line 159 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"







}
#line 168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"


#line 171 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\datetimeapi.h"




#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

#line 33 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"




#pragma region Application Family










#line 49 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
































































#line 114 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



#line 118 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


























































































#line 209 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"








#line 218 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


















#line 237 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


































#line 272 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



#line 276 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"












































#line 321 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"






































































































































































#line 488 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"




#line 493 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"













#line 507 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



#line 511 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"













#line 525 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"





















































































































#line 643 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"










#line 654 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"




















#line 675 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



                                                   
                                                   
                                                   
                                                   









#line 692 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


#line 695 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

#line 697 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"





















#line 719 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



#line 723 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


























#line 750 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



#line 754 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
























































#line 811 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"









#line 821 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"




#line 826 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


#line 829 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"




























































































#line 922 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"












typedef DWORD LGRPID;




typedef DWORD LCTYPE;




typedef DWORD CALTYPE;





typedef DWORD CALID;






typedef struct _cpinfo {
    UINT    MaxCharSize;                    
    BYTE    DefaultChar[2];   
    BYTE    LeadByte[12];        
} CPINFO, *LPCPINFO;

typedef struct _cpinfoexA {
    UINT    MaxCharSize;                    
    BYTE    DefaultChar[2];   
    BYTE    LeadByte[12];        
    WCHAR   UnicodeDefaultChar;             
    UINT    CodePage;                       
    CHAR    CodePageName[260];         
} CPINFOEXA, *LPCPINFOEXA;
typedef struct _cpinfoexW {
    UINT    MaxCharSize;                    
    BYTE    DefaultChar[2];   
    BYTE    LeadByte[12];        
    WCHAR   UnicodeDefaultChar;             
    UINT    CodePage;                       
    WCHAR   CodePageName[260];         
} CPINFOEXW, *LPCPINFOEXW;




typedef CPINFOEXA CPINFOEX;
typedef LPCPINFOEXA LPCPINFOEX;
#line 986 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"






typedef struct _numberfmtA {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPSTR   lpDecimalSep;              
    LPSTR   lpThousandSep;             
    UINT    NegativeOrder;             
} NUMBERFMTA, *LPNUMBERFMTA;
typedef struct _numberfmtW {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPWSTR  lpDecimalSep;              
    LPWSTR  lpThousandSep;             
    UINT    NegativeOrder;             
} NUMBERFMTW, *LPNUMBERFMTW;




typedef NUMBERFMTA NUMBERFMT;
typedef LPNUMBERFMTA LPNUMBERFMT;
#line 1015 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"






typedef struct _currencyfmtA {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPSTR   lpDecimalSep;              
    LPSTR   lpThousandSep;             
    UINT    NegativeOrder;             
    UINT    PositiveOrder;             
    LPSTR   lpCurrencySymbol;          
} CURRENCYFMTA, *LPCURRENCYFMTA;
typedef struct _currencyfmtW {
    UINT    NumDigits;                 
    UINT    LeadingZero;               
    UINT    Grouping;                  
    LPWSTR  lpDecimalSep;              
    LPWSTR  lpThousandSep;             
    UINT    NegativeOrder;             
    UINT    PositiveOrder;             
    LPWSTR  lpCurrencySymbol;          
} CURRENCYFMTW, *LPCURRENCYFMTW;




typedef CURRENCYFMTA CURRENCYFMT;
typedef LPCURRENCYFMTA LPCURRENCYFMT;
#line 1048 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"





enum SYSNLS_FUNCTION{
    COMPARE_STRING    =  0x0001,
};
typedef DWORD NLS_FUNCTION;














typedef struct _nlsversioninfo{
    DWORD dwNLSVersionInfoSize;     
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;         
    DWORD dwEffectiveId;            
    GUID  guidCustomVersion;        
} NLSVERSIONINFO, *LPNLSVERSIONINFO;













#line 1092 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"




typedef struct _nlsversioninfoex{
    DWORD dwNLSVersionInfoSize;     
    DWORD dwNLSVersion;
    DWORD dwDefinedVersion;         
    DWORD dwEffectiveId;            
    GUID  guidCustomVersion;        
} NLSVERSIONINFOEX, *LPNLSVERSIONINFOEX;





typedef LONG    GEOID;
typedef DWORD   GEOTYPE;
typedef DWORD   GEOCLASS;







enum SYSGEOTYPE {
    GEO_NATION      =       0x0001,
    GEO_LATITUDE    =       0x0002,
    GEO_LONGITUDE   =       0x0003,
    GEO_ISO2        =       0x0004,
    GEO_ISO3        =       0x0005,
    GEO_RFC1766     =       0x0006,
    GEO_LCID        =       0x0007,
    GEO_FRIENDLYNAME=       0x0008,
    GEO_OFFICIALNAME=       0x0009,
    GEO_TIMEZONES   =       0x000A,
    GEO_OFFICIALLANGUAGES = 0x000B,
    GEO_ISO_UN_NUMBER =     0x000C,
    GEO_PARENT      =       0x000D
};





enum SYSGEOCLASS {
    GEOCLASS_NATION  = 16,
    GEOCLASS_REGION  = 14,
    GEOCLASS_ALL = 0
};






typedef enum _NORM_FORM {
    NormalizationOther  = 0,       
    NormalizationC      = 0x1,     
    NormalizationD      = 0x2,     
    NormalizationKC     = 0x5,     
                                   
    NormalizationKD     = 0x6      
                                   
} NORM_FORM;













#line 1172 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"







typedef BOOL (__stdcall* LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);
typedef BOOL (__stdcall* LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);
typedef BOOL (__stdcall* UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);
typedef BOOL (__stdcall* CODEPAGE_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* DATEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* DATEFMT_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (__stdcall* TIMEFMT_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCEXA)(LPSTR, CALID);
typedef BOOL (__stdcall* LOCALE_ENUMPROCA)(LPSTR);
typedef BOOL (__stdcall* LOCALE_ENUMPROCW)(LPWSTR);

typedef BOOL (__stdcall* LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);
typedef BOOL (__stdcall* LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);
typedef BOOL (__stdcall* UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
typedef BOOL (__stdcall* CODEPAGE_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* DATEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__stdcall* TIMEFMT_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCW)(LPWSTR);
typedef BOOL (__stdcall* CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
typedef BOOL (__stdcall* GEO_ENUMPROC)(GEOID);


























#line 1228 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



























#line 1256 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"






typedef struct _FILEMUIINFO {
    DWORD       dwSize;                 
    DWORD       dwVersion;              
    DWORD       dwFileType;             
    BYTE        pChecksum[16];          
    BYTE        pServiceChecksum[16];   
    DWORD       dwLanguageNameOffset;   
    DWORD       dwTypeIDMainSize;       
    DWORD       dwTypeIDMainOffset;     
    DWORD       dwTypeNameMainOffset;   
    DWORD       dwTypeIDMUISize;        
    DWORD       dwTypeIDMUIOffset;      
    DWORD       dwTypeNameMUIOffset;    
    BYTE        abBuffer[8];             
} FILEMUIINFO, *PFILEMUIINFO;


#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"







#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"








































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 21 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"









#line 31 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"


extern "C" {
#line 35 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"




#pragma region Application Family



__declspec(dllimport)
int
__stdcall
CompareStringEx(
      LPCWSTR lpLocaleName,
      DWORD dwCmpFlags,
      LPCWCH lpString1,
      int cchCount1,
      LPCWCH lpString2,
      int cchCount2,
      LPNLSVERSIONINFO lpVersionInformation,
      LPVOID lpReserved,
      LPARAM lParam
    );


__declspec(dllimport)
int
__stdcall
CompareStringOrdinal(
      LPCWCH lpString1,
      int cchCount1,
      LPCWCH lpString2,
      int cchCount2,
      BOOL bIgnoreCase
    );


#line 72 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"
#pragma endregion

#line 75 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"

#pragma region Desktop Family



__declspec(dllimport)
int
__stdcall
CompareStringW(
      LCID Locale,
      DWORD dwCmpFlags,
      PCNZWCH lpString1,
      int cchCount1,
      PCNZWCH lpString2,
      int cchCount2
    );





__declspec(dllimport)
int
__stdcall
FoldStringW(
      DWORD dwMapFlags,
      LPCWCH lpSrcStr,
      int cchSrc,
      LPWSTR lpDestStr,
      int cchDest
    );





#line 112 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
BOOL
__stdcall
GetStringTypeExW(
      LCID Locale,
      DWORD dwInfoType,
      LPCWCH lpSrcStr,
      int cchSrc,
      LPWORD lpCharType
    );





__declspec(dllimport)
BOOL
__stdcall
GetStringTypeW(
      DWORD dwInfoType,
      LPCWCH lpSrcStr,
      int cchSrc,
      LPWORD lpCharType
    );







__declspec(dllimport)
 
         
int
__stdcall
MultiByteToWideChar(
      UINT CodePage,
      DWORD dwFlags,
      LPCCH lpMultiByteStr,
      int cbMultiByte,
      LPWSTR lpWideCharStr,
      int cchWideChar
    );


__declspec(dllimport)
 
         
int
__stdcall
WideCharToMultiByte(
      UINT CodePage,
      DWORD dwFlags,
      LPCWCH lpWideCharStr,
      int cchWideChar,
      LPSTR lpMultiByteStr,
      int cbMultiByte,
      LPCCH lpDefaultChar,
      LPBOOL lpUsedDefaultChar
    );


#line 182 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"
#pragma endregion


}
#line 187 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"


#line 190 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\stringapiset.h"
#line 1280 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#line 1281 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
































































__declspec(dllimport)
BOOL
__stdcall
IsValidCodePage(
      UINT  CodePage);

#line 1352 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
UINT
__stdcall
GetACP(void);

__declspec(dllimport)
UINT
__stdcall
GetOEMCP(void);

#line 1368 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
BOOL
__stdcall
GetCPInfo(
      UINT       CodePage,
      LPCPINFO  lpCPInfo);

__declspec(dllimport)
BOOL
__stdcall
GetCPInfoExA(
      UINT          CodePage,
      DWORD         dwFlags,
      LPCPINFOEXA  lpCPInfoEx);
__declspec(dllimport)
BOOL
__stdcall
GetCPInfoExW(
      UINT          CodePage,
      DWORD         dwFlags,
      LPCPINFOEXW  lpCPInfoEx);




#line 1399 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

#line 1401 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family







__declspec(dllimport)
int
__stdcall
CompareStringA(
      LCID     Locale,
      DWORD    dwCmpFlags,
      PCNZCH lpString1,
      int      cchCount1,
      PCNZCH  lpString2,
      int      cchCount2);



#line 1425 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



























#line 1453 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"




__declspec(dllimport)
int
__stdcall
FindNLSString(
                         LCID Locale,
                         DWORD dwFindNLSStringFlags,
       LPCWSTR lpStringSource,
                         int cchSource,
        LPCWSTR lpStringValue,
                         int cchValue,
                    LPINT pcchFound);

#line 1470 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
int
__stdcall
LCMapStringW(
      LCID     Locale,
      DWORD    dwMapFlags,
      LPCWSTR  lpSrcStr,
      int      cchSrc,
      LPWSTR  lpDestStr,
      int      cchDest);




__declspec(dllimport)
int
__stdcall
LCMapStringA(
      LCID     Locale,
      DWORD    dwMapFlags,
      LPCSTR  lpSrcStr,
      int      cchSrc,
      LPSTR  lpDestStr,
      int      cchDest);


#line 1499 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



__declspec(dllimport)
int
__stdcall
GetLocaleInfoW(
      LCID     Locale,
      LCTYPE   LCType,
      LPWSTR lpLCData,
      int      cchData);
    




__declspec(dllimport)
int 
__stdcall 
GetLocaleInfoA(
      LCID Locale,
      LCTYPE LCType,
      LPSTR lpLCData,
      int cchData
    );



#line 1528 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
SetLocaleInfoA(
      LCID     Locale,
      LCTYPE   LCType,
      LPCSTR  lpLCData);
__declspec(dllimport)
BOOL
__stdcall
SetLocaleInfoW(
      LCID     Locale,
      LCTYPE   LCType,
      LPCWSTR  lpLCData);




#line 1548 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"




__declspec(dllimport)
int
__stdcall
GetCalendarInfoA(
      LCID     Locale,
      CALID    Calendar,
      CALTYPE  CalType,
      LPSTR   lpCalData,
      int      cchData,
      LPDWORD  lpValue);

__declspec(dllimport)
int
__stdcall
GetCalendarInfoW(
      LCID     Locale,
      CALID    Calendar,
      CALTYPE  CalType,
      LPWSTR   lpCalData,
      int      cchData,
      LPDWORD  lpValue);




#line 1578 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
SetCalendarInfoA(
      LCID     Locale,
      CALID    Calendar,
      CALTYPE  CalType,
      LPCSTR  lpCalData);
__declspec(dllimport)
BOOL
__stdcall
SetCalendarInfoW(
      LCID     Locale,
      CALID    Calendar,
      CALTYPE  CalType,
      LPCWSTR  lpCalData);




#line 1600 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#line 1601 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"










        
__declspec(dllimport)                                
BOOL                                      
__stdcall                                    
LoadStringByReference(                    
            DWORD   Flags,             
            PCWSTR  Language,      
            PCWSTR  SourceString,      
        PWSTR   Buffer,     
            ULONG  cchBuffer,                      
        PCWSTR  Directory,                     
       PULONG  pcchBufferOut                  
    );                                                
#line 1625 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)         
BOOL               
__stdcall             
IsDBCSLeadByte(    
      BYTE  TestChar 
    );

__declspec(dllimport)
BOOL
__stdcall
IsDBCSLeadByteEx(
      UINT  CodePage,
      BYTE  TestChar
    );

#line 1643 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#pragma region Application Family



__declspec(dllimport)
int
__stdcall
LCIDToLocaleName(
      LCID     Locale,
      LPWSTR  lpName,
      int      cchName,
      DWORD    dwFlags);

__declspec(dllimport)
LCID
__stdcall
LocaleNameToLCID(
      LPCWSTR lpName,
      DWORD dwFlags);

#line 1666 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

#line 1668 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family




__declspec(dllimport)
int
__stdcall
GetDurationFormat(
      LCID             Locale,
      DWORD            dwFlags,
      const SYSTEMTIME *lpDuration,
      ULONGLONG ullDuration,
      LPCWSTR          lpFormat,
      LPWSTR          lpDurationStr,
      int              cchDuration);
#line 1687 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
int
__stdcall
GetNumberFormatA(
      LCID             Locale,
      DWORD            dwFlags,
      LPCSTR          lpValue,
      const NUMBERFMTA *lpFormat,
      LPSTR          lpNumberStr,
      int              cchNumber);

__declspec(dllimport)
int
__stdcall
GetNumberFormatW(
      LCID             Locale,
      DWORD            dwFlags,
      LPCWSTR          lpValue,
      const NUMBERFMTW *lpFormat,
      LPWSTR          lpNumberStr,
      int              cchNumber);




#line 1715 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
int
__stdcall
GetCurrencyFormatA(
      LCID               Locale,
      DWORD              dwFlags,
      LPCSTR            lpValue,
      const CURRENCYFMTA *lpFormat,
      LPSTR            lpCurrencyStr,
      int                cchCurrency);

__declspec(dllimport)
int
__stdcall
GetCurrencyFormatW(
      LCID               Locale,
      DWORD              dwFlags,
      LPCWSTR            lpValue,
      const CURRENCYFMTW *lpFormat,
      LPWSTR            lpCurrencyStr,
      int                cchCurrency);




#line 1743 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoA(
      CALINFO_ENUMPROCA lpCalInfoEnumProc,
      LCID              Locale,
      CALID             Calendar,
      CALTYPE           CalType);

__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoW(
      CALINFO_ENUMPROCW lpCalInfoEnumProc,
      LCID              Locale,
      CALID             Calendar,
      CALTYPE           CalType);




#line 1767 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExA(
      CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx,
      LCID                Locale,
      CALID               Calendar,
      CALTYPE             CalType);

__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExW(
      CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx,
      LCID                Locale,
      CALID               Calendar,
      CALTYPE             CalType);




#line 1792 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#line 1793 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsA(
      TIMEFMT_ENUMPROCA lpTimeFmtEnumProc,
      LCID              Locale,
      DWORD             dwFlags);

__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsW(
      TIMEFMT_ENUMPROCW lpTimeFmtEnumProc,
      LCID              Locale,
      DWORD             dwFlags);




#line 1815 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsA(
      DATEFMT_ENUMPROCA lpDateFmtEnumProc,
      LCID              Locale,
      DWORD             dwFlags);

__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsW(
      DATEFMT_ENUMPROCW lpDateFmtEnumProc,
      LCID              Locale,
      DWORD             dwFlags);




#line 1837 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExA(
      DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx,
      LCID                Locale,
      DWORD               dwFlags);

__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExW(
      DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx,
      LCID                Locale,
      DWORD               dwFlags);




#line 1860 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#line 1861 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
IsValidLanguageGroup(
      LGRPID  LanguageGroup,
      DWORD   dwFlags);
#line 1870 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
GetNLSVersion(
         NLS_FUNCTION     Function,
         LCID             Locale,
      LPNLSVERSIONINFO lpVersionInformation);

__declspec(dllimport)
BOOL
__stdcall
IsNLSDefinedString(
      NLS_FUNCTION     Function,
      DWORD            dwFlags,
      LPNLSVERSIONINFO lpVersionInformation,
      LPCWSTR          lpString,
      INT              cchStr);


__declspec(dllimport)
BOOL
__stdcall
IsValidLocale(
      LCID   Locale,
      DWORD  dwFlags);

#line 1899 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
int
__stdcall
GetGeoInfoA(
      GEOID       Location,
      GEOTYPE     GeoType,
      LPSTR     lpGeoData,
      int         cchData,
      LANGID      LangId);
__declspec(dllimport)
int
__stdcall
GetGeoInfoW(
      GEOID       Location,
      GEOTYPE     GeoType,
      LPWSTR     lpGeoData,
      int         cchData,
      LANGID      LangId);




#line 1927 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumSystemGeoID(
      GEOCLASS        GeoClass,
      GEOID           ParentGeoId,
      GEO_ENUMPROC    lpGeoEnumProc);

__declspec(dllimport)
GEOID
__stdcall
GetUserGeoID(
      GEOCLASS    GeoClass);

#line 1943 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#pragma region Desktop Family


__declspec(dllimport)
BOOL
__stdcall
SetUserGeoID(
      GEOID       GeoId);

__declspec(dllimport)
LCID
__stdcall
ConvertDefaultLocale(
      LCID   Locale);

__declspec(dllimport)
LCID
__stdcall
GetThreadLocale(void);

__declspec(dllimport)
BOOL
__stdcall
SetThreadLocale(
      LCID  Locale
    );


__declspec(dllimport)
LANGID
__stdcall
GetSystemDefaultUILanguage(void);

__declspec(dllimport)
LANGID
__stdcall
GetUserDefaultUILanguage(void);
#line 1983 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

__declspec(dllimport)
LANGID
__stdcall
GetSystemDefaultLangID(void);

__declspec(dllimport)
LANGID
__stdcall
GetUserDefaultLangID(void);

__declspec(dllimport)
LCID
__stdcall
GetSystemDefaultLCID(void);

__declspec(dllimport)
LCID
__stdcall
GetUserDefaultLCID(void);


__declspec(dllimport)
LANGID
__stdcall
SetThreadUILanguage(  LANGID LangId);




__declspec(dllimport)
LANGID
__stdcall
GetThreadUILanguage(void);

__declspec(dllimport)
BOOL
__stdcall
GetProcessPreferredUILanguages(
      DWORD dwFlags,
      PULONG pulNumLanguages,
      PZZWSTR pwszLanguagesBuffer,
      PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
SetProcessPreferredUILanguages(
             DWORD dwFlags,
         PCZZWSTR pwszLanguagesBuffer,
        PULONG pulNumLanguages
);

__declspec(dllimport)
BOOL
__stdcall
GetUserPreferredUILanguages (
      DWORD dwFlags,
      PULONG pulNumLanguages,
      PZZWSTR pwszLanguagesBuffer,
      PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
GetSystemPreferredUILanguages (
      DWORD dwFlags,
      PULONG pulNumLanguages,
      PZZWSTR pwszLanguagesBuffer,
      PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
GetThreadPreferredUILanguages(
      DWORD dwFlags,
      PULONG pulNumLanguages,
      PZZWSTR pwszLanguagesBuffer,
      PULONG pcchLanguagesBuffer
);


__declspec(dllimport)
BOOL
__stdcall
SetThreadPreferredUILanguages(
             DWORD dwFlags,
         PCZZWSTR pwszLanguagesBuffer,
        PULONG pulNumLanguages
);

__declspec(dllimport)
 
BOOL
__stdcall
GetFileMUIInfo(
                        DWORD           dwFlags,
                     PCWSTR          pcwszFilePath,
      PFILEMUIINFO    pFileMUIInfo,
                  DWORD*          pcbFileMUIInfo);

__declspec(dllimport)
BOOL
__stdcall
GetFileMUIPath(
      DWORD      dwFlags,
      PCWSTR     pcwszFilePath ,
        PWSTR pwszLanguage,
      PULONG  pcchLanguage,
      PWSTR pwszFileMUIPath,
              PULONG pcchFileMUIPath,
              PULONGLONG pululEnumerator
);


__declspec(dllimport)
BOOL
__stdcall
GetUILanguageInfo(
      DWORD dwFlags,
      PCZZWSTR pwmszLanguage,
      PZZWSTR pwszFallbackLanguages,
      PDWORD pcchFallbackLanguages,
      PDWORD pAttributes
);


__declspec(dllimport)
BOOL
__stdcall
NotifyUILanguageChange(
             DWORD dwFlags,
             PCWSTR pcwstrNewLanguage,
         PCWSTR pcwstrPreviousLanguage,
             DWORD dwReserved,
        PDWORD pdwStatusRtrn
);

#line 2128 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"





__declspec(dllimport)
BOOL
__stdcall
GetStringTypeExA(
                      LCID       Locale,
                      DWORD      dwInfoType,
       LPCSTR   lpSrcStr,
                      int        cchSrc,
      LPWORD     lpCharType);


#line 2145 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"












__declspec(dllimport)
BOOL
__stdcall
GetStringTypeA(
      LCID     Locale,
      DWORD    dwInfoType,
      LPCSTR   lpSrcStr,
      int      cchSrc,
      LPWORD  lpCharType);

__declspec(dllimport)
int
__stdcall
FoldStringA(
      DWORD    dwMapFlags,
      LPCSTR  lpSrcStr,
      int      cchSrc,
      LPSTR  lpDestStr,
      int      cchDest);


#line 2179 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesA(
      LOCALE_ENUMPROCA lpLocaleEnumProc,
      DWORD            dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesW(
      LOCALE_ENUMPROCW lpLocaleEnumProc,
      DWORD            dwFlags);




#line 2199 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
BOOL
__stdcall
EnumSystemLanguageGroupsA(
      LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc,
      DWORD                   dwFlags,
      LONG_PTR                lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumSystemLanguageGroupsW(
      LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc,
      DWORD                   dwFlags,
      LONG_PTR                lParam);




#line 2220 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumLanguageGroupLocalesA(
      LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc,
      LGRPID                    LanguageGroup,
      DWORD                     dwFlags,
      LONG_PTR                  lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumLanguageGroupLocalesW(
      LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
      LGRPID                    LanguageGroup,
      DWORD                     dwFlags,
      LONG_PTR                  lParam);




#line 2242 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

__declspec(dllimport)
BOOL
__stdcall
EnumUILanguagesA(
      UILANGUAGE_ENUMPROCA lpUILanguageEnumProc,
      DWORD                dwFlags,
      LONG_PTR             lParam);
__declspec(dllimport)
BOOL
__stdcall
EnumUILanguagesW(
      UILANGUAGE_ENUMPROCW lpUILanguageEnumProc,
      DWORD                dwFlags,
      LONG_PTR             lParam);




#line 2262 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#line 2263 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

#line 2265 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#pragma region Application Family


__declspec(dllimport)
BOOL
__stdcall
EnumSystemCodePagesA(
      CODEPAGE_ENUMPROCA lpCodePageEnumProc,
      DWORD              dwFlags);
__declspec(dllimport)
BOOL
__stdcall
EnumSystemCodePagesW(
      CODEPAGE_ENUMPROCW lpCodePageEnumProc,
      DWORD              dwFlags);




#line 2287 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"






__declspec(dllimport)
int
__stdcall NormalizeString(                            NORM_FORM NormForm,
                               LPCWSTR   lpSrcString,
                                                   int       cwSrcLength,
                          LPWSTR    lpDstString,
                                                   int       cwDstLength );

__declspec(dllimport)
BOOL
__stdcall IsNormalizedString(                     NORM_FORM NormForm,
                              LPCWSTR   lpString,
                                               int       cwLength );




__declspec(dllimport)
int
__stdcall IdnToAscii(                            DWORD    dwFlags,
                    	 LPCWSTR  lpUnicodeCharStr,
                                           	 int      cchUnicodeChar,
                    LPWSTR   lpASCIICharStr,
                                           	 int      cchASCIIChar);

__declspec(dllimport)
int
__stdcall IdnToNameprepUnicode(                             	DWORD   dwFlags,
                                  	LPCWSTR lpUnicodeCharStr,
                                                         	int     cchUnicodeChar,
                                LPWSTR  lpNameprepCharStr,
                                                         	int     cchNameprepChar);

__declspec(dllimport)
int
__stdcall IdnToUnicode(                          	 DWORD   dwFlags,
                         	 LPCWSTR lpASCIICharStr,
                                              	 int     cchASCIIChar,
                      LPWSTR  lpUnicodeCharStr,
                                              	 int     cchUnicodeChar);

__declspec(dllimport)
BOOL
__stdcall VerifyScripts(
         DWORD   dwFlags,            
         LPCWSTR lpLocaleScripts,    
         int     cchLocaleScripts,   
         LPCWSTR lpTestScripts,      
         int     cchTestScripts);    

__declspec(dllimport)
int
__stdcall GetStringScripts(
                                  DWORD   dwFlags,        
                                  LPCWSTR lpString,       
                                  int     cchString,      
          LPWSTR  lpScripts,      
                                  int     cchScripts);    

#line 2353 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

#line 2355 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion



#pragma region Application Family










__declspec(dllimport)
int
__stdcall
GetLocaleInfoEx(
      LPCWSTR lpLocaleName,
      LCTYPE LCType,
      LPWSTR lpLCData,
      int cchData
);

__declspec(dllimport)
int
__stdcall
GetCalendarInfoEx(
      LPCWSTR lpLocaleName,
      CALID Calendar,
      LPCWSTR lpReserved,
      CALTYPE CalType,
      LPWSTR lpCalData,
      int cchData,
      LPDWORD lpValue
);

__declspec(dllimport)
int
__stdcall
GetDurationFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      const SYSTEMTIME *lpDuration,
      ULONGLONG ullDuration,
      LPCWSTR lpFormat,
      LPWSTR lpDurationStr,
      int cchDuration
);

__declspec(dllimport)
int
__stdcall
GetNumberFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      LPCWSTR lpValue,
      const NUMBERFMTW *lpFormat,
      LPWSTR lpNumberStr,
      int cchNumber
);

__declspec(dllimport)
int
__stdcall
GetCurrencyFormatEx(
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      LPCWSTR lpValue,
      const CURRENCYFMTW *lpFormat,
      LPWSTR lpCurrencyStr,
      int cchCurrency
);

__declspec(dllimport)
int
__stdcall
GetUserDefaultLocaleName(
      LPWSTR lpLocaleName,
      int cchLocaleName
);

__declspec(dllimport)
int
__stdcall
GetSystemDefaultLocaleName(
      LPWSTR lpLocaleName,
      int cchLocaleName
);

__declspec(dllimport)
BOOL
__stdcall
GetNLSVersionEx(
     	    NLS_FUNCTION function,
         LPCWSTR lpLocaleName,
     	    LPNLSVERSIONINFOEX lpVersionInformation
);


__declspec(dllimport)
DWORD
__stdcall
IsValidNLSVersion(
             NLS_FUNCTION function,
         LPCWSTR lpLocaleName,
             LPNLSVERSIONINFOEX lpVersionInformation
);
#line 2465 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

__declspec(dllimport)
int
__stdcall
FindNLSStringEx(
      LPCWSTR lpLocaleName,
      DWORD dwFindNLSStringFlags,
      LPCWSTR lpStringSource,
      int cchSource,
      LPCWSTR lpStringValue,
      int cchValue,
      LPINT pcchFound,
      LPNLSVERSIONINFO lpVersionInformation,
      LPVOID lpReserved,
      LPARAM sortHandle
);





#line 2487 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"


__declspec(dllimport)
int
__stdcall
LCMapStringEx(
      LPCWSTR lpLocaleName,
      DWORD dwMapFlags,
      LPCWSTR lpSrcStr,
      int cchSrc,
      LPWSTR lpDestStr,
      int cchDest,
      LPNLSVERSIONINFO lpVersionInformation,
      LPVOID lpReserved,
      LPARAM sortHandle
);

__declspec(dllimport)
BOOL
__stdcall
IsValidLocaleName(
      LPCWSTR lpLocaleName
);

typedef BOOL (__stdcall* CALINFO_ENUMPROCEXEX)(LPWSTR, CALID, LPWSTR, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumCalendarInfoExEx(
      CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx,
      LPCWSTR lpLocaleName,
      CALID Calendar,
      LPCWSTR lpReserved,
      CALTYPE CalType,
      LPARAM lParam
);

typedef BOOL (__stdcall* DATEFMT_ENUMPROCEXEX)(LPWSTR, CALID, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumDateFormatsExEx(
      DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx,
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      LPARAM lParam
);

typedef BOOL (__stdcall* TIMEFMT_ENUMPROCEX)(LPWSTR, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumTimeFormatsEx(
      TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx,
      LPCWSTR lpLocaleName,
      DWORD dwFlags,
      LPARAM lParam
);

typedef BOOL (__stdcall* LOCALE_ENUMPROCEX)(LPWSTR, DWORD, LPARAM);

__declspec(dllimport)
BOOL
__stdcall
EnumSystemLocalesEx(
      LOCALE_ENUMPROCEX lpLocaleEnumProcEx,
      DWORD dwFlags,
      LPARAM lParam,
      LPVOID lpReserved
);

#line 2562 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#line 2565 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



#pragma region Application Family


__declspec(dllimport)
int
__stdcall
ResolveLocaleName(
                             LPCWSTR lpNameToResolve,
      LPWSTR  lpLocaleName,
                                 int     cchLocaleName
);

#line 2581 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#line 2584 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

#pragma region Desktop Family


    
#line 2590 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"
#pragma endregion

#line 2593 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"



}
#line 2598 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

#line 2600 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnls.h"

#line 170 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 171 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"


























#pragma once


extern "C" {
#line 32 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"



#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

#pragma region Application Family


typedef struct _COORD {
    SHORT X;
    SHORT Y;
} COORD, *PCOORD;

#line 46 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion

#pragma region Desktop Family


typedef struct _SMALL_RECT {
    SHORT Left;
    SHORT Top;
    SHORT Right;
    SHORT Bottom;
} SMALL_RECT, *PSMALL_RECT;

#line 59 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion

#pragma region Application Family


typedef struct _KEY_EVENT_RECORD {
    BOOL bKeyDown;
    WORD wRepeatCount;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } uChar;
    DWORD dwControlKeyState;
} KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;






















typedef struct _MOUSE_EVENT_RECORD {
    COORD dwMousePosition;
    DWORD dwButtonState;
    DWORD dwControlKeyState;
    DWORD dwEventFlags;
} MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;




















#line 124 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

typedef struct _WINDOW_BUFFER_SIZE_RECORD {
    COORD dwSize;
} WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;

typedef struct _MENU_EVENT_RECORD {
    UINT dwCommandId;
} MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;

typedef struct _FOCUS_EVENT_RECORD {
    BOOL bSetFocus;
} FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;

typedef struct _INPUT_RECORD {
    WORD EventType;
    union {
        KEY_EVENT_RECORD KeyEvent;
        MOUSE_EVENT_RECORD MouseEvent;
        WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        MENU_EVENT_RECORD MenuEvent;
        FOCUS_EVENT_RECORD FocusEvent;
    } Event;
} INPUT_RECORD, *PINPUT_RECORD;

#line 149 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion











#pragma region Desktop Family


typedef struct _CHAR_INFO {
    union {
        WCHAR UnicodeChar;
        CHAR   AsciiChar;
    } Char;
    WORD Attributes;
} CHAR_INFO, *PCHAR_INFO;

#line 173 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion























#pragma region Desktop Family


typedef struct _CONSOLE_SCREEN_BUFFER_INFO {
    COORD dwSize;
    COORD dwCursorPosition;
    WORD  wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
} CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;

typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX {
    ULONG cbSize;
    COORD dwSize;
    COORD dwCursorPosition;
    WORD wAttributes;
    SMALL_RECT srWindow;
    COORD dwMaximumWindowSize;
    WORD wPopupAttributes;
    BOOL bFullscreenSupported;
    COLORREF ColorTable[16];
} CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;

typedef struct _CONSOLE_CURSOR_INFO {
    DWORD  dwSize;
    BOOL   bVisible;
} CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;

typedef struct _CONSOLE_FONT_INFO {
    DWORD  nFont;
    COORD  dwFontSize;
} CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;


typedef struct _CONSOLE_FONT_INFOEX {
    ULONG cbSize;
    DWORD nFont;
    COORD dwFontSize;
    UINT FontFamily;
    UINT FontWeight;
    WCHAR FaceName[32];
} CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;
#line 240 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"



typedef struct _CONSOLE_HISTORY_INFO {
    UINT cbSize;
    UINT HistoryBufferSize;
    UINT NumberOfHistoryBuffers;
    DWORD dwFlags;
} CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;

#line 251 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion



#pragma region Desktop Family


typedef struct _CONSOLE_SELECTION_INFO {
    DWORD dwFlags;
    COORD dwSelectionAnchor;
    SMALL_RECT srSelection;
} CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;

#line 265 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion










#line 277 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

#pragma region Application Family






typedef
BOOL
(__stdcall *PHANDLER_ROUTINE)(
      DWORD CtrlType
    );

#line 292 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion






























#pragma region Desktop Family






__declspec(dllimport)
BOOL
__stdcall
PeekConsoleInputW(
      HANDLE hConsoleInput,
      PINPUT_RECORD lpBuffer,
      DWORD nLength,
      LPDWORD lpNumberOfEventsRead
    );




__declspec(dllimport)
BOOL
__stdcall
WriteConsoleInputA(
      HANDLE hConsoleInput,
      const INPUT_RECORD *lpBuffer,
      DWORD nLength,
      LPDWORD lpNumberOfEventsWritten
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleInputW(
      HANDLE hConsoleInput,
      const INPUT_RECORD *lpBuffer,
      DWORD nLength,
      LPDWORD lpNumberOfEventsWritten
    );




#line 366 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputA(
      HANDLE hConsoleOutput,
      PCHAR_INFO lpBuffer,
      COORD dwBufferSize,
      COORD dwBufferCoord,
      PSMALL_RECT lpReadRegion
    );
__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputW(
      HANDLE hConsoleOutput,
      PCHAR_INFO lpBuffer,
      COORD dwBufferSize,
      COORD dwBufferCoord,
      PSMALL_RECT lpReadRegion
    );




#line 392 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputA(
      HANDLE hConsoleOutput,
      const CHAR_INFO *lpBuffer,
      COORD dwBufferSize,
      COORD dwBufferCoord,
      PSMALL_RECT lpWriteRegion
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputW(
      HANDLE hConsoleOutput,
      const CHAR_INFO *lpBuffer,
      COORD dwBufferSize,
      COORD dwBufferCoord,
      PSMALL_RECT lpWriteRegion
    );




#line 418 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputCharacterA(
      HANDLE hConsoleOutput,
      LPSTR lpCharacter,
      DWORD nLength,
      COORD dwReadCoord,
      LPDWORD lpNumberOfCharsRead
    );
__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputCharacterW(
      HANDLE hConsoleOutput,
      LPWSTR lpCharacter,
      DWORD nLength,
      COORD dwReadCoord,
      LPDWORD lpNumberOfCharsRead
    );




#line 444 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
ReadConsoleOutputAttribute(
      HANDLE hConsoleOutput,
      LPWORD lpAttribute,
      DWORD nLength,
      COORD dwReadCoord,
      LPDWORD lpNumberOfAttrsRead
    );

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputCharacterA(
      HANDLE hConsoleOutput,
      LPCSTR lpCharacter,
      DWORD nLength,
      COORD dwWriteCoord,
      LPDWORD lpNumberOfCharsWritten
    );
__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputCharacterW(
      HANDLE hConsoleOutput,
      LPCWSTR lpCharacter,
      DWORD nLength,
      COORD dwWriteCoord,
      LPDWORD lpNumberOfCharsWritten
    );




#line 481 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleOutputAttribute(
      HANDLE hConsoleOutput,
      const WORD *lpAttribute,
      DWORD nLength,
      COORD dwWriteCoord,
      LPDWORD lpNumberOfAttrsWritten
    );

__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputCharacterA(
      HANDLE hConsoleOutput,
      CHAR  cCharacter,
      DWORD  nLength,
      COORD  dwWriteCoord,
      LPDWORD lpNumberOfCharsWritten
    );
__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputCharacterW(
      HANDLE hConsoleOutput,
      WCHAR  cCharacter,
      DWORD  nLength,
      COORD  dwWriteCoord,
      LPDWORD lpNumberOfCharsWritten
    );




#line 518 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
FillConsoleOutputAttribute(
      HANDLE hConsoleOutput,
      WORD   wAttribute,
      DWORD  nLength,
      COORD  dwWriteCoord,
      LPDWORD lpNumberOfAttrsWritten
    );




__declspec(dllimport)
BOOL
__stdcall
GetConsoleScreenBufferInfo(
      HANDLE hConsoleOutput,
      PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleScreenBufferInfoEx(
      HANDLE hConsoleOutput,
      PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);

__declspec(dllimport)
BOOL
__stdcall
SetConsoleScreenBufferInfoEx(
      HANDLE hConsoleOutput,
      PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);

__declspec(dllimport)
COORD
__stdcall
GetLargestConsoleWindowSize(
      HANDLE hConsoleOutput
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleCursorInfo(
      HANDLE hConsoleOutput,
      PCONSOLE_CURSOR_INFO lpConsoleCursorInfo
    );



__declspec(dllimport)
BOOL
__stdcall
GetCurrentConsoleFont(
      HANDLE hConsoleOutput,
      BOOL bMaximumWindow,
      PCONSOLE_FONT_INFO lpConsoleCurrentFont
    );


__declspec(dllimport)
BOOL
__stdcall
GetCurrentConsoleFontEx(
      HANDLE hConsoleOutput,
      BOOL bMaximumWindow,
      PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);

__declspec(dllimport)
BOOL
__stdcall
SetCurrentConsoleFontEx(
      HANDLE hConsoleOutput,
      BOOL bMaximumWindow,
      PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);
#line 598 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
GetConsoleHistoryInfo(
      PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);

__declspec(dllimport)
BOOL
__stdcall
SetConsoleHistoryInfo(
      PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);

__declspec(dllimport)
COORD
__stdcall
GetConsoleFontSize(
      HANDLE hConsoleOutput,
      DWORD nFont
    );

__declspec(dllimport)
BOOL
__stdcall
GetConsoleSelectionInfo(
      PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo
    );

#line 627 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
GetNumberOfConsoleMouseButtons(
      LPDWORD lpNumberOfMouseButtons
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleActiveScreenBuffer(
      HANDLE hConsoleOutput
    );

__declspec(dllimport)
BOOL
__stdcall
FlushConsoleInputBuffer(
      HANDLE hConsoleInput
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleScreenBufferSize(
      HANDLE hConsoleOutput,
      COORD dwSize
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCursorPosition(
      HANDLE hConsoleOutput,
      COORD dwCursorPosition
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCursorInfo(
      HANDLE hConsoleOutput,
      const CONSOLE_CURSOR_INFO *lpConsoleCursorInfo
    );

__declspec(dllimport)
BOOL
__stdcall
ScrollConsoleScreenBufferA(
      HANDLE hConsoleOutput,
      const SMALL_RECT *lpScrollRectangle,
      const SMALL_RECT *lpClipRectangle,
      COORD dwDestinationOrigin,
      const CHAR_INFO *lpFill
    );
__declspec(dllimport)
BOOL
__stdcall
ScrollConsoleScreenBufferW(
      HANDLE hConsoleOutput,
      const SMALL_RECT *lpScrollRectangle,
      const SMALL_RECT *lpClipRectangle,
      COORD dwDestinationOrigin,
      const CHAR_INFO *lpFill
    );




#line 698 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
SetConsoleWindowInfo(
      HANDLE hConsoleOutput,
      BOOL bAbsolute,
      const SMALL_RECT *lpConsoleWindow
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleTextAttribute(
      HANDLE hConsoleOutput,
      WORD wAttributes
    );

__declspec(dllimport)
BOOL
__stdcall
GenerateConsoleCtrlEvent(
      DWORD dwCtrlEvent,
      DWORD dwProcessGroupId);

__declspec(dllimport)
BOOL
__stdcall
FreeConsole(
    void);


__declspec(dllimport)
BOOL
__stdcall
AttachConsole(
      DWORD dwProcessId);



#line 739 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleTitleA(
      LPSTR lpConsoleTitle,
      DWORD nSize
    );
__declspec(dllimport)
DWORD
__stdcall
GetConsoleTitleW(
      LPWSTR lpConsoleTitle,
      DWORD nSize
    );




#line 759 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"


__declspec(dllimport)
DWORD
__stdcall
GetConsoleOriginalTitleA(
      LPSTR lpConsoleTitle,
      DWORD nSize);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleOriginalTitleW(
      LPWSTR lpConsoleTitle,
      DWORD nSize);




#line 778 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#line 779 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
BOOL
__stdcall
SetConsoleTitleA(
      LPCSTR lpConsoleTitle
    );
__declspec(dllimport)
BOOL
__stdcall
SetConsoleTitleW(
      LPCWSTR lpConsoleTitle
    );




#line 797 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

#line 799 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion

#pragma region Application Family


typedef struct _CONSOLE_READCONSOLE_CONTROL {
    ULONG nLength;
    ULONG nInitialChars;
    ULONG dwCtrlWakeupMask;
    ULONG dwControlKeyState;
} CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;

#line 812 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion




#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"
 









#pragma once
#line 13 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"


















#line 32 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"


extern "C" {
#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"

#pragma region Desktop Family



__declspec(dllimport)
BOOL
__stdcall
AllocConsole(
    void
    );


__declspec(dllimport)
UINT
__stdcall
GetConsoleCP(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
GetConsoleMode(
      HANDLE hConsoleHandle,
      LPDWORD lpMode
    );


__declspec(dllimport)
UINT
__stdcall
GetConsoleOutputCP(
    void
    );


__declspec(dllimport)
BOOL
__stdcall
GetNumberOfConsoleInputEvents(
      HANDLE hConsoleInput,
      LPDWORD lpNumberOfEvents
    );


__declspec(dllimport)
BOOL
__stdcall
PeekConsoleInputA(
      HANDLE hConsoleInput,
      PINPUT_RECORD lpBuffer,
      DWORD nLength,
      LPDWORD lpNumberOfEventsRead
    );




#line 97 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"

__declspec(dllimport)
 
BOOL
__stdcall
ReadConsoleA(
      HANDLE hConsoleInput,
      LPVOID lpBuffer,
      DWORD nNumberOfCharsToRead,
        LPDWORD lpNumberOfCharsRead,
      PCONSOLE_READCONSOLE_CONTROL pInputControl
    );

__declspec(dllimport)
 
BOOL
__stdcall
ReadConsoleW(
      HANDLE hConsoleInput,
      LPVOID lpBuffer,
      DWORD nNumberOfCharsToRead,
        LPDWORD lpNumberOfCharsRead,
      PCONSOLE_READCONSOLE_CONTROL pInputControl
    );





#line 127 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"

__declspec(dllimport)
 
BOOL
__stdcall
ReadConsoleInputA(
      HANDLE hConsoleInput,
      PINPUT_RECORD lpBuffer,
      DWORD nLength,
        LPDWORD lpNumberOfEventsRead
    );

__declspec(dllimport)
 
BOOL
__stdcall
ReadConsoleInputW(
      HANDLE hConsoleInput,
      PINPUT_RECORD lpBuffer,
      DWORD nLength,
        LPDWORD lpNumberOfEventsRead
    );





#line 155 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCtrlHandler(
      PHANDLER_ROUTINE HandlerRoutine,
      BOOL Add
    );


__declspec(dllimport)
BOOL
__stdcall
SetConsoleMode(
      HANDLE hConsoleHandle,
      DWORD dwMode
    );


__declspec(dllimport)
BOOL
__stdcall
WriteConsoleA(
      HANDLE hConsoleOutput,
      const void * lpBuffer,
      DWORD nNumberOfCharsToWrite,
      LPDWORD lpNumberOfCharsWritten,
      LPVOID lpReserved
    );

__declspec(dllimport)
BOOL
__stdcall
WriteConsoleW(
      HANDLE hConsoleOutput,
      const void * lpBuffer,
      DWORD nNumberOfCharsToWrite,
      LPDWORD lpNumberOfCharsWritten,
      LPVOID lpReserved
    );





#line 201 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"

#line 203 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"
#pragma endregion


}
#line 208 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"

#line 210 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\consoleapi.h"
#line 818 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#line 819 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

#pragma region Desktop Family


__declspec(dllimport)
HANDLE
__stdcall
CreateConsoleScreenBuffer(
      DWORD dwDesiredAccess,
      DWORD dwShareMode,
      const SECURITY_ATTRIBUTES *lpSecurityAttributes,
      DWORD dwFlags,
      LPVOID lpScreenBufferData
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleCP(
      UINT wCodePageID
    );

__declspec(dllimport)
BOOL
__stdcall
SetConsoleOutputCP(
      UINT wCodePageID
    );






__declspec(dllimport)
BOOL
__stdcall
GetConsoleDisplayMode(
      LPDWORD lpModeFlags);




BOOL
__stdcall
SetConsoleDisplayMode(
      HANDLE hConsoleOutput,
      DWORD dwFlags,
      PCOORD lpNewScreenBufferDimensions);

__declspec(dllimport)
HWND
__stdcall
GetConsoleWindow(
    void
    );

#line 877 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"



__declspec(dllimport)
DWORD
__stdcall
GetConsoleProcessList(
      LPDWORD lpdwProcessList,
      DWORD dwProcessCount);





__declspec(dllimport)
BOOL
__stdcall
AddConsoleAliasA(
      LPSTR Source,
      LPSTR Target,
      LPSTR ExeName);
__declspec(dllimport)
BOOL
__stdcall
AddConsoleAliasW(
      LPWSTR Source,
      LPWSTR Target,
      LPWSTR ExeName);




#line 910 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasA(
      LPSTR Source,
      LPSTR TargetBuffer,
      DWORD TargetBufferLength,
      LPSTR ExeName);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasW(
      LPWSTR Source,
      LPWSTR TargetBuffer,
      DWORD TargetBufferLength,
      LPWSTR ExeName);




#line 932 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesLengthA(
      LPSTR ExeName);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesLengthW(
      LPWSTR ExeName);




#line 948 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesLengthA(
    void);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesLengthW(
    void);




#line 964 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesA(
      LPSTR AliasBuffer,
      DWORD AliasBufferLength,
      LPSTR ExeName);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasesW(
      LPWSTR AliasBuffer,
      DWORD AliasBufferLength,
      LPWSTR ExeName);




#line 984 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesA(
      LPSTR ExeNameBuffer,
      DWORD ExeNameBufferLength);
__declspec(dllimport)
DWORD
__stdcall
GetConsoleAliasExesW(
      LPWSTR ExeNameBuffer,
      DWORD ExeNameBufferLength);




#line 1002 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

#line 1004 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

#line 1006 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"
#pragma endregion



}
#line 1012 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

#line 1014 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\wincon.h"

#line 173 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"


















#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\verrsrc.h"












#pragma region Application Family












#line 27 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\verrsrc.h"




























































#line 88 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\verrsrc.h"
#pragma endregion

#pragma region Desktop Family










































extern "C" {
#line 135 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\verrsrc.h"
    











typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            
    DWORD   dwStrucVersion;         
    DWORD   dwFileVersionMS;        
    DWORD   dwFileVersionLS;        
    DWORD   dwProductVersionMS;     
    DWORD   dwProductVersionLS;     
    DWORD   dwFileFlagsMask;        
    DWORD   dwFileFlags;            
    DWORD   dwFileOS;               
    DWORD   dwFileType;             
    DWORD   dwFileSubtype;          
    DWORD   dwFileDateMS;           
    DWORD   dwFileDateLS;           
} VS_FIXEDFILEINFO;


}
#line 167 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\verrsrc.h"

#line 169 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\verrsrc.h"

#line 171 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\verrsrc.h"
#pragma endregion

#line 20 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"



extern "C" {
#line 25 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"

#pragma region Desktop Family







DWORD
__stdcall
VerFindFileA(
                                  DWORD uFlags,
                                  LPCSTR szFileName,
                              LPCSTR szWinDir,
                                  LPCSTR szAppDir,
            LPSTR szCurDir,
                               PUINT puCurDirLen,
           LPSTR szDestDir,
                               PUINT puDestDirLen
        );
DWORD
__stdcall
VerFindFileW(
                                  DWORD uFlags,
                                  LPCWSTR szFileName,
                              LPCWSTR szWinDir,
                                  LPCWSTR szAppDir,
            LPWSTR szCurDir,
                               PUINT puCurDirLen,
           LPWSTR szDestDir,
                               PUINT puDestDirLen
        );




#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"

DWORD
__stdcall
VerInstallFileA(
                                  DWORD uFlags,
                                  LPCSTR szSrcFileName,
                                  LPCSTR szDestFileName,
                                  LPCSTR szSrcDir,
                                  LPCSTR szDestDir,
                                  LPCSTR szCurDir,
           LPSTR szTmpFile,
                               PUINT puTmpFileLen
        );
DWORD
__stdcall
VerInstallFileW(
                                  DWORD uFlags,
                                  LPCWSTR szSrcFileName,
                                  LPCWSTR szDestFileName,
                                  LPCWSTR szSrcDir,
                                  LPCWSTR szDestDir,
                                  LPCWSTR szCurDir,
           LPWSTR szTmpFile,
                               PUINT puTmpFileLen
        );




#line 93 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"


DWORD
__stdcall
GetFileVersionInfoSizeA(
                 LPCSTR lptstrFilename, 
          LPDWORD lpdwHandle       
        );

DWORD
__stdcall
GetFileVersionInfoSizeW(
                 LPCWSTR lptstrFilename, 
          LPDWORD lpdwHandle       
        );




#line 113 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"


BOOL
__stdcall
GetFileVersionInfoA(
                         LPCSTR lptstrFilename, 
                   DWORD dwHandle,          
                         DWORD dwLen,             
          LPVOID lpData            
        );

BOOL
__stdcall
GetFileVersionInfoW(
                         LPCWSTR lptstrFilename, 
                   DWORD dwHandle,          
                         DWORD dwLen,             
          LPVOID lpData            
        );




#line 137 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"

DWORD __stdcall GetFileVersionInfoSizeExA(  DWORD dwFlags,   LPCSTR lpwstrFilename,   LPDWORD lpdwHandle);
DWORD __stdcall GetFileVersionInfoSizeExW(  DWORD dwFlags,   LPCWSTR lpwstrFilename,   LPDWORD lpdwHandle);




#line 145 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"

BOOL __stdcall GetFileVersionInfoExA(  DWORD dwFlags,
                                      LPCSTR lpwstrFilename,
                                      DWORD dwHandle,
                                      DWORD dwLen,
                                      LPVOID lpData);
BOOL __stdcall GetFileVersionInfoExW(  DWORD dwFlags,
                                      LPCWSTR lpwstrFilename,
                                      DWORD dwHandle,
                                      DWORD dwLen,
                                      LPVOID lpData);




#line 161 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"


DWORD
__stdcall
VerLanguageNameA(
                           DWORD wLang,
          LPSTR szLang,
                           DWORD cchLang
        );
DWORD
__stdcall
VerLanguageNameW(
                           DWORD wLang,
          LPWSTR szLang,
                           DWORD cchLang
        );




#line 182 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"

BOOL
__stdcall
VerQueryValueA(
          LPCVOID pBlock,
          LPCSTR lpSubBlock,
         LPVOID * lplpBuffer,
          PUINT puLen
        );
BOOL
__stdcall
VerQueryValueW(
          LPCVOID pBlock,
          LPCWSTR lpSubBlock,
         LPVOID * lplpBuffer,
          PUINT puLen
        );




#line 204 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"


#line 207 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"

#line 209 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"
#pragma endregion


}
#line 214 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"


#line 217 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winver.h"

#line 174 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 175 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"
 

































#line 36 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"








extern "C" {
#line 46 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

#pragma region Desktop Family









































typedef ACCESS_MASK REGSAM;





























struct val_context {
    int valuelen;       
    LPVOID value_context;   
    LPVOID val_buff_ptr;    
};

typedef struct val_context  *PVALCONTEXT;

typedef struct pvalueA {           
    LPSTR   pv_valuename;          
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEA,  *PPVALUEA;
typedef struct pvalueW {           
    LPWSTR  pv_valuename;          
    int pv_valuelen;
    LPVOID pv_value_context;
    DWORD pv_type;
}PVALUEW,  *PPVALUEW;




typedef PVALUEA PVALUE;
typedef PPVALUEA PPVALUE;
#line 146 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

typedef
DWORD __cdecl
QUERYHANDLER (LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals,
          LPVOID outputbuffer, DWORD  *total_outlen, DWORD input_blen);

typedef QUERYHANDLER  *PQUERYHANDLER;

typedef struct provider_info {
    PQUERYHANDLER pi_R0_1val;
    PQUERYHANDLER pi_R0_allvals;
    PQUERYHANDLER pi_R3_1val;
    PQUERYHANDLER pi_R3_allvals;
    DWORD pi_flags;    
    LPVOID pi_key_context;
}REG_PROVIDER;

typedef struct provider_info  *PPROVIDER;

typedef struct value_entA {
    LPSTR   ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTA,  *PVALENTA;
typedef struct value_entW {
    LPWSTR  ve_valuename;
    DWORD ve_valuelen;
    DWORD_PTR ve_valueptr;
    DWORD ve_type;
}VALENTW,  *PVALENTW;




typedef VALENTA VALENT;
typedef PVALENTA PVALENT;
#line 184 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

#line 186 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"


#line 189 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"












typedef   LONG LSTATUS;

__declspec(dllimport)
LSTATUS
__stdcall
RegCloseKey(
      HKEY hKey
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegOverridePredefKey (
      HKEY hKey,
      HKEY hNewHKey
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenUserClassesRoot(
      HANDLE hToken,
      DWORD dwOptions,
      REGSAM samDesired,
      PHKEY phkResult
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegOpenCurrentUser(
      REGSAM samDesired,
      PHKEY phkResult
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegDisablePredefinedCache(
    void
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDisablePredefinedCacheEx(
    void
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryA (
      LPCSTR lpMachineName,
      HKEY hKey,
      PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryW (
      LPCWSTR lpMachineName,
      HKEY hKey,
      PHKEY phkResult
    );




#line 275 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryExA (
      LPCSTR lpMachineName,
      HKEY hKey,
      ULONG Flags,
      PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegConnectRegistryExW (
      LPCWSTR lpMachineName,
      HKEY hKey,
      ULONG Flags,
      PHKEY phkResult
    );




#line 299 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyA (
      HKEY hKey,
      LPCSTR lpSubKey,
      PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      PHKEY phkResult
    );




#line 321 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyExA(
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD Reserved,
      LPSTR lpClass,
      DWORD dwOptions,
      REGSAM samDesired,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      PHKEY phkResult,
      LPDWORD lpdwDisposition
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyExW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD Reserved,
      LPWSTR lpClass,
      DWORD dwOptions,
      REGSAM samDesired,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      PHKEY phkResult,
      LPDWORD lpdwDisposition
    );





#line 357 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyTransactedA (
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD Reserved,
      LPSTR lpClass,
      DWORD dwOptions,
      REGSAM samDesired,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      PHKEY phkResult,
      LPDWORD lpdwDisposition,
             HANDLE hTransaction,
      PVOID  pExtendedParemeter
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegCreateKeyTransactedW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD Reserved,
      LPWSTR lpClass,
      DWORD dwOptions,
      REGSAM samDesired,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      PHKEY phkResult,
      LPDWORD lpdwDisposition,
             HANDLE hTransaction,
      PVOID  pExtendedParemeter
    );




#line 395 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyA (
      HKEY hKey,
      LPCSTR lpSubKey
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyW (
      HKEY hKey,
      LPCWSTR lpSubKey
    );




#line 415 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyExA(
      HKEY hKey,
      LPCSTR lpSubKey,
      REGSAM samDesired,
      DWORD Reserved
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyExW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      REGSAM samDesired,
      DWORD Reserved
    );





#line 441 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyTransactedA (
      HKEY hKey,
      LPCSTR lpSubKey,
      REGSAM samDesired,
      DWORD Reserved,
             HANDLE hTransaction,
      PVOID  pExtendedParameter
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyTransactedW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      REGSAM samDesired,
      DWORD Reserved,
             HANDLE hTransaction,
      PVOID  pExtendedParameter
    );




#line 469 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LONG
__stdcall
RegDisableReflectionKey (
      HKEY hBase
    );

__declspec(dllimport)
LONG
__stdcall
RegEnableReflectionKey (
      HKEY hBase
    );

__declspec(dllimport)
LONG
__stdcall
RegQueryReflectionKey (
      HKEY hBase,
      BOOL *bIsReflectionDisabled
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteValueA(
      HKEY hKey,
      LPCSTR lpValueName
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteValueW(
      HKEY hKey,
      LPCWSTR lpValueName
    );





#line 513 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyA (
      HKEY hKey,
      DWORD dwIndex,
      LPSTR lpName,
      DWORD cchName
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyW (
      HKEY hKey,
      DWORD dwIndex,
      LPWSTR lpName,
      DWORD cchName
    );




#line 537 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyExA(
      HKEY hKey,
      DWORD dwIndex,
      LPSTR lpName,
      LPDWORD lpcchName,
      LPDWORD lpReserved,
      LPSTR lpClass,
      LPDWORD lpcchClass,
      PFILETIME lpftLastWriteTime
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumKeyExW(
      HKEY hKey,
      DWORD dwIndex,
      LPWSTR lpName,
      LPDWORD lpcchName,
      LPDWORD lpReserved,
      LPWSTR lpClass,
      LPDWORD lpcchClass,
      PFILETIME lpftLastWriteTime
    );





#line 571 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumValueA(
      HKEY hKey,
      DWORD dwIndex,
      LPSTR lpValueName,
      LPDWORD lpcchValueName,
      LPDWORD lpReserved,
      LPDWORD lpType,
       LPBYTE lpData,
      LPDWORD lpcbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegEnumValueW(
      HKEY hKey,
      DWORD dwIndex,
      LPWSTR lpValueName,
      LPDWORD lpcchValueName,
      LPDWORD lpReserved,
      LPDWORD lpType,
       LPBYTE lpData,
      LPDWORD lpcbData
    );





#line 605 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegFlushKey(
      HKEY hKey
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegGetKeySecurity(
      HKEY hKey,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor,
      LPDWORD lpcbSecurityDescriptor
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegLoadKeyA(
      HKEY hKey,
      LPCSTR lpSubKey,
      LPCSTR lpFile
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadKeyW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      LPCWSTR lpFile
    );





#line 648 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegNotifyChangeKeyValue(
      HKEY hKey,
      BOOL bWatchSubtree,
      DWORD dwNotifyFilter,
      HANDLE hEvent,
      BOOL fAsynchronous
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyA (
      HKEY hKey,
      LPCSTR lpSubKey,
      PHKEY phkResult
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      PHKEY phkResult
    );




#line 682 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyExA(
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD ulOptions,
      REGSAM samDesired,
      PHKEY phkResult
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyExW(
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD ulOptions,
      REGSAM samDesired,
      PHKEY phkResult
    );





#line 710 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyTransactedA (
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD ulOptions,
      REGSAM samDesired,
      PHKEY phkResult,
             HANDLE hTransaction,
      PVOID  pExtendedParemeter
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegOpenKeyTransactedW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD ulOptions,
      REGSAM samDesired,
      PHKEY phkResult,
             HANDLE hTransaction,
      PVOID  pExtendedParemeter
    );




#line 740 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryInfoKeyA(
      HKEY hKey,
      LPSTR lpClass,
      LPDWORD lpcchClass,
      LPDWORD lpReserved,
      LPDWORD lpcSubKeys,
      LPDWORD lpcbMaxSubKeyLen,
      LPDWORD lpcbMaxClassLen,
      LPDWORD lpcValues,
      LPDWORD lpcbMaxValueNameLen,
      LPDWORD lpcbMaxValueLen,
      LPDWORD lpcbSecurityDescriptor,
      PFILETIME lpftLastWriteTime
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryInfoKeyW(
      HKEY hKey,
      LPWSTR lpClass,
      LPDWORD lpcchClass,
      LPDWORD lpReserved,
      LPDWORD lpcSubKeys,
      LPDWORD lpcbMaxSubKeyLen,
      LPDWORD lpcbMaxClassLen,
      LPDWORD lpcValues,
      LPDWORD lpcbMaxValueNameLen,
      LPDWORD lpcbMaxValueLen,
      LPDWORD lpcbSecurityDescriptor,
      PFILETIME lpftLastWriteTime
    );





#line 782 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueA (
      HKEY hKey,
      LPCSTR lpSubKey,
       LPSTR lpData,
      PLONG lpcbData
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueW (
      HKEY hKey,
      LPCWSTR lpSubKey,
       LPWSTR lpData,
      PLONG lpcbData
    );




#line 806 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"




__declspec(dllimport)
LSTATUS
__stdcall
RegQueryMultipleValuesA (
      HKEY hKey,
      PVALENTA val_list,
      DWORD num_vals,
       LPSTR lpValueBuf,
      LPDWORD ldwTotsize
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegQueryMultipleValuesW (
      HKEY hKey,
      PVALENTW val_list,
      DWORD num_vals,
       LPWSTR lpValueBuf,
      LPDWORD ldwTotsize
    );




#line 835 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"
#line 836 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueExA(
      HKEY hKey,
      LPCSTR lpValueName,
      LPDWORD lpReserved,
      LPDWORD lpType,
       LPBYTE lpData,
    
              LPDWORD lpcbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegQueryValueExW(
      HKEY hKey,
      LPCWSTR lpValueName,
      LPDWORD lpReserved,
      LPDWORD lpType,
       LPBYTE lpData,
    
              LPDWORD lpcbData
    );





#line 868 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegReplaceKeyA (
      HKEY hKey,
      LPCSTR lpSubKey,
      LPCSTR lpNewFile,
      LPCSTR lpOldFile
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegReplaceKeyW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      LPCWSTR lpNewFile,
      LPCWSTR lpOldFile
    );




#line 892 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegRestoreKeyA(
      HKEY hKey,
      LPCSTR lpFile,
      DWORD dwFlags
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegRestoreKeyW(
      HKEY hKey,
      LPCWSTR lpFile,
      DWORD dwFlags
    );





#line 916 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"




__declspec(dllimport)
LSTATUS
__stdcall
RegRenameKey(
      HKEY hKey,
      LPCWSTR lpSubKeyName,
      LPCWSTR lpNewKeyName
    );

#line 930 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyA (
      HKEY hKey,
      LPCSTR lpFile,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyW (
      HKEY hKey,
      LPCWSTR lpFile,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes
    );




#line 952 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSetKeySecurity(
      HKEY hKey,
      SECURITY_INFORMATION SecurityInformation,
      PSECURITY_DESCRIPTOR pSecurityDescriptor
    );


__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueA (
      HKEY hKey,
      LPCSTR lpSubKey,
      DWORD dwType,
      LPCSTR lpData,
      DWORD cbData
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueW (
      HKEY hKey,
      LPCWSTR lpSubKey,
      DWORD dwType,
      LPCWSTR lpData,
      DWORD cbData
    );




#line 988 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueExA(
      HKEY hKey,
      LPCSTR lpValueName,
      DWORD Reserved,
      DWORD dwType,
      const BYTE * lpData,
      DWORD cbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSetValueExW(
      HKEY hKey,
      LPCWSTR lpValueName,
      DWORD Reserved,
      DWORD dwType,
      const BYTE * lpData,
      DWORD cbData
    );





#line 1018 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegUnLoadKeyA(
      HKEY hKey,
      LPCSTR lpSubKey
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegUnLoadKeyW(
      HKEY hKey,
      LPCWSTR lpSubKey
    );





#line 1040 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"







__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyValueA (
           HKEY     hKey,
       LPCSTR lpSubKey,
       LPCSTR lpValueName
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteKeyValueW (
           HKEY     hKey,
       LPCWSTR lpSubKey,
       LPCWSTR lpValueName
    );




#line 1068 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegSetKeyValueA (
             HKEY     hKey,
         LPCSTR  lpSubKey,
         LPCSTR  lpValueName,
             DWORD    dwType,
      LPCVOID  lpData,
             DWORD    cbData
    );
__declspec(dllimport)
LSTATUS
__stdcall
RegSetKeyValueW (
             HKEY     hKey,
         LPCWSTR  lpSubKey,
         LPCWSTR  lpValueName,
             DWORD    dwType,
      LPCVOID  lpData,
             DWORD    cbData
    );




#line 1096 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteTreeA(
      HKEY hKey,
      LPCSTR lpSubKey
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegDeleteTreeW(
      HKEY hKey,
      LPCWSTR lpSubKey
    );





#line 1118 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegCopyTreeA (
             HKEY     hKeySrc,
         LPCSTR  lpSubKey,
             HKEY     hKeyDest
    );


#line 1130 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"




__declspec(dllimport)
LSTATUS
__stdcall
RegGetValueA(
      HKEY hkey,
      LPCSTR lpSubKey,
      LPCSTR lpValue,
      DWORD dwFlags,
      LPDWORD pdwType,
    
#line 1148 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"
	
#line 1150 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"
      PVOID pvData,
      LPDWORD pcbData
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegGetValueW(
      HKEY hkey,
      LPCWSTR lpSubKey,
      LPCWSTR lpValue,
      DWORD dwFlags,
      LPDWORD pdwType,
    
#line 1168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"
	
#line 1170 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"
      PVOID pvData,
      LPDWORD pcbData
    );





#line 1179 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

#line 1181 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"




__declspec(dllimport)
LSTATUS
__stdcall
RegCopyTreeW(
      HKEY hKeySrc,
      LPCWSTR lpSubKey,
      HKEY hKeyDest
    );




#line 1198 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadMUIStringA(
      HKEY hKey,
      LPCSTR pszValue,
      LPSTR pszOutBuf,
      DWORD cbOutBuf,
      LPDWORD pcbData,
      DWORD Flags,
      LPCSTR pszDirectory
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadMUIStringW(
      HKEY hKey,
      LPCWSTR pszValue,
      LPWSTR pszOutBuf,
      DWORD cbOutBuf,
      LPDWORD pcbData,
      DWORD Flags,
      LPCWSTR pszDirectory
    );





#line 1230 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadAppKeyA(
      LPCSTR lpFile,
      PHKEY phkResult,
      REGSAM samDesired,
      DWORD dwOptions,
      DWORD Reserved
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegLoadAppKeyW(
      LPCWSTR lpFile,
      PHKEY phkResult,
      REGSAM samDesired,
      DWORD dwOptions,
      DWORD Reserved
    );





#line 1258 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

#line 1260 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"





 
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownA(
      LPSTR lpMachineName,
      LPSTR lpMessage,
      DWORD dwTimeout,
      BOOL bForceAppsClosed,
      BOOL bRebootAfterShutdown
    );
 
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownW(
      LPWSTR lpMachineName,
      LPWSTR lpMessage,
      DWORD dwTimeout,
      BOOL bForceAppsClosed,
      BOOL bRebootAfterShutdown
    );




#line 1292 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"


__declspec(dllimport)
BOOL
__stdcall
AbortSystemShutdownA(
      LPSTR lpMachineName
    );
__declspec(dllimport)
BOOL
__stdcall
AbortSystemShutdownW(
      LPWSTR lpMachineName
    );




#line 1311 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"





#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\reason.h"
















#pragma once

#pragma region Desktop Family






































































































#line 123 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\reason.h"
#pragma endregion

#line 126 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\reason.h"
#line 1317 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"


















 

#line 1338 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExA(
      LPSTR lpMachineName,
      LPSTR lpMessage,
      DWORD dwTimeout,
      BOOL bForceAppsClosed,
      BOOL bRebootAfterShutdown,
      DWORD dwReason
    );
 

#line 1352 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"
__declspec(dllimport)
BOOL
__stdcall
InitiateSystemShutdownExW(
      LPWSTR lpMachineName,
      LPWSTR lpMessage,
      DWORD dwTimeout,
      BOOL bForceAppsClosed,
      BOOL bRebootAfterShutdown,
      DWORD dwReason
    );




#line 1368 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

















__declspec(dllimport)
DWORD
__stdcall
InitiateShutdownA(
      LPSTR lpMachineName,
      LPSTR lpMessage,
          DWORD dwGracePeriod,
          DWORD dwShutdownFlags,
          DWORD dwReason
    );
__declspec(dllimport)
DWORD
__stdcall
InitiateShutdownW(
      LPWSTR lpMachineName,
      LPWSTR lpMessage,
          DWORD dwGracePeriod,
          DWORD dwShutdownFlags,
          DWORD dwReason
    );




#line 1410 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"

__declspec(dllimport)
DWORD
__stdcall
CheckForHiberboot(
      PBOOLEAN pHiberboot,
      BOOLEAN bClearFlag
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyExA(
      HKEY hKey,
      LPCSTR lpFile,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      DWORD Flags
    );

__declspec(dllimport)
LSTATUS
__stdcall
RegSaveKeyExW(
      HKEY hKey,
      LPCWSTR lpFile,
      const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
      DWORD Flags
    );





#line 1444 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"


#line 1447 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"
#pragma endregion


}
#line 1452 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"


#line 1455 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winreg.h"


#line 177 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 178 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"




























#pragma once


extern "C" {
#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

#pragma region Desktop Family







#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\wnnc.h"



























#pragma region Desktop Family




















































































#line 114 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\wnnc.h"
#pragma endregion

#line 117 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\wnnc.h"



#line 44 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"











#line 56 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"






#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"









#line 73 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"













#line 87 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"



#line 91 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

typedef struct  _NETRESOURCEA {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPSTR    lpLocalName;
    LPSTR    lpRemoteName;
    LPSTR    lpComment ;
    LPSTR    lpProvider;
}NETRESOURCEA, *LPNETRESOURCEA;
typedef struct  _NETRESOURCEW {
    DWORD    dwScope;
    DWORD    dwType;
    DWORD    dwDisplayType;
    DWORD    dwUsage;
    LPWSTR   lpLocalName;
    LPWSTR   lpRemoteName;
    LPWSTR   lpComment ;
    LPWSTR   lpProvider;
}NETRESOURCEW, *LPNETRESOURCEW;




typedef NETRESOURCEA NETRESOURCE;
typedef LPNETRESOURCEA LPNETRESOURCE;
#line 119 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"





















#line 141 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"



#line 145 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"


#line 148 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetAddConnectionA(
          LPCSTR   lpRemoteName,
      LPCSTR   lpPassword,
      LPCSTR   lpLocalName
    );
 
DWORD __stdcall
WNetAddConnectionW(
          LPCWSTR   lpRemoteName,
      LPCWSTR   lpPassword,
      LPCWSTR   lpLocalName
    );




#line 168 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetAddConnection2A(
          LPNETRESOURCEA lpNetResource,
      LPCSTR       lpPassword,
      LPCSTR       lpUserName,
          DWORD          dwFlags
    );
 
DWORD __stdcall
WNetAddConnection2W(
          LPNETRESOURCEW lpNetResource,
      LPCWSTR       lpPassword,
      LPCWSTR       lpUserName,
          DWORD          dwFlags
    );




#line 190 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetAddConnection3A(
      HWND           hwndOwner,
          LPNETRESOURCEA lpNetResource,
      LPCSTR       lpPassword,
      LPCSTR       lpUserName,
          DWORD          dwFlags
    );
 
DWORD __stdcall
WNetAddConnection3W(
      HWND           hwndOwner,
          LPNETRESOURCEW lpNetResource,
      LPCWSTR       lpPassword,
      LPCWSTR       lpUserName,
          DWORD          dwFlags
    );




#line 214 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetCancelConnectionA(
      LPCSTR lpName,
      BOOL     fForce
    );
 
DWORD __stdcall
WNetCancelConnectionW(
      LPCWSTR lpName,
      BOOL     fForce
    );




#line 232 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetCancelConnection2A(
      LPCSTR lpName,
      DWORD    dwFlags,
      BOOL     fForce
    );
 
DWORD __stdcall
WNetCancelConnection2W(
      LPCWSTR lpName,
      DWORD    dwFlags,
      BOOL     fForce
    );




#line 252 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetGetConnectionA(
      LPCSTR lpLocalName,
      LPSTR  lpRemoteName,
      LPDWORD lpnLength
    );
 
DWORD __stdcall
WNetGetConnectionW(
      LPCWSTR lpLocalName,
      LPWSTR  lpRemoteName,
      LPDWORD lpnLength
    );




#line 272 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"



 
DWORD __stdcall
WNetRestoreSingleConnectionW(
      HWND    hwndParent,
          LPCWSTR lpDevice,
          BOOL    fUseUI
    );









#line 292 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"



 
DWORD __stdcall
WNetUseConnectionA(
      HWND            hwndOwner,
          LPNETRESOURCEA  lpNetResource,
      LPCSTR        lpPassword,
      LPCSTR        lpUserId,
          DWORD           dwFlags,
      LPSTR lpAccessName,
      LPDWORD lpBufferSize,
      LPDWORD   lpResult
    );
 
DWORD __stdcall
WNetUseConnectionW(
      HWND            hwndOwner,
          LPNETRESOURCEW  lpNetResource,
      LPCWSTR        lpPassword,
      LPCWSTR        lpUserId,
          DWORD           dwFlags,
      LPWSTR lpAccessName,
      LPDWORD lpBufferSize,
      LPDWORD   lpResult
    );




#line 324 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"
#line 325 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"





 
DWORD __stdcall
WNetConnectionDialog(
      HWND  hwnd,
      DWORD dwType
    );

 
DWORD __stdcall
WNetDisconnectDialog(
      HWND hwnd,
      DWORD dwType
    );


typedef struct _CONNECTDLGSTRUCTA{
    DWORD cbStructure;       
    HWND hwndOwner;          
    LPNETRESOURCEA lpConnRes;
    DWORD dwFlags;           
    DWORD dwDevNum;          
} CONNECTDLGSTRUCTA,  *LPCONNECTDLGSTRUCTA;
typedef struct _CONNECTDLGSTRUCTW{
    DWORD cbStructure;       
    HWND hwndOwner;          
    LPNETRESOURCEW lpConnRes;
    DWORD dwFlags;           
    DWORD dwDevNum;          
} CONNECTDLGSTRUCTW,  *LPCONNECTDLGSTRUCTW;




typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;
#line 366 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"














 
DWORD __stdcall
WNetConnectionDialog1A(
      LPCONNECTDLGSTRUCTA lpConnDlgStruct
    );
 
DWORD __stdcall
WNetConnectionDialog1W(
      LPCONNECTDLGSTRUCTW lpConnDlgStruct
    );




#line 395 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

typedef struct _DISCDLGSTRUCTA{
    DWORD           cbStructure;      
    HWND            hwndOwner;        
    LPSTR           lpLocalName;      
    LPSTR           lpRemoteName;     
    DWORD           dwFlags;          
} DISCDLGSTRUCTA,  *LPDISCDLGSTRUCTA;
typedef struct _DISCDLGSTRUCTW{
    DWORD           cbStructure;      
    HWND            hwndOwner;        
    LPWSTR          lpLocalName;      
    LPWSTR          lpRemoteName;     
    DWORD           dwFlags;          
} DISCDLGSTRUCTW,  *LPDISCDLGSTRUCTW;




typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;
#line 417 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"




 
DWORD __stdcall
WNetDisconnectDialog1A(
      LPDISCDLGSTRUCTA lpConnDlgStruct
    );
 
DWORD __stdcall
WNetDisconnectDialog1W(
      LPDISCDLGSTRUCTW lpConnDlgStruct
    );




#line 436 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"
#line 437 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"





 
DWORD __stdcall
WNetOpenEnumA(
       DWORD          dwScope,
       DWORD          dwType,
       DWORD          dwUsage,
      LPNETRESOURCEA lpNetResource,
      LPHANDLE       lphEnum
    );
 
DWORD __stdcall
WNetOpenEnumW(
       DWORD          dwScope,
       DWORD          dwType,
       DWORD          dwUsage,
      LPNETRESOURCEW lpNetResource,
      LPHANDLE       lphEnum
    );




#line 465 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetEnumResourceA(
         HANDLE  hEnum,
      LPDWORD lpcCount,
      LPVOID  lpBuffer,
      LPDWORD lpBufferSize
    );
 
DWORD __stdcall
WNetEnumResourceW(
         HANDLE  hEnum,
      LPDWORD lpcCount,
      LPVOID  lpBuffer,
      LPDWORD lpBufferSize
    );




#line 487 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetCloseEnum(
      HANDLE   hEnum
    );


 
DWORD __stdcall
WNetGetResourceParentA(
      LPNETRESOURCEA lpNetResource,
      LPVOID lpBuffer,
      LPDWORD lpcbBuffer
    );
 
DWORD __stdcall
WNetGetResourceParentW(
      LPNETRESOURCEW lpNetResource,
      LPVOID lpBuffer,
      LPDWORD lpcbBuffer
    );




#line 514 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetGetResourceInformationA(
      LPNETRESOURCEA  lpNetResource,
      LPVOID lpBuffer,
      LPDWORD lpcbBuffer,
     LPSTR *lplpSystem
    );
 
DWORD __stdcall
WNetGetResourceInformationW(
      LPNETRESOURCEW  lpNetResource,
      LPVOID lpBuffer,
      LPDWORD lpcbBuffer,
     LPWSTR *lplpSystem
    );




#line 536 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"
#line 537 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"








typedef struct  _UNIVERSAL_NAME_INFOA {
    LPSTR    lpUniversalName;
}UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
typedef struct  _UNIVERSAL_NAME_INFOW {
    LPWSTR   lpUniversalName;
}UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;




typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;
#line 558 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

typedef struct  _REMOTE_NAME_INFOA {
    LPSTR    lpUniversalName;
    LPSTR    lpConnectionName;
    LPSTR    lpRemainingPath;
}REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
typedef struct  _REMOTE_NAME_INFOW {
    LPWSTR   lpUniversalName;
    LPWSTR   lpConnectionName;
    LPWSTR   lpRemainingPath;
}REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;




typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;
#line 576 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

 
DWORD __stdcall
WNetGetUniversalNameA(
      LPCSTR lpLocalPath,
      DWORD    dwInfoLevel,
      LPVOID lpBuffer,
      LPDWORD lpBufferSize
    );
 
DWORD __stdcall
WNetGetUniversalNameW(
      LPCWSTR lpLocalPath,
      DWORD    dwInfoLevel,
      LPVOID lpBuffer,
      LPDWORD lpBufferSize
    );




#line 598 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"




 
DWORD __stdcall
WNetGetUserA(
      LPCSTR  lpName,
      LPSTR lpUserName,
       LPDWORD lpnLength
    );



 
DWORD __stdcall
WNetGetUserW(
      LPCWSTR  lpName,
      LPWSTR lpUserName,
       LPDWORD lpnLength
    );




#line 624 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"












#line 637 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"



 
DWORD __stdcall
WNetGetProviderNameA(
         DWORD   dwNetType,
      LPSTR lpProviderName,
      LPDWORD lpBufferSize
    );
 
DWORD __stdcall
WNetGetProviderNameW(
         DWORD   dwNetType,
      LPWSTR lpProviderName,
      LPDWORD lpBufferSize
    );




#line 659 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

typedef struct _NETINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwProviderVersion;
    DWORD dwStatus;
    DWORD dwCharacteristics;
    ULONG_PTR dwHandle;
    WORD  wNetType;
    DWORD dwPrinters;
    DWORD dwDrives;
} NETINFOSTRUCT,  *LPNETINFOSTRUCT;





 
DWORD __stdcall
WNetGetNetworkInformationA(
       LPCSTR        lpProvider,
      LPNETINFOSTRUCT lpNetInfoStruct
    );
 
DWORD __stdcall
WNetGetNetworkInformationW(
       LPCWSTR        lpProvider,
      LPNETINFOSTRUCT lpNetInfoStruct
    );




#line 692 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

#line 694 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"





 
DWORD __stdcall
WNetGetLastErrorA(
      LPDWORD    lpError,
      LPSTR lpErrorBuf,
      DWORD      nErrorBufSize,
      LPSTR  lpNameBuf,
      DWORD      nNameBufSize
    );
 
DWORD __stdcall
WNetGetLastErrorW(
      LPDWORD    lpError,
      LPWSTR lpErrorBuf,
      DWORD      nErrorBufSize,
      LPWSTR  lpNameBuf,
      DWORD      nNameBufSize
    );




#line 722 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"





























#line 752 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"




















#line 773 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"












#line 786 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"






typedef struct _NETCONNECTINFOSTRUCT{
    DWORD cbStructure;
    DWORD dwFlags;
    DWORD dwSpeed;
    DWORD dwDelay;
    DWORD dwOptDataSize;
} NETCONNECTINFOSTRUCT,  *LPNETCONNECTINFOSTRUCT;






 
DWORD __stdcall
MultinetGetConnectionPerformanceA(
       LPNETRESOURCEA lpNetResource,
      LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );
 
DWORD __stdcall
MultinetGetConnectionPerformanceW(
       LPNETRESOURCEW lpNetResource,
      LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct
    );




#line 822 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"
#line 823 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"


#line 826 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"
#pragma endregion


}
#line 831 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"

#line 833 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winnetwk.h"


#line 180 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 181 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"




































#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"




















































#line 54 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"
#line 55 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"




#line 60 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"

#line 62 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"
#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"


extern "C" {
#line 67 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"

#pragma region Desktop Family














#line 84 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"



















#line 104 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"

__inline
PUWSTR
static
__declspec(deprecated)
ua_wcscpy(
      PUWSTR  Destination,
      PCUWSTR Source
    )
{
#pragma warning(push)
#pragma warning(disable:4995)
#pragma warning(disable:4996)



    return wcscpy(Destination, Source);
#pragma warning(pop)
}












































































































































































































































































































































































#line 488 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"






































































#line 559 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"




































#line 596 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"











































#line 640 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"



#line 644 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"














#line 659 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"










#line 670 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"

#line 672 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"



#line 676 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"

#line 678 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"
#pragma endregion


}
#line 683 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"

#line 685 "c:\\program files (x86)\\windows kits\\8.1\\include\\shared\\stralign.h"








#line 218 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"












#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"
































#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"


extern "C" {
#line 38 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

#pragma region Desktop Family





































#line 78 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"













































































































































































































































































extern "C" const GUID  NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID;
#line 354 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

extern "C" const GUID  NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID;
#line 362 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"




extern "C" const GUID  DOMAIN_JOIN_GUID;
#line 373 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

extern "C" const GUID  DOMAIN_LEAVE_GUID;
#line 381 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"





extern "C" const GUID  FIREWALL_PORT_OPEN_GUID;
#line 393 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

extern "C" const GUID  FIREWALL_PORT_CLOSE_GUID;
#line 401 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"





extern "C" const GUID  MACHINE_POLICY_PRESENT_GUID;
#line 413 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

extern "C" const GUID  USER_POLICY_PRESENT_GUID;
#line 421 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"





extern "C" const GUID  RPC_INTERFACE_EVENT_GUID;
#line 433 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

extern "C" const GUID  NAMED_PIPE_EVENT_GUID;
#line 441 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"




extern "C" const GUID  CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID;
#line 452 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"
  



typedef struct
{
    DWORD Data[2];
} SERVICE_TRIGGER_CUSTOM_STATE_ID;

typedef struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM {
    union {
        SERVICE_TRIGGER_CUSTOM_STATE_ID CustomStateId;
        struct {
            DWORD DataOffset;
            BYTE Data[1];
        } s;
    } u;
} SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM, *LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;
















typedef struct _SERVICE_DESCRIPTIONA {
    LPSTR       lpDescription;
} SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;



typedef struct _SERVICE_DESCRIPTIONW {
    LPWSTR      lpDescription;
} SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;




typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION;
#line 502 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"




typedef enum _SC_ACTION_TYPE {
        SC_ACTION_NONE          = 0,
        SC_ACTION_RESTART       = 1,
        SC_ACTION_REBOOT        = 2,
        SC_ACTION_RUN_COMMAND   = 3
} SC_ACTION_TYPE;

typedef struct _SC_ACTION {
    SC_ACTION_TYPE  Type;
    DWORD           Delay;
} SC_ACTION, *LPSC_ACTION;

typedef struct _SERVICE_FAILURE_ACTIONSA {
    DWORD       dwResetPeriod;
    LPSTR       lpRebootMsg;
    LPSTR       lpCommand;



    DWORD       cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;
typedef struct _SERVICE_FAILURE_ACTIONSW {
    DWORD       dwResetPeriod;
    LPWSTR      lpRebootMsg;
    LPWSTR      lpCommand;



    DWORD       cActions;



    SC_ACTION * lpsaActions;
} SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;




typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS;
#line 551 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"




typedef struct _SERVICE_DELAYED_AUTO_START_INFO {
    BOOL       fDelayedAutostart;      
} SERVICE_DELAYED_AUTO_START_INFO, *LPSERVICE_DELAYED_AUTO_START_INFO;




typedef struct _SERVICE_FAILURE_ACTIONS_FLAG {
    BOOL       fFailureActionsOnNonCrashFailures;       
} SERVICE_FAILURE_ACTIONS_FLAG, *LPSERVICE_FAILURE_ACTIONS_FLAG;




typedef struct _SERVICE_SID_INFO {
    DWORD       dwServiceSidType;     
} SERVICE_SID_INFO, *LPSERVICE_SID_INFO;




typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA {
    LPSTR       pmszRequiredPrivileges;             
} SERVICE_REQUIRED_PRIVILEGES_INFOA, *LPSERVICE_REQUIRED_PRIVILEGES_INFOA;



typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW {
    LPWSTR      pmszRequiredPrivileges;             
} SERVICE_REQUIRED_PRIVILEGES_INFOW, *LPSERVICE_REQUIRED_PRIVILEGES_INFOW;




typedef SERVICE_REQUIRED_PRIVILEGES_INFOA SERVICE_REQUIRED_PRIVILEGES_INFO;
typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOA LPSERVICE_REQUIRED_PRIVILEGES_INFO;
#line 592 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"




typedef struct _SERVICE_PRESHUTDOWN_INFO {
    DWORD       dwPreshutdownTimeout;   
} SERVICE_PRESHUTDOWN_INFO, *LPSERVICE_PRESHUTDOWN_INFO;




typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM
{
    DWORD   dwDataType; 



    DWORD   cbData;     



    PBYTE   pData;      
} SERVICE_TRIGGER_SPECIFIC_DATA_ITEM, *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM;




typedef struct _SERVICE_TRIGGER
{
    DWORD                       dwTriggerType;              
    DWORD                       dwAction;                   
    GUID    *                   pTriggerSubtype;            
                                                            
                                                            



    DWORD                       cDataItems;                 



    PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM  pDataItems;       
} SERVICE_TRIGGER, *PSERVICE_TRIGGER;




typedef struct _SERVICE_TRIGGER_INFO {



    DWORD                   cTriggers;  



    PSERVICE_TRIGGER        pTriggers;  
    PBYTE                   pReserved;  
} SERVICE_TRIGGER_INFO, *PSERVICE_TRIGGER_INFO;




typedef struct _SERVICE_PREFERRED_NODE_INFO {
    USHORT                  usPreferredNode;    
    BOOLEAN                 fDelete;            
} SERVICE_PREFERRED_NODE_INFO, *LPSERVICE_PREFERRED_NODE_INFO;




typedef struct _SERVICE_TIMECHANGE_INFO {
    LARGE_INTEGER   liNewTime;      
    LARGE_INTEGER   liOldTime;      
} SERVICE_TIMECHANGE_INFO, *PSERVICE_TIMECHANGE_INFO;




typedef struct _SERVICE_LAUNCH_PROTECTED_INFO {
    DWORD       dwLaunchProtected;     
} SERVICE_LAUNCH_PROTECTED_INFO, *PSERVICE_LAUNCH_PROTECTED_INFO;





struct SC_HANDLE__{int unused;}; typedef struct SC_HANDLE__ *SC_HANDLE;
typedef SC_HANDLE   *LPSC_HANDLE;

struct SERVICE_STATUS_HANDLE__{int unused;}; typedef struct SERVICE_STATUS_HANDLE__ *SERVICE_STATUS_HANDLE;





typedef enum _SC_STATUS_TYPE {
    SC_STATUS_PROCESS_INFO      = 0
} SC_STATUS_TYPE;




typedef enum _SC_ENUM_TYPE {
    SC_ENUM_PROCESS_INFO        = 0
} SC_ENUM_TYPE;






typedef struct _SERVICE_STATUS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
} SERVICE_STATUS, *LPSERVICE_STATUS;

typedef struct _SERVICE_STATUS_PROCESS {
    DWORD   dwServiceType;
    DWORD   dwCurrentState;
    DWORD   dwControlsAccepted;
    DWORD   dwWin32ExitCode;
    DWORD   dwServiceSpecificExitCode;
    DWORD   dwCheckPoint;
    DWORD   dwWaitHint;
    DWORD   dwProcessId;
    DWORD   dwServiceFlags;
} SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;






typedef struct _ENUM_SERVICE_STATUSA {
    LPSTR             lpServiceName;
    LPSTR             lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
typedef struct _ENUM_SERVICE_STATUSW {
    LPWSTR            lpServiceName;
    LPWSTR            lpDisplayName;
    SERVICE_STATUS    ServiceStatus;
} ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;




typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;
#line 747 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

typedef struct _ENUM_SERVICE_STATUS_PROCESSA {
    LPSTR                     lpServiceName;
    LPSTR                     lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
typedef struct _ENUM_SERVICE_STATUS_PROCESSW {
    LPWSTR                    lpServiceName;
    LPWSTR                    lpDisplayName;
    SERVICE_STATUS_PROCESS    ServiceStatusProcess;
} ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;




typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS;
#line 765 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"





typedef LPVOID  SC_LOCK;

typedef struct _QUERY_SERVICE_LOCK_STATUSA {
    DWORD   fIsLocked;
    LPSTR   lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
typedef struct _QUERY_SERVICE_LOCK_STATUSW {
    DWORD   fIsLocked;
    LPWSTR  lpLockOwner;
    DWORD   dwLockDuration;
} QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;




typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;
#line 789 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"







typedef struct _QUERY_SERVICE_CONFIGA {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPSTR   lpBinaryPathName;
    LPSTR   lpLoadOrderGroup;
    DWORD   dwTagId;
    LPSTR   lpDependencies;
    LPSTR   lpServiceStartName;
    LPSTR   lpDisplayName;
} QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
typedef struct _QUERY_SERVICE_CONFIGW {
    DWORD   dwServiceType;
    DWORD   dwStartType;
    DWORD   dwErrorControl;
    LPWSTR  lpBinaryPathName;
    LPWSTR  lpLoadOrderGroup;
    DWORD   dwTagId;
    LPWSTR  lpDependencies;
    LPWSTR  lpServiceStartName;
    LPWSTR  lpDisplayName;
} QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;




typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;
#line 825 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"







typedef void __stdcall SERVICE_MAIN_FUNCTIONW (
    DWORD dwNumServicesArgs,
    LPWSTR *lpServiceArgVectors
    );

typedef void __stdcall SERVICE_MAIN_FUNCTIONA (
    DWORD dwNumServicesArgs,
    LPTSTR *lpServiceArgVectors
    );





#line 847 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

typedef void (__stdcall *LPSERVICE_MAIN_FUNCTIONW)(
    DWORD   dwNumServicesArgs,
    LPWSTR  *lpServiceArgVectors
    );

typedef void (__stdcall *LPSERVICE_MAIN_FUNCTIONA)(
    DWORD   dwNumServicesArgs,
    LPSTR   *lpServiceArgVectors
    );





#line 863 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"






typedef struct _SERVICE_TABLE_ENTRYA {
    LPSTR                       lpServiceName;
    LPSERVICE_MAIN_FUNCTIONA    lpServiceProc;
}SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
typedef struct _SERVICE_TABLE_ENTRYW {
    LPWSTR                      lpServiceName;
    LPSERVICE_MAIN_FUNCTIONW    lpServiceProc;
}SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;




typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;
#line 884 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"





typedef void __stdcall HANDLER_FUNCTION (
    DWORD    dwControl
    );

typedef DWORD __stdcall HANDLER_FUNCTION_EX (
    DWORD    dwControl,
    DWORD    dwEventType,
    LPVOID   lpEventData,
    LPVOID   lpContext
    );

typedef void (__stdcall *LPHANDLER_FUNCTION)(
    DWORD    dwControl
    );

typedef DWORD (__stdcall *LPHANDLER_FUNCTION_EX)(
    DWORD    dwControl,
    DWORD    dwEventType,
    LPVOID   lpEventData,
    LPVOID   lpContext
    );




typedef
void
( __stdcall * PFN_SC_NOTIFY_CALLBACK ) (
      PVOID pParameter
    );




typedef struct _SERVICE_NOTIFY_1 {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_NOTIFY_1, *PSERVICE_NOTIFY_1;

typedef struct _SERVICE_NOTIFY_2A {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPSTR                   pszServiceNames;
} SERVICE_NOTIFY_2A, *PSERVICE_NOTIFY_2A;
typedef struct _SERVICE_NOTIFY_2W {
    DWORD                   dwVersion;
    PFN_SC_NOTIFY_CALLBACK  pfnNotifyCallback;
    PVOID                   pContext;
    DWORD                   dwNotificationStatus;
    SERVICE_STATUS_PROCESS  ServiceStatus;
    DWORD                   dwNotificationTriggered;
    LPWSTR                  pszServiceNames;
} SERVICE_NOTIFY_2W, *PSERVICE_NOTIFY_2W;




typedef SERVICE_NOTIFY_2A SERVICE_NOTIFY_2;
typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2;
#line 956 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

typedef SERVICE_NOTIFY_2A SERVICE_NOTIFYA, *PSERVICE_NOTIFYA;
typedef SERVICE_NOTIFY_2W SERVICE_NOTIFYW, *PSERVICE_NOTIFYW;




typedef SERVICE_NOTIFYA SERVICE_NOTIFY;
typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY;
#line 966 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"




typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA {
    DWORD                   dwReason;
    LPSTR                   pszComment;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSA, *PSERVICE_CONTROL_STATUS_REASON_PARAMSA;



typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW {
    DWORD                   dwReason;
    LPWSTR                  pszComment;
    SERVICE_STATUS_PROCESS  ServiceStatus;
} SERVICE_CONTROL_STATUS_REASON_PARAMSW, *PSERVICE_CONTROL_STATUS_REASON_PARAMSW;




typedef SERVICE_CONTROL_STATUS_REASON_PARAMSA SERVICE_CONTROL_STATUS_REASON_PARAMS;
typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSA PSERVICE_CONTROL_STATUS_REASON_PARAMS;
#line 990 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"




typedef struct _SERVICE_START_REASON {
    DWORD                   dwReason;
} SERVICE_START_REASON, *PSERVICE_START_REASON;





__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfigA(
             SC_HANDLE    hService,
             DWORD        dwServiceType,
             DWORD        dwStartType,
             DWORD        dwErrorControl,
         LPCSTR     lpBinaryPathName,
         LPCSTR     lpLoadOrderGroup,
        LPDWORD      lpdwTagId,
         LPCSTR     lpDependencies,
         LPCSTR     lpServiceStartName,
         LPCSTR     lpPassword,
         LPCSTR     lpDisplayName
    );
__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfigW(
             SC_HANDLE    hService,
             DWORD        dwServiceType,
             DWORD        dwStartType,
             DWORD        dwErrorControl,
         LPCWSTR     lpBinaryPathName,
         LPCWSTR     lpLoadOrderGroup,
        LPDWORD      lpdwTagId,
         LPCWSTR     lpDependencies,
         LPCWSTR     lpServiceStartName,
         LPCWSTR     lpPassword,
         LPCWSTR     lpDisplayName
    );




#line 1039 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfig2A(
             SC_HANDLE    hService,
             DWORD        dwInfoLevel,
         LPVOID       lpInfo
    );
__declspec(dllimport)
BOOL
__stdcall
ChangeServiceConfig2W(
             SC_HANDLE    hService,
             DWORD        dwInfoLevel,
         LPVOID       lpInfo
    );




#line 1061 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
CloseServiceHandle(
             SC_HANDLE   hSCObject
    );

__declspec(dllimport)
BOOL
__stdcall
ControlService(
             SC_HANDLE           hService,
             DWORD               dwControl,
            LPSERVICE_STATUS    lpServiceStatus
    );

 
__declspec(dllimport)
SC_HANDLE
__stdcall
CreateServiceA(
             SC_HANDLE    hSCManager,
             LPCSTR     lpServiceName,
         LPCSTR     lpDisplayName,
             DWORD        dwDesiredAccess,
             DWORD        dwServiceType,
             DWORD        dwStartType,
             DWORD        dwErrorControl,
         LPCSTR     lpBinaryPathName,
         LPCSTR     lpLoadOrderGroup,
        LPDWORD      lpdwTagId,
         LPCSTR     lpDependencies,
         LPCSTR     lpServiceStartName,
         LPCSTR     lpPassword
    );
 
__declspec(dllimport)
SC_HANDLE
__stdcall
CreateServiceW(
             SC_HANDLE    hSCManager,
             LPCWSTR     lpServiceName,
         LPCWSTR     lpDisplayName,
             DWORD        dwDesiredAccess,
             DWORD        dwServiceType,
             DWORD        dwStartType,
             DWORD        dwErrorControl,
         LPCWSTR     lpBinaryPathName,
         LPCWSTR     lpLoadOrderGroup,
        LPDWORD      lpdwTagId,
         LPCWSTR     lpDependencies,
         LPCWSTR     lpServiceStartName,
         LPCWSTR     lpPassword
    );




#line 1121 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
DeleteService(
             SC_HANDLE   hService
    );

 
__declspec(dllimport)
BOOL
__stdcall
EnumDependentServicesA(
                 SC_HANDLE               hService,
                 DWORD                   dwServiceState,
     
                    LPENUM_SERVICE_STATUSA  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned
    );
 
__declspec(dllimport)
BOOL
__stdcall
EnumDependentServicesW(
                 SC_HANDLE               hService,
                 DWORD                   dwServiceState,
     
                    LPENUM_SERVICE_STATUSW  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned
    );




#line 1160 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusA(
                 SC_HANDLE               hSCManager,
                 DWORD                   dwServiceType,
                 DWORD                   dwServiceState,
     
                    LPENUM_SERVICE_STATUSA  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned,
          LPDWORD                 lpResumeHandle
    );
 
__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusW(
                 SC_HANDLE               hSCManager,
                 DWORD                   dwServiceType,
                 DWORD                   dwServiceState,
     
                    LPENUM_SERVICE_STATUSW  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned,
          LPDWORD                 lpResumeHandle
    );




#line 1196 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusExA(
                 SC_HANDLE               hSCManager,
                 SC_ENUM_TYPE            InfoLevel,
                 DWORD                   dwServiceType,
                 DWORD                   dwServiceState,
     
                    LPBYTE                  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned,
          LPDWORD                 lpResumeHandle,
             LPCSTR                pszGroupName
    );
 
__declspec(dllimport)
BOOL
__stdcall
EnumServicesStatusExW(
                 SC_HANDLE               hSCManager,
                 SC_ENUM_TYPE            InfoLevel,
                 DWORD                   dwServiceType,
                 DWORD                   dwServiceState,
     
                    LPBYTE                  lpServices,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded,
                LPDWORD                 lpServicesReturned,
          LPDWORD                 lpResumeHandle,
             LPCWSTR                pszGroupName
    );




#line 1236 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
GetServiceKeyNameA(
                 SC_HANDLE               hSCManager,
                 LPCSTR                lpDisplayName,
     
                    LPSTR                 lpServiceName,
              LPDWORD                 lpcchBuffer
    );
 
__declspec(dllimport)
BOOL
__stdcall
GetServiceKeyNameW(
                 SC_HANDLE               hSCManager,
                 LPCWSTR                lpDisplayName,
     
                    LPWSTR                 lpServiceName,
              LPDWORD                 lpcchBuffer
    );




#line 1264 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
GetServiceDisplayNameA(
                 SC_HANDLE               hSCManager,
                 LPCSTR                lpServiceName,
     
                    LPSTR                 lpDisplayName,
              LPDWORD                 lpcchBuffer
    );
 
__declspec(dllimport)
BOOL
__stdcall
GetServiceDisplayNameW(
                 SC_HANDLE               hSCManager,
                 LPCWSTR                lpServiceName,
     
                    LPWSTR                 lpDisplayName,
              LPDWORD                 lpcchBuffer
    );




#line 1292 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

__declspec(dllimport)
SC_LOCK
__stdcall
LockServiceDatabase(
                 SC_HANDLE               hSCManager
    );

__declspec(dllimport)
BOOL
__stdcall
NotifyBootConfigStatus(
                 BOOL                    BootAcceptable
    );

 
__declspec(dllimport)
SC_HANDLE
__stdcall
OpenSCManagerA(
             LPCSTR                lpMachineName,
             LPCSTR                lpDatabaseName,
                 DWORD                   dwDesiredAccess
    );
 
__declspec(dllimport)
SC_HANDLE
__stdcall
OpenSCManagerW(
             LPCWSTR                lpMachineName,
             LPCWSTR                lpDatabaseName,
                 DWORD                   dwDesiredAccess
    );




#line 1330 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

 
__declspec(dllimport)
SC_HANDLE
__stdcall
OpenServiceA(
                 SC_HANDLE               hSCManager,
                 LPCSTR                lpServiceName,
                 DWORD                   dwDesiredAccess
    );
 
__declspec(dllimport)
SC_HANDLE
__stdcall
OpenServiceW(
                 SC_HANDLE               hSCManager,
                 LPCWSTR                lpServiceName,
                 DWORD                   dwDesiredAccess
    );




#line 1354 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfigA(
                 SC_HANDLE               hService,
     
                    LPQUERY_SERVICE_CONFIGA lpServiceConfig,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );
 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfigW(
                 SC_HANDLE               hService,
     
                    LPQUERY_SERVICE_CONFIGW lpServiceConfig,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );




#line 1382 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"


#line 1385 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

#line 1387 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

#line 1390 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"
 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfig2A(
                 SC_HANDLE               hService,
                 DWORD                   dwInfoLevel,
     
                    LPBYTE                  lpBuffer,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );

#line 1404 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

#line 1406 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

#line 1409 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"
 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceConfig2W(
                 SC_HANDLE               hService,
                 DWORD                   dwInfoLevel,
     
                    LPBYTE                  lpBuffer,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );




#line 1426 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceLockStatusA(
                 SC_HANDLE                       hSCManager,
     
                    LPQUERY_SERVICE_LOCK_STATUSA    lpLockStatus,
                 DWORD                           cbBufSize,
                LPDWORD                         pcbBytesNeeded
    );
 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceLockStatusW(
                 SC_HANDLE                       hSCManager,
     
                    LPQUERY_SERVICE_LOCK_STATUSW    lpLockStatus,
                 DWORD                           cbBufSize,
                LPDWORD                         pcbBytesNeeded
    );




#line 1454 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceObjectSecurity(
                 SC_HANDLE               hService,
                 SECURITY_INFORMATION    dwSecurityInformation,
     
                    PSECURITY_DESCRIPTOR    lpSecurityDescriptor,
                 DWORD                   cbBufSize,
                LPDWORD                 pcbBytesNeeded
    );

 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceStatus(
                 SC_HANDLE           hService,
                LPSERVICE_STATUS    lpServiceStatus
    );

 
__declspec(dllimport)
BOOL
__stdcall
QueryServiceStatusEx(
                 SC_HANDLE           hService,
                 SC_STATUS_TYPE      InfoLevel,
     
                    LPBYTE              lpBuffer,
                 DWORD               cbBufSize,
                LPDWORD             pcbBytesNeeded
    );

 
__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerA(
         LPCSTR                    lpServiceName,
         
            LPHANDLER_FUNCTION          lpHandlerProc
    );
 
__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerW(
         LPCWSTR                    lpServiceName,
         
            LPHANDLER_FUNCTION          lpHandlerProc
    );




#line 1513 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

 
__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerExA(
         LPCSTR                    lpServiceName,
         
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
      LPVOID                     lpContext
    );
 
__declspec(dllimport)
SERVICE_STATUS_HANDLE
__stdcall
RegisterServiceCtrlHandlerExW(
         LPCWSTR                    lpServiceName,
         
            LPHANDLER_FUNCTION_EX       lpHandlerProc,
      LPVOID                     lpContext
    );




#line 1539 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
SetServiceObjectSecurity(
             SC_HANDLE               hService,
             SECURITY_INFORMATION    dwSecurityInformation,
             PSECURITY_DESCRIPTOR    lpSecurityDescriptor
    );

__declspec(dllimport)
BOOL
__stdcall
SetServiceStatus(
             SERVICE_STATUS_HANDLE   hServiceStatus,
             LPSERVICE_STATUS        lpServiceStatus
    );

__declspec(dllimport)
BOOL
__stdcall
StartServiceCtrlDispatcherA(
      const  SERVICE_TABLE_ENTRYA    *lpServiceStartTable
    );
__declspec(dllimport)
BOOL
__stdcall
StartServiceCtrlDispatcherW(
      const  SERVICE_TABLE_ENTRYW    *lpServiceStartTable
    );




#line 1574 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"


__declspec(dllimport)
BOOL
__stdcall
StartServiceA(
                 SC_HANDLE            hService,
                 DWORD                dwNumServiceArgs,
     
                    LPCSTR             *lpServiceArgVectors
    );
__declspec(dllimport)
BOOL
__stdcall
StartServiceW(
                 SC_HANDLE            hService,
                 DWORD                dwNumServiceArgs,
     
                    LPCWSTR             *lpServiceArgVectors
    );




#line 1599 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
UnlockServiceDatabase(
                 SC_LOCK             ScLock
    );



__declspec(dllimport)
DWORD
__stdcall
NotifyServiceStatusChangeA (
             SC_HANDLE               hService,
             DWORD                   dwNotifyMask,
             PSERVICE_NOTIFYA        pNotifyBuffer
    );
__declspec(dllimport)
DWORD
__stdcall
NotifyServiceStatusChangeW (
             SC_HANDLE               hService,
             DWORD                   dwNotifyMask,
             PSERVICE_NOTIFYW        pNotifyBuffer
    );




#line 1630 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
ControlServiceExA(
             SC_HANDLE               hService,
             DWORD                   dwControl,
             DWORD                   dwInfoLevel,
          PVOID                   pControlParams
    );
__declspec(dllimport)
BOOL
__stdcall
ControlServiceExW(
             SC_HANDLE               hService,
             DWORD                   dwControl,
             DWORD                   dwInfoLevel,
          PVOID                   pControlParams
    );




#line 1654 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

__declspec(dllimport)
BOOL
__stdcall
QueryServiceDynamicInformation (
             SERVICE_STATUS_HANDLE   hServiceStatus,
             DWORD                   dwInfoLevel,
        PVOID           *       ppDynamicInfo
    );

#line 1665 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

#line 1667 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"
#pragma endregion


}
#line 1672 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"

#line 1674 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\winsvc.h"


#line 231 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 232 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"



#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\mcx.h"












#pragma once
#line 15 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\mcx.h"

typedef struct _MODEMDEVCAPS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    
    DWORD   dwModemProviderVersion;
    DWORD   dwModemManufacturerOffset;
    DWORD   dwModemManufacturerSize;
    DWORD   dwModemModelOffset;
    DWORD   dwModemModelSize;
    DWORD   dwModemVersionOffset;
    DWORD   dwModemVersionSize;

    
    DWORD   dwDialOptions;          
    DWORD   dwCallSetupFailTimer;   
    DWORD   dwInactivityTimeout;    
    DWORD   dwSpeakerVolume;        
    DWORD   dwSpeakerMode;          
    DWORD   dwModemOptions;         
    DWORD   dwMaxDTERate;           
    DWORD   dwMaxDCERate;           

    
    BYTE    abVariablePortion [1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS {
    DWORD   dwActualSize;
    DWORD   dwRequiredSize;
    DWORD   dwDevSpecificOffset;
    DWORD   dwDevSpecificSize;

    
    DWORD   dwCallSetupFailTimer;       
    DWORD   dwInactivityTimeout;        
    DWORD   dwSpeakerVolume;            
    DWORD   dwSpeakerMode;              
    DWORD   dwPreferredModemOptions;    

    
    DWORD   dwNegotiatedModemOptions;   
    DWORD   dwNegotiatedDCERate;        

    
    BYTE    abVariablePortion [1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

















































































































































































































































































































































































































































































































































































































































































#line 723 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\mcx.h"
#line 236 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 237 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"


#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"













extern "C" {
#line 16 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"






#pragma region Application Family



struct HIMC__{int unused;}; typedef struct HIMC__ *HIMC;
struct HIMCC__{int unused;}; typedef struct HIMCC__ *HIMCC;



#line 32 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

#line 34 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion

#pragma region Desktop Family


typedef HKL   *LPHKL;
typedef UINT  *LPUINT;

#line 43 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion

#pragma region Application Family


typedef struct tagCOMPOSITIONFORM {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} COMPOSITIONFORM, *PCOMPOSITIONFORM,  *NPCOMPOSITIONFORM,  *LPCOMPOSITIONFORM;


typedef struct tagCANDIDATEFORM {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT  rcArea;
} CANDIDATEFORM, *PCANDIDATEFORM,  *NPCANDIDATEFORM,  *LPCANDIDATEFORM;

#line 63 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagCANDIDATELIST {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[1];
} CANDIDATELIST, *PCANDIDATELIST,  *NPCANDIDATELIST,  *LPCANDIDATELIST;

#line 81 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion


#pragma region Application Family


typedef struct tagREGISTERWORDA {
    LPSTR   lpReading;
    LPSTR   lpWord;
} REGISTERWORDA, *PREGISTERWORDA,  *NPREGISTERWORDA,  *LPREGISTERWORDA;
typedef struct tagREGISTERWORDW {
    LPWSTR  lpReading;
    LPWSTR  lpWord;
} REGISTERWORDW, *PREGISTERWORDW,  *NPREGISTERWORDW,  *LPREGISTERWORDW;






typedef REGISTERWORDA REGISTERWORD;
typedef PREGISTERWORDA PREGISTERWORD;
typedef NPREGISTERWORDA NPREGISTERWORD;
typedef LPREGISTERWORDA LPREGISTERWORD;
#line 106 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

#line 108 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion



#pragma region Desktop Family


typedef struct tagRECONVERTSTRING {
    DWORD dwSize;
    DWORD dwVersion;
    DWORD dwStrLen;
    DWORD dwStrOffset;
    DWORD dwCompStrLen;
    DWORD dwCompStrOffset;
    DWORD dwTargetStrLen;
    DWORD dwTargetStrOffset;
} RECONVERTSTRING, *PRECONVERTSTRING,  *NPRECONVERTSTRING,  *LPRECONVERTSTRING;

#line 127 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion

#line 130 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"



#pragma region Application Family


typedef struct tagSTYLEBUFA {
    DWORD       dwStyle;
    CHAR        szDescription[32];
} STYLEBUFA, *PSTYLEBUFA,  *NPSTYLEBUFA,  *LPSTYLEBUFA;
typedef struct tagSTYLEBUFW {
    DWORD       dwStyle;
    WCHAR       szDescription[32];
} STYLEBUFW, *PSTYLEBUFW,  *NPSTYLEBUFW,  *LPSTYLEBUFW;






typedef STYLEBUFA STYLEBUF;
typedef PSTYLEBUFA PSTYLEBUF;
typedef NPSTYLEBUFA NPSTYLEBUF;
typedef LPSTYLEBUFA LPSTYLEBUF;
#line 155 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

#line 157 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion

#pragma region Desktop Family



#line 164 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion





#pragma region Desktop Family


typedef struct tagIMEMENUITEMINFOA {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    CHAR        szString[80];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOA, *PIMEMENUITEMINFOA,  *NPIMEMENUITEMINFOA,  *LPIMEMENUITEMINFOA;
typedef struct tagIMEMENUITEMINFOW {
    UINT        cbSize;
    UINT        fType;
    UINT        fState;
    UINT        wID;
    HBITMAP     hbmpChecked;
    HBITMAP     hbmpUnchecked;
    DWORD       dwItemData;
    WCHAR       szString[80];
    HBITMAP     hbmpItem;
} IMEMENUITEMINFOW, *PIMEMENUITEMINFOW,  *NPIMEMENUITEMINFOW,  *LPIMEMENUITEMINFOW;






typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;
#line 206 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

typedef struct tagIMECHARPOSITION {
    DWORD       dwSize;
    DWORD       dwCharPos;
    POINT       pt;
    UINT        cLineHeight;
    RECT        rcDocument;
} IMECHARPOSITION, *PIMECHARPOSITION,  *NPIMECHARPOSITION,  *LPIMECHARPOSITION;

typedef BOOL    (__stdcall* IMCENUMPROC)(HIMC, LPARAM);

#line 218 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion

#line 221 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"





#pragma region Desktop Family


HKL  __stdcall ImmInstallIMEA(  LPCSTR lpszIMEFileName,   LPCSTR lpszLayoutText);
HKL  __stdcall ImmInstallIMEW(  LPCWSTR lpszIMEFileName,   LPCWSTR lpszLayoutText);




#line 236 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

HWND __stdcall ImmGetDefaultIMEWnd( HWND);

UINT __stdcall ImmGetDescriptionA( HKL,   LPSTR lpszDescription,  UINT uBufLen);
UINT __stdcall ImmGetDescriptionW( HKL,   LPWSTR lpszDescription,  UINT uBufLen);




#line 246 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

UINT __stdcall ImmGetIMEFileNameA( HKL,   LPSTR lpszFileName,  UINT uBufLen);
UINT __stdcall ImmGetIMEFileNameW( HKL,   LPWSTR lpszFileName,  UINT uBufLen);




#line 254 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

DWORD __stdcall ImmGetProperty( HKL,  DWORD);

BOOL __stdcall ImmIsIME( HKL);

BOOL __stdcall ImmSimulateHotKey( HWND,  DWORD);

HIMC __stdcall ImmCreateContext(void);
BOOL __stdcall ImmDestroyContext( HIMC);
HIMC __stdcall ImmGetContext( HWND);
BOOL __stdcall ImmReleaseContext( HWND,  HIMC);
HIMC __stdcall ImmAssociateContext( HWND,  HIMC);

BOOL __stdcall ImmAssociateContextEx( HWND,  HIMC,  DWORD);
#line 269 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

LONG  __stdcall ImmGetCompositionStringA( HIMC,  DWORD,   LPVOID lpBuf,  DWORD dwBufLen);
LONG  __stdcall ImmGetCompositionStringW( HIMC,  DWORD,   LPVOID lpBuf,  DWORD dwBufLen);




#line 277 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

BOOL  __stdcall ImmSetCompositionStringA( HIMC,  DWORD dwIndex,   LPVOID lpComp,  DWORD dwCompLen,   LPVOID lpRead,  DWORD dwReadLen);
BOOL  __stdcall ImmSetCompositionStringW( HIMC,  DWORD dwIndex,   LPVOID lpComp,  DWORD dwCompLen,   LPVOID lpRead,  DWORD dwReadLen);




#line 285 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

DWORD __stdcall ImmGetCandidateListCountA( HIMC,   LPDWORD lpdwListCount);
DWORD __stdcall ImmGetCandidateListCountW( HIMC,   LPDWORD lpdwListCount);




#line 293 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

DWORD __stdcall ImmGetCandidateListA( HIMC,  DWORD deIndex,   LPCANDIDATELIST lpCandList,  DWORD dwBufLen);
DWORD __stdcall ImmGetCandidateListW( HIMC,  DWORD deIndex,   LPCANDIDATELIST lpCandList,  DWORD dwBufLen);




#line 301 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

DWORD __stdcall ImmGetGuideLineA(  HIMC,   DWORD dwIndex,   LPSTR lpBuf,   DWORD dwBufLen);
DWORD __stdcall ImmGetGuideLineW(  HIMC,   DWORD dwIndex,   LPWSTR lpBuf,   DWORD dwBufLen);




#line 309 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

BOOL __stdcall ImmGetConversionStatus( HIMC,   LPDWORD lpfdwConversion,   LPDWORD lpfdwSentence);
BOOL __stdcall ImmSetConversionStatus( HIMC,  DWORD,  DWORD);
BOOL __stdcall ImmGetOpenStatus( HIMC);
BOOL __stdcall ImmSetOpenStatus( HIMC,  BOOL);


BOOL __stdcall ImmGetCompositionFontA( HIMC,   LPLOGFONTA lplf);
BOOL __stdcall ImmGetCompositionFontW( HIMC,   LPLOGFONTW lplf);




#line 323 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

BOOL __stdcall ImmSetCompositionFontA( HIMC,   LPLOGFONTA lplf);
BOOL __stdcall ImmSetCompositionFontW( HIMC,   LPLOGFONTW lplf);




#line 331 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#line 332 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

BOOL    __stdcall ImmConfigureIMEA( HKL,  HWND,  DWORD,  LPVOID);
BOOL    __stdcall ImmConfigureIMEW( HKL,  HWND,  DWORD,  LPVOID);




#line 340 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

LRESULT __stdcall ImmEscapeA( HKL,  HIMC,  UINT,  LPVOID);
LRESULT __stdcall ImmEscapeW( HKL,  HIMC,  UINT,  LPVOID);




#line 348 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

DWORD   __stdcall ImmGetConversionListA( HKL,  HIMC,   LPCSTR lpSrc,   LPCANDIDATELIST lpDst,  DWORD dwBufLen,  UINT uFlag);
DWORD   __stdcall ImmGetConversionListW( HKL,  HIMC,   LPCWSTR lpSrc,   LPCANDIDATELIST lpDst,  DWORD dwBufLen,  UINT uFlag);




#line 356 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

BOOL    __stdcall ImmNotifyIME( HIMC,  DWORD dwAction,  DWORD dwIndex,  DWORD dwValue);

BOOL __stdcall ImmGetStatusWindowPos( HIMC,   LPPOINT lpptPos);
BOOL __stdcall ImmSetStatusWindowPos( HIMC,   LPPOINT lpptPos);
BOOL __stdcall ImmGetCompositionWindow( HIMC,   LPCOMPOSITIONFORM lpCompForm);
BOOL __stdcall ImmSetCompositionWindow( HIMC,   LPCOMPOSITIONFORM lpCompForm);
BOOL __stdcall ImmGetCandidateWindow( HIMC,  DWORD,   LPCANDIDATEFORM lpCandidate);
BOOL __stdcall ImmSetCandidateWindow( HIMC,   LPCANDIDATEFORM lpCandidate);

BOOL __stdcall ImmIsUIMessageA( HWND,  UINT,  WPARAM,  LPARAM);
BOOL __stdcall ImmIsUIMessageW( HWND,  UINT,  WPARAM,  LPARAM);




#line 373 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"


UINT __stdcall ImmGetVirtualKey( HWND);

typedef int (__stdcall *REGISTERWORDENUMPROCA)(  LPCSTR lpszReading, DWORD,   LPCSTR lpszString, LPVOID);
typedef int (__stdcall *REGISTERWORDENUMPROCW)(  LPCWSTR lpszReading, DWORD,   LPCWSTR lpszString, LPVOID);




#line 384 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

BOOL __stdcall ImmRegisterWordA( HKL,   LPCSTR lpszReading,  DWORD,   LPCSTR lpszRegister);
BOOL __stdcall ImmRegisterWordW( HKL,   LPCWSTR lpszReading,  DWORD,   LPCWSTR lpszRegister);




#line 392 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

BOOL __stdcall ImmUnregisterWordA( HKL,   LPCSTR lpszReading,  DWORD,   LPCSTR lpszUnregister);
BOOL __stdcall ImmUnregisterWordW( HKL,   LPCWSTR lpszReading,  DWORD,   LPCWSTR lpszUnregister);




#line 400 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

UINT __stdcall ImmGetRegisterWordStyleA( HKL,  UINT nItem,   LPSTYLEBUFA lpStyleBuf);
UINT __stdcall ImmGetRegisterWordStyleW( HKL,  UINT nItem,   LPSTYLEBUFW lpStyleBuf);




#line 408 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

UINT __stdcall ImmEnumRegisterWordA( HKL,  REGISTERWORDENUMPROCA,   LPCSTR lpszReading,  DWORD,   LPCSTR lpszRegister,  LPVOID);
UINT __stdcall ImmEnumRegisterWordW( HKL,  REGISTERWORDENUMPROCW,   LPCWSTR lpszReading,  DWORD,   LPCWSTR lpszRegister,  LPVOID);




#line 416 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"


BOOL __stdcall ImmDisableIME( DWORD);
BOOL __stdcall ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
DWORD __stdcall ImmGetImeMenuItemsA( HIMC,  DWORD,  DWORD,   LPIMEMENUITEMINFOA lpImeParentMenu,   LPIMEMENUITEMINFOA lpImeMenu,  DWORD dwSize);
DWORD __stdcall ImmGetImeMenuItemsW( HIMC,  DWORD,  DWORD,   LPIMEMENUITEMINFOW lpImeParentMenu,   LPIMEMENUITEMINFOW lpImeMenu,  DWORD dwSize);




#line 427 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

BOOL __stdcall ImmDisableTextFrameService(DWORD idThread);
#line 430 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"


BOOL __stdcall ImmDisableLegacyIME();
#line 434 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

#line 436 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"
#pragma endregion









































































































































































































#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ime_cmodes.h"



#pragma once

















#line 23 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\ime_cmodes.h"

#line 639 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"






















































#line 694 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"






































































#line 765 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"








#line 774 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"


}
#line 778 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"

#line 780 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\imm.h"


#line 240 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 241 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 242 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 243 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"




#pragma warning(pop)





#line 254 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 255 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#line 256 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#line 258 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#line 260 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"
#pragma endregion

#line 263 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#line 265 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\windows.h"

#line 64 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"












#line 77 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"


            

#pragma comment (lib, "freeglut.lib")
#line 83 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"

#line 85 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"

#line 87 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"



#pragma comment (lib, "glu32.lib")    
#pragma comment (lib, "opengl32.lib") 
#pragma comment (lib, "gdi32.lib")    
#pragma comment (lib, "winmm.lib")    
#pragma comment (lib, "user32.lib")   
#line 96 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"







#line 104 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"

















#line 122 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"
#line 1 "c:\\program files (x86)\\windows kits\\8.1\\include\\um\\gl\\gl.h"































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 123 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"

#line 125 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"










































































































#line 232 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"
































































































































































__declspec(dllimport) void    __stdcall glutInit( int* pargc, char** argv );
__declspec(dllimport) void    __stdcall glutInitWindowPosition( int x, int y );
__declspec(dllimport) void    __stdcall glutInitWindowSize( int width, int height );
__declspec(dllimport) void    __stdcall glutInitDisplayMode( unsigned int displayMode );
__declspec(dllimport) void    __stdcall glutInitDisplayString( const char* displayMode );




__declspec(dllimport) void    __stdcall glutMainLoop( void );




__declspec(dllimport) int     __stdcall glutCreateWindow( const char* title );
__declspec(dllimport) int     __stdcall glutCreateSubWindow( int window, int x, int y, int width, int height );
__declspec(dllimport) void    __stdcall glutDestroyWindow( int window );
__declspec(dllimport) void    __stdcall glutSetWindow( int window );
__declspec(dllimport) int     __stdcall glutGetWindow( void );
__declspec(dllimport) void    __stdcall glutSetWindowTitle( const char* title );
__declspec(dllimport) void    __stdcall glutSetIconTitle( const char* title );
__declspec(dllimport) void    __stdcall glutReshapeWindow( int width, int height );
__declspec(dllimport) void    __stdcall glutPositionWindow( int x, int y );
__declspec(dllimport) void    __stdcall glutShowWindow( void );
__declspec(dllimport) void    __stdcall glutHideWindow( void );
__declspec(dllimport) void    __stdcall glutIconifyWindow( void );
__declspec(dllimport) void    __stdcall glutPushWindow( void );
__declspec(dllimport) void    __stdcall glutPopWindow( void );
__declspec(dllimport) void    __stdcall glutFullScreen( void );




__declspec(dllimport) void    __stdcall glutPostWindowRedisplay( int window );
__declspec(dllimport) void    __stdcall glutPostRedisplay( void );
__declspec(dllimport) void    __stdcall glutSwapBuffers( void );




__declspec(dllimport) void    __stdcall glutWarpPointer( int x, int y );
__declspec(dllimport) void    __stdcall glutSetCursor( int cursor );




__declspec(dllimport) void    __stdcall glutEstablishOverlay( void );
__declspec(dllimport) void    __stdcall glutRemoveOverlay( void );
__declspec(dllimport) void    __stdcall glutUseLayer( GLenum layer );
__declspec(dllimport) void    __stdcall glutPostOverlayRedisplay( void );
__declspec(dllimport) void    __stdcall glutPostWindowOverlayRedisplay( int window );
__declspec(dllimport) void    __stdcall glutShowOverlay( void );
__declspec(dllimport) void    __stdcall glutHideOverlay( void );




__declspec(dllimport) int     __stdcall glutCreateMenu( void (* callback)( int menu ) );
__declspec(dllimport) void    __stdcall glutDestroyMenu( int menu );
__declspec(dllimport) int     __stdcall glutGetMenu( void );
__declspec(dllimport) void    __stdcall glutSetMenu( int menu );
__declspec(dllimport) void    __stdcall glutAddMenuEntry( const char* label, int value );
__declspec(dllimport) void    __stdcall glutAddSubMenu( const char* label, int subMenu );
__declspec(dllimport) void    __stdcall glutChangeToMenuEntry( int item, const char* label, int value );
__declspec(dllimport) void    __stdcall glutChangeToSubMenu( int item, const char* label, int value );
__declspec(dllimport) void    __stdcall glutRemoveMenuItem( int item );
__declspec(dllimport) void    __stdcall glutAttachMenu( int button );
__declspec(dllimport) void    __stdcall glutDetachMenu( int button );




__declspec(dllimport) void    __stdcall glutTimerFunc( unsigned int time, void (* callback)( int ), int value );
__declspec(dllimport) void    __stdcall glutIdleFunc( void (* callback)( void ) );




__declspec(dllimport) void    __stdcall glutKeyboardFunc( void (* callback)( unsigned char, int, int ) );
__declspec(dllimport) void    __stdcall glutSpecialFunc( void (* callback)( int, int, int ) );
__declspec(dllimport) void    __stdcall glutReshapeFunc( void (* callback)( int, int ) );
__declspec(dllimport) void    __stdcall glutVisibilityFunc( void (* callback)( int ) );
__declspec(dllimport) void    __stdcall glutDisplayFunc( void (* callback)( void ) );
__declspec(dllimport) void    __stdcall glutMouseFunc( void (* callback)( int, int, int, int ) );
__declspec(dllimport) void    __stdcall glutMotionFunc( void (* callback)( int, int ) );
__declspec(dllimport) void    __stdcall glutPassiveMotionFunc( void (* callback)( int, int ) );
__declspec(dllimport) void    __stdcall glutEntryFunc( void (* callback)( int ) );

__declspec(dllimport) void    __stdcall glutKeyboardUpFunc( void (* callback)( unsigned char, int, int ) );
__declspec(dllimport) void    __stdcall glutSpecialUpFunc( void (* callback)( int, int, int ) );
__declspec(dllimport) void    __stdcall glutJoystickFunc( void (* callback)( unsigned int, int, int, int ), int pollInterval );
__declspec(dllimport) void    __stdcall glutMenuStateFunc( void (* callback)( int ) );
__declspec(dllimport) void    __stdcall glutMenuStatusFunc( void (* callback)( int, int, int ) );
__declspec(dllimport) void    __stdcall glutOverlayDisplayFunc( void (* callback)( void ) );
__declspec(dllimport) void    __stdcall glutWindowStatusFunc( void (* callback)( int ) );

__declspec(dllimport) void    __stdcall glutSpaceballMotionFunc( void (* callback)( int, int, int ) );
__declspec(dllimport) void    __stdcall glutSpaceballRotateFunc( void (* callback)( int, int, int ) );
__declspec(dllimport) void    __stdcall glutSpaceballButtonFunc( void (* callback)( int, int ) );
__declspec(dllimport) void    __stdcall glutButtonBoxFunc( void (* callback)( int, int ) );
__declspec(dllimport) void    __stdcall glutDialsFunc( void (* callback)( int, int ) );
__declspec(dllimport) void    __stdcall glutTabletMotionFunc( void (* callback)( int, int ) );
__declspec(dllimport) void    __stdcall glutTabletButtonFunc( void (* callback)( int, int, int, int ) );




__declspec(dllimport) int     __stdcall glutGet( GLenum query );
__declspec(dllimport) int     __stdcall glutDeviceGet( GLenum query );
__declspec(dllimport) int     __stdcall glutGetModifiers( void );
__declspec(dllimport) int     __stdcall glutLayerGet( GLenum query );




__declspec(dllimport) void    __stdcall glutBitmapCharacter( void* font, int character );
__declspec(dllimport) int     __stdcall glutBitmapWidth( void* font, int character );
__declspec(dllimport) void    __stdcall glutStrokeCharacter( void* font, int character );
__declspec(dllimport) int     __stdcall glutStrokeWidth( void* font, int character );
__declspec(dllimport) int     __stdcall glutBitmapLength( void* font, const unsigned char* string );
__declspec(dllimport) int     __stdcall glutStrokeLength( void* font, const unsigned char* string );




__declspec(dllimport) void    __stdcall glutWireCube( GLdouble size );
__declspec(dllimport) void    __stdcall glutSolidCube( GLdouble size );
__declspec(dllimport) void    __stdcall glutWireSphere( GLdouble radius, GLint slices, GLint stacks );
__declspec(dllimport) void    __stdcall glutSolidSphere( GLdouble radius, GLint slices, GLint stacks );
__declspec(dllimport) void    __stdcall glutWireCone( GLdouble base, GLdouble height, GLint slices, GLint stacks );
__declspec(dllimport) void    __stdcall glutSolidCone( GLdouble base, GLdouble height, GLint slices, GLint stacks );

__declspec(dllimport) void    __stdcall glutWireTorus( GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings );
__declspec(dllimport) void    __stdcall glutSolidTorus( GLdouble innerRadius, GLdouble outerRadius, GLint sides, GLint rings );
__declspec(dllimport) void    __stdcall glutWireDodecahedron( void );
__declspec(dllimport) void    __stdcall glutSolidDodecahedron( void );
__declspec(dllimport) void    __stdcall glutWireOctahedron( void );
__declspec(dllimport) void    __stdcall glutSolidOctahedron( void );
__declspec(dllimport) void    __stdcall glutWireTetrahedron( void );
__declspec(dllimport) void    __stdcall glutSolidTetrahedron( void );
__declspec(dllimport) void    __stdcall glutWireIcosahedron( void );
__declspec(dllimport) void    __stdcall glutSolidIcosahedron( void );





__declspec(dllimport) void    __stdcall glutWireTeapot( GLdouble size );
__declspec(dllimport) void    __stdcall glutSolidTeapot( GLdouble size );




__declspec(dllimport) void    __stdcall glutGameModeString( const char* string );
__declspec(dllimport) int     __stdcall glutEnterGameMode( void );
__declspec(dllimport) void    __stdcall glutLeaveGameMode( void );
__declspec(dllimport) int     __stdcall glutGameModeGet( GLenum query );




__declspec(dllimport) int     __stdcall glutVideoResizeGet( GLenum query );
__declspec(dllimport) void    __stdcall glutSetupVideoResizing( void );
__declspec(dllimport) void    __stdcall glutStopVideoResizing( void );
__declspec(dllimport) void    __stdcall glutVideoResize( int x, int y, int width, int height );
__declspec(dllimport) void    __stdcall glutVideoPan( int x, int y, int width, int height );




__declspec(dllimport) void    __stdcall glutSetColor( int color, GLfloat red, GLfloat green, GLfloat blue );
__declspec(dllimport) GLfloat __stdcall glutGetColor( int color, int component );
__declspec(dllimport) void    __stdcall glutCopyColormap( int window );




__declspec(dllimport) void    __stdcall glutIgnoreKeyRepeat( int ignore );
__declspec(dllimport) void    __stdcall glutSetKeyRepeat( int repeatMode );
__declspec(dllimport) void    __stdcall glutForceJoystickFunc( void );




__declspec(dllimport) int     __stdcall glutExtensionSupported( const char* extension );
__declspec(dllimport) void    __stdcall glutReportErrors( void );



























__declspec(dllimport) void __stdcall __glutInitWithExit(int *argcp, char **argv, void (__cdecl *exitfunc)(int));
__declspec(dllimport) int __stdcall __glutCreateWindowWithExit(const char *title, void (__cdecl *exitfunc)(int));
__declspec(dllimport) int __stdcall __glutCreateMenuWithExit(void (* func)(int), void (__cdecl *exitfunc)(int));



#line 612 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"

#line 614 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"
static void __stdcall  glutInit_ATEXIT_HACK(int *argcp, char **argv) { __glutInitWithExit(argcp, argv, exit); }

static int __stdcall  glutCreateWindow_ATEXIT_HACK(const char *title) { return __glutCreateWindowWithExit(title, exit); }

static int __stdcall  glutCreateMenu_ATEXIT_HACK(void (* func)(int)) { return __glutCreateMenuWithExit(func, exit); }

#line 621 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"
#line 622 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"


    }
#line 626 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"



#line 630 "d:\\gl files\\freeglut\\include\\gl\\freeglut_std.h"

#line 18 "d:\\gl files\\freeglut\\include\\gl\\freeglut.h"
#line 1 "d:\\gl files\\freeglut\\include\\gl\\freeglut_ext.h"































    extern "C" {
#line 34 "d:\\gl files\\freeglut\\include\\gl\\freeglut_ext.h"



























































































__declspec(dllimport) void    __stdcall glutMainLoopEvent( void );
__declspec(dllimport) void    __stdcall glutLeaveMainLoop( void );
__declspec(dllimport) void    __stdcall glutExit         ( void );




__declspec(dllimport) void    __stdcall glutFullScreenToggle( void );
__declspec(dllimport) void    __stdcall glutLeaveFullScreen( void );




__declspec(dllimport) void    __stdcall glutMouseWheelFunc( void (* callback)( int, int, int, int ) );
__declspec(dllimport) void    __stdcall glutCloseFunc( void (* callback)( void ) );
__declspec(dllimport) void    __stdcall glutWMCloseFunc( void (* callback)( void ) );

__declspec(dllimport) void    __stdcall glutMenuDestroyFunc( void (* callback)( void ) );




__declspec(dllimport) void    __stdcall glutSetOption ( GLenum option_flag, int value );
__declspec(dllimport) int *   __stdcall glutGetModeValues(GLenum mode, int * size);

__declspec(dllimport) void*   __stdcall glutGetWindowData( void );
__declspec(dllimport) void    __stdcall glutSetWindowData(void* data);
__declspec(dllimport) void*   __stdcall glutGetMenuData( void );
__declspec(dllimport) void    __stdcall glutSetMenuData(void* data);




__declspec(dllimport) int     __stdcall glutBitmapHeight( void* font );
__declspec(dllimport) GLfloat __stdcall glutStrokeHeight( void* font );
__declspec(dllimport) void    __stdcall glutBitmapString( void* font, const unsigned char *string );
__declspec(dllimport) void    __stdcall glutStrokeString( void* font, const unsigned char *string );




__declspec(dllimport) void    __stdcall glutWireRhombicDodecahedron( void );
__declspec(dllimport) void    __stdcall glutSolidRhombicDodecahedron( void );
__declspec(dllimport) void    __stdcall glutWireSierpinskiSponge ( int num_levels, GLdouble offset[3], GLdouble scale );
__declspec(dllimport) void    __stdcall glutSolidSierpinskiSponge ( int num_levels, GLdouble offset[3], GLdouble scale );
__declspec(dllimport) void    __stdcall glutWireCylinder( GLdouble radius, GLdouble height, GLint slices, GLint stacks);
__declspec(dllimport) void    __stdcall glutSolidCylinder( GLdouble radius, GLdouble height, GLint slices, GLint stacks);




typedef void (*GLUTproc)();
__declspec(dllimport) GLUTproc __stdcall glutGetProcAddress( const char *procName );







__declspec(dllimport) void __stdcall glutMultiEntryFunc( void (* callback)( int, int ) );
__declspec(dllimport) void __stdcall glutMultiButtonFunc( void (* callback)( int, int, int, int, int ) );
__declspec(dllimport) void __stdcall glutMultiMotionFunc( void (* callback)( int, int, int ) );
__declspec(dllimport) void __stdcall glutMultiPassiveFunc( void (* callback)( int, int, int ) );










int     glutJoystickGetNumAxes( int ident );
int     glutJoystickGetNumButtons( int ident );
int     glutJoystickNotWorking( int ident );
float   glutJoystickGetDeadBand( int ident, int axis );
void    glutJoystickSetDeadBand( int ident, int axis, float db );
float   glutJoystickGetSaturation( int ident, int axis );
void    glutJoystickSetSaturation( int ident, int axis, float st );
void    glutJoystickSetMinRange( int ident, float *axes );
void    glutJoystickSetMaxRange( int ident, float *axes );
void    glutJoystickSetCenter( int ident, float *axes );
void    glutJoystickGetMinRange( int ident, float *axes );
void    glutJoystickGetMaxRange( int ident, float *axes );
void    glutJoystickGetCenter( int ident, float *axes );




__declspec(dllimport) void    __stdcall glutInitContextVersion( int majorVersion, int minorVersion );
__declspec(dllimport) void    __stdcall glutInitContextFlags( int flags );
__declspec(dllimport) void    __stdcall glutInitContextProfile( int profile );




__declspec(dllimport) void    __stdcall glutInitErrorFunc( void (* vError)( const char *fmt, va_list ap ) );
__declspec(dllimport) void    __stdcall glutInitWarningFunc( void (* vWarning)( const char *fmt, va_list ap ) );









    }
#line 236 "d:\\gl files\\freeglut\\include\\gl\\freeglut_ext.h"



#line 240 "d:\\gl files\\freeglut\\include\\gl\\freeglut_ext.h"
#line 19 "d:\\gl files\\freeglut\\include\\gl\\freeglut.h"



#line 23 "d:\\gl files\\freeglut\\include\\gl\\freeglut.h"
#line 5 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\ai_assert.h"










#line 12 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\ai_assert.h"


#line 15 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\ai_assert.h"
#line 6 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\gl files\\simple opengl image library\\src\\soil.h"











































extern "C" {
#line 46 "d:\\gl files\\simple opengl image library\\src\\soil.h"









enum
{
	SOIL_LOAD_AUTO = 0,
	SOIL_LOAD_L = 1,
	SOIL_LOAD_LA = 2,
	SOIL_LOAD_RGB = 3,
	SOIL_LOAD_RGBA = 4
};








enum
{
	SOIL_CREATE_NEW_ID = 0
};




















enum
{
	SOIL_FLAG_POWER_OF_TWO = 1,
	SOIL_FLAG_MIPMAPS = 2,
	SOIL_FLAG_TEXTURE_REPEATS = 4,
	SOIL_FLAG_MULTIPLY_ALPHA = 8,
	SOIL_FLAG_INVERT_Y = 16,
	SOIL_FLAG_COMPRESS_TO_DXT = 32,
	SOIL_FLAG_DDS_LOAD_DIRECT = 64,
	SOIL_FLAG_NTSC_SAFE_RGB = 128,
	SOIL_FLAG_CoCg_Y = 256,
	SOIL_FLAG_TEXTURE_RECTANGLE = 512
};







enum
{
	SOIL_SAVE_TYPE_TGA = 0,
	SOIL_SAVE_TYPE_BMP = 1,
	SOIL_SAVE_TYPE_DDS = 2
};
















enum
{
	SOIL_HDR_RGBE = 0,
	SOIL_HDR_RGBdivA = 1,
	SOIL_HDR_RGBdivA2 = 2
};









unsigned int
	SOIL_load_OGL_texture
	(
		const char *filename,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);














unsigned int
	SOIL_load_OGL_cubemap
	(
		const char *x_pos_file,
		const char *x_neg_file,
		const char *y_pos_file,
		const char *y_neg_file,
		const char *z_pos_file,
		const char *z_neg_file,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);










unsigned int
	SOIL_load_OGL_single_cubemap
	(
		const char *filename,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);









unsigned int
	SOIL_load_OGL_HDR_texture
	(
		const char *filename,
		int fake_HDR_format,
		int rescale_to_max,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);










unsigned int
	SOIL_load_OGL_texture_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);




















unsigned int
	SOIL_load_OGL_cubemap_from_memory
	(
		const unsigned char *const x_pos_buffer,
		int x_pos_buffer_length,
		const unsigned char *const x_neg_buffer,
		int x_neg_buffer_length,
		const unsigned char *const y_pos_buffer,
		int y_pos_buffer_length,
		const unsigned char *const y_neg_buffer,
		int y_neg_buffer_length,
		const unsigned char *const z_pos_buffer,
		int z_pos_buffer_length,
		const unsigned char *const z_neg_buffer,
		int z_neg_buffer_length,
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);











unsigned int
	SOIL_load_OGL_single_cubemap_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		const char face_order[6],
		int force_channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);












unsigned int
	SOIL_create_OGL_texture
	(
		const unsigned char *const data,
		int width, int height, int channels,
		unsigned int reuse_texture_ID,
		unsigned int flags
	);












unsigned int
	SOIL_create_OGL_single_cubemap
	(
		const unsigned char *const data,
		int width, int height, int channels,
		const char face_order[6],
		unsigned int reuse_texture_ID,
		unsigned int flags
	);





int
	SOIL_save_screenshot
	(
		const char *filename,
		int image_type,
		int x, int y,
		int width, int height
	);










unsigned char*
	SOIL_load_image
	(
		const char *filename,
		int *width, int *height, int *channels,
		int force_channels
	);










unsigned char*
	SOIL_load_image_from_memory
	(
		const unsigned char *const buffer,
		int buffer_length,
		int *width, int *height, int *channels,
		int force_channels
	);





int
	SOIL_save_image
	(
		const char *filename,
		int image_type,
		int width, int height, int channels,
		const unsigned char *const data
	);






void
	SOIL_free_image_data
	(
		unsigned char *img_data
	);






const char*
	SOIL_last_result
	(
		void
	);



}
#line 432 "d:\\gl files\\simple opengl image library\\src\\soil.h"

#line 434 "d:\\gl files\\simple opengl image library\\src\\soil.h"
#line 7 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\vec2.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.hpp"
































#pragma once


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\precision.hpp"
































#pragma once

namespace glm
{
	enum precision
	{
		highp,
		mediump,
		lowp,
		defaultp = highp
	};
}
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_int.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"
































#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cassert"



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"









#line 11 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 5 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cassert"





#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"














#line 51 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



















#line 71 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 73 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 75 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"











#line 87 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



























#line 115 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



















































































#line 199 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"










#line 210 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 213 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 215 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 217 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 219 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 223 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"





























































#line 285 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"























#line 309 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"






#line 316 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 318 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 320 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 324 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"








#line 333 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"































#line 365 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 369 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 372 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 374 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"














#line 389 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"









#line 399 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"





#line 405 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 407 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"





#line 413 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"














#line 428 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"







































#line 468 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"
#line 469 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

























#line 495 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"










#line 506 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 508 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 512 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 517 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 519 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 523 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 528 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"





#line 534 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"





#line 540 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 543 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 547 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 552 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 554 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 558 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 563 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 568 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 573 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 575 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 579 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 584 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 586 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 590 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 595 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 597 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 602 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 607 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 609 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 614 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 619 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 621 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 626 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




#line 631 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 634 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"








#line 643 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 646 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"







#line 654 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"







































#line 694 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 696 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 698 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 700 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 702 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 704 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"











#line 716 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 719 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 721 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 723 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 727 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"
















#line 744 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"






#line 751 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 755 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 758 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 761 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 764 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"








#line 773 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"
#line 774 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"
















#line 791 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"













#line 805 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"







#line 813 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 816 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 820 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 822 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"












#line 835 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


#line 838 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"
















#line 855 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

























#line 881 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"



#line 885 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

#line 887 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"






namespace glm
{
	using std::size_t;


#line 899 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"
		typedef int length_t;
#line 901 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

namespace detail
{



		typedef length_t component_count_t;
#line 909 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"

	template <typename genType>
	 inline  component_count_t component_count(genType const & m)
	{



			return m.length();
#line 918 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"
	}
}
}










#line 932 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"






#line 939 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"


	namespace glm
	{
		template <typename T, std::size_t N>
		constexpr std::size_t countof(T const (&)[N])
		{
			return N;
		}
	}





#line 955 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\setup.hpp"




namespace glm
{
	enum ctor{uninitialize};
}

#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_int.hpp"


#line 39 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_int.hpp"



#line 43 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_int.hpp"

namespace glm{
namespace detail
{

		typedef std::int8_t					int8;
		typedef std::int16_t				int16;
		typedef std::int32_t				int32;
		typedef std::int64_t				int64;
	
		typedef std::uint8_t				uint8;
		typedef std::uint16_t				uint16;
		typedef std::uint32_t				uint32;
		typedef std::uint64_t				uint64;
























#line 82 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_int.hpp"
	
	typedef signed int						lowp_int_t;
	typedef signed int						mediump_int_t;
	typedef signed int						highp_int_t;
	
	typedef unsigned int					lowp_uint_t;
	typedef unsigned int					mediump_uint_t;
	typedef unsigned int					highp_uint_t;


		using std::make_signed;
		using std::make_unsigned;

































































































































#line 224 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_int.hpp"
}

	typedef detail::int8					int8;
	typedef detail::int16					int16;
	typedef detail::int32					int32;
	typedef detail::int64					int64;
	
	typedef detail::uint8					uint8;
	typedef detail::uint16					uint16;
	typedef detail::uint32					uint32;
	typedef detail::uint64					uint64;

	
	

	
	
	
	
	
	typedef detail::lowp_int_t				lowp_int;

	
	
	
	
	
	typedef detail::mediump_int_t			mediump_int;

	
	
	
	
	
	typedef detail::highp_int_t				highp_int;

	
	
	
	
	
	typedef detail::lowp_uint_t				lowp_uint;

	
	
	
	
	
	typedef detail::mediump_uint_t			mediump_uint;

	
	
	
	
	
	typedef detail::highp_uint_t			highp_uint;


	typedef mediump_int					int_t;








#line 292 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_int.hpp"


	typedef mediump_uint				uint_t;








#line 304 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_int.hpp"

	
	
	
	typedef unsigned int				uint;

	




	static_assert(sizeof(glm::int8) == 1, "int8 size isn't 1 byte on this platform");
	static_assert(sizeof(glm::int16) == 2, "int16 size isn't 2 bytes on this platform");
	static_assert(sizeof(glm::int32) == 4, "int32 size isn't 4 bytes on this platform");
	static_assert(sizeof(glm::int64) == 8, "int64 size isn't 8 bytes on this platform");

	static_assert(sizeof(glm::uint8) == 1, "uint8 size isn't 1 byte on this platform");
	static_assert(sizeof(glm::uint16) == 2, "uint16 size isn't 2 bytes on this platform");
	static_assert(sizeof(glm::uint32) == 4, "uint32 size isn't 4 bytes on this platform");
	static_assert(sizeof(glm::uint64) == 8, "uint64 size isn't 8 bytes on this platform");
#line 325 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_int.hpp"

}
#line 37 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"

namespace glm
{
	template <typename T, precision P> struct tvec1;
	template <typename T, precision P> struct tvec2;
	template <typename T, precision P> struct tvec3;
	template <typename T, precision P> struct tvec4;

	typedef tvec1<float, highp>		highp_vec1_t;
	typedef tvec1<float, mediump>	mediump_vec1_t;
	typedef tvec1<float, lowp>		lowp_vec1_t;
	typedef tvec1<double, highp>	highp_dvec1_t;
	typedef tvec1<double, mediump>	mediump_dvec1_t;
	typedef tvec1<double, lowp>		lowp_dvec1_t;
	typedef tvec1<int, highp>		highp_ivec1_t;
	typedef tvec1<int, mediump>		mediump_ivec1_t;
	typedef tvec1<int, lowp>		lowp_ivec1_t;
	typedef tvec1<uint, highp>		highp_uvec1_t;
	typedef tvec1<uint, mediump>	mediump_uvec1_t;
	typedef tvec1<uint, lowp>		lowp_uvec1_t;
	typedef tvec1<bool, highp>		highp_bvec1_t;
	typedef tvec1<bool, mediump>	mediump_bvec1_t;
	typedef tvec1<bool, lowp>		lowp_bvec1_t;

	
	

	
	
	
	
	
	typedef tvec2<float, highp>		highp_vec2;

	
	
	
	
	
	typedef tvec2<float, mediump>	mediump_vec2;

	
	
	
	
	
	typedef tvec2<float, lowp>		lowp_vec2;

	
	
	
	
	
	typedef tvec2<double, highp>	highp_dvec2;

	
	
	
	
	
	typedef tvec2<double, mediump>	mediump_dvec2;

	
	
	
	
	
	typedef tvec2<double, lowp>		lowp_dvec2;

	
	
	
	
	
	typedef tvec2<int, highp>		highp_ivec2;

	
	
	
	
	
	typedef tvec2<int, mediump>		mediump_ivec2;

	
	
	
	
	
	typedef tvec2<int, lowp>		lowp_ivec2;

	
	
	
	
	
	typedef tvec2<uint, highp>		highp_uvec2;

	
	
	
	
	
	typedef tvec2<uint, mediump>	mediump_uvec2;

	
	
	
	
	
	typedef tvec2<uint, lowp>		lowp_uvec2;

	
	
	
	
	
	typedef tvec2<bool, highp>		highp_bvec2;

	
	
	
	
	
	typedef tvec2<bool, mediump>	mediump_bvec2;

	
	
	
	
	
	typedef tvec2<bool, lowp>		lowp_bvec2;

	


	
	

	
	
	
	
	
	typedef tvec3<float, highp>		highp_vec3;

	
	
	
	
	
	typedef tvec3<float, mediump>	mediump_vec3;

	
	
	
	
	
	typedef tvec3<float, lowp>		lowp_vec3;

	
	
	
	
	
	typedef tvec3<double, highp>	highp_dvec3;

	
	
	
	
	
	typedef tvec3<double, mediump>	mediump_dvec3;

	
	
	
	
	
	typedef tvec3<double, lowp>		lowp_dvec3;

	
	
	
	
	
	typedef tvec3<int, highp>		highp_ivec3;

	
	
	
	
	
	typedef tvec3<int, mediump>		mediump_ivec3;

	
	
	
	
	
	typedef tvec3<int, lowp>		lowp_ivec3;

	
	
	
	
	
	typedef tvec3<uint, highp>		highp_uvec3;

	
	
	
	
	
	typedef tvec3<uint, mediump>	mediump_uvec3;

	
	
	
	
	
	typedef tvec3<uint, lowp>		lowp_uvec3;

	
	
	
	
	typedef tvec3<bool, highp>		highp_bvec3;

	
	
	
	
	typedef tvec3<bool, mediump>	mediump_bvec3;

	
	
	
	
	typedef tvec3<bool, lowp>		lowp_bvec3;

	

	
	

	
	
	
	
	typedef tvec4<float, highp>		highp_vec4;

	
	
	
	
	typedef tvec4<float, mediump>	mediump_vec4;

	
	
	
	
	typedef tvec4<float, lowp>		lowp_vec4;

	
	
	
	
	typedef tvec4<double, highp>	highp_dvec4;

	
	
	
	
	typedef tvec4<double, mediump>	mediump_dvec4;

	
	
	
	
	typedef tvec4<double, lowp>		lowp_dvec4;

	
	
	
	
	typedef tvec4<int, highp>		highp_ivec4;

	
	
	
	
	typedef tvec4<int, mediump>		mediump_ivec4;

	
	
	
	
	typedef tvec4<int, lowp>		lowp_ivec4;

	
	
	
	
	typedef tvec4<uint, highp>		highp_uvec4;

	
	
	
	
	typedef tvec4<uint, mediump>	mediump_uvec4;

	
	
	
	
	typedef tvec4<uint, lowp>		lowp_uvec4;

	
	
	
	
	typedef tvec4<bool, highp>		highp_bvec4;

	
	
	
	
	typedef tvec4<bool, mediump>	mediump_bvec4;

	
	
	
	
	typedef tvec4<bool, lowp>		lowp_bvec4;

	

	
	

	
	





#line 385 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"



#line 389 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
	
	
	
	typedef highp_vec2			vec2;

	
	
	
	typedef highp_vec3			vec3;

	
	
	
	typedef highp_vec4			vec4;
#line 404 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"

	
	





#line 413 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"



#line 417 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
	
	
	
	typedef highp_dvec2			dvec2;
	
	
	
	
	typedef highp_dvec3			dvec3;
	
	
	
	
	typedef highp_dvec4			dvec4;
#line 432 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
	
	
	
	




#line 441 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"



#line 445 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
	
	
	
	typedef highp_ivec2			ivec2;
	
	
	
	
	typedef highp_ivec3			ivec3;
	
	
	
	
	typedef highp_ivec4			ivec4;
#line 460 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
	
	
	
	




#line 469 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"



#line 473 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
	
	
	
	typedef highp_uvec2			uvec2;
	
	
	
	
	typedef highp_uvec3			uvec3;
	
	
	
	
	typedef highp_uvec4			uvec4;
#line 488 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
	
	
	





#line 497 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"



#line 501 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
	
	
	
	typedef highp_bvec2			bvec2;
	
	
	
	
	typedef highp_bvec3			bvec3;
	
	
	
	
	typedef highp_bvec4			bvec4;
#line 516 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec.hpp"
	
	
}
#line 37 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.hpp"









namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec2
	{
		
		

		typedef tvec2<T, P> type;
		typedef tvec2<bool, P> bool_type;
		typedef T value_type;

		
		


			union
			{
				struct{ T x, y; };
				struct{ T r, g; };
				struct{ T s, t; };












			};







#line 88 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.hpp"

		
		









			
			typedef length_t length_type;
			  length_type length() const;

			 T & operator[](length_type i);
			 T const & operator[](length_type i) const;
#line 107 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.hpp"

		
		

		 tvec2();
		 tvec2(tvec2<T, P> const & v);
		template <precision Q>
		 tvec2(tvec2<T, Q> const & v);

		
		

		 explicit tvec2(ctor);
		 explicit tvec2(T const & s);
		 tvec2(T const & s1, T const & s2);

		
		

		
		template <typename A, typename B>
		 tvec2(A const & x, B const & y);
		template <typename A, typename B>
		 tvec2(tvec1<A, P> const & v1, tvec1<B, P> const & v2);

		
		

		
		template <typename U, precision Q>
		 explicit tvec2(tvec3<U, Q> const & v);
		
		template <typename U, precision Q>
		 explicit tvec2(tvec4<U, Q> const & v);






			
			template <typename U, precision Q>
			 tvec2(tvec2<U, Q> const & v);
#line 151 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.hpp"

		
		







#line 162 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.hpp"

		
		

		 tvec2<T, P>& operator=(tvec2<T, P> const & v);

		template <typename U>
		 tvec2<T, P>& operator=(tvec2<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator+=(U s);
		template <typename U>
		 tvec2<T, P>& operator+=(tvec1<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator+=(tvec2<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator-=(U s);
		template <typename U>
		 tvec2<T, P>& operator-=(tvec1<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator-=(tvec2<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator*=(U s);
		template <typename U>
		 tvec2<T, P>& operator*=(tvec1<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator*=(tvec2<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator/=(U s);
		template <typename U>
		 tvec2<T, P>& operator/=(tvec1<U, P> const & v);
		template <typename U>
		 tvec2<T, P>& operator/=(tvec2<U, P> const & v);

		
		

		 tvec2<T, P> & operator++();
		 tvec2<T, P> & operator--();
		 tvec2<T, P> operator++(int);
		 tvec2<T, P> operator--(int);

		
		

		template <typename U> 
		 tvec2<T, P> & operator%=(U s);
		template <typename U> 
		 tvec2<T, P> & operator%=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator%=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator&=(U s);
		template <typename U> 
		 tvec2<T, P> & operator&=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator&=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator|=(U s);
		template <typename U> 
		 tvec2<T, P> & operator|=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator|=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator^=(U s);
		template <typename U> 
		 tvec2<T, P> & operator^=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator^=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator<<=(U s);
		template <typename U> 
		 tvec2<T, P> & operator<<=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator<<=(tvec2<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator>>=(U s);
		template <typename U> 
		 tvec2<T, P> & operator>>=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec2<T, P> & operator>>=(tvec2<U, P> const & v);
	};

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator+(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator*(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator/(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator-(tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator%(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator&(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator|(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator^(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec2<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(T const & s, tvec2<T, P> const & v);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

	template <typename T, precision P>
	 tvec2<T, P> operator~(tvec2<T, P> const & v);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.inl"




























namespace glm
{







	template <typename T, precision P>
	 inline  length_t tvec2<T, P>::length() const
	{
		return 2;
	}
#line 44 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.inl"

	
	

	template <typename T, precision P>
	 inline T & tvec2<T, P>::operator[](length_t i)
	{
		(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.inl", (unsigned)(51)), 0) );
		return (&x)[i];
	}

	template <typename T, precision P>
	 inline T const & tvec2<T, P>::operator[](length_t i) const
	{
		(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.inl", (unsigned)(58)), 0) );
		return (&x)[i];
	}

	
	

	template <typename T, precision P>
	 inline tvec2<T, P>::tvec2()

			: x(0), y(0)
#line 70 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.inl"
	{}

	template <typename T, precision P>
	 inline tvec2<T, P>::tvec2(tvec2<T, P> const & v)
		: x(v.x), y(v.y)
	{}

	template <typename T, precision P>
	template <precision Q>
	 inline tvec2<T, P>::tvec2(tvec2<T, Q> const & v)
		: x(v.x), y(v.y)
	{}

	
	

	template <typename T, precision P>
	 inline tvec2<T, P>::tvec2(ctor)
	{}

	template <typename T, precision P>
	 inline tvec2<T, P>::tvec2(T const & s)
		: x(s), y(s)
	{}

	template <typename T, precision P>
	 inline tvec2<T, P>::tvec2(T const & s1, T const & s2)
		: x(s1), y(s2)
	{}

	
	

	template <typename T, precision P>
	template <typename A, typename B>
	 inline tvec2<T, P>::tvec2(A const & a, B const & b)
		: x(static_cast<T>(a))
		, y(static_cast<T>(b))
	{}

	template <typename T, precision P>
	template <typename A, typename B>
	 inline tvec2<T, P>::tvec2(tvec1<A, P> const & a, tvec1<B, P> const & b)
		: x(static_cast<T>(a.x))
		, y(static_cast<T>(b.x))
	{}

	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec2<T, P>::tvec2(tvec2<U, Q> const & v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec2<T, P>::tvec2(tvec3<U, Q> const & v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec2<T, P>::tvec2(tvec4<U, Q> const & v)
		: x(static_cast<T>(v.x))
		, y(static_cast<T>(v.y))
	{}

	
	

	template <typename T, precision P>
	 inline tvec2<T, P> & tvec2<T, P>::operator=(tvec2<T, P> const & v)
	{
		this->x = v.x;
		this->y = v.y;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator=(tvec2<U, P> const & v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator+=(U s)
	{
		this->x += static_cast<T>(s);
		this->y += static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator+=(tvec1<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator+=(tvec2<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator-=(U s)
	{
		this->x -= static_cast<T>(s);
		this->y -= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator-=(tvec1<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator-=(tvec2<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator*=(U s)
	{
		this->x *= static_cast<T>(s);
		this->y *= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator*=(tvec1<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator*=(tvec2<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator/=(U s)
	{
		this->x /= static_cast<T>(s);
		this->y /= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator/=(tvec1<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator/=(tvec2<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		return *this;
	}
	
	

	template <typename T, precision P>
	 inline tvec2<T, P> & tvec2<T, P>::operator++()
	{
		++this->x;
		++this->y;
		return *this;
	}

	template <typename T, precision P>
	 inline tvec2<T, P> & tvec2<T, P>::operator--()
	{
		--this->x;
		--this->y;
		return *this;
	}

	template <typename T, precision P> 
	 inline tvec2<T, P> tvec2<T, P>::operator++(int)
	{
		tvec2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 inline tvec2<T, P> tvec2<T, P>::operator--(int)
	{
		tvec2<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return (v1.x == v2.x) && (v1.y == v2.y);
	}

	template <typename T, precision P>
	 inline bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return (v1.x != v2.x) || (v1.y != v2.y);
	}

	
	

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator%=(U s)
	{
		this->x %= static_cast<T>(s);
		this->y %= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator%=(tvec1<U, P> const & v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator%=(tvec2<U, P> const & v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator&=(U s)
	{
		this->x &= static_cast<T>(s);
		this->y &= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator&=(tvec1<U, P> const & v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator&=(tvec2<U, P> const & v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator|=(U s)
	{
		this->x |= static_cast<T>(s);
		this->y |= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator|=(tvec1<U, P> const & v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator|=(tvec2<U, P> const & v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator^=(U s)
	{
		this->x ^= static_cast<T>(s);
		this->y ^= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator^=(tvec1<U, P> const & v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator^=(tvec2<U, P> const & v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator<<=(U s)
	{
		this->x <<= static_cast<T>(s);
		this->y <<= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator<<=(tvec1<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator<<=(tvec2<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator>>=(U s)
	{
		this->x >>= static_cast<T>(s);
		this->y >>= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator>>=(tvec1<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec2<T, P> & tvec2<T, P>::operator>>=(tvec2<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		return *this;
	}

	
	

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(tvec2<T, P> const & v, T const & s)
	{
		return tvec2<T, P>(
			v.x + s,
			v.y + s);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x + v2.x,
			v1.y + v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s + v.x,
			s + v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x + v2.x,
			v1.x + v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x + v2.x,
			v1.y + v2.y);
	}

	
	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec2<T, P> const & v, T const & s)
	{
		return tvec2<T, P>(
			v.x - s,
			v.y - s);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x - v2.x,
			v1.y - v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s - v.x,
			s - v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x - v2.x,
			v1.x - v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x - v2.x,
			v1.y - v2.y);
	}

	
	template <typename T, precision P>
	 inline tvec2<T, P> operator*(tvec2<T, P> const & v1, T const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2,
			v1.y * v2);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2.x,
			v1.y * v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator*(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s * v.x,
			s * v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2.x,
			v1.x * v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x * v2.x,
			v1.y * v2.y);
	}

	
	template <typename T, precision P>
	 inline tvec2<T, P> operator/(tvec2<T, P> const & v, T const & s)
	{
		return tvec2<T, P>(
			v.x / s,
			v.y / s);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x / v2.x,
			v1.y / v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator/(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s / v.x,
			s / v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x / v2.x,
			v1.x / v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x / v2.x,
			v1.y / v2.y);
	}

	
	template <typename T, precision P>
	 inline tvec2<T, P> operator-(tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			-v.x, 
			-v.y);
	}

	
	

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(tvec2<T, P> const & v, T const & s)
	{
		return tvec2<T, P>(
			v.x % s,
			v.y % s);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x % v2.x,
			v1.y % v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s % v.x,
			s % v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x % v2.x,
			v1.x % v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x % v2.x,
			v1.y % v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(tvec2<T, P> const & v, T const & s)
	{
		return tvec2<T, P>(
			v.x & s,
			v.y & s);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x & v2.x,
			v1.y & v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s & v.x,
			s & v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x & v2.x,
			v1.x & v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x & v2.x,
			v1.y & v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(tvec2<T, P> const & v, T const & s)
	{
		return tvec2<T, P>(
			v.x | s,
			v.y | s);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x | v2.x,
			v1.y | v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s | v.x,
			s | v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x | v2.x,
			v1.x | v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x | v2.x,
			v1.y | v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(tvec2<T, P> const & v, T const & s)
	{
		return tvec2<T, P>(
			v.x ^ s,
			v.y ^ s);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s ^ v.x,
			s ^ v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x ^ v2.x,
			v1.x ^ v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(tvec2<T, P> const & v, T const & s)
	{
		return tvec2<T, P>(
			v.x << s,
			v.y << s);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x << v2.x,
			v1.y << v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s << v.x,
			s << v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x << v2.x,
			v1.x << v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x << v2.x,
			v1.y << v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(tvec2<T, P> const & v, T const & s)
	{
		return tvec2<T, P>(
			v.x >> s,
			v.y >> s);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.x);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(T const & s, tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			s >> v.x,
			s >> v.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x >> v2.x,
			v1.x >> v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
	{
		return tvec2<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.y);
	}

	template <typename T, precision P>
	 inline tvec2<T, P> operator~(tvec2<T, P> const & v)
	{
		return tvec2<T, P>(
			~v.x,
			~v.y);
	}
}
#line 403 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.hpp"
#line 404 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec2.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\vec2.hpp"
#line 10 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\vec3.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.hpp"
































#pragma once












namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec3
	{	
		
		

		typedef tvec3<T, P> type;
		typedef tvec3<bool, P> bool_type;
		typedef T value_type;

	
		
		


			union
			{
				struct{ T x, y, z; };
				struct{ T r, g, b; };
				struct{ T s, t, p; };












			};








#line 90 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.hpp"

		
		









			
			typedef length_t length_type;
			  length_type length() const;

			
			  tvec2<T, P> xz_func()
			{
				return vec2(this->x, this->z);
			}
			  tvec2<T, P> xy_func()
			{
				return vec2(this->x, this->y);
			}



			 T & operator[](length_type i);
			 T const & operator[](length_type i) const;
#line 121 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.hpp"

		
		

		 tvec3();
		 tvec3(tvec3<T, P> const & v);
		template <precision Q>
		 tvec3(tvec3<T, Q> const & v);

		
		

		 explicit tvec3(ctor);
		 explicit tvec3(T const & s);
		 tvec3(T const & a, T const & b, T const & c);

		
		

		
		template <typename A, typename B, typename C>
		 tvec3(A const & a, B const & b, C const & c);
		template <typename A, typename B, typename C>
		 tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c);

		
		

		
		template <typename A, typename B, precision Q>
		 explicit tvec3(tvec2<A, Q> const & a, B const & b);
		
		template <typename A, typename B, precision Q>
		 explicit tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		 explicit tvec3(A const & a, tvec2<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		 explicit tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b);
		
		template <typename U, precision Q>
		 explicit tvec3(tvec4<U, Q> const & v);






			
			template <typename U, precision Q>
			 tvec3(tvec3<U, Q> const & v);
#line 174 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.hpp"

		
		



















#line 197 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.hpp"

		
		

		 tvec3<T, P> & operator=(tvec3<T, P> const & v);

		template <typename U>
		 tvec3<T, P> & operator=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator+=(U s);
		template <typename U>
		 tvec3<T, P> & operator+=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator+=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator-=(U s);
		template <typename U>
		 tvec3<T, P> & operator-=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator-=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator*=(U s);
		template <typename U>
		 tvec3<T, P> & operator*=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator*=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator/=(U s);
		template <typename U>
		 tvec3<T, P> & operator/=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator/=(tvec3<U, P> const & v);

		
		

		 tvec3<T, P> & operator++();
		 tvec3<T, P> & operator--();
		 tvec3<T, P> operator++(int);
		 tvec3<T, P> operator--(int);

		
		

		template <typename U>
		 tvec3<T, P> & operator%=(U s);
		template <typename U>
		 tvec3<T, P> & operator%=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator%=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator&=(U s);
		template <typename U>
		 tvec3<T, P> & operator&=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator&=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator|=(U s);
		template <typename U>
		 tvec3<T, P> & operator|=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator|=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator^=(U s);
		template <typename U>
		 tvec3<T, P> & operator^=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator^=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator<<=(U s);
		template <typename U>
		 tvec3<T, P> & operator<<=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator<<=(tvec3<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator>>=(U s);
		template <typename U>
		 tvec3<T, P> & operator>>=(tvec1<U, P> const & v);
		template <typename U>
		 tvec3<T, P> & operator>>=(tvec3<U, P> const & v);
	};

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator+(T const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator-(T const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator*(T const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator/(T const & s, tvec3<T, P> const & v);

	
	
	
	
	
	

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator-(tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator%(T const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator&(T const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator|(T const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator^(T const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(T const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec3<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(T const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec1<T, P> const & s, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

	template <typename T, precision P> 
	 tvec3<T, P> operator~(tvec3<T, P> const & v);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.inl"
































namespace glm
{
	
	

	template <typename T, precision P>
	 inline tvec3<T, P>::tvec3()

			: x(0), y(0), z(0)
#line 43 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.inl"
	{}

	template <typename T, precision P>
	 inline tvec3<T, P>::tvec3(tvec3<T, P> const & v)
		: x(v.x), y(v.y), z(v.z)
	{}

	template <typename T, precision P>
	template <precision Q>
	 inline tvec3<T, P>::tvec3(tvec3<T, Q> const & v)
		: x(v.x), y(v.y), z(v.z)
	{}

	
	

	template <typename T, precision P>
	 inline tvec3<T, P>::tvec3(ctor)
	{}

	template <typename T, precision P>
	 inline tvec3<T, P>::tvec3(T const & s)
		: x(s), y(s), z(s)
	{}

	template <typename T, precision P>
	 inline tvec3<T, P>::tvec3(T const & a, T const & b, T const & c)
		: x(a), y(b), z(c)
	{}

	
	

	template <typename T, precision P>
	template <typename A, typename B, typename C>
	 inline tvec3<T, P>::tvec3(A const & a, B const & b, C const & c) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b)),
		z(static_cast<T>(c))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C>
	 inline tvec3<T, P>::tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b)),
		z(static_cast<T>(c))
	{}

	
	

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline tvec3<T, P>::tvec3(tvec2<A, Q> const & a, B const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline tvec3<T, P>::tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline tvec3<T, P>::tvec3(A const & a, tvec2<B, Q> const & b) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline tvec3<T, P>::tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec3<T, P>::tvec3(tvec3<U, Q> const & v) :
		x(static_cast<T>(v.x)),
		y(static_cast<T>(v.y)),
		z(static_cast<T>(v.z))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec3<T, P>::tvec3(tvec4<U, Q> const & v) :
		x(static_cast<T>(v.x)),
		y(static_cast<T>(v.y)),
		z(static_cast<T>(v.z))
	{}

	
	






















		template <typename T, precision P>
		 inline  typename tvec3<T, P>::length_type tvec3<T, P>::length() const
		{
			return 3;
		}

		template <typename T, precision P>
		 inline T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)
		{
			(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.inl", (unsigned)(176)), 0) );
			return (&x)[i];
		}

		template <typename T, precision P>
		 inline T const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) const
		{
			(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.inl", (unsigned)(183)), 0) );
			return (&x)[i];
		}
#line 187 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.inl"

	
	

	template <typename T, precision P>
	 inline tvec3<T, P>& tvec3<T, P>::operator=(tvec3<T, P> const & v)
	{
		this->x = v.x;
		this->y = v.y;
		this->z = v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> const & v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator+=(U s)
	{
		this->x += static_cast<T>(s);
		this->y += static_cast<T>(s);
		this->z += static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.x);
		this->z += static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		this->z += static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator-=(U s)
	{
		this->x -= static_cast<T>(s);
		this->y -= static_cast<T>(s);
		this->z -= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.x);
		this->z -= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		this->z -= static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator*=(U s)
	{
		this->x *= static_cast<T>(s);
		this->y *= static_cast<T>(s);
		this->z *= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		this->z *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		this->z *= static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator/=(U s)
	{
		this->x /= static_cast<T>(s);
		this->y /= static_cast<T>(s);
		this->z /= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		this->z /= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		this->z /= static_cast<T>(v.z);
		return *this;
	}

	
	

	template <typename T, precision P>
	 inline tvec3<T, P> & tvec3<T, P>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		return *this;
	}

	template <typename T, precision P>
	 inline tvec3<T, P> & tvec3<T, P>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		return *this;
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> tvec3<T, P>::operator++(int)
	{
		tvec3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> tvec3<T, P>::operator--(int)
	{
		tvec3<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator%=(U s)
	{
		this->x %= s;
		this->y %= s;
		this->z %= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> const & v)
	{
		this->x %= v.x;
		this->y %= v.x;
		this->z %= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> const & v)
	{
		this->x %= v.x;
		this->y %= v.y;
		this->z %= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator&=(U s)
	{
		this->x &= s;
		this->y &= s;
		this->z &= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> const & v)
	{
		this->x &= v.x;
		this->y &= v.x;
		this->z &= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> const & v)
	{
		this->x &= v.x;
		this->y &= v.y;
		this->z &= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec3<T, P> & tvec3<T, P>::operator|=(U s)
	{
		this->x |= s;
		this->y |= s;
		this->z |= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> const & v)
	{
		this->x |= v.x;
		this->y |= v.x;
		this->z |= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> const & v)
	{
		this->x |= v.x;
		this->y |= v.y;
		this->z |= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator^=(U s)
	{
		this->x ^= s;
		this->y ^= s;
		this->z ^= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> const & v)
	{
		this->x ^= v.x;
		this->y ^= v.x;
		this->z ^= v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> const & v)
	{
		this->x ^= v.x;
		this->y ^= v.y;
		this->z ^= v.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator<<=(U s)
	{
		this->x <<= s;
		this->y <<= s;
		this->z <<= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		this->z <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		this->z <<= static_cast<T>(v.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator>>=(U s)
	{
		this->x >>= static_cast<T>(s);
		this->y >>= static_cast<T>(s);
		this->z >>= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.x);
		this->z >>= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		this->z >>= static_cast<T>(v.z);
		return *this;
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
	}

	template <typename T, precision P>
	 inline bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
	}

	
	

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x + s,
			v.y + s,
			v.z + s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x + s.x,
			v.y + s.x,
			v.z + s.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s + v.x,
			s + v.y,
			s + v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x + v.x,
			s.x + v.y,
			s.x + v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x + v2.x,
			v1.y + v2.y,
			v1.z + v2.z);
	}

	
	template <typename T, precision P>
	 inline tvec3<T, P> operator-(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x - s,
			v.y - s,
			v.z - s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x - s.x,
			v.y - s.x,
			v.z - s.x);
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> operator-(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s - v.x,
			s - v.y,
			s - v.z);
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> operator-(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x - v.x,
			s.x - v.y,
			s.x - v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x - v2.x,
			v1.y - v2.y,
			v1.z - v2.z);
	}

	
	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x * s,
			v.y * s,
			v.z * s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x * s.x,
			v.y * s.x,
			v.z * s.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s * v.x,
			s * v.y,
			s * v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x * v.x,
			s.x * v.y,
			s.x * v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x * v2.x,
			v1.y * v2.y,
			v1.z * v2.z);
	}

	
	template <typename T, precision P>
	 inline tvec3<T, P> operator/(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x / s,
			v.y / s,
			v.z / s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x / s.x,
			v.y / s.x,
			v.z / s.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator/(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s / v.x,
			s / v.y,
			s / v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator/(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x / v.x,
			s.x / v.y,
			s.x / v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x / v2.x,
			v1.y / v2.y,
			v1.z / v2.z);
	}

	
	template <typename T, precision P>
	 inline tvec3<T, P> operator-(tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			-v.x, 
			-v.y, 
			-v.z);
	}

	
	

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x % s,
			v.y % s,
			v.z % s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x % s.x,
			v.y % s.x,
			v.z % s.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s % v.x,
			s % v.y,
			s % v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x % v.x,
			s.x % v.y,
			s.x % v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x % v2.x,
			v1.y % v2.y,
			v1.z % v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x & s,
			v.y & s,
			v.z & s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x & s.x,
			v.y & s.x,
			v.z & s.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s & v.x,
			s & v.y,
			s & v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x & v.x,
			s.x & v.y,
			s.x & v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x & v2.x,
			v1.y & v2.y,
			v1.z & v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x | s,
			v.y | s,
			v.z | s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x | s.x,
			v.y | s.x,
			v.z | s.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s | v.x,
			s | v.y,
			s | v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x | v.x,
			s.x | v.y,
			s.x | v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x | v2.x,
			v1.y | v2.y,
			v1.z | v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x ^ s,
			v.y ^ s,
			v.z ^ s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x ^ s.x,
			v.y ^ s.x,
			v.z ^ s.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s ^ v.x,
			s ^ v.y,
			s ^ v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x ^ v.x,
			s.x ^ v.y,
			s.x ^ v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.y,
			v1.z ^ v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x << s,
			v.y << s,
			v.z << s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x << s.x,
			v.y << s.x,
			v.z << s.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s << v.x,
			s << v.y,
			s << v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x << v.x,
			s.x << v.y,
			s.x << v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x << v2.x,
			v1.y << v2.y,
			v1.z << v2.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(tvec3<T, P> const & v, T const & s)
	{
		return tvec3<T, P>(
			v.x >> s,
			v.y >> s,
			v.z >> s);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec3<T, P>(
			v.x >> s.x,
			v.y >> s.x,
			v.z >> s.x);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(T const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s >> v.x,
			s >> v.y,
			s >> v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(tvec1<T, P> const & s, tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			s.x >> v.x,
			s.x >> v.y,
			s.x >> v.z);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
	{
		return tvec3<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.y,
			v1.z >> v2.z);
	}

	template <typename T, precision P> 
	 inline tvec3<T, P> operator~(tvec3<T, P> const & v)
	{
		return tvec3<T, P>(
			~v.x,
			~v.y,
			~v.z);
	}
}
#line 445 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.hpp"
#line 446 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec3.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\vec3.hpp"
#line 11 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\vec4.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"
































#pragma once













namespace glm{
namespace detail
{
	template <typename T>
	struct simd
	{
		typedef T type[4];
	};




		template <>
		struct simd<float>
		{
			typedef __m128 type;
		};

		template <>
		struct simd<int>
		{
			typedef __m128i type;
		};

		template <>
		struct simd<unsigned int>
		{
			typedef __m128i type;
		};
#line 77 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"







#line 85 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"













#line 99 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"

}

	template <typename T, precision P = defaultp>
	struct tvec4
	{
		
		

		typedef tvec4<T, P> type;
		typedef tvec4<bool, P> bool_type;
		typedef T value_type;

		
		


			union
			{
				struct { T x, y, z, w;};
				struct { T r, g, b, a; };
				struct { T s, t, p, q; };

				typename detail::simd<T>::type data;












			};









#line 146 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"

		
		









			
			typedef length_t length_type;
			  length_type length() const;

			 T & operator[](length_type i);
			 T const & operator[](length_type i) const;
#line 165 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"

		
		

		 tvec4();
		 tvec4(tvec4<T, P> const & v);
		template <precision Q>
		 tvec4(tvec4<T, Q> const & v);

		
		

		 explicit tvec4(ctor);
		 explicit tvec4(T s);
		 tvec4(T a, T b, T c, T d);
		 ~tvec4(){}

		
		

		
		template <typename A, typename B, typename C, typename D>
		 tvec4(A a, B b, C c, D d);
		template <typename A, typename B, typename C, typename D>
		 tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d);

		
		

		
		template <typename A, typename B, typename C, precision Q>
		 explicit tvec4(tvec2<A, Q> const & a, B b, C c);
		
		template <typename A, typename B, typename C, precision Q>
		 explicit tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c);
		
		template <typename A, typename B, typename C, precision Q>
		 explicit tvec4(A a, tvec2<B, Q> const & b, C c);
		
		template <typename A, typename B, typename C, precision Q>
		 explicit tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c);
		
		template <typename A, typename B, typename C, precision Q>
		 explicit tvec4(A a, B b, tvec2<C, Q> const & c);
		
		template <typename A, typename B, typename C, precision Q>
		 explicit tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c);
		
		template <typename A, typename B, precision Q>
		 explicit tvec4(tvec3<A, Q> const & a, B b);
		
		template <typename A, typename B, precision Q>
		 explicit tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		 explicit tvec4(A a, tvec3<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		 explicit tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b);
		
		template <typename A, typename B, precision Q>
		 explicit tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b);
		





			
			template <typename U, precision Q>
			 tvec4(tvec4<U, Q> const & v);
#line 237 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"

		
		











































#line 284 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"

		
		

		 tvec4<T, P> & operator=(tvec4<T, P> const & v);

		template <typename U>
		 tvec4<T, P> & operator=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator+=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator+=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator+=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator-=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator-=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator-=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator*=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator*=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator*=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator/=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator/=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator/=(tvec4<U, P> const & v);

		
		

		 tvec4<T, P> & operator++();
		 tvec4<T, P> & operator--();
		 tvec4<T, P> operator++(int);
		 tvec4<T, P> operator--(int);

		
		

		template <typename U>
		 tvec4<T, P> & operator%=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator%=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator%=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator&=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator&=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator&=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator|=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator|=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator|=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator^=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator^=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator^=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator<<=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator<<=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator<<=(tvec4<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator>>=(U scalar);
		template <typename U>
		 tvec4<T, P> & operator>>=(tvec1<U, P> const & v);
		template <typename U>
		 tvec4<T, P> & operator>>=(tvec4<U, P> const & v);
	};

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator-(tvec4<T, P> const & v);

	template <typename T, precision P>
	 bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & s);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec1<T, P> const & s, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

	template <typename T, precision P> 
	 tvec4<T, P> operator~(tvec4<T, P> const & v);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl"
































namespace glm
{
	
	

	template <typename T, precision P>
	 inline tvec4<T, P>::tvec4()

			: x(0), y(0), z(0), w(0)
#line 43 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl"
	{}

	template <typename T, precision P>
	 inline tvec4<T, P>::tvec4(tvec4<T, P> const & v)
		: x(v.x), y(v.y), z(v.z), w(v.w)
	{}

	template <typename T, precision P>
	template <precision Q>
	 inline tvec4<T, P>::tvec4(tvec4<T, Q> const & v)
		: x(v.x), y(v.y), z(v.z), w(v.w)
	{}

	
	

	template <typename T, precision P>
	 inline tvec4<T, P>::tvec4(ctor)
	{}

	template <typename T, precision P>
	 inline tvec4<T, P>::tvec4(T s)
		: x(s), y(s), z(s), w(s)
	{}

	template <typename T, precision P>
	 inline tvec4<T, P>::tvec4(T a, T b, T c, T d)
		: x(a), y(b), z(c), w(d)
	{}

	
	

	template <typename T, precision P>
	template <typename A, typename B, typename C, typename D>
	 inline tvec4<T, P>::tvec4(A a, B b, C c, D d) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b)),
		z(static_cast<T>(c)),
		w(static_cast<T>(d))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, typename D>
	 inline tvec4<T, P>::tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(c.x)),
		w(static_cast<T>(d.x))
	{}

	
	

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline tvec4<T, P>::tvec4(tvec2<A, Q> const & a, B b, C c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b)),
		w(static_cast<T>(c))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b.x)),
		w(static_cast<T>(c.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline tvec4<T, P>::tvec4(A s1, tvec2<B, Q> const & v, C s2) :
		x(static_cast<T>(s1)),
		y(static_cast<T>(v.x)),
		z(static_cast<T>(v.y)),
		w(static_cast<T>(s2))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y)),
		w(static_cast<T>(c.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline tvec4<T, P>::tvec4(A s1, B s2, tvec2<C, Q> const & v) :
		x(static_cast<T>(s1)),
		y(static_cast<T>(s2)),
		z(static_cast<T>(v.x)),
		w(static_cast<T>(v.y))
	{}

	template <typename T, precision P>
	template <typename A, typename B, typename C, precision Q>
	 inline tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(c.x)),
		w(static_cast<T>(c.y))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline tvec4<T, P>::tvec4(tvec3<A, Q> const & a, B b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(a.z)),
		w(static_cast<T>(b))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline tvec4<T, P>::tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(a.z)),
		w(static_cast<T>(b.x))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline tvec4<T, P>::tvec4(A a, tvec3<B, Q> const & b) :
		x(static_cast<T>(a)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y)),
		w(static_cast<T>(b.z))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(b.x)),
		z(static_cast<T>(b.y)),
		w(static_cast<T>(b.z))
	{}

	template <typename T, precision P>
	template <typename A, typename B, precision Q>
	 inline tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b) :
		x(static_cast<T>(a.x)),
		y(static_cast<T>(a.y)),
		z(static_cast<T>(b.x)),
		w(static_cast<T>(b.y))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec4<T, P>::tvec4(tvec4<U, Q> const & v) :
		x(static_cast<T>(v.x)),
		y(static_cast<T>(v.y)),
		z(static_cast<T>(v.z)),
		w(static_cast<T>(v.w))
	{}

	
	






















		template <typename T, precision P>
		 inline  typename tvec4<T, P>::length_type tvec4<T, P>::length() const
		{
			return 4;
		}

		template <typename T, precision P>
		 inline T & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i)
		{
			(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl", (unsigned)(238)), 0) );
			return (&x)[i];
		}

		template <typename T, precision P>
		 inline T const & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i) const
		{
			(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl", (unsigned)(245)), 0) );
			return (&x)[i];
		}
#line 249 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl"

	
	

	template <typename T, precision P>
	 inline tvec4<T, P> & tvec4<T, P>::operator=(tvec4<T, P> const & v)
	{
		this->x = v.x;
		this->y = v.y;
		this->z = v.z;
		this->w = v.w;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator=(tvec4<U, P> const & v)
	{
		this->x = static_cast<T>(v.x);
		this->y = static_cast<T>(v.y);
		this->z = static_cast<T>(v.z);
		this->w = static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator+=(U scalar)
	{
		this->x += static_cast<T>(scalar);
		this->y += static_cast<T>(scalar);
		this->z += static_cast<T>(scalar);
		this->w += static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator+=(tvec1<U, P> const & v)
	{
		T const scalar = static_cast<T>(v.x);
		this->x += scalar;
		this->y += scalar;
		this->z += scalar;
		this->w += scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator+=(tvec4<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		this->y += static_cast<T>(v.y);
		this->z += static_cast<T>(v.z);
		this->w += static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator-=(U scalar)
	{
		this->x -= static_cast<T>(scalar);
		this->y -= static_cast<T>(scalar);
		this->z -= static_cast<T>(scalar);
		this->w -= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator-=(tvec1<U, P> const & v)
	{
		T const scalar = static_cast<T>(v.x);
		this->x -= scalar;
		this->y -= scalar;
		this->z -= scalar;
		this->w -= scalar;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator-=(tvec4<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		this->y -= static_cast<T>(v.y);
		this->z -= static_cast<T>(v.z);
		this->w -= static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator*=(U s)
	{
		this->x *= static_cast<T>(s);
		this->y *= static_cast<T>(s);
		this->z *= static_cast<T>(s);
		this->w *= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator*=(tvec1<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.x);
		this->z *= static_cast<T>(v.x);
		this->w *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tvec4<T, P> & tvec4<T, P>::operator*=(tvec4<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		this->y *= static_cast<T>(v.y);
		this->z *= static_cast<T>(v.z);
		this->w *= static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator/=(U s)
	{
		this->x /= static_cast<T>(s);
		this->y /= static_cast<T>(s);
		this->z /= static_cast<T>(s);
		this->w /= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator/=(tvec1<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.x);
		this->z /= static_cast<T>(v.x);
		this->w /= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator/=(tvec4<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		this->y /= static_cast<T>(v.y);
		this->z /= static_cast<T>(v.z);
		this->w /= static_cast<T>(v.w);
		return *this;
	}

	
	

	template <typename T, precision P>
	 inline tvec4<T, P> & tvec4<T, P>::operator++()
	{
		++this->x;
		++this->y;
		++this->z;
		++this->w;
		return *this;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> & tvec4<T, P>::operator--()
	{
		--this->x;
		--this->y;
		--this->z;
		--this->w;
		return *this;
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> tvec4<T, P>::operator++(int)
	{
		tvec4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> tvec4<T, P>::operator--(int)
	{
		tvec4<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator%=(U scalar)
	{
		this->x %= static_cast<T>(scalar);
		this->y %= static_cast<T>(scalar);
		this->z %= static_cast<T>(scalar);
		this->w %= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator%=(tvec1<U, P> const & v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.x);
		this->z %= static_cast<T>(v.x);
		this->w %= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator%=(tvec4<U, P> const & v)
	{
		this->x %= static_cast<T>(v.x);
		this->y %= static_cast<T>(v.y);
		this->z %= static_cast<T>(v.z);
		this->w %= static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator&=(U scalar)
	{
		this->x &= static_cast<T>(scalar);
		this->y &= static_cast<T>(scalar);
		this->z &= static_cast<T>(scalar);
		this->w &= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator&=(tvec1<U, P> const & v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.x);
		this->z &= static_cast<T>(v.x);
		this->w &= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator&=(tvec4<U, P> const & v)
	{
		this->x &= static_cast<T>(v.x);
		this->y &= static_cast<T>(v.y);
		this->z &= static_cast<T>(v.z);
		this->w &= static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator|=(U scalar)
	{
		this->x |= static_cast<T>(scalar);
		this->y |= static_cast<T>(scalar);
		this->z |= static_cast<T>(scalar);
		this->w |= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator|=(tvec1<U, P> const & v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.x);
		this->z |= static_cast<T>(v.x);
		this->w |= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator|=(tvec4<U, P> const & v)
	{
		this->x |= static_cast<T>(v.x);
		this->y |= static_cast<T>(v.y);
		this->z |= static_cast<T>(v.z);
		this->w |= static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator^=(U scalar)
	{
		this->x ^= static_cast<T>(scalar);
		this->y ^= static_cast<T>(scalar);
		this->z ^= static_cast<T>(scalar);
		this->w ^= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator^=(tvec1<U, P> const & v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.x);
		this->z ^= static_cast<T>(v.x);
		this->w ^= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator^=(tvec4<U, P> const & v)
	{
		this->x ^= static_cast<T>(v.x);
		this->y ^= static_cast<T>(v.y);
		this->z ^= static_cast<T>(v.z);
		this->w ^= static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator<<=(U scalar)
	{
		this->x <<= static_cast<T>(scalar);
		this->y <<= static_cast<T>(scalar);
		this->z <<= static_cast<T>(scalar);
		this->w <<= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator<<=(tvec1<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.x);
		this->z <<= static_cast<T>(v.x);
		this->w <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator<<=(tvec4<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		this->y <<= static_cast<T>(v.y);
		this->z <<= static_cast<T>(v.z);
		this->w <<= static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator>>=(U scalar)
	{
		this->x >>= static_cast<T>(scalar);
		this->y >>= static_cast<T>(scalar);
		this->z >>= static_cast<T>(scalar);
		this->w >>= static_cast<T>(scalar);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator>>=(tvec1<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		this->z >>= static_cast<T>(v.z);
		this->w >>= static_cast<T>(v.w);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec4<T, P> & tvec4<T, P>::operator>>=(tvec4<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		this->y >>= static_cast<T>(v.y);
		this->z >>= static_cast<T>(v.z);
		this->w >>= static_cast<T>(v.w);
		return *this;
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
	}

	template <typename T, precision P>
	 inline bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
	}

	
	

	template <typename T, precision P> 
	 inline tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(
			v.x + scalar,
			v.y + scalar,
			v.z + scalar,
			v.w + scalar);
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			scalar + v.x,
			scalar + v.y,
			scalar + v.z,
			scalar + v.w);
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x + v2.x,
			v1.y + v2.y,
			v1.z + v2.z,
			v1.w + v2.w);
	}

	
	template <typename T, precision P> 
	 inline tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(
			v.x - scalar,
			v.y - scalar,
			v.z - scalar,
			v.w - scalar);
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			scalar - v.x,
			scalar - v.y,
			scalar - v.z,
			scalar - v.w);
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x - v2.x,
			v1.y - v2.y,
			v1.z - v2.z,
			v1.w - v2.w);
	}

	
	template <typename T, precision P> 
	 inline tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(
			v.x * scalar,
			v.y * scalar,
			v.z * scalar,
			v.w * scalar);
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			scalar * v.x,
			scalar * v.y,
			scalar * v.z,
			scalar * v.w);
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x * v2.x,
			v1.y * v2.y,
			v1.z * v2.z,
			v1.w * v2.w);
	}

	
	template <typename T, precision P> 
	 inline tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(
			v.x / scalar,
			v.y / scalar,
			v.z / scalar,
			v.w / scalar);
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			scalar / v.x,
			scalar / v.y,
			scalar / v.z,
			scalar / v.w);
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x / v2.x,
			v1.y / v2.y,
			v1.z / v2.z,
			v1.w / v2.w);
	}

	
	template <typename T, precision P> 
	 inline tvec4<T, P> operator-(tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			-v.x, 
			-v.y, 
			-v.z, 
			-v.w);
	}

	
	

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(tvec4<T, P> const & v, T s)
	{
		return tvec4<T, P>(
			v.x % s,
			v.y % s,
			v.z % s,
			v.w % s);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec4<T, P>(
			v.x % s.x,
			v.y % s.x,
			v.z % s.x,
			v.w % s.x);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(T s, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			s % v.x,
			s % v.y,
			s % v.z,
			s % v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(tvec1<T, P> const & s, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			s.x % v.x,
			s.x % v.y,
			s.x % v.z,
			s.x % v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x % v2.x,
			v1.y % v2.y,
			v1.z % v2.z,
			v1.w % v2.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(tvec4<T, P> const & v, T s)
	{
		return tvec4<T, P>(
			v.x & s,
			v.y & s,
			v.z & s,
			v.w & s);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec4<T, P>(
			v.x & s.x,
			v.y & s.x,
			v.z & s.x,
			v.w & s.x);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(T s, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			s & v.x,
			s & v.y,
			s & v.z,
			s & v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(tvec1<T, P> const & s, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			s.x & v.x,
			s.x & v.y,
			s.x & v.z,
			s.x & v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x & v2.x,
			v1.y & v2.y,
			v1.z & v2.z,
			v1.w & v2.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(tvec4<T, P> const & v, T s)
	{
		return tvec4<T, P>(
			v.x | s,
			v.y | s,
			v.z | s,
			v.w | s);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec4<T, P>(
			v.x | s.x,
			v.y | s.x,
			v.z | s.x,
			v.w | s.x);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(T s, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			s | v.x,
			s | v.y,
			s | v.z,
			s | v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(tvec1<T, P> const & s, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			s.x | v.x,
			s.x | v.y,
			s.x | v.z,
			s.x | v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x | v2.x,
			v1.y | v2.y,
			v1.z | v2.z,
			v1.w | v2.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(tvec4<T, P> const & v, T s)
	{
		return tvec4<T, P>(
			v.x ^ s,
			v.y ^ s,
			v.z ^ s,
			v.w ^ s);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec4<T, P>(
			v.x ^ s.x,
			v.y ^ s.x,
			v.z ^ s.x,
			v.w ^ s.x);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			scalar ^ v.x,
			scalar ^ v.y,
			scalar ^ v.z,
			scalar ^ v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(tvec1<T, P> const & s, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			s.x ^ v.x,
			s.x ^ v.y,
			s.x ^ v.z,
			s.x ^ v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x ^ v2.x,
			v1.y ^ v2.y,
			v1.z ^ v2.z,
			v1.w ^ v2.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(
			v.x << scalar,
			v.y << scalar,
			v.z << scalar,
			v.w << scalar);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec4<T, P>(
			v.x << s.x,
			v.y << s.x,
			v.z << s.x,
			v.w << s.x);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			scalar << v.x,
			scalar << v.y,
			scalar << v.z,
			scalar << v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(tvec1<T, P> const & s, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			s.x << v.x,
			s.x << v.y,
			s.x << v.z,
			s.x << v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x << v2.x,
			v1.y << v2.y,
			v1.z << v2.z,
			v1.w << v2.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar)
	{
		return tvec4<T, P>(
			v.x >> scalar,
			v.y >> scalar,
			v.z >> scalar,
			v.w >> scalar);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & s)
	{
		return tvec4<T, P>(
			v.x >> s.x,
			v.y >> s.x,
			v.z >> s.x,
			v.w >> s.x);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			scalar >> v.x,
			scalar >> v.y,
			scalar >> v.z,
			scalar >> v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(tvec1<T, P> const & s, tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			s.x >> v.x,
			s.x >> v.y,
			s.x >> v.z,
			s.x >> v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
	{
		return tvec4<T, P>(
			v1.x >> v2.x,
			v1.y >> v2.y,
			v1.z >> v2.z,
			v1.w >> v2.w);
	}

	template <typename T, precision P> 
	 inline tvec4<T, P> operator~(tvec4<T, P> const & v)
	{
		return tvec4<T, P>(
			~v.x,
			~v.y,
			~v.z,
			~v.w);
	}
}



#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4_sse2.inl"
































namespace glm{
namespace detail
{

}

	template <>
	 inline tvec4<float, lowp>::tvec4()

			: data(_mm_setzero_ps())
#line 44 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4_sse2.inl"
	{}
	
	template <>
	 inline tvec4<float, mediump>::tvec4()

			: data(_mm_setzero_ps())
#line 51 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4_sse2.inl"
	{}

	template <>
	 inline tvec4<float, lowp>::tvec4(float s) :
		data(_mm_set_ps1(s))
	{}
	
	template <>
	 inline tvec4<float, mediump>::tvec4(float s) :
		data(_mm_set_ps1(s))
	{}

	template <>
	 inline tvec4<float, lowp>::tvec4(float a, float b, float c, float d) :
		data(_mm_set_ps(d, c, b, a))
	{}
	
	template <>
	 inline tvec4<float, mediump>::tvec4(float a, float b, float c, float d) :
		data(_mm_set_ps(d, c, b, a))
	{}

	template <>
	template <typename U>
	 inline tvec4<float, lowp> & tvec4<float, lowp>::operator+=(U scalar)
	{
		this->data = _mm_add_ps(this->data, _mm_set_ps1(static_cast<float>(scalar)));
		return *this;
	}

	template <>
	template <>
	 inline tvec4<float, lowp> & tvec4<float, lowp>::operator+=<float>(float scalar)
	{
		this->data = _mm_add_ps(this->data, _mm_set_ps1(scalar));
		return *this;
	}

	template <>
	template <typename U>
	 inline tvec4<float, mediump> & tvec4<float, mediump>::operator+=(U scalar)
	{
		this->data = _mm_add_ps(this->data, _mm_set_ps1(static_cast<float>(scalar)));
		return *this;
	}

	template <>
	template <>
	 inline tvec4<float, mediump> & tvec4<float, mediump>::operator+=<float>(float scalar)
	{
		this->data = _mm_add_ps(this->data, _mm_set_ps1(scalar));
		return *this;
	}

	template <>
	template <typename U>
	 inline tvec4<float, lowp> & tvec4<float, lowp>::operator+=(tvec1<U, lowp> const & v)
	{
		this->data = _mm_add_ps(this->data, _mm_set_ps1(static_cast<float>(v.x)));
		return *this;
	}

	template <>
	template <typename U>
	 inline tvec4<float, mediump> & tvec4<float, mediump>::operator+=(tvec1<U, mediump> const & v)
	{
		this->data = _mm_add_ps(this->data, _mm_set_ps1(static_cast<float>(v.x)));
		return *this;
	}
}
#line 1117 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl"
#line 1118 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl"


#line 1121 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl"


#line 1124 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl"
#line 1125 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.inl"

#line 531 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"
#line 532 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec4.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\vec4.hpp"
#line 12 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat4x4.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
































#pragma once


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_float.hpp"
































#pragma once



namespace glm{
namespace detail
{
	typedef float				float32;
	typedef double				float64;
}
	
	typedef float				lowp_float_t;
	typedef float				mediump_float_t;
	typedef double				highp_float_t;

	
	

	
	
	
	
	
	typedef lowp_float_t		lowp_float;

	
	
	
	
	
	typedef mediump_float_t		mediump_float;

	
	
	
	
	
	typedef highp_float_t		highp_float;


	typedef mediump_float		float_t;








#line 83 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_float.hpp"

	typedef float				float32;
	typedef double				float64;




	static_assert(sizeof(glm::float32) == 4, "float32 size isn't 4 bytes on this platform");
	static_assert(sizeof(glm::float64) == 8, "float64 size isn't 8 bytes on this platform");
#line 93 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_float.hpp"

	

}
#line 37 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat.hpp"
































#pragma once



namespace glm{
namespace detail
{
	template <typename T, precision P, template <class, precision> class colType, template <class, precision> class rowType>
	struct outerProduct_trait{};
}

	template <typename T, precision P> struct tvec2;
	template <typename T, precision P> struct tvec3;
	template <typename T, precision P> struct tvec4;
	template <typename T, precision P> struct tmat2x2;
	template <typename T, precision P> struct tmat2x3;
	template <typename T, precision P> struct tmat2x4;
	template <typename T, precision P> struct tmat3x2;
	template <typename T, precision P> struct tmat3x3;
	template <typename T, precision P> struct tmat3x4;
	template <typename T, precision P> struct tmat4x2;
	template <typename T, precision P> struct tmat4x3;
	template <typename T, precision P> struct tmat4x4;

	
	
	
	
	
	
	
	
	typedef tmat2x2<float, lowp>		lowp_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, mediump>		mediump_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, highp>		highp_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, lowp>		lowp_mat2x2;
	
	
	
	
	
	
	typedef tmat2x2<float, mediump>		mediump_mat2x2;
	
	
	
	
	
	
	typedef tmat2x2<float, highp>		highp_mat2x2;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x3<float, lowp>		lowp_mat2x3;
	
	
	
	
	
	
	typedef tmat2x3<float, mediump>		mediump_mat2x3;
	
	
	
	
	
	
	typedef tmat2x3<float, highp>		highp_mat2x3;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x4<float, lowp>		lowp_mat2x4;
	
	
	
	
	
	
	typedef tmat2x4<float, mediump>		mediump_mat2x4;
	
	
	
	
	
	
	typedef tmat2x4<float, highp>		highp_mat2x4;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x2<float, lowp>		lowp_mat3x2;
	
	
	
	
	
	
	typedef tmat3x2<float, mediump>		mediump_mat3x2;
	
	
	
	
	
	
	typedef tmat3x2<float, highp>		highp_mat3x2;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, mediump>		mediump_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, highp>		highp_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_mat3x3;
	
	
	
	
	
	
	typedef tmat3x3<float, mediump>		mediump_mat3x3;
	
	
	
	
	
	
	typedef tmat3x3<float, highp>		highp_mat3x3;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x4<float, lowp>		lowp_mat3x4;
	
	
	
	
	
	
	typedef tmat3x4<float, mediump>		mediump_mat3x4;
	
	
	
	
	
	
	typedef tmat3x4<float, highp>		highp_mat3x4;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x2<float, lowp>		lowp_mat4x2;
	
	
	
	
	
	
	typedef tmat4x2<float, mediump>		mediump_mat4x2;
	
	
	
	
	
	
	typedef tmat4x2<float, highp>		highp_mat4x2;
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x3<float, lowp>		lowp_mat4x3;
	
	
	
	
	
	
	typedef tmat4x3<float, mediump>		mediump_mat4x3;
	
	
	
	
	
	
	typedef tmat4x3<float, highp>		highp_mat4x3;
	
	
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x4<float, lowp>		lowp_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, mediump>		mediump_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, highp>		highp_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, lowp>		lowp_mat4x4;
	
	
	
	
	
	
	typedef tmat4x4<float, mediump>		mediump_mat4x4;
	
	
	
	
	
	
	typedef tmat4x4<float, highp>		highp_mat4x4;
	
	
	
	
	
	
	
	
	










#line 372 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat.hpp"









#line 382 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat.hpp"
	
	
	
	typedef highp_mat2x2			mat2x2;
	
	
	
	
	typedef highp_mat2x3			mat2x3;
	
	
	
	
	typedef highp_mat2x4			mat2x4;
	
	
	
	
	typedef highp_mat3x2			mat3x2;
	
	
	
	
	typedef highp_mat3x3			mat3x3;
	
	
	
	
	typedef highp_mat3x4			mat3x4;
	
	
	
	
	typedef highp_mat4x2			mat4x2;
	
	
	
	
	typedef highp_mat4x3			mat4x3;
	
	
	
	
	typedef highp_mat4x4			mat4x4;
	
#line 428 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat.hpp"
	
	
	
	
	typedef mat2x2					mat2;
	
	
	
	
	typedef mat3x3					mat3;
	
	
	
	
	typedef mat4x4					mat4;
		
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x2<double, lowp>		lowp_dmat2;
	
	
	
	
	
	typedef tmat2x2<double, mediump>	mediump_dmat2;
	
	
	
	
	
	typedef tmat2x2<double, highp>		highp_dmat2;
	
	
	
	
	
	typedef tmat2x2<double, lowp>		lowp_dmat2x2;
	
	
	
	
	
	typedef tmat2x2<double, mediump>	mediump_dmat2x2;
	
	
	
	
	
	typedef tmat2x2<double, highp>		highp_dmat2x2;
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x3<double, lowp>		lowp_dmat2x3;
	
	
	
	
	
	typedef tmat2x3<double, mediump>	mediump_dmat2x3;
	
	
	
	
	
	typedef tmat2x3<double, highp>		highp_dmat2x3;
	
	
	
	
	
	
	
	
	
	
	typedef tmat2x4<double, lowp>		lowp_dmat2x4;
	
	
	
	
	
	typedef tmat2x4<double, mediump>	mediump_dmat2x4;
	
	
	
	
	
	typedef tmat2x4<double, highp>		highp_dmat2x4;
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x2<double, lowp>		lowp_dmat3x2;
	
	
	
	
	
	typedef tmat3x2<double, mediump>	mediump_dmat3x2;
	
	
	
	
	
	typedef tmat3x2<double, highp>		highp_dmat3x2;
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_dmat3;
	
	
	
	
	
	typedef tmat3x3<double, mediump>	mediump_dmat3;
	
	
	
	
	
	typedef tmat3x3<double, highp>		highp_dmat3;
	
	
	
	
	
	typedef tmat3x3<double, lowp>		lowp_dmat3x3;
	
	
	
	
	
	typedef tmat3x3<double, mediump>	mediump_dmat3x3;
	
	
	
	
	
	typedef tmat3x3<double, highp>		highp_dmat3x3;
	
	
	
	
	
	
	
	
	
	
	typedef tmat3x4<double, lowp>		lowp_dmat3x4;
	
	
	
	
	
	typedef tmat3x4<double, mediump>	mediump_dmat3x4;
	
	
	
	
	
	typedef tmat3x4<double, highp>		highp_dmat3x4;
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x2<double, lowp>		lowp_dmat4x2;
	
	
	
	
	
	typedef tmat4x2<double, mediump>	mediump_dmat4x2;
	
	
	
	
	
	typedef tmat4x2<double, highp>		highp_dmat4x2;
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x3<double, lowp>		lowp_dmat4x3;
	
	
	
	
	
	typedef tmat4x3<double, mediump>	mediump_dmat4x3;
	
	
	
	
	
	typedef tmat4x3<double, highp>		highp_dmat4x3;
	
	
	
	
	
	
	
	
	
	
	typedef tmat4x4<double, lowp>		lowp_dmat4;
	
	
	
	
	
	typedef tmat4x4<double, mediump>	mediump_dmat4;
	
	
	
	
	
	typedef tmat4x4<double, highp>		highp_dmat4;
	
	
	
	
	
	typedef tmat4x4<double, lowp>		lowp_dmat4x4;
	
	
	
	
	
	typedef tmat4x4<double, mediump>	mediump_dmat4x4;
	
	
	
	
	
	typedef tmat4x4<double, highp>		highp_dmat4x4;
	
	
	










#line 719 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat.hpp"









#line 729 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat.hpp"
	
	
	
	
	typedef highp_dmat2x2		dmat2;
	
	
	
	
	typedef highp_dmat3x3		dmat3;
	
	
	
	
	typedef highp_dmat4x4		dmat4;
	
	
	
	
	typedef highp_dmat2x2		dmat2x2;
	
	
	
	
	typedef highp_dmat2x3		dmat2x3;
	
	
	
	
	typedef highp_dmat2x4		dmat2x4;
	
	
	
	
	typedef highp_dmat3x2		dmat3x2;
	
	
	
	
	typedef highp_dmat3x3		dmat3x3;
	
	
	
	
	typedef highp_dmat3x4		dmat3x4;
	
	
	
	
	typedef highp_dmat4x2		dmat4x2;
	
	
	
	
	typedef highp_dmat4x3		dmat4x3;
	
	
	
	
	typedef highp_dmat4x4		dmat4x4;

#line 791 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat.hpp"
	
	
}

#line 39 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"



namespace glm
{
	template <typename T, precision P> struct tquat;

	
	
	
	typedef tquat<float, lowp>		lowp_quat;

	
	
	
	typedef tquat<float, mediump>	mediump_quat;

	
	
	
	typedef tquat<float, highp>		highp_quat;



#line 64 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

#line 66 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

#line 68 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	typedef highp_quat			quat;
#line 71 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

	
	
	
	typedef lowp_quat			lowp_fquat;

	
	
	
	typedef mediump_quat		mediump_fquat;

	
	
	
	typedef highp_quat			highp_fquat;

	
	
	
	typedef quat				fquat;


	
	
	
	typedef tquat<double, lowp>		lowp_dquat;
	
	
	
	
	typedef tquat<double, mediump>	mediump_dquat;
	
	
	
	
	typedef tquat<double, highp>	highp_dquat;
	


#line 111 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

#line 113 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

#line 115 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	
	typedef highp_dquat			dquat;
#line 120 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

}



namespace glm
{
	
	

	
	
	typedef detail::int8 lowp_int8;
	
	
	
	typedef detail::int16 lowp_int16;

	
	
	typedef detail::int32 lowp_int32;

	
	
	typedef detail::int64 lowp_int64;

	
	
	typedef detail::int8 lowp_int8_t;
	
	
	
	typedef detail::int16 lowp_int16_t;

	
	
	typedef detail::int32 lowp_int32_t;

	
	
	typedef detail::int64 lowp_int64_t;

	
	
	typedef detail::int8 lowp_i8;
	
	
	
	typedef detail::int16 lowp_i16;

	
	
	typedef detail::int32 lowp_i32;

	
	
	typedef detail::int64 lowp_i64;

	
	
	typedef detail::int8 mediump_int8;
	
	
	
	typedef detail::int16 mediump_int16;

	
	
	typedef detail::int32 mediump_int32;

	
	
	typedef detail::int64 mediump_int64;

	
	
	typedef detail::int8 mediump_int8_t;
	
	
	
	typedef detail::int16 mediump_int16_t;

	
	
	typedef detail::int32 mediump_int32_t;

	
	
	typedef detail::int64 mediump_int64_t;

	
	
	typedef detail::int8 mediump_i8;
	
	
	
	typedef detail::int16 mediump_i16;

	
	
	typedef detail::int32 mediump_i32;

	
	
	typedef detail::int64 mediump_i64;

	
	
	typedef detail::int8 highp_int8;
	
	
	
	typedef detail::int16 highp_int16;

	
	
	typedef detail::int32 highp_int32;

	
	
	typedef detail::int64 highp_int64;

	
	
	typedef detail::int8 highp_int8_t;
	
	
	
	typedef detail::int16 highp_int16_t;

	
	
	typedef detail::int32 highp_int32_t;

	
	
	typedef detail::int64 highp_int64_t;

	
	
	typedef detail::int8 highp_i8;
	
	
	
	typedef detail::int16 highp_i16;

	
	
	typedef detail::int32 highp_i32;

	
	
	typedef detail::int64 highp_i64;
	

	
	
	typedef detail::int8 int8;
	
	
	
	typedef detail::int16 int16;

	
	
	typedef detail::int32 int32;

	
	
	typedef detail::int64 int64;



	using std::int8_t;
	using std::int16_t;
	using std::int32_t;
	using std::int64_t;
















#line 314 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

	
	
	typedef detail::int8 i8;
	
	
	
	typedef detail::int16 i16;

	
	
	typedef detail::int32 i32;

	
	
	typedef detail::int64 i64;
	
	
	
	
	
	typedef tvec1<i8, lowp> lowp_i8vec1;
	
	
	
	typedef tvec2<i8, lowp> lowp_i8vec2;
	
	
	
	typedef tvec3<i8, lowp> lowp_i8vec3;
	
	
	
	typedef tvec4<i8, lowp> lowp_i8vec4;
	

	
	
	typedef tvec1<i8, mediump> mediump_i8vec1;
	
	
	
	typedef tvec2<i8, mediump> mediump_i8vec2;
	
	
	
	typedef tvec3<i8, mediump> mediump_i8vec3;
	
	
	
	typedef tvec4<i8, mediump> mediump_i8vec4;
	
	
	
	
	typedef tvec1<i8, highp> highp_i8vec1;
	
	
	
	typedef tvec2<i8, highp> highp_i8vec2;
	
	
	
	typedef tvec3<i8, highp> highp_i8vec3;
	
	
	
	typedef tvec4<i8, highp> highp_i8vec4;
	





#line 389 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 394 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_i8vec1			i8vec1;
	
	
	
	typedef highp_i8vec2			i8vec2;
	
	
	
	typedef highp_i8vec3			i8vec3;
	
	
	
	typedef highp_i8vec4			i8vec4;
#line 410 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	
	
	typedef tvec1<i16, lowp>		lowp_i16vec1;
	
	
	
	typedef tvec2<i16, lowp>		lowp_i16vec2;
	
	
	
	typedef tvec3<i16, lowp>		lowp_i16vec3;
	
	
	
	typedef tvec4<i16, lowp>		lowp_i16vec4;
	
	
	
	
	typedef tvec1<i16, mediump>		mediump_i16vec1;
	
	
	
	typedef tvec2<i16, mediump>		mediump_i16vec2;
	
	
	
	typedef tvec3<i16, mediump>		mediump_i16vec3;
	
	
	
	typedef tvec4<i16, mediump>		mediump_i16vec4;
	
	
	
	
	typedef tvec1<i16, highp>		highp_i16vec1;
	
	
	
	typedef tvec2<i16, highp>		highp_i16vec2;
	
	
	
	typedef tvec3<i16, highp>		highp_i16vec3;
	
	
	
	typedef tvec4<i16, highp>		highp_i16vec4;
	
	





#line 469 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 474 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_i16vec1			i16vec1;
	
	
	
	typedef highp_i16vec2			i16vec2;
	
	
	
	typedef highp_i16vec3			i16vec3;
	
	
	
	typedef highp_i16vec4			i16vec4;
#line 490 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"


	
	
	typedef tvec1<i32, lowp>		lowp_i32vec1;
	
	
	
	typedef tvec2<i32, lowp>		lowp_i32vec2;
	
	
	
	typedef tvec3<i32, lowp>		lowp_i32vec3;
	
	
	
	typedef tvec4<i32, lowp>		lowp_i32vec4;
	
	
	
	
	typedef tvec1<i32, mediump>		mediump_i32vec1;
	
	
	
	typedef tvec2<i32, mediump>		mediump_i32vec2;
	
	
	
	typedef tvec3<i32, mediump>		mediump_i32vec3;
	
	
	
	typedef tvec4<i32, mediump>		mediump_i32vec4;
	
	
	
	
	typedef tvec1<i32, highp>		highp_i32vec1;
	
	
	
	typedef tvec2<i32, highp>		highp_i32vec2;
	
	
	
	typedef tvec3<i32, highp>		highp_i32vec3;
	
	
	
	typedef tvec4<i32, highp>		highp_i32vec4;
	





#line 548 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 553 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_i32vec1			i32vec1;
	
	
	
	typedef highp_i32vec2			i32vec2;
	
	
	
	typedef highp_i32vec3			i32vec3;
	
	
	
	typedef highp_i32vec4			i32vec4;
#line 569 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"


	
	
	typedef tvec1<i32, lowp>		lowp_i32vec1;
	
	
	
	typedef tvec2<i32, lowp>		lowp_i32vec2;
	
	
	
	typedef tvec3<i32, lowp>		lowp_i32vec3;
	
	
	
	typedef tvec4<i32, lowp>		lowp_i32vec4;
	
	
	
	
	typedef tvec1<i32, mediump>		mediump_i32vec1;
	
	
	
	typedef tvec2<i32, mediump>		mediump_i32vec2;
	
	
	
	typedef tvec3<i32, mediump>		mediump_i32vec3;
	
	
	
	typedef tvec4<i32, mediump>		mediump_i32vec4;
	
	
	
	
	typedef tvec1<i32, highp>		highp_i32vec1;
	
	
	
	typedef tvec2<i32, highp>		highp_i32vec2;
	
	
	
	typedef tvec3<i32, highp>		highp_i32vec3;
	
	
	
	typedef tvec4<i32, highp>		highp_i32vec4;
	





#line 627 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 632 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_i32vec1			i32vec1;

	
	
	typedef highp_i32vec2			i32vec2;
	
	
	
	typedef highp_i32vec3			i32vec3;
	
	
	
	typedef highp_i32vec4			i32vec4;
#line 648 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"


	
	
	
	typedef tvec1<i64, lowp>		lowp_i64vec1;
	
	
	
	typedef tvec2<i64, lowp>		lowp_i64vec2;
	
	
	
	typedef tvec3<i64, lowp>		lowp_i64vec3;
	
	
	
	typedef tvec4<i64, lowp>		lowp_i64vec4;
	
	
	
	
	typedef tvec1<i64, mediump>		mediump_i64vec1;
	
	
	
	typedef tvec2<i64, mediump>		mediump_i64vec2;
	
	
	
	typedef tvec3<i64, mediump>		mediump_i64vec3;
	
	
	
	typedef tvec4<i64, mediump>		mediump_i64vec4;
	
	
	
	
	typedef tvec1<i64, highp>		highp_i64vec1;
	
	
	
	typedef tvec2<i64, highp>		highp_i64vec2;
	
	
	
	typedef tvec3<i64, highp>		highp_i64vec3;
	
	
	
	typedef tvec4<i64, highp>		highp_i64vec4;
	





#line 707 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 712 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_i64vec1			i64vec1;

	
	
	typedef highp_i64vec2			i64vec2;
	
	
	
	typedef highp_i64vec3			i64vec3;
	
	
	
	typedef highp_i64vec4			i64vec4;
#line 728 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	
	
	
	
	
	typedef detail::uint8 lowp_uint8;
	
	
	
	typedef detail::uint16 lowp_uint16;
	
	
	
	typedef detail::uint32 lowp_uint32;
	
	
	
	typedef detail::uint64 lowp_uint64;
	
	
	
	
	typedef detail::uint8 lowp_uint8_t;
	
	
	
	typedef detail::uint16 lowp_uint16_t;
	
	
	
	typedef detail::uint32 lowp_uint32_t;
	
	
	
	typedef detail::uint64 lowp_uint64_t;
	
	
	
	
	typedef detail::uint8 lowp_u8;
	
	
	
	typedef detail::uint16 lowp_u16;
	
	
	
	typedef detail::uint32 lowp_u32;
	
	
	
	typedef detail::uint64 lowp_u64;
	
	
	
	
	
	typedef detail::uint8 mediump_uint8;
	
	
	
	typedef detail::uint16 mediump_uint16;
	
	
	
	typedef detail::uint32 mediump_uint32;
	
	
	
	typedef detail::uint64 mediump_uint64;
	
	
	
	typedef detail::uint8 mediump_uint8_t;
	
	
	
	typedef detail::uint16 mediump_uint16_t;
	
	
	
	typedef detail::uint32 mediump_uint32_t;
	
	
	
	typedef detail::uint64 mediump_uint64_t;
	
	
	
	typedef detail::uint8 mediump_u8;
	
	
	
	typedef detail::uint16 mediump_u16;
	
	
	
	typedef detail::uint32 mediump_u32;
	
	
	
	typedef detail::uint64 mediump_u64;
		
	
	
	
	
	typedef detail::uint8 highp_uint8;
	
	
	
	typedef detail::uint16 highp_uint16;
	
	
	
	typedef detail::uint32 highp_uint32;
	
	
	
	typedef detail::uint64 highp_uint64;
	
	
	
	typedef detail::uint8 highp_uint8_t;
	
	
	
	typedef detail::uint16 highp_uint16_t;
	
	
	
	typedef detail::uint32 highp_uint32_t;
	
	
	
	typedef detail::uint64 highp_uint64_t;
	
	
	
	typedef detail::uint8 highp_u8;
	
	
	
	typedef detail::uint16 highp_u16;
	
	
	
	typedef detail::uint32 highp_u32;
	
	
	
	typedef detail::uint64 highp_u64;
	
	
	
	
	
	typedef detail::uint8 uint8;
	
	
	
	typedef detail::uint16 uint16;
	
	
	
	typedef detail::uint32 uint32;
	
	
	
	typedef detail::uint64 uint64;
	

	using std::uint8_t;
	using std::uint16_t;
	using std::uint32_t;
	using std::uint64_t;
















#line 923 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

	
	
	typedef detail::uint8 u8;

	
	
	typedef detail::uint16 u16;

	
	
	typedef detail::uint32 u32;

	
	
	typedef detail::uint64 u64;



	
	
	typedef tvec1<u8, lowp> lowp_u8vec1;
	
	
	
	typedef tvec2<u8, lowp> lowp_u8vec2;
	
	
	
	typedef tvec3<u8, lowp> lowp_u8vec3;
	
	
	
	typedef tvec4<u8, lowp> lowp_u8vec4;
	

	
	
	typedef tvec1<u8, mediump> mediump_u8vec1;

	
	
	typedef tvec2<u8, mediump> mediump_u8vec2;

	
	
	typedef tvec3<u8, mediump> mediump_u8vec3;

	
	
	typedef tvec4<u8, mediump> mediump_u8vec4;


	
	
	typedef tvec1<u8, highp> highp_u8vec1;

	
	
	typedef tvec2<u8, highp> highp_u8vec2;

	
	
	typedef tvec3<u8, highp> highp_u8vec3;

	
	
	typedef tvec4<u8, highp> highp_u8vec4;






#line 998 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 1003 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_u8vec1			u8vec1;

	
	
	typedef highp_u8vec2			u8vec2;

	
	
	typedef highp_u8vec3			u8vec3;

	
	
	typedef highp_u8vec4			u8vec4;
#line 1019 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"


	
	
	typedef tvec1<u16, lowp>		lowp_u16vec1;

	
	
	typedef tvec2<u16, lowp>		lowp_u16vec2;

	
	
	typedef tvec3<u16, lowp>		lowp_u16vec3;

	
	
	typedef tvec4<u16, lowp>		lowp_u16vec4;


	
	
	typedef tvec1<u16, mediump>		mediump_u16vec1;

	
	
	typedef tvec2<u16, mediump>		mediump_u16vec2;

	
	
	typedef tvec3<u16, mediump>		mediump_u16vec3;

	
	
	typedef tvec4<u16, mediump>		mediump_u16vec4;


	
	
	typedef tvec1<u16, highp>		highp_u16vec1;

	
	
	typedef tvec2<u16, highp>		highp_u16vec2;

	
	
	typedef tvec3<u16, highp>		highp_u16vec3;

	
	
	typedef tvec4<u16, highp>		highp_u16vec4;







#line 1078 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 1083 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_u16vec1			u16vec1;

	
	
	typedef highp_u16vec2			u16vec2;

	
	
	typedef highp_u16vec3			u16vec3;

	
	
	typedef highp_u16vec4			u16vec4;
#line 1099 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"


	
	
	typedef tvec1<u32, lowp>		lowp_u32vec1;

	
	
	typedef tvec2<u32, lowp>		lowp_u32vec2;

	
	
	typedef tvec3<u32, lowp>		lowp_u32vec3;

	
	
	typedef tvec4<u32, lowp>		lowp_u32vec4;


	
	
	typedef tvec1<u32, mediump>		mediump_u32vec1;

	
	
	typedef tvec2<u32, mediump>		mediump_u32vec2;

	
	
	typedef tvec3<u32, mediump>		mediump_u32vec3;

	
	
	typedef tvec4<u32, mediump>		mediump_u32vec4;


	
	
	typedef tvec1<u32, highp>		highp_u32vec1;

	
	
	typedef tvec2<u32, highp>		highp_u32vec2;

	
	
	typedef tvec3<u32, highp>		highp_u32vec3;

	
	
	typedef tvec4<u32, highp>		highp_u32vec4;






#line 1157 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 1162 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_u32vec1			u32vec1;

	
	
	typedef highp_u32vec2			u32vec2;

	
	
	typedef highp_u32vec3			u32vec3;

	
	
	typedef highp_u32vec4			u32vec4;
#line 1178 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"


	
	
	typedef tvec1<u32, lowp>		lowp_u32vec1;

	
	
	typedef tvec2<u32, lowp>		lowp_u32vec2;

	
	
	typedef tvec3<u32, lowp>		lowp_u32vec3;

	
	
	typedef tvec4<u32, lowp>		lowp_u32vec4;


	
	
	typedef tvec1<u32, mediump>		mediump_u32vec1;

	
	
	typedef tvec2<u32, mediump>		mediump_u32vec2;

	
	
	typedef tvec3<u32, mediump>		mediump_u32vec3;

	
	
	typedef tvec4<u32, mediump>		mediump_u32vec4;


	
	
	typedef tvec1<u32, highp>		highp_u32vec1;

	
	
	typedef tvec2<u32, highp>		highp_u32vec2;

	
	
	typedef tvec3<u32, highp>		highp_u32vec3;

	
	
	typedef tvec4<u32, highp>		highp_u32vec4;






#line 1236 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 1241 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_u32vec1			u32vec1;

	
	
	typedef highp_u32vec2			u32vec2;
	
	
	
	typedef highp_u32vec3			u32vec3;
	
	
	
	typedef highp_u32vec4			u32vec4;
#line 1257 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"


	
	
	
	typedef tvec1<u64, lowp>		lowp_u64vec1;

	
	
	typedef tvec2<u64, lowp>		lowp_u64vec2;

	
	
	typedef tvec3<u64, lowp>		lowp_u64vec3;

	
	
	typedef tvec4<u64, lowp>		lowp_u64vec4;


	
	
	typedef tvec1<u64, mediump>		mediump_u64vec1;

	
	
	typedef tvec2<u64, mediump>		mediump_u64vec2;

	
	
	typedef tvec3<u64, mediump>		mediump_u64vec3;

	
	
	typedef tvec4<u64, mediump>		mediump_u64vec4;


	
	
	typedef tvec1<u64, highp>		highp_u64vec1;

	
	
	typedef tvec2<u64, highp>		highp_u64vec2;

	
	
	typedef tvec3<u64, highp>		highp_u64vec3;

	
	
	typedef tvec4<u64, highp>		highp_u64vec4;






#line 1316 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"




#line 1321 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_u64vec1			u64vec1;

	
	
	typedef highp_u64vec2			u64vec2;
	
	
	
	typedef highp_u64vec3			u64vec3;
	
	
	
	typedef highp_u64vec4			u64vec4;
#line 1337 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	
	

	
	
	typedef detail::float32 lowp_float32;

	
	
	typedef detail::float64 lowp_float64;

	
	
	typedef detail::float32 lowp_float32_t;

	
	
	typedef detail::float64 lowp_float64_t;

	
	
	typedef float32 lowp_f32;

	
	
	typedef float64 lowp_f64;

	
	
	typedef detail::float32 lowp_float32;

	
	
	typedef detail::float64 lowp_float64;

	
	
	typedef detail::float32 lowp_float32_t;

	
	
	typedef detail::float64 lowp_float64_t;

	
	
	typedef float32 lowp_f32;

	
	
	typedef float64 lowp_f64;


	
	
	typedef detail::float32 lowp_float32;

	
	
	typedef detail::float64 lowp_float64;

	
	
	typedef detail::float32 lowp_float32_t;
	
	
	
	typedef detail::float64 lowp_float64_t;

	
	
	typedef float32 lowp_f32;

	
	
	typedef float64 lowp_f64;


	
	
	typedef detail::float32 mediump_float32;

	
	
	typedef detail::float64 mediump_float64;

	
	
	typedef detail::float32 mediump_float32_t;

	
	
	typedef detail::float64 mediump_float64_t;

	
	
	typedef float32 mediump_f32;

	
	
	typedef float64 mediump_f64;


	
	
	typedef detail::float32 highp_float32;

	
	
	typedef detail::float64 highp_float64;

	
	
	typedef detail::float32 highp_float32_t;

	
	
	typedef detail::float64 highp_float64_t;

	
	
	typedef float32 highp_f32;

	
	
	typedef float64 highp_f64;



























#line 1492 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

























#line 1518 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

	
	
	typedef highp_float32 float32;

	
	
	typedef highp_float64 float64;

	
	
	typedef highp_float32_t float32_t;

	
	
	typedef highp_float64_t float64_t;

	
	
	typedef highp_float32_t f32;

	
	
	typedef highp_float64_t f64;
#line 1543 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"


	
	
	typedef tvec1<float, lowp> lowp_vec1;

	
	
	typedef tvec2<float, lowp> lowp_vec2;

	
	
	typedef tvec3<float, lowp> lowp_vec3;

	
	
	typedef tvec4<float, lowp> lowp_vec4;

	
	
	typedef tvec1<float, lowp> lowp_fvec1;

	
	
	typedef tvec2<float, lowp> lowp_fvec2;

	
	
	typedef tvec3<float, lowp> lowp_fvec3;

	
	
	typedef tvec4<float, lowp> lowp_fvec4;


	
	
	typedef tvec1<float, mediump> mediump_vec1;

	
	
	typedef tvec2<float, mediump> mediump_vec2;

	
	
	typedef tvec3<float, mediump> mediump_vec3;

	
	
	typedef tvec4<float, mediump> mediump_vec4;

	
	
	typedef tvec1<float, mediump> mediump_fvec1;

	
	
	typedef tvec2<float, mediump> mediump_fvec2;

	
	
	typedef tvec3<float, mediump> mediump_fvec3;

	
	
	typedef tvec4<float, mediump> mediump_fvec4;


	
	
	typedef tvec1<float, highp> highp_vec1;

	
	
	typedef tvec2<float, highp> highp_vec2;

	
	
	typedef tvec3<float, highp> highp_vec3;

	
	
	typedef tvec4<float, highp> highp_vec4;

	
	
	typedef tvec1<float, highp> highp_fvec1;

	
	
	typedef tvec2<float, highp> highp_fvec2;

	
	
	typedef tvec3<float, highp> highp_fvec3;

	
	
	typedef tvec4<float, highp> highp_fvec4;


	
	
	typedef tvec1<f32, lowp> lowp_f32vec1;

	
	
	typedef tvec2<f32, lowp> lowp_f32vec2;

	
	
	typedef tvec3<f32, lowp> lowp_f32vec3;

	
	
	typedef tvec4<f32, lowp> lowp_f32vec4;

	
	
	typedef tvec1<f32, mediump> mediump_f32vec1;

	
	
	typedef tvec2<f32, mediump> mediump_f32vec2;

	
	
	typedef tvec3<f32, mediump> mediump_f32vec3;

	
	
	typedef tvec4<f32, mediump> mediump_f32vec4;

	
	
	typedef tvec1<f32, highp> highp_f32vec1;

	
	
	typedef tvec2<f32, highp> highp_f32vec2;

	
	
	typedef tvec3<f32, highp> highp_f32vec3;

	
	
	typedef tvec4<f32, highp> highp_f32vec4;


	
	
	typedef tvec1<f64, lowp> lowp_f64vec1;

	
	
	typedef tvec2<f64, lowp> lowp_f64vec2;

	
	
	typedef tvec3<f64, lowp> lowp_f64vec3;

	
	
	typedef tvec4<f64, lowp> lowp_f64vec4;

	
	
	typedef tvec1<f64, mediump> mediump_f64vec1;

	
	
	typedef tvec2<f64, mediump> mediump_f64vec2;

	
	
	typedef tvec3<f64, mediump> mediump_f64vec3;

	
	
	typedef tvec4<f64, mediump> mediump_f64vec4;

	
	
	typedef tvec1<f64, highp> highp_f64vec1;

	
	
	typedef tvec2<f64, highp> highp_f64vec2;

	
	
	typedef tvec3<f64, highp> highp_f64vec3;

	
	
	typedef tvec4<f64, highp> highp_f64vec4;


	
	

	
	
	

	
	
	typedef tmat2x2<f32, lowp> lowp_fmat2x2;

	
	
	typedef tmat2x3<f32, lowp> lowp_fmat2x3;

	
	
	typedef tmat2x4<f32, lowp> lowp_fmat2x4;

	
	
	typedef tmat3x2<f32, lowp> lowp_fmat3x2;

	
	
	typedef tmat3x3<f32, lowp> lowp_fmat3x3;

	
	
	typedef tmat3x4<f32, lowp> lowp_fmat3x4;

	
	
	typedef tmat4x2<f32, lowp> lowp_fmat4x2;

	
	
	typedef tmat4x3<f32, lowp> lowp_fmat4x3;

	
	
	typedef tmat4x4<f32, lowp> lowp_fmat4x4;

	
	
	

	
	
	typedef lowp_fmat2x2 lowp_fmat2;

	
	
	typedef lowp_fmat3x3 lowp_fmat3;

	
	
	typedef lowp_fmat4x4 lowp_fmat4;


	
	
	

	
	
	typedef tmat2x2<f32, mediump> mediump_fmat2x2;

	
	
	typedef tmat2x3<f32, mediump> mediump_fmat2x3;

	
	
	typedef tmat2x4<f32, mediump> mediump_fmat2x4;

	
	
	typedef tmat3x2<f32, mediump> mediump_fmat3x2;

	
	
	typedef tmat3x3<f32, mediump> mediump_fmat3x3;

	
	
	typedef tmat3x4<f32, mediump> mediump_fmat3x4;

	
	
	typedef tmat4x2<f32, mediump> mediump_fmat4x2;

	
	
	typedef tmat4x3<f32, mediump> mediump_fmat4x3;

	
	
	typedef tmat4x4<f32, mediump> mediump_fmat4x4;

	
	
	

	
	
	typedef mediump_fmat2x2 mediump_fmat2;

	
	
	typedef mediump_fmat3x3 mediump_fmat3;

	
	
	typedef mediump_fmat4x4 mediump_fmat4;


	
	
	

	
	
	typedef tmat2x2<f32, highp> highp_fmat2x2;

	
	
	typedef tmat2x3<f32, highp> highp_fmat2x3;

	
	
	typedef tmat2x4<f32, highp> highp_fmat2x4;

	
	
	typedef tmat3x2<f32, highp> highp_fmat3x2;

	
	
	typedef tmat3x3<f32, highp> highp_fmat3x3;

	
	
	typedef tmat3x4<f32, highp> highp_fmat3x4;

	
	
	typedef tmat4x2<f32, highp> highp_fmat4x2;

	
	
	typedef tmat4x3<f32, highp> highp_fmat4x3;

	
	
	typedef tmat4x4<f32, highp> highp_fmat4x4;

	
	
	

	
	
	typedef highp_fmat2x2 highp_fmat2;

	
	
	typedef highp_fmat3x3 highp_fmat3;
	
	
	
	typedef highp_fmat4x4 highp_fmat4;


	
	
	

	
	
	typedef tmat2x2<f32, lowp> lowp_f32mat2x2;

	
	
	typedef tmat2x3<f32, lowp> lowp_f32mat2x3;

	
	
	typedef tmat2x4<f32, lowp> lowp_f32mat2x4;

	
	
	typedef tmat3x2<f32, lowp> lowp_f32mat3x2;

	
	
	typedef tmat3x3<f32, lowp> lowp_f32mat3x3;

	
	
	typedef tmat3x4<f32, lowp> lowp_f32mat3x4;

	
	
	typedef tmat4x2<f32, lowp> lowp_f32mat4x2;

	
	
	typedef tmat4x3<f32, lowp> lowp_f32mat4x3;

	
	
	typedef tmat4x4<f32, lowp> lowp_f32mat4x4;

	
	
	

	
	
	typedef lowp_f32mat2x2 lowp_f32mat2;

	
	
	typedef lowp_f32mat3x3 lowp_f32mat3;

	
	
	typedef lowp_f32mat4x4 lowp_f32mat4;


	
	
	

	
	
	typedef tmat2x2<f32, mediump> mediump_f32mat2x2;

	
	
	typedef tmat2x3<f32, mediump> mediump_f32mat2x3;

	
	
	typedef tmat2x4<f32, mediump> mediump_f32mat2x4;

	
	
	typedef tmat3x2<f32, mediump> mediump_f32mat3x2;

	
	
	typedef tmat3x3<f32, mediump> mediump_f32mat3x3;

	
	
	typedef tmat3x4<f32, mediump> mediump_f32mat3x4;

	
	
	typedef tmat4x2<f32, mediump> mediump_f32mat4x2;

	
	
	typedef tmat4x3<f32, mediump> mediump_f32mat4x3;

	
	
	typedef tmat4x4<f32, mediump> mediump_f32mat4x4;

	
	
	

	
	
	typedef mediump_f32mat2x2 mediump_f32mat2;

	
	
	typedef mediump_f32mat3x3 mediump_f32mat3;

	
	
	typedef mediump_f32mat4x4 mediump_f32mat4;


	
	
	

	
	
	typedef tmat2x2<f32, highp> highp_f32mat2x2;

	
	
	typedef tmat2x3<f32, highp> highp_f32mat2x3;

	
	
	typedef tmat2x4<f32, highp> highp_f32mat2x4;

	
	
	typedef tmat3x2<f32, highp> highp_f32mat3x2;

	
	
	typedef tmat3x3<f32, highp> highp_f32mat3x3;

	
	
	typedef tmat3x4<f32, highp> highp_f32mat3x4;

	
	
	typedef tmat4x2<f32, highp> highp_f32mat4x2;

	
	
	typedef tmat4x3<f32, highp> highp_f32mat4x3;

	
	
	typedef tmat4x4<f32, highp> highp_f32mat4x4;

	
	
	

	
	
	typedef highp_f32mat2x2 highp_f32mat2;

	
	
	typedef highp_f32mat3x3 highp_f32mat3;

	
	
	typedef highp_f32mat4x4 highp_f32mat4;


	
	
	

	
	
	typedef tmat2x2<f64, lowp> lowp_f64mat2x2;

	
	
	typedef tmat2x3<f64, lowp> lowp_f64mat2x3;

	
	
	typedef tmat2x4<f64, lowp> lowp_f64mat2x4;

	
	
	typedef tmat3x2<f64, lowp> lowp_f64mat3x2;

	
	
	typedef tmat3x3<f64, lowp> lowp_f64mat3x3;

	
	
	typedef tmat3x4<f64, lowp> lowp_f64mat3x4;

	
	
	typedef tmat4x2<f64, lowp> lowp_f64mat4x2;

	
	
	typedef tmat4x3<f64, lowp> lowp_f64mat4x3;
	
	
	
	typedef tmat4x4<f64, lowp> lowp_f64mat4x4;

	
	
	

	
	
	typedef lowp_f64mat2x2 lowp_f64mat2;

	
	
	typedef lowp_f64mat3x3 lowp_f64mat3;

	
	
	typedef lowp_f64mat4x4 lowp_f64mat4;


	
	
	

	
	
	typedef tmat2x2<f64, mediump> mediump_f64mat2x2;

	
	
	typedef tmat2x3<f64, mediump> mediump_f64mat2x3;

	
	
	typedef tmat2x4<f64, mediump> mediump_f64mat2x4;

	
	
	typedef tmat3x2<f64, mediump> mediump_f64mat3x2;

	
	
	typedef tmat3x3<f64, mediump> mediump_f64mat3x3;

	
	
	typedef tmat3x4<f64, mediump> mediump_f64mat3x4;

	
	
	typedef tmat4x2<f64, mediump> mediump_f64mat4x2;

	
	
	typedef tmat4x3<f64, mediump> mediump_f64mat4x3;

	
	
	typedef tmat4x4<f64, mediump> mediump_f64mat4x4;

	
	
	

	
	
	typedef mediump_f64mat2x2 mediump_f64mat2;

	
	
	typedef mediump_f64mat3x3 mediump_f64mat3;

	
	
	typedef mediump_f64mat4x4 mediump_f64mat4;

	
	
	

	
	
	typedef tmat2x2<f64, highp> highp_f64mat2x2;

	
	
	typedef tmat2x3<f64, highp> highp_f64mat2x3;

	
	
	typedef tmat2x4<f64, highp> highp_f64mat2x4;

	
	
	typedef tmat3x2<f64, highp> highp_f64mat3x2;

	
	
	typedef tmat3x3<f64, highp> highp_f64mat3x3;

	
	
	typedef tmat3x4<f64, highp> highp_f64mat3x4;

	
	
	typedef tmat4x2<f64, highp> highp_f64mat4x2;

	
	
	typedef tmat4x3<f64, highp> highp_f64mat4x3;

	
	
	typedef tmat4x4<f64, highp> highp_f64mat4x4;

	
	
	

	
	
	typedef highp_f64mat2x2 highp_f64mat2;

	
	
	typedef highp_f64mat3x3 highp_f64mat3;

	
	
	typedef highp_f64mat4x4 highp_f64mat4;

	
	

	
	
	typedef tquat<f32, lowp> lowp_f32quat;

	
	
	typedef tquat<f64, lowp> lowp_f64quat;

	
	
	typedef tquat<f32, mediump> mediump_f32quat;

	
	
	typedef tquat<f64, mediump> mediump_f64quat;

	
	
	typedef tquat<f32, highp> highp_f32quat;

	
	
	typedef tquat<f64, highp> highp_f64quat;






































#line 2321 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"



































#line 2357 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_f32vec1			fvec1;

	
	
	typedef highp_f32vec2			fvec2;

	
	
	typedef highp_f32vec3			fvec3;

	
	
	typedef highp_f32vec4			fvec4;

	
	
	typedef highp_f32mat2x2			fmat2x2;

	
	
	typedef highp_f32mat2x3			fmat2x3;

	
	
	typedef highp_f32mat2x4			fmat2x4;

	
	
	typedef highp_f32mat3x2			fmat3x2;

	
	
	typedef highp_f32mat3x3			fmat3x3;

	
	
	typedef highp_f32mat3x4			fmat3x4;

	
	
	typedef highp_f32mat4x2			fmat4x2;

	
	
	typedef highp_f32mat4x3			fmat4x3;

	
	
	typedef highp_f32mat4x4			fmat4x4;
	
	
	
	typedef fmat2x2					fmat2;

	
	
	typedef fmat3x3					fmat3;

	
	
	typedef fmat4x4					fmat4;

	
	
	typedef highp_fquat				fquat;
	


	
	
	typedef highp_f32vec1			f32vec1;

	
	
	typedef highp_f32vec2			f32vec2;

	
	
	typedef highp_f32vec3			f32vec3;

	
	
	typedef highp_f32vec4			f32vec4;

	
	
	typedef highp_f32mat2x2			f32mat2x2;

	
	
	typedef highp_f32mat2x3			f32mat2x3;

	
	
	typedef highp_f32mat2x4			f32mat2x4;

	
	
	typedef highp_f32mat3x2			f32mat3x2;

	
	
	typedef highp_f32mat3x3			f32mat3x3;

	
	
	typedef highp_f32mat3x4			f32mat3x4;

	
	
	typedef highp_f32mat4x2			f32mat4x2;

	
	
	typedef highp_f32mat4x3			f32mat4x3;

	
	
	typedef highp_f32mat4x4			f32mat4x4;

	
	
	typedef f32mat2x2				f32mat2;

	
	
	typedef f32mat3x3				f32mat3;

	
	
	typedef f32mat4x4				f32mat4;

	
	
	typedef highp_f32quat			f32quat;
#line 2495 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"



















#line 2515 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"

















#line 2533 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
	
	
	typedef highp_f64vec1			f64vec1;

	
	
	typedef highp_f64vec2			f64vec2;

	
	
	typedef highp_f64vec3			f64vec3;

	
	
	typedef highp_f64vec4			f64vec4;

	
	
	typedef highp_f64mat2x2			f64mat2x2;

	
	
	typedef highp_f64mat2x3			f64mat2x3;

	
	
	typedef highp_f64mat2x4			f64mat2x4;

	
	
	typedef highp_f64mat3x2			f64mat3x2;

	
	
	typedef highp_f64mat3x3			f64mat3x3;

	
	
	typedef highp_f64mat3x4			f64mat3x4;

	
	
	typedef highp_f64mat4x2			f64mat4x2;

	
	
	typedef highp_f64mat4x3			f64mat4x3;

	
	
	typedef highp_f64mat4x4			f64mat4x4;

	
	
	typedef f64mat2x2				f64mat2;

	
	
	typedef f64mat3x3				f64mat3;

	
	
	typedef f64mat4x4				f64mat4;

	
	
	typedef highp_f64quat			f64quat;
#line 2601 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\fwd.hpp"
}

#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.hpp"





namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat4x4
	{
		typedef tvec4<T, P> col_type;
		typedef tvec4<T, P> row_type;
		typedef tmat4x4<T, P> type;
		typedef tmat4x4<T, P> transpose_type;
		typedef T value_type;

		template <typename U, precision Q>
		friend tvec4<U, Q> operator/(tmat4x4<U, Q> const & m, tvec4<U, Q> const & v);
		template <typename U, precision Q>
		friend tvec4<U, Q> operator/(tvec4<U, Q> const & v, tmat4x4<U, Q> const & m);

	private:
		
		col_type value[4];
		

	public:
		
		 tmat4x4();
		 tmat4x4(tmat4x4<T, P> const & m);
		template <precision Q>
		 tmat4x4(tmat4x4<T, Q> const & m);

		 explicit tmat4x4(ctor);
		 explicit tmat4x4(T const & x);
		 tmat4x4(
			T const & x0, T const & y0, T const & z0, T const & w0,
			T const & x1, T const & y1, T const & z1, T const & w1,
			T const & x2, T const & y2, T const & z2, T const & w2,
			T const & x3, T const & y3, T const & z3, T const & w3);
		 tmat4x4(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2,
			col_type const & v3);

		
		

		template <
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3,
			typename X4, typename Y4, typename Z4, typename W4>
		 tmat4x4(
			X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
			X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
			X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
			X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);

		template <typename V1, typename V2, typename V3, typename V4>
		 tmat4x4(
			tvec4<V1, P> const & v1,
			tvec4<V2, P> const & v2,
			tvec4<V3, P> const & v3,
			tvec4<V4, P> const & v4);

		
		





			template <typename U, precision Q>
			 tmat4x4(tmat4x4<U, Q> const & m);
#line 113 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.hpp"

		 explicit tmat4x4(tmat2x2<T, P> const & x);
		 explicit tmat4x4(tmat3x3<T, P> const & x);
		 explicit tmat4x4(tmat2x3<T, P> const & x);
		 explicit tmat4x4(tmat3x2<T, P> const & x);
		 explicit tmat4x4(tmat2x4<T, P> const & x);
		 explicit tmat4x4(tmat4x2<T, P> const & x);
		 explicit tmat4x4(tmat3x4<T, P> const & x);
		 explicit tmat4x4(tmat4x3<T, P> const & x);

		
		








			typedef length_t length_type;
			  length_type length() const;

			 col_type & operator[](length_type i);
			 col_type const & operator[](length_type i) const;
#line 139 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.hpp"

		
		

		 tmat4x4<T, P> & operator=(tmat4x4<T, P> const & m);

		template <typename U>
		 tmat4x4<T, P> & operator=(tmat4x4<U, P> const & m);
		template <typename U>
		 tmat4x4<T, P> & operator+=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator+=(tmat4x4<U, P> const & m);
		template <typename U>
		 tmat4x4<T, P> & operator-=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator-=(tmat4x4<U, P> const & m);
		template <typename U>
		 tmat4x4<T, P> & operator*=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator*=(tmat4x4<U, P> const & m);
		template <typename U>
		 tmat4x4<T, P> & operator/=(U s);
		template <typename U>
		 tmat4x4<T, P> & operator/=(tmat4x4<U, P> const & m);

		
		

		 tmat4x4<T, P> & operator++();
		 tmat4x4<T, P> & operator--();
		 tmat4x4<T, P> operator++(int);
		 tmat4x4<T, P> operator--(int);
	};

	
	template <typename T, precision P>
	 tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m);

	template <typename T, precision P> 
	 tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

	template <typename T, precision P> 
	 tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s);

	template <typename T, precision P> 
	 tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1,	tmat4x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::col_type operator*(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::row_type operator*(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type & v, tmat4x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1,	tmat4x4<T, P> const & m2);

	
	template <typename T, precision P>
	 tmat4x4<T, P> const operator-(tmat4x4<T, P> const & m);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.inl"
































namespace glm{
namespace detail
{
	template <typename T, precision P>
	 inline tmat4x4<T, P> compute_inverse(tmat4x4<T, P> const & m)
	{
		T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
		T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
		T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

		T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
		T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
		T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

		T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
		T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
		T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

		T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
		T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
		T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

		T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
		T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
		T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

		T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
		T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
		T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

		tvec4<T, P> Fac0(Coef00, Coef00, Coef02, Coef03);
		tvec4<T, P> Fac1(Coef04, Coef04, Coef06, Coef07);
		tvec4<T, P> Fac2(Coef08, Coef08, Coef10, Coef11);
		tvec4<T, P> Fac3(Coef12, Coef12, Coef14, Coef15);
		tvec4<T, P> Fac4(Coef16, Coef16, Coef18, Coef19);
		tvec4<T, P> Fac5(Coef20, Coef20, Coef22, Coef23);

		tvec4<T, P> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
		tvec4<T, P> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
		tvec4<T, P> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
		tvec4<T, P> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

		tvec4<T, P> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
		tvec4<T, P> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
		tvec4<T, P> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
		tvec4<T, P> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

		tvec4<T, P> SignA(+1, -1, +1, -1);
		tvec4<T, P> SignB(-1, +1, -1, +1);
		tmat4x4<T, P> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

		tvec4<T, P> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

		tvec4<T, P> Dot0(m[0] * Row0);
		T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

		T OneOverDeterminant = static_cast<T>(1) / Dot1;

		return Inverse * OneOverDeterminant;
	}
}

	
	

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4()
	{

			this->value[0] = col_type(1, 0, 0, 0);
			this->value[1] = col_type(0, 1, 0, 0);
			this->value[2] = col_type(0, 0, 1, 0);
			this->value[3] = col_type(0, 0, 0, 1);
#line 107 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.inl"
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat4x4<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
	}

	template <typename T, precision P>
	template <precision Q>
	 inline tmat4x4<T, P>::tmat4x4(tmat4x4<T, Q> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(ctor)
	{}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(T const & s)
	{
		this->value[0] = col_type(s, 0, 0, 0);
		this->value[1] = col_type(0, s, 0, 0);
		this->value[2] = col_type(0, 0, s, 0);
		this->value[3] = col_type(0, 0, 0, s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4
	(
		T const & x0, T const & y0, T const & z0, T const & w0,
		T const & x1, T const & y1, T const & z1, T const & w1,
		T const & x2, T const & y2, T const & z2, T const & w2,
		T const & x3, T const & y3, T const & z3, T const & w3
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
		this->value[3] = col_type(x3, y3, z3, w3);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2,
		col_type const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat4x4<T, P>::tmat4x4
	(
		tmat4x4<U, Q> const & m
	)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	
	
	template <typename T, precision P> 
	template <
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3,
		typename X4, typename Y4, typename Z4, typename W4>
	 inline tmat4x4<T, P>::tmat4x4
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
		X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
		X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
		X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4
	)
	{
		static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

		static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
		static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
		static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
		static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

		static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
		static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
		static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
		static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

		static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
		static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
		static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
		static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");

		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3, typename V4>
	 inline tmat4x4<T, P>::tmat4x4
	(
		tvec4<V1, P> const & v1,
		tvec4<V2, P> const & v2,
		tvec4<V3, P> const & v3,
		tvec4<V4, P> const & v4
	)		
	{
		static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
		static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
		static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
		static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	
	
	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 0, 0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat2x4<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat3x4<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = col_type(0, 0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P>::tmat4x4(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
		this->value[3] = col_type(m[3], 1);
	}

	
	






















		template <typename T, precision P>
		 inline  typename tmat4x4<T, P>::length_type tmat4x4<T, P>::length() const
		{
			return 4;
		}

		template <typename T, precision P>
		 inline typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i)
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.inl", (unsigned)(354)), 0) );
			return this->value[i];
		}

		template <typename T, precision P>
		 inline typename tmat4x4<T, P>::col_type const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i) const
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.inl", (unsigned)(361)), 0) );
			return this->value[i];
		}
#line 365 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.inl"

	
	

	template <typename T, precision P>
	 inline tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<T, P> const & m)
	{
		
		
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P> 
	template <typename U> 
	 inline tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<U, P> const & m)
	{
		
		
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P>& tmat4x4<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P>& tmat4x4<T, P>::operator+=(tmat4x4<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator-=(tmat4x4<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator*=(tmat4x4<U, P> const & m)
	{
		return (*this = *this * m);
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator/=(tmat4x4<U, P> const & m)
	{
		return (*this = *this * detail::compute_inverse<T, P>(m));
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> & tmat4x4<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> tmat4x4<T, P>::operator++(int)
	{
		tmat4x4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> tmat4x4<T, P>::operator--(int)
	{
		tmat4x4<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	template <typename T, precision P>
	 inline tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s)
	{
		return tmat4x4<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return tmat4x4<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s)
	{
		return tmat4x4<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			s - m[0],
			s - m[1],
			s - m[2],
			s - m[3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return tmat4x4<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const  & s)
	{
		return tmat4x4<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::col_type operator*
	(
		tmat4x4<T, P> const & m,
		typename tmat4x4<T, P>::row_type const & v
	)
	{



















		typename tmat4x4<T, P>::col_type const Mov0(v[0]);
		typename tmat4x4<T, P>::col_type const Mov1(v[1]);
		typename tmat4x4<T, P>::col_type const Mul0 = m[0] * Mov0;
		typename tmat4x4<T, P>::col_type const Mul1 = m[1] * Mov1;
		typename tmat4x4<T, P>::col_type const Add0 = Mul0 + Mul1;
		typename tmat4x4<T, P>::col_type const Mov2(v[2]);
		typename tmat4x4<T, P>::col_type const Mov3(v[3]);
		typename tmat4x4<T, P>::col_type const Mul2 = m[2] * Mov2;
		typename tmat4x4<T, P>::col_type const Mul3 = m[3] * Mov3;
		typename tmat4x4<T, P>::col_type const Add1 = Mul2 + Mul3;
		typename tmat4x4<T, P>::col_type const Add2 = Add0 + Add1;
		return Add2;








	}

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::row_type operator*
	(
		typename tmat4x4<T, P>::col_type const & v,
		tmat4x4<T, P> const & m
	)
	{
		return typename tmat4x4<T, P>::row_type(
			m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
			m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
			m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
			m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		typename tmat4x4<T, P>::col_type const SrcA0 = m1[0];
		typename tmat4x4<T, P>::col_type const SrcA1 = m1[1];
		typename tmat4x4<T, P>::col_type const SrcA2 = m1[2];
		typename tmat4x4<T, P>::col_type const SrcA3 = m1[3];

		typename tmat4x4<T, P>::col_type const SrcB0 = m2[0];
		typename tmat4x4<T, P>::col_type const SrcB1 = m2[1];
		typename tmat4x4<T, P>::col_type const SrcB2 = m2[2];
		typename tmat4x4<T, P>::col_type const SrcB3 = m2[3];

		tmat4x4<T, P> Result(uninitialize);
		Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
		Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
		Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
		Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s)
	{
		return tmat4x4<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator/(T const & s,	tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v)
	{
		return detail::compute_inverse<T, P>(m) * v;
	}

	template <typename T, precision P>
	 inline typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m)
	{
		return v * detail::compute_inverse<T, P>(m);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		tmat4x4<T, P> m1_copy(m1);
		return m1_copy /= m2;
	}

	
	template <typename T, precision P>
	 inline tmat4x4<T, P> const operator-(tmat4x4<T, P> const & m)
	{
		return tmat4x4<T, P>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	template <typename T, precision P> 
	 inline tmat4x4<T, P> const operator++(tmat4x4<T, P> const & m, int)
	{
		return tmat4x4<T, P>(
			m[0] + static_cast<T>(1),
			m[1] + static_cast<T>(1),
			m[2] + static_cast<T>(1),
			m[3] + static_cast<T>(1));
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> const operator--(tmat4x4<T, P> const & m, int)
	{
		return tmat4x4<T, P>(
			m[0] - static_cast<T>(1),
			m[1] - static_cast<T>(1),
			m[2] - static_cast<T>(1),
			m[3] - static_cast<T>(1));
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
}
#line 235 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.hpp"
#line 236 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x4.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat4x4.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat4x4<float, lowp>		lowp_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, mediump>		mediump_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, highp>		highp_mat4;
	
	
	
	
	
	
	typedef tmat4x4<float, lowp>		lowp_mat4x4;
	
	
	
	
	
	
	typedef tmat4x4<float, mediump>		mediump_mat4x4;
	
	
	
	
	
	
	typedef tmat4x4<float, highp>		highp_mat4x4;

}
#line 13 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat3x3.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.hpp"
































#pragma once







namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat3x3
	{
		typedef tvec3<T, P> col_type;
		typedef tvec3<T, P> row_type;
		typedef tmat3x3<T, P> type;
		typedef tmat3x3<T, P> transpose_type;
		typedef T value_type;

		template <typename U, precision Q>
		friend tvec3<U, Q> operator/(tmat3x3<U, Q> const & m, tvec3<U, Q> const & v);
		template <typename U, precision Q>
		friend tvec3<U, Q> operator/(tvec3<U, Q> const & v, tmat3x3<U, Q> const & m);

	private:
		
		col_type value[3];
		

	public:
		
		 tmat3x3();
		 tmat3x3(tmat3x3<T, P> const & m);
		template <precision Q>
		 tmat3x3(tmat3x3<T, Q> const & m);

		 explicit tmat3x3(ctor);
		 explicit tmat3x3(T const & s);
		 tmat3x3(
			T const & x0, T const & y0, T const & z0,
			T const & x1, T const & y1, T const & z1,
			T const & x2, T const & y2, T const & z2);
		 tmat3x3(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2);

		
		

		template<
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3>
		 tmat3x3(
			X1 const & x1, Y1 const & y1, Z1 const & z1,
			X2 const & x2, Y2 const & y2, Z2 const & z2,
			X3 const & x3, Y3 const & y3, Z3 const & z3);
			
		template <typename V1, typename V2, typename V3>
		 tmat3x3(
			tvec3<V1, P> const & v1,
			tvec3<V2, P> const & v2,
			tvec3<V3, P> const & v3);

		
		





			template <typename U, precision Q>
			 tmat3x3(tmat3x3<U, Q> const & m);
#line 108 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.hpp"

		 explicit tmat3x3(tmat2x2<T, P> const & x);
		 explicit tmat3x3(tmat4x4<T, P> const & x);
		 explicit tmat3x3(tmat2x3<T, P> const & x);
		 explicit tmat3x3(tmat3x2<T, P> const & x);
		 explicit tmat3x3(tmat2x4<T, P> const & x);
		 explicit tmat3x3(tmat4x2<T, P> const & x);
		 explicit tmat3x3(tmat3x4<T, P> const & x);
		 explicit tmat3x3(tmat4x3<T, P> const & x);

		
		








			typedef length_t length_type;
			  length_type length() const;

			 col_type & operator[](length_type i);
			 col_type const & operator[](length_type i) const;
#line 134 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.hpp"

		
		

		 tmat3x3<T, P> & operator=(tmat3x3<T, P> const & m);

		template <typename U>
		 tmat3x3<T, P> & operator=(tmat3x3<U, P> const & m);
		template <typename U>
		 tmat3x3<T, P> & operator+=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator+=(tmat3x3<U, P> const & m);
		template <typename U>
		 tmat3x3<T, P> & operator-=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator-=(tmat3x3<U, P> const & m);
		template <typename U>
		 tmat3x3<T, P> & operator*=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator*=(tmat3x3<U, P> const & m);
		template <typename U>
		 tmat3x3<T, P> & operator/=(U s);
		template <typename U>
		 tmat3x3<T, P> & operator/=(tmat3x3<U, P> const & m);

		
		

		 tmat3x3<T, P> & operator++();
		 tmat3x3<T, P> & operator--();
		 tmat3x3<T, P> operator++(int);
		 tmat3x3<T, P> operator--(int);
	};

	
	template <typename T, precision P>
	 tmat3x3<T, P> operator+(tmat3x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(T const & s, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator+(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(tmat3x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(T const & s, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator-(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat3x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(T const & s, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat2x3<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator/(tmat3x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x3<T, P> operator/(T const & s, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m);

	template <typename T, precision P>
	 tmat3x3<T, P> operator/(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2);

	
	template <typename T, precision P>
	 tmat3x3<T, P> const operator-(tmat3x3<T, P> const & m);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.inl"
































namespace glm{
namespace detail
{
	template <typename T, precision P>
	 inline tmat3x3<T, P> compute_inverse(tmat3x3<T, P> const & m)
	{
		T OneOverDeterminant = static_cast<T>(1) / (
			+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
			- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
			+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

		tmat3x3<T, P> Inverse(uninitialize);
		Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
		Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
		Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
		Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
		Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
		Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
		Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
		Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
		Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

		return Inverse;
	}
}

	
	

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3()
	{

			this->value[0] = col_type(1, 0, 0);
			this->value[1] = col_type(0, 1, 0);
			this->value[2] = col_type(0, 0, 1);
#line 70 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.inl"
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(ctor)
	{}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat3x3<T, P> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	template <precision Q>
	 inline tmat3x3<T, P>::tmat3x3(tmat3x3<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(T const & s)
	{
		this->value[0] = col_type(s, 0, 0);
		this->value[1] = col_type(0, s, 0);
		this->value[2] = col_type(0, 0, s);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3
	(
		T const & x0, T const & y0, T const & z0,
		T const & x1, T const & y1, T const & z1,
		T const & x2, T const & y2, T const & z2
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	
	
	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3>
	 inline tmat3x3<T, P>::tmat3x3
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1,
		X2 const & x2, Y2 const & y2, Z2 const & z2,
		X3 const & x3, Y3 const & y3, Z3 const & z3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3>
	 inline tmat3x3<T, P>::tmat3x3
	(
		tvec3<V1, P> const & v1,
		tvec3<V2, P> const & v2,
		tvec3<V3, P> const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}

	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat3x3<T, P>::tmat3x3(tmat3x3<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat2x3<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P>::tmat3x3(tmat4x3<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}

	
	






















		template <typename T, precision P>
		 inline  typename tmat3x3<T, P>::length_type tmat3x3<T, P>::length() const
		{
			return 3;
		}

		template <typename T, precision P>
		 inline typename tmat3x3<T, P>::col_type & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i)
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.inl", (unsigned)(269)), 0) );
			return this->value[i];
		}

		template <typename T, precision P>
		 inline typename tmat3x3<T, P>::col_type const & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i) const
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.inl", (unsigned)(276)), 0) );
			return this->value[i];
		}
#line 280 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.inl"

	
	

	template <typename T, precision P>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator+=(tmat3x3<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator-=(tmat3x3<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator*=(tmat3x3<U, P> const & m)
	{
		return (*this = *this * m);
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator/=(tmat3x3<U, P> const & m)
	{
		return (*this = *this * detail::compute_inverse<T, P>(m));
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> & tmat3x3<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> tmat3x3<T, P>::operator++(int)
	{
		tmat3x3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> tmat3x3<T, P>::operator--(int)
	{
		tmat3x3<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator+(tmat3x3<T, P> const & m, T const & s)
	{
		return tmat3x3<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator+(T const & s, tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator+(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return tmat3x3<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator-(tmat3x3<T, P> const & m, T const & s)
	{
		return tmat3x3<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator-(T const & s, tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			s - m[0],
			s - m[1],
			s - m[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator-(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return tmat3x3<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator*(tmat3x3<T, P> const & m, T const & s)
	{
		return tmat3x3<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator*(T const & s, tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T, precision P> 
	 inline typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
	{
		return typename tmat3x3<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
	}

	template <typename T, precision P> 
	 inline typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
	{
		return typename tmat3x3<T, P>::row_type(
			m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
			m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
			m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
	}

	template <typename T, precision P> 
	 inline tmat3x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];

		tmat3x3<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator/(tmat3x3<T, P> const & m,	T const & s)
	{
		return tmat3x3<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator/(T const & s, tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			s / m[0],
			s / m[1],
			s / m[2]);
	}

	template <typename T, precision P>
	 inline typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
	{
		return detail::compute_inverse<T, P>(m) * v;
	}

	template <typename T, precision P>
	 inline typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
	{
		return v * detail::compute_inverse<T, P>(m);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator/(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		tmat3x3<T, P> m1_copy(m1);
		return m1_copy /= m2;
	}

	
	template <typename T, precision P>
	 inline tmat3x3<T, P> const operator-(tmat3x3<T, P> const & m)
	{
		return tmat3x3<T, P>(
			-m[0], 
			-m[1],
			-m[2]);
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 230 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.hpp"
#line 231 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x3.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat3x3.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, mediump>		mediump_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, highp>		highp_mat3;
	
	
	
	
	
	
	typedef tmat3x3<float, lowp>		lowp_mat3x3;
	
	
	
	
	
	
	typedef tmat3x3<float, mediump>		mediump_mat3x3;
	
	
	
	
	
	
	typedef tmat3x3<float, highp>		highp_mat3x3;

}
#line 14 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"






























































#pragma once


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.hpp"











































#pragma once






#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\constants.hpp"










































#pragma once






#line 51 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\constants.hpp"

namespace glm
{
	
	

	
	
	template <typename genType>
	 genType epsilon();

	
	
	template <typename genType>
	 genType zero();

	
	
	template <typename genType>
	 genType one();

	
	
	template <typename genType>
	 genType pi();

	
	
	template <typename genType>
	 genType two_pi();

	
	
	template <typename genType>
	 genType root_pi();

	
	
	template <typename genType>
	 genType half_pi();

	
	
	template <typename genType>
	 genType three_over_two_pi();

	
	
	template <typename genType>
	 genType quarter_pi();

	
	
	template <typename genType>
	 genType one_over_pi();

	
	
	template <typename genType>
	 genType one_over_two_pi();

	
	
	template <typename genType>
	 genType two_over_pi();

	
	
	template <typename genType>
	 genType four_over_pi();

	
	
	template <typename genType>
	 genType two_over_root_pi();

	
	
	template <typename genType>
	 genType one_over_root_two();

	
	
	template <typename genType>
	 genType root_half_pi();

	
	
	template <typename genType>
	 genType root_two_pi();

	
	
	template <typename genType>
	 genType root_ln_four();

	
	
	template <typename genType>
	 genType e();

	
	
	template <typename genType>
	 genType euler();

	
	
	template <typename genType>
	 genType root_two();

	
	
	template <typename genType>
	 genType root_three();

	
	
	template <typename genType>
	 genType root_five();

	
	
	template <typename genType>
	 genType ln_two();

	
	
	template <typename genType>
	 genType ln_ten();

	
	
	template <typename genType>
	 genType ln_ln_two();

	
	
	template <typename genType>
	 genType third();

	
	
	template <typename genType>
	 genType two_thirds();

	
	
	template <typename genType>
	 genType golden_ratio();

	
} 

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\constants.inl"


































namespace glm
{
	template <typename genType>
	 inline genType epsilon()
	{
		return std::numeric_limits<genType>::epsilon();
	}

	template <typename genType>
	 inline genType zero()
	{
		return genType(0);
	}

	template <typename genType>
	 inline genType one()
	{
		return genType(1);
	}

	template <typename genType>
	 inline genType pi()
	{
		return genType(3.14159265358979323846264338327950288);
	}

	template <typename genType>
	 inline genType two_pi()
	{
		return genType(6.28318530717958647692528676655900576);
	}

	template <typename genType>
	 inline genType root_pi()
	{
		return genType(1.772453850905516027);
	}

	template <typename genType>
	 inline genType half_pi()
	{
		return genType(1.57079632679489661923132169163975144);
	}

	template <typename genType>
	 inline genType three_over_two_pi()
	{
		return genType(4.71238898038468985769396507491925432);           
	}

	template <typename genType>
	 inline genType quarter_pi()
	{
		return genType(0.785398163397448309615660845819875721);
	}

	template <typename genType>
	 inline genType one_over_pi()
	{
		return genType(0.318309886183790671537767526745028724);
	}

	template <typename genType>
	 inline genType one_over_two_pi()
	{
		return genType(0.159154943091895335768883763372514362);
	}

	template <typename genType>
	 inline genType two_over_pi()
	{
		return genType(0.636619772367581343075535053490057448);
	}

	template <typename genType>
	 inline genType four_over_pi()
	{
		return genType(1.273239544735162686151070106980114898);
	}

	template <typename genType>
	 inline genType two_over_root_pi()
	{
		return genType(1.12837916709551257389615890312154517);
	}

	template <typename genType>
	 inline genType one_over_root_two()
	{
		return genType(0.707106781186547524400844362104849039);
	}

	template <typename genType>
	 inline genType root_half_pi()
	{
		return genType(1.253314137315500251);
	}

	template <typename genType>
	 inline genType root_two_pi()
	{
		return genType(2.506628274631000502);
	}

	template <typename genType>
	 inline genType root_ln_four()
	{
		return genType(1.17741002251547469);
	}

	template <typename genType>
	 inline genType e()
	{
		return genType(2.71828182845904523536);
	}

	template <typename genType>
	 inline genType euler()
	{
		return genType(0.577215664901532860606);
	}

	template <typename genType>
	 inline genType root_two()
	{
		return genType(1.41421356237309504880168872420969808);
	}

	template <typename genType>
	 inline genType root_three()
	{
		return genType(1.73205080756887729352744634150587236);
	}

	template <typename genType>
	 inline genType root_five()
	{
		return genType(2.23606797749978969640917366873127623);
	}

	template <typename genType>
	 inline genType ln_two()
	{
		return genType(0.693147180559945309417232121458176568);
	}

	template <typename genType>
	 inline genType ln_ten()
	{
		return genType(2.30258509299404568401799145468436421);
	}

	template <typename genType>
	 inline genType ln_ln_two()
	{
		return genType(-0.3665129205816643);
	}

	template <typename genType>
	 inline genType third()
	{
		return genType(0.3333333333333333333333333333333333333333);
	}

	template <typename genType>
	 inline genType two_thirds()
	{
		return genType(0.666666666666666666666666666666666666667);
	}

	template <typename genType>
	 inline genType golden_ratio()
	{
		return genType(1.61803398874989484820458683436563811);
	}
} 
#line 206 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\constants.hpp"
#line 52 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.hpp"



#line 56 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.hpp"

namespace glm
{
	
	

	template <typename T, precision P>
	struct tquat
	{
		typedef tquat<T, P> type;
		typedef T value_type;

	public:
		T x, y, z, w;

		
		









			typedef length_t length_type;
			
			  length_type length() const;

			 T & operator[](length_type i);
			 T const & operator[](length_type i) const;
#line 89 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.hpp"

		
		

		 tquat();
		 tquat(tquat<T, P> const & q);
		template <precision Q>
		 tquat(tquat<T, Q> const & q);

		
		

		 explicit tquat(ctor);
		 explicit tquat(T const & s, tvec3<T, P> const & v);
		 tquat(T const & w, T const & x, T const & y, T const & z);

		
		





			template <typename U, precision Q>
			 tquat(tquat<U, Q> const & q);
#line 115 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.hpp"
		
		

			 explicit operator tmat3x3<T, P>();
			 explicit operator tmat4x4<T, P>();
#line 121 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.hpp"
		
		
		
		
		
		
		
		 explicit tquat(tvec3<T, P> const & u,	tvec3<T, P> const & v);

		
		 explicit tquat(tvec3<T, P> const & eulerAngles);
		 explicit tquat(tmat3x3<T, P> const & m);
		 explicit tquat(tmat4x4<T, P> const & m);

		
		

		 tquat<T, P> & operator=(tquat<T, P> const & m);

		template <typename U>
		 tquat<T, P> & operator=(tquat<U, P> const & m);
		template <typename U>
		 tquat<T, P> & operator+=(tquat<U, P> const & q);
		template <typename U>
		 tquat<T, P> & operator*=(tquat<U, P> const & q);
		template <typename U>
		 tquat<T, P> & operator*=(U s);
		template <typename U>
		 tquat<T, P> & operator/=(U s);
	};

	template <typename T, precision P>
	 tquat<T, P> operator-(tquat<T, P> const & q);

	template <typename T, precision P>
	 tquat<T, P> operator+(tquat<T, P> const & q, tquat<T, P> const & p);

	template <typename T, precision P>
	 tquat<T, P> operator*(tquat<T, P> const & q, tquat<T, P> const & p);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tquat<T, P> const & q, tvec3<T, P> const & v);

	template <typename T, precision P>
	 tvec3<T, P> operator*(tvec3<T, P> const & v, tquat<T, P> const & q);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tquat<T, P> const & q, tvec4<T, P> const & v);

	template <typename T, precision P>
	 tvec4<T, P> operator*(tvec4<T, P> const & v, tquat<T, P> const & q);

	template <typename T, precision P>
	 tquat<T, P> operator*(tquat<T, P> const & q, T const & s);

	template <typename T, precision P>
	 tquat<T, P> operator*(T const & s, tquat<T, P> const & q);

	template <typename T, precision P>
	 tquat<T, P> operator/(tquat<T, P> const & q, T const & s);

	
	
	
	template <typename T, precision P>
	 T length(tquat<T, P> const & q);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> normalize(tquat<T, P> const & q);
		
	
	
	
	template <typename T, precision P, template <typename, precision> class quatType>
	 T dot(quatType<T, P> const & x, quatType<T, P> const & y);

	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> mix(tquat<T, P> const & x, tquat<T, P> const & y, T a);

	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> lerp(tquat<T, P> const & x, tquat<T, P> const & y, T a);

	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> slerp(tquat<T, P> const & x, tquat<T, P> const & y, T a);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> conjugate(tquat<T, P> const & q);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> inverse(tquat<T, P> const & q);

	
	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> rotate(tquat<T, P> const & q, T const & angle, tvec3<T, P> const & axis);

	
	
	
	
	template <typename T, precision P>
	 tvec3<T, P> eulerAngles(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 T roll(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 T pitch(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 T yaw(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tmat3x3<T, P> mat3_cast(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> mat4_cast(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> quat_cast(tmat3x3<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tquat<T, P> quat_cast(tmat4x4<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 T angle(tquat<T, P> const & x);

	
	
	
	template <typename T, precision P>
	 tvec3<T, P> axis(tquat<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P>
	 tquat<T, P> angleAxis(T const & angle, tvec3<T, P> const & axis);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> lessThan(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> lessThanEqual(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> greaterThan(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> greaterThanEqual(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> equal(tquat<T, P> const & x, tquat<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P>
	 tvec4<bool, P> notEqual(tquat<T, P> const & x, tquat<T, P> const & y);
	
} 

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl"
































#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\trigonometric.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_trigonometric.hpp"











































#pragma once




namespace glm
{
	
	

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> radians(vecType<T, P> const & degrees);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> degrees(vecType<T, P> const & radians);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sin(vecType<T, P> const & angle);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> cos(vecType<T, P> const & angle);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> tan(vecType<T, P> const & angle); 

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> asin(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> acos(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> atan(vecType<T, P> const & y, vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> atan(vecType<T, P> const & y_over_x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sinh(vecType<T, P> const & angle);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> cosh(vecType<T, P> const & angle);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> tanh(vecType<T, P> const & angle);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> asinh(vecType<T, P> const & x);
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> acosh(vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> atanh(vecType<T, P> const & x);

	
}

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_trigonometric.inl"
































#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\_vectorize.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.hpp"
































#pragma once












namespace glm
{
	template <typename T, precision P = defaultp>
	struct tvec1
	{
		
		

		typedef tvec1<T, P> type;
		typedef tvec1<bool, P> bool_type;
		typedef T value_type;

		
		


			union
			{
				T x;
				T r;
				T s;












			};






#line 87 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.hpp"

		
		









			
			typedef length_t length_type;
			  length_type length() const;

			 T & operator[](length_type i);
			 T const & operator[](length_type i) const;
#line 106 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.hpp"

		
		

		 tvec1();
		 tvec1(tvec1<T, P> const & v);
		template <precision Q>
		 tvec1(tvec1<T, Q> const & v);

		
		

		 explicit tvec1(ctor);
		 explicit tvec1(T const & s);

		
		
		
		
		template <typename U, precision Q>
		 explicit tvec1(tvec2<U, Q> const & v);
		
		template <typename U, precision Q>
		 explicit tvec1(tvec3<U, Q> const & v);
		
		template <typename U, precision Q>
		 explicit tvec1(tvec4<U, Q> const & v);






			
			template <typename U, precision Q>
			 tvec1(tvec1<U, Q> const & v);
#line 143 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.hpp"

		
		







#line 154 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.hpp"

		
		

		 tvec1<T, P> & operator=(tvec1<T, P> const & v);

		template <typename U> 
		 tvec1<T, P> & operator=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec1<T, P> & operator+=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator+=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec1<T, P> & operator-=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator-=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec1<T, P> & operator*=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator*=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec1<T, P> & operator/=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator/=(tvec1<U, P> const & v);

		
		

		 tvec1<T, P> & operator++();
		 tvec1<T, P> & operator--();
		 tvec1<T, P> operator++(int);
		 tvec1<T, P> operator--(int);

		
		

		template <typename U> 
		 tvec1<T, P> & operator%=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator%=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec1<T, P> & operator&=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator&=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec1<T, P> & operator|=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator|=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec1<T, P> & operator^=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator^=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec1<T, P> & operator<<=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator<<=(tvec1<U, P> const & v);
		template <typename U> 
		 tvec1<T, P> & operator>>=(U const & s);
		template <typename U> 
		 tvec1<T, P> & operator>>=(tvec1<U, P> const & v);
	};


	template <typename T, precision P>
	 tvec1<T, P> operator+(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator+(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator-(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator-(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator-	(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator*(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator*(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator/(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator/(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator-(tvec1<T, P> const & v);

	template <typename T, precision P>
	 bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator%(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator%(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator&(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator&(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator|(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator|(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator^(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator^(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator<<(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator<<(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P>
	 tvec1<T, P> operator>>(tvec1<T, P> const & v, T const & s);

	template <typename T, precision P>
	 tvec1<T, P> operator>>(T const & s, tvec1<T, P> const & v);

	template <typename T, precision P>
	 tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

	template <typename T, precision P> 
	 tvec1<T, P> operator~(tvec1<T, P> const & v);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.inl"
































namespace glm
{
	
	

	template <typename T, precision P>
	 inline tvec1<T, P>::tvec1()

			: x(0)
#line 43 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.inl"
	{}

	template <typename T, precision P>
	 inline tvec1<T, P>::tvec1(tvec1<T, P> const & v)
		: x(v.x)
	{}

	template <typename T, precision P>
	template <precision Q>
	 inline tvec1<T, P>::tvec1(tvec1<T, Q> const & v)
		: x(v.x)
	{}

	
	

	template <typename T, precision P>
	 inline tvec1<T, P>::tvec1(ctor)
	{}

	template <typename T, precision P>
	 inline  tvec1<T, P>::tvec1(T const & s)
		: x(s)
	{}

	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec1<T, P>::tvec1(tvec1<U, Q> const & v)
		: x(static_cast<T>(v.x))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec1<T, P>::tvec1(tvec2<U, Q> const & v)
		: x(static_cast<T>(v.x))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec1<T, P>::tvec1(tvec3<U, Q> const & v)
		: x(static_cast<T>(v.x))
	{}

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tvec1<T, P>::tvec1(tvec4<U, Q> const & v)
		: x(static_cast<T>(v.x))
	{}

	
	






















		template <typename T, precision P>
		 inline  typename tvec1<T, P>::length_type tvec1<T, P>::length() const
		{
			return 1;
		}

		template <typename T, precision P>
		 inline T & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i)
		{
			(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.inl", (unsigned)(128)), 0) );
			return (&x)[i];
		}

		template <typename T, precision P>
		 inline T const & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i) const
		{
			(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.inl", (unsigned)(135)), 0) );
			return (&x)[i];
		}
#line 139 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.inl"

	
	

	template <typename T, precision P>
	 inline tvec1<T, P> & tvec1<T, P>::operator=(tvec1<T, P> const & v)
	{
		this->x = v.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator=(tvec1<U, P> const & v)
	{
		this->x = static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator+=(U const & s)
	{
		this->x += static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator+=(tvec1<U, P> const & v)
	{
		this->x += static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator-=(U const & s)
	{
		this->x -= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator-=(tvec1<U, P> const & v)
	{
		this->x -= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator*=(U const & s)
	{
		this->x *= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator*=(tvec1<U, P> const & v)
	{
		this->x *= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator/=(U const & s)
	{
		this->x /= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator/=(tvec1<U, P> const & v)
	{
		this->x /= static_cast<T>(v.x);
		return *this;
	}

	
	

	template <typename T, precision P>
	 inline tvec1<T, P> & tvec1<T, P>::operator++()
	{
		++this->x;
		return *this;
	}

	template <typename T, precision P>
	 inline tvec1<T, P> & tvec1<T, P>::operator--()
	{
		--this->x;
		return *this;
	}

	template <typename T, precision P> 
	 inline tvec1<T, P> tvec1<T, P>::operator++(int)
	{
		tvec1<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P> 
	 inline tvec1<T, P> tvec1<T, P>::operator--(int)
	{
		tvec1<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P> 
	 inline bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return (v1.x == v2.x);
	}

	template <typename T, precision P> 
	 inline bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return (v1.x != v2.x);
	}

	
	

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator%=(U const & s)
	{
		this->x %= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator%=(tvec1<U, P> const & v)
	{
		this->x %= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator&=(U const & s)
	{
		this->x &= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator&=(tvec1<U, P> const & v)
	{
		this->x &= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator|=(U const & s)
	{
		this->x |= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator|=(tvec1<U, P> const & v)
	{
		this->x |= U(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator^=(U const & s)
	{
		this->x ^= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator^=(tvec1<U, P> const & v)
	{
		this->x ^= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator<<=(U const & s)
	{
		this->x <<= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator<<=(tvec1<U, P> const & v)
	{
		this->x <<= static_cast<T>(v.x);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator>>=(U const & s)
	{
		this->x >>= static_cast<T>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U> 
	 inline tvec1<T, P> & tvec1<T, P>::operator>>=(tvec1<U, P> const & v)
	{
		this->x >>= static_cast<T>(v.x);
		return *this;
	}

	
	

	template <typename T, precision P> 
	 inline tvec1<T, P> operator+(tvec1<T, P> const & v, T const & s)
	{
		return tvec1<T, P>(
			v.x + s);
	}

	template <typename T, precision P> 
	 inline tvec1<T, P> operator+(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s + v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x + v2.x);
	}

	
	template <typename T, precision P> 
	 inline tvec1<T, P> operator-(tvec1<T, P> const & v, T const & s)
	{
		return tvec1<T, P>(
			v.x - s);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator-(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s - v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator-(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x - v2.x);
	}

	
	template <typename T, precision P>
	 inline tvec1<T, P> operator*(tvec1<T, P> const & v, T const & s)
	{
		return tvec1<T, P>(
			v.x * s);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator*(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s * v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x * v2.x);
	}

	
	template <typename T, precision P>
	 inline tvec1<T, P> operator/(tvec1<T, P> const & v,	T const & s)
	{
		return tvec1<T, P>(
			v.x / s);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator/(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s / v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x / v2.x);
	}

	
	template <typename T, precision P>
	 inline tvec1<T, P> operator-(tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			-v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator++(tvec1<T, P> const & v, int)
	{
		return tvec1<T, P>(
			v.x + T(1));
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator--(tvec1<T, P> const & v, int)
	{
		return tvec1<T, P>(
			v.x - T(1));
	}

	
	

	template <typename T, precision P>
	 inline tvec1<T, P> operator%(tvec1<T, P> const & v, T const & s)
	{
		return tvec1<T, P>(
			v.x % s);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator%(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s % v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x % v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator&(tvec1<T, P> const & v, T const & s)
	{
		return tvec1<T, P>(
			v.x & s);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator&(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s & v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x & v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator|(tvec1<T, P> const & v, T const & s)
	{
		return tvec1<T, P>(
			v.x | s);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator|(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s | v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x | v2.x);
	}
		
	template <typename T, precision P>
	 inline tvec1<T, P> operator^(tvec1<T, P> const & v, T const & s)
	{
		return tvec1<T, P>(
			v.x ^ s);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator^(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s ^ v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x ^ v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator<<(tvec1<T, P> const & v, T const & s)
	{
		return tvec1<T, P>(
			v.x << s);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator<<(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s << v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x << v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator>>(tvec1<T, P> const & v, T const & s)
	{
		return tvec1<T, P>(
			v.x >> s);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator>>(T const & s, tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			s >> v.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
	{
		return tvec1<T, P>(
			v1.x >> v2.x);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> operator~(tvec1<T, P> const & v)
	{
		return tvec1<T, P>(
			~v.x);
	}
}
#line 322 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.hpp"
#line 323 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_vec1.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\_vectorize.hpp"




namespace glm{
namespace detail
{
	template <typename R, typename T, precision P, template <typename, precision> class vecType>
	struct functor1{};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec1>
	{
		 inline static tvec1<R, P> call(R (*Func) (T x), tvec1<T, P> const & v)
		{
			return tvec1<R, P>(Func(v.x));
		}
	};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec2>
	{
		 inline static tvec2<R, P> call(R (*Func) (T x), tvec2<T, P> const & v)
		{
			return tvec2<R, P>(Func(v.x), Func(v.y));
		}
	};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec3>
	{
		 inline static tvec3<R, P> call(R (*Func) (T x), tvec3<T, P> const & v)
		{
			return tvec3<R, P>(Func(v.x), Func(v.y), Func(v.z));
		}
	};

	template <typename R, typename T, precision P>
	struct functor1<R, T, P, tvec4>
	{
		 inline static tvec4<R, P> call(R (*Func) (T x), tvec4<T, P> const & v)
		{
			return tvec4<R, P>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct functor2{};

	template <typename T, precision P>
	struct functor2<T, P, tvec1>
	{
		 inline static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, tvec1<T, P> const & b)
		{
			return tvec1<T, P>(Func(a.x, b.x));
		}
	};

	template <typename T, precision P>
	struct functor2<T, P, tvec2>
	{
		 inline static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, tvec2<T, P> const & b)
		{
			return tvec2<T, P>(Func(a.x, b.x), Func(a.y, b.y));
		}
	};

	template <typename T, precision P>
	struct functor2<T, P, tvec3>
	{
		 inline static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, tvec3<T, P> const & b)
		{
			return tvec3<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
		}
	};

	template <typename T, precision P>
	struct functor2<T, P, tvec4>
	{
		 inline static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, tvec4<T, P> const & b)
		{
			return tvec4<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
		}
	};

	template <typename T, precision P, template <typename, precision> class vecType>
	struct functor2_vec_sca{};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec1>
	{
		 inline static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, T b)
		{
			return tvec1<T, P>(Func(a.x, b));
		}
	};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec2>
	{
		 inline static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, T b)
		{
			return tvec2<T, P>(Func(a.x, b), Func(a.y, b));
		}
	};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec3>
	{
		 inline static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, T b)
		{
			return tvec3<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
		}
	};

	template <typename T, precision P>
	struct functor2_vec_sca<T, P, tvec4>
	{
		 inline static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, T b)
		{
			return tvec4<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
		}
	};
}
}
#line 34 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_trigonometric.inl"



namespace glm
{
	
	template <typename genType>
	 inline genType radians(genType degrees)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'radians' only accept floating-point input");

		return degrees * static_cast<genType>(0.01745329251994329576923690768489);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> radians(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(radians, v);
	}
	
	
	template <typename genType>
	 inline genType degrees(genType radians)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'degrees' only accept floating-point input");

		return radians * static_cast<genType>(57.295779513082320876798154814105);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> degrees(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(degrees, v);
	}

	
	using ::std::sin;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> sin(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(sin, v);
	}

	
	using std::cos;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> cos(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(cos, v);
	}

	
	using std::tan;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> tan(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(tan, v);
	}

	
	using std::asin;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> asin(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(asin, v);
	}

	
	using std::acos;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> acos(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(acos, v);
	}

	
	template <typename genType>
	 inline genType atan(genType const & y, genType const & x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'atan' only accept floating-point input");

		return ::std::atan2(y, x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> atan(vecType<T, P> const & a, vecType<T, P> const & b)
	{
		return detail::functor2<T, P, vecType>::call(atan2, a, b);
	}

	using std::atan;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> atan(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(atan, v);
	}

	
	using std::sinh;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> sinh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(sinh, v);
	}

	
	using std::cosh;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> cosh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(cosh, v);
	}

	
	using std::tanh;

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> tanh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(tanh, v);
	}

	

		using std::asinh;








#line 176 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_trigonometric.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> asinh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(asinh, v);
	}

	

		using std::acosh;










#line 197 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_trigonometric.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> acosh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(acosh, v);
	}

	

		using std::atanh;










#line 218 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_trigonometric.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> atanh(vecType<T, P> const & v)
	{
		return detail::functor1<T, T, P, vecType>::call(atanh, v);
	}
}
#line 206 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_trigonometric.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\trigonometric.hpp"
#line 34 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\geometric.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_geometric.hpp"







































#pragma once



namespace glm
{
	
	

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 T length(
		vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 T distance(
		vecType<T, P> const & p0,
		vecType<T, P> const & p1);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 T dot(
		vecType<T, P> const & x,
		vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P>
	 tvec3<T, P> cross(
		tvec3<T, P> const & x,
		tvec3<T, P> const & y);

	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> normalize(
		vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> faceforward(
		vecType<T, P> const & N,
		vecType<T, P> const & I,
		vecType<T, P> const & Nref);

	
	
	
	
	
	
	
	template <typename genType>
	 genType reflect(
		genType const & I,
		genType const & N);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> refract(
		vecType<T, P> const & I,
		vecType<T, P> const & N,
		T eta);

	
}

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_geometric.inl"
































#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_exponential.hpp"







































#pragma once







namespace glm
{
	
	

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> exp(vecType<T, P> const & v);

	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> log(vecType<T, P> const & v);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> exp2(vecType<T, P> const & v);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> log2(vecType<T, P> const & v);

	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sqrt(vecType<T, P> const & v);
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> inversesqrt(vecType<T, P> const & v);

	
}

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_exponential.inl"
































#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_vector_relational.hpp"












































#pragma once




namespace glm
{
	
	

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 bool any(vecType<bool, P> const & v);

	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 bool all(vecType<bool, P> const & v);

	
	
	
	
	
	
	
	template <precision P, template <typename, precision> class vecType>
	 vecType<bool, P> not_(vecType<bool, P> const & v);

	
}

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_vector_relational.inl"


































namespace glm
{
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(detail::component_count(x) == detail::component_count(y))) || (_wassert(L"detail::component_count(x) == detail::component_count(y)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_vector_relational.inl", (unsigned)(40)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] < y[i];

		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(detail::component_count(x) == detail::component_count(y))) || (_wassert(L"detail::component_count(x) == detail::component_count(y)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_vector_relational.inl", (unsigned)(52)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(detail::component_count(x) == detail::component_count(y))) || (_wassert(L"detail::component_count(x) == detail::component_count(y)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_vector_relational.inl", (unsigned)(63)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(detail::component_count(x) == detail::component_count(y))) || (_wassert(L"detail::component_count(x) == detail::component_count(y)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_vector_relational.inl", (unsigned)(74)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(detail::component_count(x) == detail::component_count(y))) || (_wassert(L"detail::component_count(x) == detail::component_count(y)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_vector_relational.inl", (unsigned)(85)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		(void)( (!!(detail::component_count(x) == detail::component_count(y))) || (_wassert(L"detail::component_count(x) == detail::component_count(y)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_vector_relational.inl", (unsigned)(96)), 0) );

		vecType<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}

	template <precision P, template <typename, precision> class vecType>
	 inline bool any(vecType<bool, P> const & v)
	{
		bool Result = false;
		for(detail::component_count_t i = 0; i < detail::component_count(v); ++i)
			Result = Result || v[i];
		return Result;
	}

	template <precision P, template <typename, precision> class vecType>
	 inline bool all(vecType<bool, P> const & v)
	{
		bool Result = true;
		for(detail::component_count_t i = 0; i < detail::component_count(v); ++i)
			Result = Result && v[i];
		return Result;
	}

	template <precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> not_(vecType<bool, P> const & v)
	{
		vecType<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(v); ++i)
			Result[i] = !v[i];
		return Result;
	}
}

#line 141 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_vector_relational.hpp"
#line 34 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_exponential.inl"



#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cassert"



#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"









#line 11 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 5 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\cassert"





#line 38 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_exponential.inl"

namespace glm{
namespace detail
{

		using std::log2;






#line 51 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_exponential.inl"

	template <typename T, precision P, template <class, precision> class vecType, bool isFloat = true>
	struct compute_log2
	{
		 inline static vecType<T, P> call(vecType<T, P> const & vec)
		{
			return detail::functor1<T, T, P, vecType>::call(log2, vec);
		}
	};

	template <template <class, precision> class vecType, typename T, precision P>
	struct compute_inversesqrt
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return static_cast<T>(1) / sqrt(x);
		}
	};
		
	template <template <class, precision> class vecType>
	struct compute_inversesqrt<vecType, float, lowp>
	{
		 inline static vecType<float, lowp> call(vecType<float, lowp> const & x)
		{
			vecType<float, lowp> tmp(x);
			vecType<float, lowp> xhalf(tmp * 0.5f);
			vecType<uint, lowp>* p = reinterpret_cast<vecType<uint, lowp>*>(const_cast<vecType<float, lowp>*>(&x));
			vecType<uint, lowp> i = vecType<uint, lowp>(0x5f375a86) - (*p >> vecType<uint, lowp>(1));
			vecType<float, lowp>* ptmp = reinterpret_cast<vecType<float, lowp>*>(&i);
			tmp = *ptmp;
			tmp = tmp * (1.5f - xhalf * tmp * tmp);
			return tmp;
		}
	};
}

	
	using std::pow;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent)
	{
		return detail::functor2<T, P, vecType>::call(pow, base, exponent);
	}

	
	using std::exp;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> exp(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(exp, x);
	}

	
	using std::log;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> log(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(log, x);
	}

	
	template <typename genType>
	 inline genType exp2(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'exp2' only accept floating-point inputs");

		return std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> exp2(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(exp2, x);
	}

	
	template <typename genType>
	 inline genType log2(genType x)
	{
		return log2(tvec1<genType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> log2(vecType<T, P> const & x)
	{
		return detail::compute_log2<T, P, vecType, std::numeric_limits<T>::is_iec559>::call(x);
	}

	
	using std::sqrt;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> sqrt(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'sqrt' only accept floating-point inputs");
		return detail::functor1<T, T, P, vecType>::call(sqrt, x);
	}

	
	template <typename genType>
	 inline genType inversesqrt(genType x)
	{
		return static_cast<genType>(1) / sqrt(x);
	}
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> inversesqrt(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'inversesqrt' only accept floating-point inputs");
		return detail::compute_inversesqrt<vecType, T, P>::call(x);
	}
}
#line 133 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_exponential.hpp"
#line 34 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_geometric.inl"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.hpp"







































#pragma once




#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\_fixes.hpp"



























































#line 46 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	template <typename genType>
	 genType abs(genType x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> abs(vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> sign(vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> floor(vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> trunc(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> round(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> roundEven(vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> ceil(vecType<T, P> const & x);

	
	
	
	
	
	
	template <typename genType>
	 genType fract(genType x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> fract(vecType<T, P> const & x);

	
	
	
	
	
	
	
	template <typename genType>
	 genType mod(genType x, genType y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mod(vecType<T, P> const & x, T y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	
	
	
	template <typename genType>
	 genType modf(genType x, genType & i);

	
	
	
	
	
	
	template <typename genType>
	 genType min(genType x, genType y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> min(vecType<T, P> const & x, T y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> min(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	template <typename genType>
	 genType max(genType x, genType y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> max(vecType<T, P> const & x, T y);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> max(vecType<T, P> const & x, vecType<T, P> const & y);

	
	
	
	
	
	
	
	template <typename genType>
	 genType clamp(genType x, genType minVal, genType maxVal);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a);

	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a);

	template <typename genTypeT, typename genTypeU>
	 genTypeT mix(genTypeT x, genTypeT y, genTypeU a);

	
	
	
	
	template <typename genType>
	 genType step(genType edge, genType x);

	
	
	
	
	template <template <typename, precision> class vecType, typename T, precision P>
	 vecType<T, P> step(T edge, vecType<T, P> const & x);

	
	
	
	
	template <template <typename, precision> class vecType, typename T, precision P>
	 vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genType>
	 genType smoothstep(genType edge0, genType edge1, genType x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x);

	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isnan(vecType<T, P> const & x);

	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecType>
	 vecType<bool, P> isinf(vecType<T, P> const & x);

	
	
	
	
	
	
	 int floatBitsToInt(float const & v);

	
	
	
	
	
	
	template <template <typename, precision> class vecType, precision P>
	 vecType<int, P> floatBitsToInt(vecType<float, P> const & v);

	
	
	
	
	
	
	 uint floatBitsToUint(float const & v);

	
	
	
	
	
	
	template <template <typename, precision> class vecType, precision P>
	 vecType<uint, P> floatBitsToUint(vecType<float, P> const & v);

	
	
	
	
	
	
	
	
	 float intBitsToFloat(int const & v);

	
	
	
	
	
	
	
	
	template <template <typename, precision> class vecType, precision P>
	 vecType<float, P> intBitsToFloat(vecType<int, P> const & v);

	
	
	
	
	
	
	
	
	 float uintBitsToFloat(uint const & v);

	
	
	
	
	
	
	
	
	template <template <typename, precision> class vecType, precision P>
	 vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v);

	
	
	
	
	
	
	template <typename genType>
	 genType fma(genType const & a, genType const & b, genType const & c);

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename genType, typename genIType>
	 genType frexp(genType const & x, genIType & exp);

	
	
	
	
	
	
	
	
	
	
	
	template <typename genType, typename genIType>
	 genType ldexp(genType const & x, genIType const & exp);

	
}

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.inl"







































namespace glm{
namespace detail
{
	template <typename genFIType, bool >
	struct compute_abs
	{};

	template <typename genFIType>
	struct compute_abs<genFIType, true>
	{
		 inline static genFIType call(genFIType x)
		{
			static_assert(std::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs");
#line 55 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.inl"

			return x >= genFIType(0) ? x : -x;
			
		}
	};

	template <typename genFIType>
	struct compute_abs<genFIType, false>
	{
		 inline static genFIType call(genFIType x)
		{
			static_assert(!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer, "'abs' only accept floating-point and integer scalar or vector inputs");
#line 69 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.inl"
			return x;
		}
	};

	template <typename T, typename U, precision P, template <class, precision> class vecType>
	struct compute_mix_vector
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
		{
			static_assert(std::numeric_limits<U>::is_iec559, "'mix' only accept floating-point inputs for the interpolator a");

			return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
		}
	};

	template <typename T, precision P, template <class, precision> class vecType>
	struct compute_mix_vector<T, bool, P, vecType>
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<bool, P> const & a)
		{
			vecType<T, P> Result(uninitialize);
			for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
				Result[i] = a[i] ? y[i] : x[i];
			return Result;
		}
	};

	template <typename T, typename U, precision P, template <class, precision> class vecType>
	struct compute_mix_scalar
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, U const & a)
		{
			static_assert(std::numeric_limits<U>::is_iec559, "'mix' only accept floating-point inputs for the interpolator a");

			return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
		}
	};

	template <typename T, precision P, template <class, precision> class vecType>
	struct compute_mix_scalar<T, bool, P, vecType>
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, bool const & a)
		{
			return a ? y : x;
		}
	};

	template <typename T, typename U>
	struct compute_mix
	{
		 inline static T call(T const & x, T const & y, U const & a)
		{
			static_assert(std::numeric_limits<U>::is_iec559, "'mix' only accept floating-point inputs for the interpolator a");

			return static_cast<T>(static_cast<U>(x) + a * static_cast<U>(y - x));
		}
	};

	template <typename T>
	struct compute_mix<T, bool>
	{
		 inline static T call(T const & x, T const & y, bool const & a)
		{
			return a ? y : x;
		}
	};

	template <typename T, precision P, template <class, precision> class vecType, bool isFloat = true, bool isSigned = true>
	struct compute_sign
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return vecType<T, P>(glm::lessThan(vecType<T, P>(0), x)) - vecType<T, P>(glm::lessThan(x, vecType<T, P>(0)));
		}
	};

	template <typename T, precision P, template <class, precision> class vecType>
	struct compute_sign<T, P, vecType, false, false>
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			return vecType<T, P>(glm::greaterThan(x , vecType<T, P>(0)));
		}
	};

	template <typename T, precision P, template <class, precision> class vecType>
	struct compute_sign<T, P, vecType, false, true>
	{
		 inline static vecType<T, P> call(vecType<T, P> const & x)
		{
			T const Shift(static_cast<T>(sizeof(T) * 8 - 1));
			vecType<T, P> const y(vecType<typename make_unsigned<T>::type, P>(-x) >> typename make_unsigned<T>::type(Shift));

			return (x >> Shift) | y;
		}
	};

	template <typename T, precision P, template <class, precision> class vecType, typename genType, bool isFloat = true>
	struct compute_mod
	{
		 inline static vecType<T, P> call(vecType<T, P> const & a, genType const & b)
		{
			static_assert(std::numeric_limits<T>::is_iec559, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
			return a - b * floor(a / b);
		}
	};
}

	
	template <>
	 inline int32 abs(int32 x)
	{
		int32 const y = x >> 31;
		return (x ^ y) - y;
	}

	template <typename genFIType>
	 inline genFIType abs(genFIType x)
	{
		return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> abs(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(abs, x);
	}

	
	
	template <typename genFIType> 
	 inline genFIType sign(genFIType x)
	{
		static_assert(std::numeric_limits<genFIType>::is_iec559 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs");
#line 205 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.inl"
		
		return detail::compute_sign<genFIType, defaultp, tvec1, std::numeric_limits<genFIType>::is_iec559>::call(tvec1<genFIType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> sign(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs");
#line 215 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.inl"

		return detail::compute_sign<T, P, vecType, std::numeric_limits<T>::is_iec559>::call(x);
	}

	
	using ::std::floor;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> floor(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(floor, x);
	}

	

		using ::std::trunc;








#line 239 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> trunc(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(trunc, x);
	}

	

		using ::std::round;








#line 258 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> round(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(round, x);
	}












	
	template <typename genType>
	 inline genType roundEven(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'roundEven' only accept floating-point inputs");
		
		int Integer = static_cast<int>(x);
		genType IntegerPart = static_cast<genType>(Integer);
		genType FractionalPart = fract(x);

		if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
		{
			return round(x);
		}
		else if((Integer % 2) == 0)
		{
			return IntegerPart;
		}
		else if(x <= static_cast<genType>(0)) 
		{
			return IntegerPart - static_cast<genType>(1);
		}
		else
		{
			return IntegerPart + static_cast<genType>(1);
		}
		
		
		
		
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> roundEven(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(roundEven, x);
	}

	
	using ::std::ceil;
	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> ceil(vecType<T, P> const & x)
	{
		return detail::functor1<T, T, P, vecType>::call(ceil, x);
	}

	
	template <typename genType>
	 inline genType fract(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'fract' only accept floating-point inputs");

		return fract(tvec1<genType>(x)).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> fract(vecType<T, P> const & x)
	{
		return x - floor(x);
	}

	
	template <typename genType>
	 inline genType mod(genType x, genType y)
	{
		return mod(tvec1<genType>(x), y).x;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> mod(vecType<T, P> const & x, T y)
	{
		return detail::compute_mod<T, P, vecType, T, std::numeric_limits<T>::is_iec559>::call(x, y);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		return detail::compute_mod<T, P, vecType, vecType<T, P>, std::numeric_limits<T>::is_iec559>::call(x, y);
	}

	
	template <typename genType>
	 inline genType modf(genType x, genType & i)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'modf' only accept floating-point inputs");

		return std::modf(x, &i);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> modf(tvec1<T, P> const & x, tvec1<T, P> & i)
	{
		return tvec1<T, P>(
			modf(x.x, i.x));
	}

	template <typename T, precision P>
	 inline tvec2<T, P> modf(tvec2<T, P> const & x, tvec2<T, P> & i)
	{
		return tvec2<T, P>(
			modf(x.x, i.x),
			modf(x.y, i.y));
	}

	template <typename T, precision P>
	 inline tvec3<T, P> modf(tvec3<T, P> const & x, tvec3<T, P> & i)
	{
		return tvec3<T, P>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z));
	}

	template <typename T, precision P>
	 inline tvec4<T, P> modf(tvec4<T, P> const & x, tvec4<T, P> & i)
	{
		return tvec4<T, P>(
			modf(x.x, i.x),
			modf(x.y, i.y),
			modf(x.z, i.z),
			modf(x.w, i.w));
	}

	
	
	
	
	
	
	

	
	template <typename genType>
	 inline genType min(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs");

		return x < y ? x : y;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> min(vecType<T, P> const & a, T b)
	{
		return detail::functor2_vec_sca<T, P, vecType>::call(min, a, b);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> min(vecType<T, P> const & a, vecType<T, P> const & b)
	{
		return detail::functor2<T, P, vecType>::call(min, a, b);
	}

	
	template <typename genType>
	 inline genType max(genType x, genType y)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs");

		return x > y ? x : y;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> max(vecType<T, P> const & a, T b)
	{
		return detail::functor2_vec_sca<T, P, vecType>::call(max, a, b);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> max(vecType<T, P> const & a, vecType<T, P> const & b)
	{
		return detail::functor2<T, P, vecType>::call(max, a, b);
	}

	
	template <typename genType>
	 inline genType clamp(genType x, genType minVal, genType maxVal)
	{
		static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs");
		
		return min(max(x, minVal), maxVal);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");

		return min(max(x, minVal), maxVal);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal)
	{
		static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");

		return min(max(x, minVal), maxVal);
	}

	template <typename genTypeT, typename genTypeU>
	 inline genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
	{
		return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
	}

	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a)
	{
		return detail::compute_mix_scalar<T, U, P, vecType>::call(x, y, a);
	}
	
	template <typename T, typename U, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
	{
		return detail::compute_mix_vector<T, U, P, vecType>::call(x, y, a);
	}

	
	template <typename genType>
	 inline genType step(genType edge, genType x)
	{
		return mix(static_cast<genType>(1), static_cast<genType>(0), glm::lessThan(x, edge));
	}

	template <template <typename, precision> class vecType, typename T, precision P>
	 inline vecType<T, P> step(T edge, vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'step' only accept floating-point inputs");

		return mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, vecType<T, P>(edge)));
	}

	template <template <typename, precision> class vecType, typename T, precision P>
	 inline vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x)
	{
		return mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, edge));
	}

	
	template <typename genType>
	 inline genType smoothstep(genType edge0, genType edge1, genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'smoothstep' only accept floating-point inputs");

		genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
		return tmp * tmp * (genType(3) - genType(2) * tmp);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs");

		vecType<T, P> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
		return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs");

		vecType<T, P> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
		return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
	}


		using std::isnan;






















#line 566 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> isnan(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

		return detail::functor1<bool, T, P, vecType>::call(isnan, x);
	}


		using std::isinf;























#line 601 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.inl"

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<bool, P> isinf(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

		return detail::functor1<bool, T, P, vecType>::call(isinf, x);
	}

	 inline int floatBitsToInt(float const & v)
	{
		return reinterpret_cast<int&>(const_cast<float&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 inline vecType<int, P> floatBitsToInt(vecType<float, P> const & v)
	{
		return reinterpret_cast<vecType<int, P>&>(const_cast<vecType<float, P>&>(v));
	}

	 inline uint floatBitsToUint(float const & v)
	{
		return reinterpret_cast<uint&>(const_cast<float&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 inline vecType<uint, P> floatBitsToUint(vecType<float, P> const & v)
	{
		return reinterpret_cast<vecType<uint, P>&>(const_cast<vecType<float, P>&>(v));
	}

	 inline float intBitsToFloat(int const & v)
	{
		return reinterpret_cast<float&>(const_cast<int&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 inline vecType<float, P> intBitsToFloat(vecType<int, P> const & v)
	{
		return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<int, P>&>(v));
	}

	 inline float uintBitsToFloat(uint const & v)
	{
		return reinterpret_cast<float&>(const_cast<uint&>(v));
	}

	template <template <typename, precision> class vecType, precision P>
	 inline vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v)
	{
		return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<uint, P>&>(v));
	}
	
	template <typename genType>
	 inline genType fma(genType const & a, genType const & b, genType const & c)
	{
		return a * b + c;
	}

	template <typename genType>
	 inline genType frexp(genType x, int & exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'frexp' only accept floating-point inputs");

		return std::frexp(x, exp);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> frexp(tvec1<T, P> const & x, tvec1<int, P> & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

		return tvec1<T, P>(std::frexp(x.x, exp.x));
	}

	template <typename T, precision P>
	 inline tvec2<T, P> frexp(tvec2<T, P> const & x, tvec2<int, P> & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

		return tvec2<T, P>(
			frexp(x.x, exp.x),
			frexp(x.y, exp.y));
	}

	template <typename T, precision P>
	 inline tvec3<T, P> frexp(tvec3<T, P> const & x, tvec3<int, P> & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

		return tvec3<T, P>(
			frexp(x.x, exp.x),
			frexp(x.y, exp.y),
			frexp(x.z, exp.z));
	}

	template <typename T, precision P>
	 inline tvec4<T, P> frexp(tvec4<T, P> const & x, tvec4<int, P> & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

		return tvec4<T, P>(
			frexp(x.x, exp.x),
			frexp(x.y, exp.y),
			frexp(x.z, exp.z),
			frexp(x.w, exp.w));
	}

	template <typename genType, precision P>
	 inline genType ldexp(genType const & x, int const & exp)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'ldexp' only accept floating-point inputs");

		return std::ldexp(x, exp);
	}

	template <typename T, precision P>
	 inline tvec1<T, P> ldexp(tvec1<T, P> const & x, tvec1<int, P> const & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

		return tvec1<T, P>(
			ldexp(x.x, exp.x));
	}

	template <typename T, precision P>
	 inline tvec2<T, P> ldexp(tvec2<T, P> const & x, tvec2<int, P> const & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

		return tvec2<T, P>(
			ldexp(x.x, exp.x),
			ldexp(x.y, exp.y));
	}

	template <typename T, precision P>
	 inline tvec3<T, P> ldexp(tvec3<T, P> const & x, tvec3<int, P> const & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

		return tvec3<T, P>(
			ldexp(x.x, exp.x),
			ldexp(x.y, exp.y),
			ldexp(x.z, exp.z));
	}

	template <typename T, precision P>
	 inline tvec4<T, P> ldexp(tvec4<T, P> const & x, tvec4<int, P> const & exp)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

		return tvec4<T, P>(
			ldexp(x.x, exp.x),
			ldexp(x.y, exp.y),
			ldexp(x.z, exp.z),
			ldexp(x.w, exp.w));
	}
}
#line 456 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_common.hpp"

#line 35 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_geometric.inl"




namespace glm{
namespace detail
{
	template <template <class, precision> class vecType, typename T, precision P>
	struct compute_dot{};

	template <typename T, precision P>
	struct compute_dot<tvec1, T, P>
	{
		 inline static T call(tvec1<T, P> const & a, tvec1<T, P> const & b)
		{
			return a.x * b.x;
		}
	};

	template <typename T, precision P>
	struct compute_dot<tvec2, T, P>
	{
		 inline static T call(tvec2<T, P> const & x, tvec2<T, P> const & y)
		{
			tvec2<T, P> tmp(x * y);
			return tmp.x + tmp.y;
		}
	};

	template <typename T, precision P>
	struct compute_dot<tvec3, T, P>
	{
		 inline static T call(tvec3<T, P> const & x, tvec3<T, P> const & y)
		{
			tvec3<T, P> tmp(x * y);
			return tmp.x + tmp.y + tmp.z;
		}
	};

	template <typename T, precision P>
	struct compute_dot<tvec4, T, P>
	{
		 inline static T call(tvec4<T, P> const & x, tvec4<T, P> const & y)
		{
			tvec4<T, P> tmp(x * y);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};
}

	
	template <typename genType>
	 inline genType length(genType x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'length' only accept floating-point inputs");

		return abs(x);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline T length(vecType<T, P> const & v)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'length' only accept floating-point inputs");

		return sqrt(dot(v, v));
	}

	
	template <typename genType>
	 inline genType distance(genType const & p0, genType const & p1)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'distance' only accept floating-point inputs");

		return length(p1 - p0);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline T distance(vecType<T, P> const & p0, vecType<T, P> const & p1)
	{
		return length(p1 - p0);
	}

	
	template <typename T>
	 inline T dot(T x, T y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' only accept floating-point inputs");
		return x * y;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline T dot(vecType<T, P> const & x, vecType<T, P> const & y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'dot' only accept floating-point inputs");
		return detail::compute_dot<vecType, T, P>::call(x, y);
	}

	
	template <typename T, precision P>
	 inline tvec3<T, P> cross(tvec3<T, P> const & x, tvec3<T, P> const & y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'cross' only accept floating-point inputs");

		return tvec3<T, P>(
			x.y * y.z - y.y * x.z,
			x.z * y.x - y.z * x.x,
			x.x * y.y - y.x * x.y);
	}

	
	template <typename genType>
	 inline genType normalize(genType const & x)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'normalize' only accept floating-point inputs");

		return x < genType(0) ? genType(-1) : genType(1);
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> normalize(vecType<T, P> const & x)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'normalize' only accept floating-point inputs");

		return x * inversesqrt(dot(x, x));
	}

	
	template <typename genType>
	 inline genType faceforward(genType const & N, genType const & I, genType const & Nref)
	{
		return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> faceforward(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)
	{
		return dot(Nref, I) < static_cast<T>(0) ? N : -N;
	}

	
	template <typename genType>
	 inline genType reflect(genType const & I, genType const & N)
	{
		return I - N * dot(N, I) * static_cast<genType>(2);
	}

	
	template <typename genType>
	 inline genType refract(genType const & I, genType const & N, genType const & eta)
	{
		static_assert(std::numeric_limits<genType>::is_iec559, "'refract' only accept floating-point inputs");

		genType const dotValue(dot(N, I));
		genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
		return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
	}

	template <typename T, precision P, template <typename, precision> class vecType>
	 inline vecType<T, P> refract(vecType<T, P> const & I, vecType<T, P> const & N, T eta)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'refract' only accept floating-point inputs");

		T const dotValue(dot(N, I));
		T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
		return (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));
	}
}
#line 143 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_geometric.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\geometric.hpp"
#line 35 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\exponential.hpp"
































#pragma once


#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl"


namespace glm{
namespace detail
{
	template <typename T, precision P>
	struct compute_dot<tquat, T, P>
	{
		static  inline T call(tquat<T, P> const & x, tquat<T, P> const & y)
		{
			tvec4<T, P> tmp(x.x * y.x, x.y * y.y, x.z * y.z, x.w * y.w);
			return (tmp.x + tmp.y) + (tmp.z + tmp.w);
		}
	};
}

	
	






















		template <typename T, precision P>
		 inline  typename tquat<T, P>::length_type tquat<T, P>::length() const
		{
			return 4;
		}

		template <typename T, precision P>
		 inline T & tquat<T, P>::operator[](typename tquat<T, P>::length_type i)
		{
			(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl", (unsigned)(85)), 0) );
			return (&x)[i];
		}

		template <typename T, precision P>
		 inline T const & tquat<T, P>::operator[](typename tquat<T, P>::length_type i) const
		{
			(void)( (!!(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this))) || (_wassert(L"i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl", (unsigned)(92)), 0) );
			return (&x)[i];
		}
#line 96 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl"

	
	

	template <typename T, precision P>
	 inline tquat<T, P>::tquat()

			: x(0), y(0), z(0), w(1)
#line 105 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl"
	{}

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(tquat<T, P> const & q)
		: x(q.x), y(q.y), z(q.z), w(q.w)
	{}

	template <typename T, precision P>
	template <precision Q>
	 inline tquat<T, P>::tquat(tquat<T, Q> const & q)
		: x(q.x), y(q.y), z(q.z), w(q.w)
	{}

	
	

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(ctor)
	{}

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(T const & s, tvec3<T, P> const & v)
		: x(v.x), y(v.y), z(v.z), w(s)
	{}

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(T const & w, T const & x, T const & y, T const & z)
		: x(x), y(y), z(z), w(w)
	{}

	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tquat<T, P>::tquat(tquat<U, Q> const & q)
		: x(static_cast<T>(q.x))
		, y(static_cast<T>(q.y))
		, z(static_cast<T>(q.z))
		, w(static_cast<T>(q.w))
	{}

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(tvec3<T, P> const & u, tvec3<T, P> const & v)
	{
		tvec3<T, P> const LocalW(cross(u, v));
		T Dot = detail::compute_dot<tvec3, T, P>::call(u, v);
		tquat<T, P> q(T(1) + Dot, LocalW.x, LocalW.y, LocalW.z);

		*this = normalize(q);
	}

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(tvec3<T, P> const & eulerAngle)
	{
		tvec3<T, P> c = glm::cos(eulerAngle * T(0.5));
		tvec3<T, P> s = glm::sin(eulerAngle * T(0.5));
		
		this->w = c.x * c.y * c.z + s.x * s.y * s.z;
		this->x = s.x * c.y * c.z - c.x * s.y * s.z;
		this->y = c.x * s.y * c.z + s.x * c.y * s.z;
		this->z = c.x * c.y * s.z - s.x * s.y * c.z;
	}

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(tmat3x3<T, P> const & m)
	{
		*this = quat_cast(m);
	}

	template <typename T, precision P>
	 inline tquat<T, P>::tquat(tmat4x4<T, P> const & m)
	{
		*this = quat_cast(m);
	}


	template <typename T, precision P>
	 inline tquat<T, P>::operator tmat3x3<T, P>()
	{
		return mat3_cast(*this);
	}
	
	template <typename T, precision P>	
	 inline tquat<T, P>::operator tmat4x4<T, P>()
	{
		return mat4_cast(*this);
	}
#line 212 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl"

	template <typename T, precision P>
	 inline tquat<T, P> conjugate(tquat<T, P> const & q)
	{
		return tquat<T, P>(q.w, -q.x, -q.y, -q.z);
	}

	template <typename T, precision P>
	 inline tquat<T, P> inverse(tquat<T, P> const & q)
	{
		return conjugate(q) / dot(q, q);
	}

	
	

	template <typename T, precision P>
	 inline tquat<T, P> & tquat<T, P>::operator=(tquat<T, P> const & q)
	{
		this->w = q.w;
		this->x = q.x;
		this->y = q.y;
		this->z = q.z;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator=(tquat<U, P> const & q)
	{
		this->w = static_cast<T>(q.w);
		this->x = static_cast<T>(q.x);
		this->y = static_cast<T>(q.y);
		this->z = static_cast<T>(q.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator+=(tquat<U, P> const & q)
	{
		this->w += static_cast<T>(q.w);
		this->x += static_cast<T>(q.x);
		this->y += static_cast<T>(q.y);
		this->z += static_cast<T>(q.z);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator*=(tquat<U, P> const & r)
	{
		tquat<T, P> const p(*this);
		tquat<T, P> const q(r);

		this->w = p.w * q.w - p.x * q.x - p.y * q.y - p.z * q.z;
		this->x = p.w * q.x + p.x * q.w + p.y * q.z - p.z * q.y;
		this->y = p.w * q.y + p.y * q.w + p.z * q.x - p.x * q.z;
		this->z = p.w * q.z + p.z * q.w + p.x * q.y - p.y * q.x;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator*=(U s)
	{
		this->w *= static_cast<U>(s);
		this->x *= static_cast<U>(s);
		this->y *= static_cast<U>(s);
		this->z *= static_cast<U>(s);
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tquat<T, P> & tquat<T, P>::operator/=(U s)
	{
		this->w /= static_cast<U>(s);
		this->x /= static_cast<U>(s);
		this->y /= static_cast<U>(s);
		this->z /= static_cast<U>(s);
		return *this;
	}

	
	

	template <typename T, precision P>
	 inline tquat<T, P> operator-(tquat<T, P> const & q)
	{
		return tquat<T, P>(-q.w, -q.x, -q.y, -q.z);
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator+(tquat<T, P> const & q,	tquat<T, P> const & p)
	{
		return tquat<T, P>(q) += p;
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator*(tquat<T, P> const & q,	tquat<T, P> const & p)
	{
		return tquat<T, P>(q) *= p;
	}

	
	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tquat<T, P> const & q,	tvec3<T, P> const & v)
	{
		tvec3<T, P> const QuatVector(q.x, q.y, q.z);
		tvec3<T, P> const uv(glm::cross(QuatVector, v));
		tvec3<T, P> const uuv(glm::cross(QuatVector, uv));

		return v + ((uv * q.w) + uuv) * static_cast<T>(2);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> operator*(tvec3<T, P> const & v, tquat<T, P> const & q)
	{
		return glm::inverse(q) * v;
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator*(tquat<T, P> const & q,	tvec4<T, P> const & v)
	{
		return tvec4<T, P>(q * tvec3<T, P>(v), v.w);
	}

	template <typename T, precision P>
	 inline tvec4<T, P> operator*(tvec4<T, P> const & v, tquat<T, P> const & q)
	{
		return glm::inverse(q) * v;
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator*(tquat<T, P> const & q, T const & s)
	{
		return tquat<T, P>(
			q.w * s, q.x * s, q.y * s, q.z * s);
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator*(T const & s, tquat<T, P> const & q)
	{
		return q * s;
	}

	template <typename T, precision P>
	 inline tquat<T, P> operator/(tquat<T, P> const & q, T const & s)
	{
		return tquat<T, P>(
			q.w / s, q.x / s, q.y / s, q.z / s);
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tquat<T, P> const & q1, tquat<T, P> const & q2)
	{
		return (q1.x == q2.x) && (q1.y == q2.y) && (q1.z == q2.z) && (q1.w == q2.w);
	}

	template <typename T, precision P>
	 inline bool operator!=(tquat<T, P> const & q1, tquat<T, P> const & q2)
	{
		return (q1.x != q2.x) || (q1.y != q2.y) || (q1.z != q2.z) || (q1.w != q2.w);
	}

	
	template <typename T, precision P>
	 inline T length(tquat<T, P> const & q)
	{
		return glm::sqrt(dot(q, q));
	}

	template <typename T, precision P>
	 inline tquat<T, P> normalize(tquat<T, P> const & q)
	{
		T len = length(q);
		if(len <= T(0)) 
			return tquat<T, P>(1, 0, 0, 0);
		T oneOverLen = T(1) / len;
		return tquat<T, P>(q.w * oneOverLen, q.x * oneOverLen, q.y * oneOverLen, q.z * oneOverLen);
	}

	template <typename T, precision P>
	 inline tquat<T, P> cross(tquat<T, P> const & q1, tquat<T, P> const & q2)
	{
		return tquat<T, P>(
			q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
			q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
			q1.w * q2.y + q1.y * q2.w + q1.z * q2.x - q1.x * q2.z,
			q1.w * q2.z + q1.z * q2.w + q1.x * q2.y - q1.y * q2.x);
	}













































































	template <typename T, precision P>
	 inline tquat<T, P> mix(tquat<T, P> const & x, tquat<T, P> const & y, T a)
	{
		T cosTheta = dot(x, y);

		
		if(cosTheta > T(1) - epsilon<T>())
		{
			
			return tquat<T, P>(
				mix(x.w, y.w, a),
				mix(x.x, y.x, a),
				mix(x.y, y.y, a),
				mix(x.z, y.z, a));
		}
		else
		{
			
			T angle = acos(cosTheta);
			return (sin((T(1) - a) * angle) * x + sin(a * angle) * y) / sin(angle);
		}
	}

	template <typename T, precision P>
	 inline tquat<T, P> lerp(tquat<T, P> const & x, tquat<T, P> const & y, T a)
	{
		
		(void)( (!!(a >= static_cast<T>(0))) || (_wassert(L"a >= static_cast<T>(0)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl", (unsigned)(511)), 0) );
		(void)( (!!(a <= static_cast<T>(1))) || (_wassert(L"a <= static_cast<T>(1)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl", (unsigned)(512)), 0) );

		return x * (T(1) - a) + (y * a);
	}

	template <typename T, precision P>
	 inline tquat<T, P> slerp(tquat<T, P> const & x,	tquat<T, P> const & y, T a)
	{
		tquat<T, P> z = y;

		T cosTheta = dot(x, y);

		
		
		if (cosTheta < T(0))
		{
			z        = -y;
			cosTheta = -cosTheta;
		}

		
		if(cosTheta > T(1) - epsilon<T>())
		{
			
			return tquat<T, P>(
				mix(x.w, z.w, a),
				mix(x.x, z.x, a),
				mix(x.y, z.y, a),
				mix(x.z, z.z, a));
		}
		else
		{
			
			T angle = acos(cosTheta);
			return (sin((T(1) - a) * angle) * x + sin(a * angle) * z) / sin(angle);
		}
	}

	template <typename T, precision P>
	 inline tquat<T, P> rotate(tquat<T, P> const & q, T const & angle, tvec3<T, P> const & v)
	{
		tvec3<T, P> Tmp = v;

		
		T len = glm::length(Tmp);
		if(abs(len - T(1)) > T(0.001))
		{
			T oneOverLen = static_cast<T>(1) / len;
			Tmp.x *= oneOverLen;
			Tmp.y *= oneOverLen;
			Tmp.z *= oneOverLen;
		}

		T const AngleRad(angle);
		T const Sin = sin(AngleRad * T(0.5));

		return q * tquat<T, P>(cos(AngleRad * T(0.5)), Tmp.x * Sin, Tmp.y * Sin, Tmp.z * Sin);
		
	}

	template <typename T, precision P>
	 inline tvec3<T, P> eulerAngles(tquat<T, P> const & x)
	{
		return tvec3<T, P>(pitch(x), yaw(x), roll(x));
	}

	template <typename T, precision P>
	 inline T roll(tquat<T, P> const & q)
	{
		return T(atan(T(2) * (q.x * q.y + q.w * q.z), q.w * q.w + q.x * q.x - q.y * q.y - q.z * q.z));
	}

	template <typename T, precision P>
	 inline T pitch(tquat<T, P> const & q)
	{
		return T(atan(T(2) * (q.y * q.z + q.w * q.x), q.w * q.w - q.x * q.x - q.y * q.y + q.z * q.z));
	}

	template <typename T, precision P>
	 inline T yaw(tquat<T, P> const & q)
	{
		return asin(T(-2) * (q.x * q.z - q.w * q.y));
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> mat3_cast(tquat<T, P> const & q)
	{
		tmat3x3<T, P> Result(T(1));
		T qxx(q.x * q.x);
		T qyy(q.y * q.y);
		T qzz(q.z * q.z);
		T qxz(q.x * q.z);
		T qxy(q.x * q.y);
		T qyz(q.y * q.z);
		T qwx(q.w * q.x);
		T qwy(q.w * q.y);
		T qwz(q.w * q.z);

		Result[0][0] = 1 - 2 * (qyy +  qzz);
		Result[0][1] = 2 * (qxy + qwz);
		Result[0][2] = 2 * (qxz - qwy);

		Result[1][0] = 2 * (qxy - qwz);
		Result[1][1] = 1 - 2 * (qxx +  qzz);
		Result[1][2] = 2 * (qyz + qwx);

		Result[2][0] = 2 * (qxz + qwy);
		Result[2][1] = 2 * (qyz - qwx);
		Result[2][2] = 1 - 2 * (qxx +  qyy);
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> mat4_cast(tquat<T, P> const & q)
	{
		return tmat4x4<T, P>(mat3_cast(q));
	}

	template <typename T, precision P>
	 inline tquat<T, P> quat_cast(tmat3x3<T, P> const & m)
	{
		T fourXSquaredMinus1 = m[0][0] - m[1][1] - m[2][2];
		T fourYSquaredMinus1 = m[1][1] - m[0][0] - m[2][2];
		T fourZSquaredMinus1 = m[2][2] - m[0][0] - m[1][1];
		T fourWSquaredMinus1 = m[0][0] + m[1][1] + m[2][2];

		int biggestIndex = 0;
		T fourBiggestSquaredMinus1 = fourWSquaredMinus1;
		if(fourXSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourXSquaredMinus1;
			biggestIndex = 1;
		}
		if(fourYSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourYSquaredMinus1;
			biggestIndex = 2;
		}
		if(fourZSquaredMinus1 > fourBiggestSquaredMinus1)
		{
			fourBiggestSquaredMinus1 = fourZSquaredMinus1;
			biggestIndex = 3;
		}

		T biggestVal = sqrt(fourBiggestSquaredMinus1 + T(1)) * T(0.5);
		T mult = static_cast<T>(0.25) / biggestVal;

		tquat<T, P> Result(uninitialize);
		switch(biggestIndex)
		{
		case 0:
			Result.w = biggestVal;
			Result.x = (m[1][2] - m[2][1]) * mult;
			Result.y = (m[2][0] - m[0][2]) * mult;
			Result.z = (m[0][1] - m[1][0]) * mult;
			break;
		case 1:
			Result.w = (m[1][2] - m[2][1]) * mult;
			Result.x = biggestVal;
			Result.y = (m[0][1] + m[1][0]) * mult;
			Result.z = (m[2][0] + m[0][2]) * mult;
			break;
		case 2:
			Result.w = (m[2][0] - m[0][2]) * mult;
			Result.x = (m[0][1] + m[1][0]) * mult;
			Result.y = biggestVal;
			Result.z = (m[1][2] + m[2][1]) * mult;
			break;
		case 3:
			Result.w = (m[0][1] - m[1][0]) * mult;
			Result.x = (m[2][0] + m[0][2]) * mult;
			Result.y = (m[1][2] + m[2][1]) * mult;
			Result.z = biggestVal;
			break;
			
		default:					
			(void)( (!!(false)) || (_wassert(L"false", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.inl", (unsigned)(688)), 0) );
			break;
		}
		return Result;
	}

	template <typename T, precision P>
	 inline tquat<T, P> quat_cast(tmat4x4<T, P> const & m4)
	{
		return quat_cast(tmat3x3<T, P>(m4));
	}

	template <typename T, precision P>
	 inline T angle(tquat<T, P> const & x)
	{
		return acos(x.w) * T(2);
	}

	template <typename T, precision P>
	 inline tvec3<T, P> axis(tquat<T, P> const & x)
	{
		T tmp1 = static_cast<T>(1) - x.w * x.w;
		if(tmp1 <= static_cast<T>(0))
			return tvec3<T, P>(0, 0, 1);
		T tmp2 = static_cast<T>(1) / sqrt(tmp1);
		return tvec3<T, P>(x.x * tmp2, x.y * tmp2, x.z * tmp2);
	}

	template <typename T, precision P>
	 inline tquat<T, P> angleAxis(T const & angle, tvec3<T, P> const & v)
	{
		tquat<T, P> Result(uninitialize);

		T const a(angle);
		T const s = glm::sin(a * static_cast<T>(0.5));

		Result.w = glm::cos(a * static_cast<T>(0.5));
		Result.x = v.x * s;
		Result.y = v.y * s;
		Result.z = v.z * s;
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> lessThan(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] < y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> lessThanEqual(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] <= y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> greaterThan(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] > y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> greaterThanEqual(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] >= y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> equal(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] == y[i];
		return Result;
	}

	template <typename T, precision P>
	 inline tvec4<bool, P> notEqual(tquat<T, P> const & x, tquat<T, P> const & y)
	{
		tvec4<bool, P> Result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
			Result[i] = x[i] != y[i];
		return Result;
	}
}
#line 378 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\quaternion.hpp"
#line 67 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"



#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat2x2.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.hpp"
































#pragma once







namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat2x2
	{
		typedef tvec2<T, P> col_type;
		typedef tvec2<T, P> row_type;
		typedef tmat2x2<T, P> type;
		typedef tmat2x2<T, P> transpose_type;
		typedef T value_type;

		template <typename U, precision Q>
		friend tvec2<U, Q> operator/(tmat2x2<U, Q> const & m, tvec2<U, Q> const & v);
		template <typename U, precision Q>
		friend tvec2<U, Q> operator/(tvec2<U, Q> const & v, tmat2x2<U, Q> const & m);

	private:
		
		col_type value[2];
		
		
	public:
		
		
		 tmat2x2();
		 tmat2x2(tmat2x2<T, P> const & m);
		template <precision Q>
		 tmat2x2(tmat2x2<T, Q> const & m);

		 explicit tmat2x2(ctor);
		 explicit tmat2x2(T const & x);
		 tmat2x2(
			T const & x1, T const & y1,
			T const & x2, T const & y2);
		 tmat2x2(
			col_type const & v1,
			col_type const & v2);

		
		
		template <typename U, typename V, typename M, typename N>
		 tmat2x2(
			U const & x1, V const & y1,
			M const & x2, N const & y2);

		template <typename U, typename V>
		 tmat2x2(
			tvec2<U, P> const & v1,
			tvec2<V, P> const & v2);

		
		





			template <typename U, precision Q>
			 tmat2x2(tmat2x2<U, Q> const & m);
#line 101 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.hpp"

		 explicit tmat2x2(tmat3x3<T, P> const & x);
		 explicit tmat2x2(tmat4x4<T, P> const & x);
		 explicit tmat2x2(tmat2x3<T, P> const & x);
		 explicit tmat2x2(tmat3x2<T, P> const & x);
		 explicit tmat2x2(tmat2x4<T, P> const & x);
		 explicit tmat2x2(tmat4x2<T, P> const & x);
		 explicit tmat2x2(tmat3x4<T, P> const & x);
		 explicit tmat2x2(tmat4x3<T, P> const & x);

		
		








			typedef length_t length_type;
			  length_type length() const;

			 col_type & operator[](length_type i);
			 col_type const & operator[](length_type i) const;
#line 127 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.hpp"

		
		

		 tmat2x2<T, P> & operator=(tmat2x2<T, P> const & v);

		template <typename U> 
		 tmat2x2<T, P> & operator=(tmat2x2<U, P> const & m);
		template <typename U> 
		 tmat2x2<T, P> & operator+=(U s);
		template <typename U> 
		 tmat2x2<T, P> & operator+=(tmat2x2<U, P> const & m);
		template <typename U> 
		 tmat2x2<T, P> & operator-=(U s);
		template <typename U> 
		 tmat2x2<T, P> & operator-=(tmat2x2<U, P> const & m);
		template <typename U> 
		 tmat2x2<T, P> & operator*=(U s);
		template <typename U> 
		 tmat2x2<T, P> & operator*=(tmat2x2<U, P> const & m);
		template <typename U> 
		 tmat2x2<T, P> & operator/=(U s);
		template <typename U> 
		 tmat2x2<T, P> & operator/=(tmat2x2<U, P> const & m);

		
		

		 tmat2x2<T, P> & operator++ ();
		 tmat2x2<T, P> & operator-- ();
		 tmat2x2<T, P> operator++(int);
		 tmat2x2<T, P> operator--(int);
	};

	
	template <typename T, precision P>
	 tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(T const & s, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1,	tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(T const & s, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1,	tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat2x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(T const & s, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::col_type operator*(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::row_type operator*(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1,	tmat2x2<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x2<T, P> operator/(tmat2x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x2<T, P> operator/(T const & s, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

	
	template <typename T, precision P> 
	 tmat2x2<T, P> const operator-(tmat2x2<T, P> const & m);
} 


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.inl"
































namespace glm{
namespace detail
{
	template <typename T, precision P>
	 inline tmat2x2<T, P> compute_inverse(tmat2x2<T, P> const & m)
	{
		T OneOverDeterminant = static_cast<T>(1) / (
			+ m[0][0] * m[1][1]
			- m[1][0] * m[0][1]);

		tmat2x2<T, P> Inverse(
			+ m[1][1] * OneOverDeterminant,
			- m[0][1] * OneOverDeterminant,
			- m[1][0] * OneOverDeterminant,
			+ m[0][0] * OneOverDeterminant);

		return Inverse;
	}
}

	
	

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2()
	{

			this->value[0] = col_type(1, 0);
			this->value[1] = col_type(0, 1);
#line 63 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.inl"
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat2x2<T, P> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P>
	template <precision Q>
	 inline tmat2x2<T, P>::tmat2x2(tmat2x2<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(ctor)
	{}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(T const & s)
	{
		this->value[0] = col_type(s, 0);
		this->value[1] = col_type(0, s);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2
	(
		T const & x0, T const & y0,
		T const & x1, T const & y1
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(col_type const & v0, col_type const & v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	
	
	template <typename T, precision P>
	template <typename X1, typename Y1, typename X2, typename Y2>
	 inline tmat2x2<T, P>::tmat2x2
	(
		X1 const & x1, Y1 const & y1,
		X2 const & x2, Y2 const & y2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2>
	 inline tmat2x2<T, P>::tmat2x2(tvec2<V1, P> const & v1, tvec2<V2, P> const & v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat2x2<T, P>::tmat2x2(tmat2x2<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x2<T, P>::tmat2x2(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat3x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat4x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>::tmat2x2(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	
	






















		template <typename T, precision P>
		 inline  typename tmat2x2<T, P>::length_type tmat2x2<T, P>::length() const
		{
			return 2;
		}

		template <typename T, precision P>
		 inline typename tmat2x2<T, P>::col_type & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i)
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.inl", (unsigned)(231)), 0) );
			return this->value[i];
		}

		template <typename T, precision P>
		 inline typename tmat2x2<T, P>::col_type const & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i) const
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.inl", (unsigned)(238)), 0) );
			return this->value[i];
		}
#line 242 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.inl"

	
	

	template <typename T, precision P>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator+=(tmat2x2<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator-=(tmat2x2<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator*=(tmat2x2<U, P> const & m)
	{
		return (*this = *this * m);
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator/=(tmat2x2<U, P> const & m)
	{
		return (*this = *this * detail::compute_inverse<T, P>(m));
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P>& tmat2x2<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> tmat2x2<T, P>::operator++(int)
	{
		tmat2x2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> tmat2x2<T, P>::operator--(int)
	{
		tmat2x2<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T const & s)
	{
		return tmat2x2<T, P>(
			m[0] + s,
			m[1] + s);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator+(T const & s, tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			m[0] + s,
			m[1] + s);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x2<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T const & s)
	{
		return tmat2x2<T, P>(
			m[0] - s,
			m[1] - s);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator-(T const & s, tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			s - m[0],
			s - m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x2<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(tmat2x2<T, P> const & m,	T const & s)
	{
		return tmat2x2<T, P>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(T const & s, tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::col_type operator*
	(
		tmat2x2<T, P> const & m,
		typename tmat2x2<T, P>::row_type const & v
	)
	{
		return tvec2<T, P>(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y);
	}

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::row_type operator*
	(
		typename tmat2x2<T, P>::col_type const & v,
		tmat2x2<T, P> const & m
	)
	{
		return tvec2<T, P>(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
	}

	template <typename T, precision P> 
	 inline tmat2x2<T, P> operator/(tmat2x2<T, P> const & m,	T const & s)
	{
		return tmat2x2<T, P>(
			m[0] / s,
			m[1] / s);
	}

	template <typename T, precision P> 
	 inline tmat2x2<T, P> operator/(T const & s, tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			s / m[0],
			s / m[1]);
	}

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v)
	{
		return detail::compute_inverse<T, P>(m) * v;
	}

	template <typename T, precision P>
	 inline typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m)
	{
		return v * detail::compute_inverse<T, P>(m);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{	
		tmat2x2<T, P> m1_copy(m1);
		return m1_copy /= m2;
	}

	
	template <typename T, precision P>
	 inline tmat2x2<T, P> const operator-(tmat2x2<T, P> const & m)
	{
		return tmat2x2<T, P>(
			-m[0], 
			-m[1]);
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 223 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.hpp"
#line 224 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x2.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat2x2.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat2x2<float, lowp>		lowp_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, mediump>		mediump_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, highp>		highp_mat2;
	
	
	
	
	
	
	typedef tmat2x2<float, lowp>		lowp_mat2x2;
	
	
	
	
	
	
	typedef tmat2x2<float, mediump>		mediump_mat2x2;
	
	
	
	
	
	
	typedef tmat2x2<float, highp>		highp_mat2x2;

}
#line 71 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat2x3.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.hpp"
































#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat2x3
	{
		typedef tvec3<T, P> col_type;
		typedef tvec2<T, P> row_type;
		typedef tmat2x3<T, P> type;
		typedef tmat3x2<T, P> transpose_type;
		typedef T value_type;

	private:
		
		col_type value[2];
		
		
	public:
		
		 tmat2x3();
		 tmat2x3(tmat2x3<T, P> const & m);
		template <precision Q>
		 tmat2x3(tmat2x3<T, Q> const & m);

		 explicit tmat2x3(ctor);
		 explicit tmat2x3(T const & s);
		 tmat2x3(
			T const & x0, T const & y0, T const & z0,
			T const & x1, T const & y1, T const & z1);
		 tmat2x3(
			col_type const & v0,
			col_type const & v1);

		
		

		template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
		 tmat2x3(
			X1 const & x1, Y1 const & y1, Z1 const & z1,
			X2 const & x2, Y2 const & y2, Z2 const & z2);
			
		template <typename U, typename V>
		 tmat2x3(
			tvec3<U, P> const & v1,
			tvec3<V, P> const & v2);

		
		





			template <typename U, precision Q>
			 tmat2x3(tmat2x3<U, Q> const & m);
#line 97 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.hpp"

		 explicit tmat2x3(tmat2x2<T, P> const & x);
		 explicit tmat2x3(tmat3x3<T, P> const & x);
		 explicit tmat2x3(tmat4x4<T, P> const & x);
		 explicit tmat2x3(tmat2x4<T, P> const & x);
		 explicit tmat2x3(tmat3x2<T, P> const & x);
		 explicit tmat2x3(tmat3x4<T, P> const & x);
		 explicit tmat2x3(tmat4x2<T, P> const & x);
		 explicit tmat2x3(tmat4x3<T, P> const & x);

		
		








			typedef length_t length_type;
			  length_type length() const;

			 col_type & operator[](length_type i);
			 col_type const & operator[](length_type i) const;
#line 123 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.hpp"

		
		

		 tmat2x3<T, P> & operator=(tmat2x3<T, P> const & m);

		template <typename U> 
		 tmat2x3<T, P> & operator=(tmat2x3<U, P> const & m);
		template <typename U> 
		 tmat2x3<T, P> & operator+=(U s);
		template <typename U> 
		 tmat2x3<T, P> & operator+=(tmat2x3<U, P> const & m);
		template <typename U> 
		 tmat2x3<T, P> & operator-=(U s);
		template <typename U> 
		 tmat2x3<T, P> & operator-=(tmat2x3<U, P> const & m);
		template <typename U> 
		 tmat2x3<T, P> & operator*=(U s);
		template <typename U> 
		 tmat2x3<T, P> & operator/=(U s);

		
		

		 tmat2x3<T, P> & operator++ ();
		 tmat2x3<T, P> & operator-- ();
		 tmat2x3<T, P> operator++(int);
		 tmat2x3<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat2x3<T, P> operator+(tmat2x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x3<T, P> operator+(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator-(tmat2x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x3<T, P> operator-(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat2x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(T const & s, tmat2x3<T, P> const & m);

	template <typename T, precision P>
	 typename tmat2x3<T, P>::col_type operator*(tmat2x3<T, P> const & m, typename tmat2x3<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat2x3<T, P>::row_type operator*(typename tmat2x3<T, P>::col_type const & v, tmat2x3<T, P> const & m);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x3<T, P> operator/(tmat2x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x3<T, P> operator/(T const & s, tmat2x3<T, P> const & m);

	
	template <typename T, precision P>
	 tmat2x3<T, P> const operator-(tmat2x3<T, P> const & m);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.inl"
































namespace glm
{
	
	

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3()
	{

			this->value[0] = col_type(1, 0, 0);
			this->value[1] = col_type(0, 1, 0);
#line 45 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.inl"
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P>::tmat2x3(tmat2x3<T, P> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P>
	template <precision Q>
	 inline tmat2x3<T, P>::tmat2x3(tmat2x3<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(ctor)
	{}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(T const & s)
	{
		this->value[0] = col_type(s, 0, 0);
		this->value[1] = col_type(0, s, 0);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3
	(
		T const & x0, T const & y0, T const & z0,
		T const & x1, T const & y1, T const & z1
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(col_type const & v0, col_type const & v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	
	
	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2>
	 inline tmat2x3<T, P>::tmat2x3
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1,
		X2 const & x2, Y2 const & y2, Z2 const & z2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2>
	 inline tmat2x3<T, P>::tmat2x3(tvec3<V1, P> const & v1, tvec3<V2, P> const & v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat2x3<T, P>::tmat2x3(tmat2x3<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P>::tmat2x3(tmat4x3<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	
	






















		template <typename T, precision P>
		 inline  typename tmat2x3<T, P>::length_type tmat2x3<T, P>::length() const
		{
			return 2;
		}

		template <typename T, precision P>
		 inline typename tmat2x3<T, P>::col_type & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i)
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.inl", (unsigned)(215)), 0) );
			return this->value[i];
		}

		template <typename T, precision P>
		 inline typename tmat2x3<T, P>::col_type const & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i) const
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.inl", (unsigned)(222)), 0) );
			return this->value[i];
		}
#line 226 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.inl"

	
	

	template <typename T, precision P>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P> & tmat2x3<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator+=(tmat2x3<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator-=(tmat2x3<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P>& tmat2x3<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x3<T, P> & tmat2x3<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> & tmat2x3<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> & tmat2x3<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> tmat2x3<T, P>::operator++(int)
	{
		tmat2x3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> tmat2x3<T, P>::operator--(int)
	{
		tmat2x3<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator+(tmat2x3<T, P> const & m, T const & s)
	{
		return tmat2x3<T, P>(
			m[0] + s,
			m[1] + s);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator+(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator-(tmat2x3<T, P> const & m, T const & s)
	{
		return tmat2x3<T, P>(
			m[0] - s,
			m[1] - s);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator-(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x3<T, P> operator*(tmat2x3<T, P> const & m, T const & s)
	{
		return tmat2x3<T, P>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator*(T const & s, tmat2x3<T, P> const & m)
	{
		return tmat2x3<T, P>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T, precision P>
	 inline typename tmat2x3<T, P>::col_type operator*
	(
		tmat2x3<T, P> const & m,
		typename tmat2x3<T, P>::row_type const & v)
	{
		return typename tmat2x3<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y);
	}

	template <typename T, precision P>
	 inline typename tmat2x3<T, P>::row_type operator*
	(
		typename tmat2x3<T, P>::col_type const & v,
		tmat2x3<T, P> const & m)
	{
		return typename tmat2x3<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];

		tmat3x3<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator/(tmat2x3<T, P> const & m, T const & s)
	{
		return tmat2x3<T, P>(
			m[0] / s,
			m[1] / s);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator/(T const & s,	tmat2x3<T, P> const & m)
	{
		return tmat2x3<T, P>(
			s / m[0],
			s / m[1]);
	}

	
	template <typename T, precision P>
	 inline tmat2x3<T, P> const operator-(tmat2x3<T, P> const & m)
	{
		return tmat2x3<T, P>(
			-m[0],
			-m[1]);
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 201 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.hpp"
#line 202 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x3.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat2x3.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat2x3<float, lowp>		lowp_mat2x3;

	
	
	
	
	
	typedef tmat2x3<float, mediump>		mediump_mat2x3;

	
	
	
	
	
	typedef tmat2x3<float, highp>		highp_mat2x3;

}

#line 72 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat2x4.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.hpp"
































#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat2x4
	{
		typedef tvec4<T, P> col_type;
		typedef tvec2<T, P> row_type;
		typedef tmat2x4<T, P> type;
		typedef tmat4x2<T, P> transpose_type;
		typedef T value_type;

	private:
		
		col_type value[2];
		
		
	public:
		
		 tmat2x4();
		 tmat2x4(tmat2x4<T, P> const & m);
		template <precision Q>
		 tmat2x4(tmat2x4<T, Q> const & m);

		 explicit tmat2x4(ctor);
		 explicit tmat2x4(T const & s);
		 tmat2x4(
			T const & x0, T const & y0, T const & z0, T const & w0,
			T const & x1, T const & y1, T const & z1, T const & w1);
		 tmat2x4(
			col_type const & v0, 
			col_type const & v1);

		
		
		template <
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2>
		 tmat2x4(
			X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
			X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2);

		template <typename U, typename V>
		 tmat2x4(
			tvec4<U, P> const & v1,
			tvec4<V, P> const & v2);

		
		





			template <typename U, precision Q>
			 tmat2x4(tmat2x4<U, Q> const & m);
#line 98 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.hpp"

		 explicit tmat2x4(tmat2x2<T, P> const & x);
		 explicit tmat2x4(tmat3x3<T, P> const & x);
		 explicit tmat2x4(tmat4x4<T, P> const & x);
		 explicit tmat2x4(tmat2x3<T, P> const & x);
		 explicit tmat2x4(tmat3x2<T, P> const & x);
		 explicit tmat2x4(tmat3x4<T, P> const & x);
		 explicit tmat2x4(tmat4x2<T, P> const & x);
		 explicit tmat2x4(tmat4x3<T, P> const & x);

		
		








			typedef length_t length_type;
			  length_type length() const;

			 col_type & operator[](length_type i);
			 col_type const & operator[](length_type i) const;
#line 124 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.hpp"

		
		

		 tmat2x4<T, P> & operator=(tmat2x4<T, P> const & m);

		template <typename U> 
		 tmat2x4<T, P> & operator=(tmat2x4<U, P> const & m);
		template <typename U> 
		 tmat2x4<T, P> & operator+=(U s);
		template <typename U> 
		 tmat2x4<T, P> & operator+=(tmat2x4<U, P> const & m);
		template <typename U> 
		 tmat2x4<T, P> & operator-=(U s);
		template <typename U> 
		 tmat2x4<T, P> & operator-=(tmat2x4<U, P> const & m);
		template <typename U> 
		 tmat2x4<T, P> & operator*=(U s);
		template <typename U> 
		 tmat2x4<T, P> & operator/=(U s);

		
		

		 tmat2x4<T, P> & operator++ ();
		 tmat2x4<T, P> & operator-- ();
		 tmat2x4<T, P> operator++(int);
		 tmat2x4<T, P> operator--(int);
	};

	

	template <typename T, precision P>
	 tmat2x4<T, P> operator+(tmat2x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x4<T, P> operator+(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator-(tmat2x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x4<T, P> operator-(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat2x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat2x4<T, P> operator*(T const & s, tmat2x4<T, P> const & m);

	template <typename T, precision P>
	 typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> const & m, typename tmat2x4<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type const & v, tmat2x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat4x2<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat2x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat3x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat2x4<T, P> operator/(tmat2x4<T, P> const & m, T s);

	template <typename T, precision P> 
	 tmat2x4<T, P> operator/(T s, tmat2x4<T, P> const & m);

	
	template <typename T, precision P>
	 tmat2x4<T, P> const operator-(tmat2x4<T, P> const & m);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.inl"
































namespace glm
{
	
	

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4()
	{

			this->value[0] = col_type(1, 0, 0, 0);
			this->value[1] = col_type(0, 1, 0, 0);
#line 45 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.inl"
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat2x4<T, P> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P>
	template <precision Q>
	 inline tmat2x4<T, P>::tmat2x4(tmat2x4<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(ctor)
	{}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(T const & s)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, s, Zero, Zero);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4
	(
		T const & x0, T const & y0, T const & z0, T const & w0,
		T const & x1, T const & y1, T const & z1, T const & w1
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(col_type const & v0, col_type const & v1)
	{
		this->value[0] = v0;
		this->value[1] = v1;
	}

	
	
	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2>
	 inline tmat2x4<T, P>::tmat2x4
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
		X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2>
	 inline tmat2x4<T, P>::tmat2x4(tvec4<V1, P> const & v1, tvec4<V2, P> const & v2)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
	}

	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat2x4<T, P>::tmat2x4(tmat2x4<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat3x4<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>::tmat2x4(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
	}

	
	






















		template <typename T, precision P>
		 inline  typename tmat2x4<T, P>::length_type tmat2x4<T, P>::length() const
		{
			return 2;
		}

		template <typename T, precision P>
		 inline typename tmat2x4<T, P>::col_type & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i)
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.inl", (unsigned)(216)), 0) );
			return this->value[i];
		}

		template <typename T, precision P>
		 inline typename tmat2x4<T, P>::col_type const & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i) const
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.inl", (unsigned)(223)), 0) );
			return this->value[i];
		}
#line 227 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.inl"

	
	

	template <typename T, precision P>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator+=(tmat2x4<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator-=(tmat2x4<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat2x4<T, P> & tmat2x4<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P>& tmat2x4<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> tmat2x4<T, P>::operator++(int)
	{
		tmat2x4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> tmat2x4<T, P>::operator--(int)
	{
		tmat2x4<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator+(tmat2x4<T, P> const & m, T const & s)
	{
		return tmat2x4<T, P>(
			m[0] + s,
			m[1] + s);
	}

	template <typename T, precision P> 
	 inline tmat2x4<T, P> operator+(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1]);
	}

	template <typename T, precision P> 
	 inline tmat2x4<T, P> operator-(tmat2x4<T, P> const & m, T const & s)
	{
		return tmat2x4<T, P>(
			m[0] - s,
			m[1] - s);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator-(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1]);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator*(tmat2x4<T, P> const & m, T const & s)
	{
		return tmat2x4<T, P>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T, precision P> 
	 inline tmat2x4<T, P> operator*(T const & s, tmat2x4<T, P> const & m)
	{
		return tmat2x4<T, P>(
			m[0] * s,
			m[1] * s);
	}

	template <typename T, precision P>
	 inline typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> const & m, typename tmat2x4<T, P>::row_type const & v)
	{
		return typename tmat2x4<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y,
			m[0][1] * v.x + m[1][1] * v.y,
			m[0][2] * v.x + m[1][2] * v.y,
			m[0][3] * v.x + m[1][3] * v.y);
	}

	template <typename T, precision P>
	 inline typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type const & v, tmat2x4<T, P> const & m)
	{
		return typename tmat2x4<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		T SrcA00 = m1[0][0];
		T SrcA01 = m1[0][1];
		T SrcA02 = m1[0][2];
		T SrcA03 = m1[0][3];
		T SrcA10 = m1[1][0];
		T SrcA11 = m1[1][1];
		T SrcA12 = m1[1][2];
		T SrcA13 = m1[1][3];

		T SrcB00 = m2[0][0];
		T SrcB01 = m2[0][1];
		T SrcB10 = m2[1][0];
		T SrcB11 = m2[1][1];
		T SrcB20 = m2[2][0];
		T SrcB21 = m2[2][1];
		T SrcB30 = m2[3][0];
		T SrcB31 = m2[3][1];

		tmat4x4<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat2x2<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
	}

	template <typename T, precision P> 
	 inline tmat2x4<T, P> operator/(tmat2x4<T, P> const & m, T s)
	{
		return tmat2x4<T, P>(
			m[0] / s,
			m[1] / s);
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator/(T s, tmat2x4<T, P> const & m)
	{
		return tmat2x4<T, P>(
			s / m[0],
			s / m[1]);
	}

	
	template <typename T, precision P>
	 inline tmat2x4<T, P> const operator-(tmat2x4<T, P> const & m)
	{
		return tmat2x4<T, P>(
			-m[0], 
			-m[1]);
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]);
	}
} 
#line 202 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.hpp"
#line 203 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat2x4.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat2x4.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat2x4<float, lowp>		lowp_mat2x4;
	
	
	
	
	
	
	typedef tmat2x4<float, mediump>		mediump_mat2x4;
	
	
	
	
	
	
	typedef tmat2x4<float, highp>		highp_mat2x4;

}
#line 73 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat3x2.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.hpp"
































#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat3x2
	{
		typedef tvec2<T, P> col_type;
		typedef tvec3<T, P> row_type;
		typedef tmat3x2<T, P> type;
		typedef tmat2x3<T, P> transpose_type;
		typedef T value_type;

	private:
		
		col_type value[3];
		
		
	public:
		
		 tmat3x2();
		 tmat3x2(tmat3x2<T, P> const & m);
		template <precision Q>
		 tmat3x2(tmat3x2<T, Q> const & m);

		 explicit tmat3x2(ctor);
		 explicit tmat3x2(T const & s);
		 tmat3x2(
			T const & x0, T const & y0,
			T const & x1, T const & y1,
			T const & x2, T const & y2);
		 tmat3x2(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2);

		
		

		template<
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3>
		 tmat3x2(
			X1 const & x1, Y1 const & y1,
			X2 const & x2, Y2 const & y2,
			X3 const & x3, Y3 const & y3);
			
		template <typename V1, typename V2, typename V3>
		 tmat3x2(
			tvec2<V1, P> const & v1,
			tvec2<V2, P> const & v2,
			tvec2<V3, P> const & v3);

		
		





			template <typename U, precision Q>
			 tmat3x2(tmat3x2<U, Q> const & m);
#line 104 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.hpp"

		 explicit tmat3x2(tmat2x2<T, P> const & x);
		 explicit tmat3x2(tmat3x3<T, P> const & x);
		 explicit tmat3x2(tmat4x4<T, P> const & x);
		 explicit tmat3x2(tmat2x3<T, P> const & x);
		 explicit tmat3x2(tmat2x4<T, P> const & x);
		 explicit tmat3x2(tmat3x4<T, P> const & x);
		 explicit tmat3x2(tmat4x2<T, P> const & x);
		 explicit tmat3x2(tmat4x3<T, P> const & x);

		
		








			typedef length_t length_type;
			  length_type length() const;

			 col_type & operator[](length_type i);
			 col_type const & operator[](length_type i) const;
#line 130 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.hpp"

		
		

		 tmat3x2<T, P> & operator=(tmat3x2<T, P> const & m);

		template <typename U> 
		 tmat3x2<T, P> & operator=(tmat3x2<U, P> const & m);
		template <typename U> 
		 tmat3x2<T, P> & operator+=(U s);
		template <typename U> 
		 tmat3x2<T, P> & operator+=(tmat3x2<U, P> const & m);
		template <typename U> 
		 tmat3x2<T, P> & operator-=(U s);
		template <typename U> 
		 tmat3x2<T, P> & operator-=(tmat3x2<U, P> const & m);
		template <typename U> 
		 tmat3x2<T, P> & operator*=(U s);
		template <typename U> 
		 tmat3x2<T, P> & operator/=(U s);

		
		

		 tmat3x2<T, P> & operator++ ();
		 tmat3x2<T, P> & operator-- ();
		 tmat3x2<T, P> operator++(int);
		 tmat3x2<T, P> operator--(int);
	};

	
	template <typename T, precision P>
	 tmat3x2<T, P> operator+(tmat3x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x2<T, P> operator+(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator-(tmat3x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x2<T, P> operator-(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat3x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(T const & s, tmat3x2<T, P> const & m);

	template <typename T, precision P>
	 typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> const & m, typename tmat3x2<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type const & v, tmat3x2<T, P> const & m);

	template <typename T, precision P>
	 tmat2x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat2x3<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat3x3<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x2<T, P> operator/(tmat3x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x2<T, P> operator/(T const & s, tmat3x2<T, P> const & m);

	
	template <typename T, precision P>
	 tmat3x2<T, P> const operator-(tmat3x2<T, P> const & m);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.inl"
































namespace glm
{
	
	

	template <typename T, precision P> 
	 inline tmat3x2<T, P>::tmat3x2()
	{

			this->value[0] = col_type(1, 0);
			this->value[1] = col_type(0, 1);
			this->value[2] = col_type(0, 0);
#line 46 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.inl"
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat3x2<T, P> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	template <precision Q>
	 inline tmat3x2<T, P>::tmat3x2(tmat3x2<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(ctor)
	{}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(T const & s)
	{
		this->value[0] = col_type(s, 0);
		this->value[1] = col_type(0, s);
		this->value[2] = col_type(0, 0);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2
	(
		T const & x0, T const & y0,
		T const & x1, T const & y1,
		T const & x2, T const & y2
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	
	
	template <typename T, precision P>
	template <
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3>
	 inline tmat3x2<T, P>::tmat3x2
	(
		X1 const & x1, Y1 const & y1,
		X2 const & x2, Y2 const & y2,
		X3 const & x3, Y3 const & y3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
	}

	template <typename T, precision P>
	template <typename V1, typename V2, typename V3>
	 inline tmat3x2<T, P>::tmat3x2
	(
		tvec2<V1, P> const & v1,
		tvec2<V2, P> const & v2,
		tvec2<V3, P> const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}

	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat3x2<T, P>::tmat3x2(tmat3x2<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat2x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>::tmat3x2(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P>::tmat3x2(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(T(0));
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P>::tmat3x2(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P>::tmat3x2(tmat4x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P>::tmat3x2(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	
	






















		template <typename T, precision P>
		 inline  typename tmat3x2<T, P>::length_type tmat3x2<T, P>::length() const
		{
			return 3;
		}

		template <typename T, precision P>
		 inline typename tmat3x2<T, P>::col_type & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i)
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.inl", (unsigned)(245)), 0) );
			return this->value[i];
		}

		template <typename T, precision P>
		 inline typename tmat3x2<T, P>::col_type const & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i) const
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.inl", (unsigned)(252)), 0) );
			return this->value[i];
		}
#line 256 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.inl"

	
	

	template <typename T, precision P>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator+=(tmat3x2<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator-=(tmat3x2<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x2<T, P> & tmat3x2<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P>& tmat3x2<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> tmat3x2<T, P>::operator++(int)
	{
		tmat3x2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> tmat3x2<T, P>::operator--(int)
	{
		tmat3x2<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator+(tmat3x2<T, P> const & m, T const & s)
	{
		return tmat3x2<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator+(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator-(tmat3x2<T, P> const & m, T const & s)
	{
		return tmat3x2<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s);
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P> operator-(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P> operator*(tmat3x2<T, P> const & m, T const & s)
	{
		return tmat3x2<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P> operator*(T const & s, tmat3x2<T, P> const & m)
	{
		return tmat3x2<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}
   
	template <typename T, precision P>
	 inline typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> const & m, typename tmat3x2<T, P>::row_type const & v)
	{
		return typename tmat3x2<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
	}

	template <typename T, precision P>
	 inline typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type const & v, tmat3x2<T, P> const & m)
	{
		return typename tmat3x2<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];

		tmat2x2<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator/(tmat3x2<T, P> const & m, T const & s)
	{
		return tmat3x2<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s);
	}

	template <typename T, precision P> 
	 inline tmat3x2<T, P> operator/(T const & s, tmat3x2<T, P> const & m)
	{
		return tmat3x2<T, P>(
			s / m[0],
			s / m[1],
			s / m[2]);
	}

	
	template <typename T, precision P> 
	 inline tmat3x2<T, P> const operator-(tmat3x2<T, P> const & m)
	{
		return tmat3x2<T, P>(
			-m[0],
			-m[1],
			-m[2]);
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T, precision P> 
	 inline bool operator!=(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 207 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.hpp"
#line 208 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x2.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat3x2.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat3x2<float, lowp>		lowp_mat3x2;
	
	
	
	
	
	
	typedef tmat3x2<float, mediump>		mediump_mat3x2;
	
	
	
	
	
	
	typedef tmat3x2<float, highp>		highp_mat3x2;

}
#line 74 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat3x4.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.hpp"
































#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat3x4
	{
		typedef tvec4<T, P> col_type;
		typedef tvec3<T, P> row_type;
		typedef tmat3x4<T, P> type;
		typedef tmat4x3<T, P> transpose_type;
		typedef T value_type;

	private:
		
		col_type value[3];
		

	public:
		
		 tmat3x4();
		 tmat3x4(tmat3x4<T, P> const & m);
		template <precision Q>
		 tmat3x4(tmat3x4<T, Q> const & m);

		 explicit tmat3x4(ctor);
		 explicit tmat3x4(T const & s);
		 tmat3x4(
			T const & x0, T const & y0, T const & z0, T const & w0,
			T const & x1, T const & y1, T const & z1, T const & w1,
			T const & x2, T const & y2, T const & z2, T const & w2);
		 tmat3x4(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2);

		
		
		template<
			typename X1, typename Y1, typename Z1, typename W1,
			typename X2, typename Y2, typename Z2, typename W2,
			typename X3, typename Y3, typename Z3, typename W3>
		 tmat3x4(
			X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
			X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
			X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3);
			
		template <typename V1, typename V2, typename V3>
		 tmat3x4(
			tvec4<V1, P> const & v1,
			tvec4<V2, P> const & v2,
			tvec4<V3, P> const & v3);

		
		





			template <typename U, precision Q>
			 tmat3x4(tmat3x4<U, Q> const & m);
#line 103 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.hpp"

		 explicit tmat3x4(tmat2x2<T, P> const & x);
		 explicit tmat3x4(tmat3x3<T, P> const & x);
		 explicit tmat3x4(tmat4x4<T, P> const & x);
		 explicit tmat3x4(tmat2x3<T, P> const & x);
		 explicit tmat3x4(tmat3x2<T, P> const & x);
		 explicit tmat3x4(tmat2x4<T, P> const & x);
		 explicit tmat3x4(tmat4x2<T, P> const & x);
		 explicit tmat3x4(tmat4x3<T, P> const & x);

		
		








			typedef length_t length_type;
			  length_type length() const;

			 col_type & operator[](length_type i);
			 col_type const & operator[](length_type i) const;
#line 129 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.hpp"

		
		

		 tmat3x4<T, P> & operator=(tmat3x4<T, P> const & m);

		template <typename U> 
		 tmat3x4<T, P> & operator=(tmat3x4<U, P> const & m);
		template <typename U> 
		 tmat3x4<T, P> & operator+=(U s);
		template <typename U> 
		 tmat3x4<T, P> & operator+=(tmat3x4<U, P> const & m);
		template <typename U> 
		 tmat3x4<T, P> & operator-=(U s);
		template <typename U> 
		 tmat3x4<T, P> & operator-=(tmat3x4<U, P> const & m);
		template <typename U> 
		 tmat3x4<T, P> & operator*=(U s);
		template <typename U> 
		 tmat3x4<T, P> & operator/=(U s);

		
		

		 tmat3x4<T, P> & operator++();
		 tmat3x4<T, P> & operator--();
		 tmat3x4<T, P> operator++(int);
		 tmat3x4<T, P> operator--(int);
	};

	
	template <typename T, precision P>
	 tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator-(tmat3x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x4<T, P> operator*(T const & s, tmat3x4<T, P> const & m);

	template <typename T, precision P>
	 typename tmat3x4<T, P>::col_type operator*(tmat3x4<T, P> const & m, typename tmat3x4<T, P>::row_type const & v);

	template <typename T, precision P> 
	 typename tmat3x4<T, P>::row_type operator*(typename tmat3x4<T, P>::col_type const & v, tmat3x4<T, P> const & m);

	template <typename T, precision P>
	 tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1,	tmat4x3<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1,	tmat3x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x4<T, P> operator/(tmat3x4<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat3x4<T, P> operator/(T const & s, tmat3x4<T, P> const & m);

	
	template <typename T, precision P>
	 tmat3x4<T, P> const operator-(tmat3x4<T, P> const & m);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.inl"
































namespace glm
{
	
	

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4()
	{

			this->value[0] = col_type(1, 0, 0, 0);
			this->value[1] = col_type(0, 1, 0, 0);
			this->value[2] = col_type(0, 0, 1, 0);
#line 46 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.inl"
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat3x4<T, P> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	template <precision Q>
	 inline tmat3x4<T, P>::tmat3x4(tmat3x4<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(ctor)
	{}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(T const & s)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero, Zero, Zero);
		this->value[1] = col_type(Zero, s, Zero, Zero);
		this->value[2] = col_type(Zero, Zero, s, Zero);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4
	(
		T const & x0, T const & y0, T const & z0, T const & w0,
		T const & x1, T const & y1, T const & z1, T const & w1,
		T const & x2, T const & y2, T const & z2, T const & w2
	)
	{
		this->value[0] = col_type(x0, y0, z0, w0);
		this->value[1] = col_type(x1, y1, z1, w1);
		this->value[2] = col_type(x2, y2, z2, w2);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
	}

	
	
	template <typename T, precision P>
	template <
		typename X1, typename Y1, typename Z1, typename W1,
		typename X2, typename Y2, typename Z2, typename W2,
		typename X3, typename Y3, typename Z3, typename W3>
	 inline tmat3x4<T, P>::tmat3x4
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
		X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
		X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3>
	 inline tmat3x4<T, P>::tmat3x4
	(
		tvec4<V1, P> const & v1,
		tvec4<V2, P> const & v2,
		tvec4<V3, P> const & v3
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
	}
	
	
	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat3x4<T, P>::tmat3x4(tmat3x4<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>::tmat3x4(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
	}

	template <typename T, precision P> 
	 inline tmat3x4<T, P>::tmat3x4(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
	}

	template <typename T, precision P> 
	 inline tmat3x4<T, P>::tmat3x4(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T, precision P> 
	 inline tmat3x4<T, P>::tmat3x4(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 0, 1);
	}

	template <typename T, precision P> 
	 inline tmat3x4<T, P>::tmat3x4(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1, 0);
	}

	template <typename T, precision P> 
	 inline tmat3x4<T, P>::tmat3x4(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0, 0);
		this->value[1] = col_type(m[1], 0, 0);
		this->value[2] = col_type(m[2], 1, 0);
	}

	template <typename T, precision P> 
	 inline tmat3x4<T, P>::tmat3x4(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 0);
	}

	
	






















		template <typename T, precision P>
		 inline  typename tmat3x4<T, P>::length_type tmat3x4<T, P>::length() const
		{
			return 3;
		}

		template <typename T, precision P>
		 inline typename tmat3x4<T, P>::col_type & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i)
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.inl", (unsigned)(244)), 0) );
			return this->value[i];
		}

		template <typename T, precision P>
		 inline typename tmat3x4<T, P>::col_type const & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i) const
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.inl", (unsigned)(251)), 0) );
			return this->value[i];
		}
#line 255 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.inl"

	
	

	template <typename T, precision P>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P> 
	template <typename U> 
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		return *this;
	}

	template <typename T, precision P> 
	template <typename U> 
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		return *this;
	}

	template <typename T, precision P> 
	template <typename U> 
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator+=(tmat3x4<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator-=(tmat3x4<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat3x4<T, P> & tmat3x4<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P>& tmat3x4<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> tmat3x4<T, P>::operator++(int)
	{
		tmat3x4<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> tmat3x4<T, P>::operator--(int)
	{
		tmat3x4<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T const & s)
	{
		return tmat3x4<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator-(tmat3x4<T, P> const & m,	T const & s)
	{
		return tmat3x4<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T const & s)
	{
		return tmat3x4<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(T const & s, tmat3x4<T, P> const & m)
	{
		return tmat3x4<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s);
	}

	template <typename T, precision P>
	 inline typename tmat3x4<T, P>::col_type operator*
	(
		tmat3x4<T, P> const & m,
		typename tmat3x4<T, P>::row_type const & v
	)
	{
		return typename tmat3x4<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
			m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
	}

	template <typename T, precision P>
	 inline typename tmat3x4<T, P>::row_type operator*
	(
		typename tmat3x4<T, P>::col_type const & v,
		tmat3x4<T, P> const & m
	)
	{
		return typename tmat3x4<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		const T SrcA00 = m1[0][0];
		const T SrcA01 = m1[0][1];
		const T SrcA02 = m1[0][2];
		const T SrcA03 = m1[0][3];
		const T SrcA10 = m1[1][0];
		const T SrcA11 = m1[1][1];
		const T SrcA12 = m1[1][2];
		const T SrcA13 = m1[1][3];
		const T SrcA20 = m1[2][0];
		const T SrcA21 = m1[2][1];
		const T SrcA22 = m1[2][2];
		const T SrcA23 = m1[2][3];

		const T SrcB00 = m2[0][0];
		const T SrcB01 = m2[0][1];
		const T SrcB02 = m2[0][2];
		const T SrcB10 = m2[1][0];
		const T SrcB11 = m2[1][1];
		const T SrcB12 = m2[1][2];
		const T SrcB20 = m2[2][0];
		const T SrcB21 = m2[2][1];
		const T SrcB22 = m2[2][2];
		const T SrcB30 = m2[3][0];
		const T SrcB31 = m2[3][1];
		const T SrcB32 = m2[3][2];

		tmat4x4<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
		Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
		Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
		Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
		Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
		Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
		Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
		Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2)
	{
		return tmat2x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat3x3<T, P> const & m2)
	{
		return tmat3x4<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
			m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
			m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
			m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator/(tmat3x4<T, P> const & m,	T const & s)
	{
		return tmat3x4<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s);
	}

	template <typename T, precision P>
	 inline tmat3x4<T, P> operator/(T const & s, tmat3x4<T, P> const & m)
	{
		return tmat3x4<T, P>(
			s / m[0],
			s / m[1],
			s / m[2]);
	}

	
	template <typename T, precision P>
	 inline tmat3x4<T, P> const operator-(tmat3x4<T, P> const & m)
	{
		return tmat3x4<T, P>(
			-m[0],
			-m[1],
			-m[2]);
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
	}
} 
#line 206 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.hpp"
#line 207 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat3x4.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat3x4.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat3x4<float, lowp>		lowp_mat3x4;
	
	
	
	
	
	
	typedef tmat3x4<float, mediump>		mediump_mat3x4;
	
	
	
	
	
	
	typedef tmat3x4<float, highp>		highp_mat3x4;

}
#line 76 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat4x2.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.hpp"
































#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat4x2
	{
		typedef tvec2<T, P> col_type;
		typedef tvec4<T, P> row_type;
		typedef tmat4x2<T, P> type;
		typedef tmat2x4<T, P> transpose_type;
		typedef T value_type;

	private:
		
		col_type value[4];
		

	public:
		
		 tmat4x2();
		 tmat4x2(tmat4x2<T, P> const & m);
		template <precision Q>
		 tmat4x2(tmat4x2<T, Q> const & m);

		 explicit tmat4x2(ctor);
		 explicit tmat4x2(T const & x);
		 tmat4x2(
			T const & x0, T const & y0,
			T const & x1, T const & y1,
			T const & x2, T const & y2,
			T const & x3, T const & y3);
		 tmat4x2(
			col_type const & v0, 
			col_type const & v1,
			col_type const & v2,
			col_type const & v3);

		
		

		template <
			typename X1, typename Y1,
			typename X2, typename Y2,
			typename X3, typename Y3,
			typename X4, typename Y4>
		 tmat4x2(
			X1 const & x1, Y1 const & y1,
			X2 const & x2, Y2 const & y2,
			X3 const & x3, Y3 const & y3,
			X4 const & x4, Y4 const & y4);

		template <typename V1, typename V2, typename V3, typename V4>
		 tmat4x2(
			tvec2<V1, P> const & v1,
			tvec2<V2, P> const & v2,
			tvec2<V3, P> const & v3,
			tvec2<V4, P> const & v4);

		
		





			template <typename U, precision Q>
			 tmat4x2(tmat4x2<U, Q> const & m);
#line 109 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.hpp"

		 explicit tmat4x2(tmat2x2<T, P> const & x);
		 explicit tmat4x2(tmat3x3<T, P> const & x);
		 explicit tmat4x2(tmat4x4<T, P> const & x);
		 explicit tmat4x2(tmat2x3<T, P> const & x);
		 explicit tmat4x2(tmat3x2<T, P> const & x);
		 explicit tmat4x2(tmat2x4<T, P> const & x);
		 explicit tmat4x2(tmat4x3<T, P> const & x);
		 explicit tmat4x2(tmat3x4<T, P> const & x);

		
		








			typedef length_t length_type;
			  length_type length() const;

			 col_type & operator[](length_type i);
			 col_type const & operator[](length_type i) const;
#line 135 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.hpp"

		
		

		 tmat4x2<T, P> & operator=(tmat4x2<T, P> const & m);

		template <typename U> 
		 tmat4x2<T, P> & operator=(tmat4x2<U, P> const & m);
		template <typename U> 
		 tmat4x2<T, P> & operator+=(U s);
		template <typename U> 
		 tmat4x2<T, P> & operator+=(tmat4x2<U, P> const & m);
		template <typename U> 
		 tmat4x2<T, P> & operator-=(U s);
		template <typename U> 
		 tmat4x2<T, P> & operator-=(tmat4x2<U, P> const & m);
		template <typename U> 
		 tmat4x2<T, P> & operator*=(U s);
		template <typename U> 
		 tmat4x2<T, P> & operator/=(U s);

		
		

		 tmat4x2<T, P> & operator++ ();
		 tmat4x2<T, P> & operator-- ();
		 tmat4x2<T, P> operator++(int);
		 tmat4x2<T, P> operator--(int);
	};

	
	template <typename T, precision P>
	 tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1,	tmat4x2<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x2<T, P> operator*(T const & s, tmat4x2<T, P> const & m);

	template <typename T, precision P>
	 typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m);

	template <typename T, precision P>
	 tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x2<T, P> operator/(T const & s, tmat4x2<T, P> const & m);

	
	template <typename T, precision P>
	 tmat4x2<T, P> const operator-(tmat4x2<T, P> const & m);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.inl"
































namespace glm
{
	
	

	template <typename T, precision P> 
	 inline tmat4x2<T, P>::tmat4x2()
	{

			this->value[0] = col_type(1, 0);
			this->value[1] = col_type(0, 1);
			this->value[2] = col_type(0, 0);
			this->value[3] = col_type(0, 0);
#line 47 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.inl"
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat4x2<T, P> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T, precision P>
	template <precision Q>
	 inline tmat4x2<T, P>::tmat4x2(tmat4x2<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(ctor)
	{}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(T const & s)
	{
		value_type const Zero(0);
		this->value[0] = col_type(s, Zero);
		this->value[1] = col_type(Zero, s);
		this->value[2] = col_type(Zero, Zero);
		this->value[3] = col_type(Zero, Zero);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2
	(
		T const & x0, T const & y0,
		T const & x1, T const & y1,
		T const & x2, T const & y2,
		T const & x3, T const & y3
	)
	{
		this->value[0] = col_type(x0, y0);
		this->value[1] = col_type(x1, y1);
		this->value[2] = col_type(x2, y2);
		this->value[3] = col_type(x3, y3);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2
	(
		col_type const & v0,
		col_type const & v1,
		col_type const & v2,
		col_type const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	
	

	template <typename T, precision P>
	template <
		typename X1, typename Y1,
		typename X2, typename Y2,
		typename X3, typename Y3,
		typename X4, typename Y4>
	 inline tmat4x2<T, P>::tmat4x2
	(
		X1 const & x1, Y1 const & y1,
		X2 const & x2, Y2 const & y2,
		X3 const & x3, Y3 const & y3,
		X4 const & x4, Y4 const & y4
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3, typename V4>
	 inline tmat4x2<T, P>::tmat4x2
	(
		tvec2<V1, P> const & v1,
		tvec2<V2, P> const & v2,
		tvec2<V3, P> const & v3,
		tvec2<V4, P> const & v4
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	
	
	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat4x2<T, P>::tmat4x2(tmat4x2<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P>::tmat4x2(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P> 
	 inline tmat4x2<T, P>::tmat4x2(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P> 
	 inline tmat4x2<T, P>::tmat4x2(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P> 
	 inline tmat4x2<T, P>::tmat4x2(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P> 
	 inline tmat4x2<T, P>::tmat4x2(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P> 
	 inline tmat4x2<T, P>::tmat4x2(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P> 
	 inline tmat4x2<T, P>::tmat4x2(tmat4x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P> 
	 inline tmat4x2<T, P>::tmat4x2(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	
	






















		template <typename T, precision P>
		 inline  typename tmat4x2<T, P>::length_type tmat4x2<T, P>::length() const
		{
			return 4;
		}

		template <typename T, precision P>
		 inline typename tmat4x2<T, P>::col_type & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i)
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.inl", (unsigned)(268)), 0) );
			return this->value[i];
		}

		template <typename T, precision P>
		 inline typename tmat4x2<T, P>::col_type const & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i) const
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.inl", (unsigned)(275)), 0) );
			return this->value[i];
		}
#line 279 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.inl"

	
	

	template <typename T, precision P>
	 inline tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator+=(tmat4x2<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator-=(tmat4x2<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> & tmat4x2<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> tmat4x2<T, P>::operator++(int)
	{
		tmat4x2<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> tmat4x2<T, P>::operator--(int)
	{
		tmat4x2<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T const & s)
	{
		return tmat4x2<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T const & s)
	{
		return tmat4x2<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T const & s)
	{
		return tmat4x2<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(T const & s, tmat4x2<T, P> const & m)
	{
		return tmat4x2<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v)
	{
		return typename tmat4x2<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
	}

	template <typename T, precision P>
	 inline typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m)
	{
		return typename tmat4x2<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1],
			v.x * m[1][0] + v.y * m[1][1],
			v.x * m[2][0] + v.y * m[2][1],
			v.x * m[3][0] + v.y * m[3][1]);
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];

		tmat2x2<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		return tmat3x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return tmat4x2<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T const & s)
	{
		return tmat4x2<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template <typename T, precision P>
	 inline tmat4x2<T, P> operator/(T const & s, tmat4x2<T, P> const & m)
	{
		return tmat4x2<T, P>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	
	template <typename T, precision P>
	 inline tmat4x2<T, P> const operator-(tmat4x2<T, P> const & m)
	{
		return tmat4x2<T, P>(
			-m[0], 
			-m[1], 
			-m[2], 
			-m[3]);
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 212 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.hpp"
#line 213 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x2.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat4x2.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat4x2<float, lowp>		lowp_mat4x2;
	
	
	
	
	
	
	typedef tmat4x2<float, mediump>		mediump_mat4x2;
	
	
	
	
	
	
	typedef tmat4x2<float, highp>		highp_mat4x2;

}
#line 77 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat4x3.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.hpp"
































#pragma once








namespace glm
{
	template <typename T, precision P = defaultp>
	struct tmat4x3
	{
		typedef tvec3<T, P> col_type;
		typedef tvec4<T, P> row_type;
		typedef tmat4x3<T, P> type;
		typedef tmat3x4<T, P> transpose_type;
		typedef T value_type;

	private:
		
		col_type value[4];

	public:
		
		 tmat4x3();
		 tmat4x3(tmat4x3<T, P> const & m);
		template <precision Q>
		 tmat4x3(tmat4x3<T, Q> const & m);

		 explicit tmat4x3(ctor);
		 explicit tmat4x3(T const & x);
		 tmat4x3(
			T const & x0, T const & y0, T const & z0,
			T const & x1, T const & y1, T const & z1,
			T const & x2, T const & y2, T const & z2,
			T const & x3, T const & y3, T const & z3);
		 tmat4x3(
			col_type const & v0,
			col_type const & v1,
			col_type const & v2,
			col_type const & v3);

		
		

		template <
			typename X1, typename Y1, typename Z1,
			typename X2, typename Y2, typename Z2,
			typename X3, typename Y3, typename Z3,
			typename X4, typename Y4, typename Z4>
		 tmat4x3(
			X1 const & x1, Y1 const & y1, Z1 const & z1,
			X2 const & x2, Y2 const & y2, Z2 const & z2,
			X3 const & x3, Y3 const & y3, Z3 const & z3,
			X4 const & x4, Y4 const & y4, Z4 const & z4);
			
		template <typename V1, typename V2, typename V3, typename V4>
		 tmat4x3(
			tvec3<V1, P> const & v1,
			tvec3<V2, P> const & v2,
			tvec3<V3, P> const & v3,
			tvec3<V4, P> const & v4);

		
		





			template <typename U, precision Q>
			 tmat4x3(tmat4x3<U, Q> const & m);
#line 108 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.hpp"

		 explicit tmat4x3(tmat2x2<T, P> const & x);
		 explicit tmat4x3(tmat3x3<T, P> const & x);
		 explicit tmat4x3(tmat4x4<T, P> const & x);
		 explicit tmat4x3(tmat2x3<T, P> const & x);
		 explicit tmat4x3(tmat3x2<T, P> const & x);
		 explicit tmat4x3(tmat2x4<T, P> const & x);
		 explicit tmat4x3(tmat4x2<T, P> const & x);
		 explicit tmat4x3(tmat3x4<T, P> const & x);

		
		








			typedef length_t length_type;
			  length_type length() const;

			 col_type & operator[](length_type i);
			 col_type const & operator[](length_type i) const;
#line 134 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.hpp"

		
		

		 tmat4x3<T, P> & operator=(tmat4x3<T, P> const & m);

		template <typename U>
		 tmat4x3<T, P> & operator=(tmat4x3<U, P> const & m);
		template <typename U>
		 tmat4x3<T, P> & operator+=(U s);
		template <typename U>
		 tmat4x3<T, P> & operator+=(tmat4x3<U, P> const & m);
		template <typename U>
		 tmat4x3<T, P> & operator-=(U s);
		template <typename U>
		 tmat4x3<T, P> & operator-=(tmat4x3<U, P> const & m);
		template <typename U>
		 tmat4x3<T, P> & operator*=(U s);
		template <typename U>
		 tmat4x3<T, P> & operator/=(U s);

		
		

		 tmat4x3<T, P> & operator++();
		 tmat4x3<T, P> & operator--();
		 tmat4x3<T, P> operator++(int);
		 tmat4x3<T, P> operator--(int);
	};

	
	template <typename T, precision P>
	 tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m);

	template <typename T, precision P>
	 typename tmat4x3<T, P>::col_type operator*(tmat4x3<T, P> const & m, typename tmat4x3<T, P>::row_type const & v);

	template <typename T, precision P>
	 typename tmat4x3<T, P>::row_type operator*(typename tmat4x3<T, P>::col_type const & v, tmat4x3<T, P> const & m);

	template <typename T, precision P>
	 tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1,	tmat3x4<T, P> const & m2);
		
	template <typename T, precision P>
	 tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2);

	template <typename T, precision P>
	 tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s);

	template <typename T, precision P>
	 tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m);

	
	template <typename T, precision P>
	 tmat4x3<T, P> const operator-(tmat4x3<T, P> const & m);
}


#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.inl"
































namespace glm
{
	
	

	template <typename T, precision P> 
	 inline tmat4x3<T, P>::tmat4x3()
	{

			this->value[0] = col_type(1, 0, 0);
			this->value[1] = col_type(0, 1, 0);
			this->value[2] = col_type(0, 0, 1);
			this->value[3] = col_type(0, 0, 0);
#line 47 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.inl"
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat4x3<T, P> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T, precision P>
	template <precision Q>
	 inline tmat4x3<T, P>::tmat4x3(tmat4x3<T, Q> const & m)
	{
		this->value[0] = m.value[0];
		this->value[1] = m.value[1];
		this->value[2] = m.value[2];
		this->value[3] = m.value[3];
	}

	template <typename T, precision P> 
	 inline tmat4x3<T, P>::tmat4x3(ctor)
	{}

	template <typename T, precision P> 
	 inline tmat4x3<T, P>::tmat4x3(T const & s)
	{
		this->value[0] = col_type(s, 0, 0);
		this->value[1] = col_type(0, s, 0);
		this->value[2] = col_type(0, 0, s);
		this->value[3] = col_type(0, 0, 0);
	}

	template <typename T, precision P> 
	 inline tmat4x3<T, P>::tmat4x3
	(
		T const & x0, T const & y0, T const & z0,
		T const & x1, T const & y1, T const & z1,
		T const & x2, T const & y2, T const & z2,
		T const & x3, T const & y3, T const & z3
	)
	{
		this->value[0] = col_type(x0, y0, z0);
		this->value[1] = col_type(x1, y1, z1);
		this->value[2] = col_type(x2, y2, z2);
		this->value[3] = col_type(x3, y3, z3);
	}

	template <typename T, precision P> 
	 inline tmat4x3<T, P>::tmat4x3
	(
		col_type const & v0, 
		col_type const & v1, 
		col_type const & v2,
		col_type const & v3
	)
	{
		this->value[0] = v0;
		this->value[1] = v1;
		this->value[2] = v2;
		this->value[3] = v3;
	}

	
	

	template <typename T, precision P> 
	template <
		typename X1, typename Y1, typename Z1,
		typename X2, typename Y2, typename Z2,
		typename X3, typename Y3, typename Z3,
		typename X4, typename Y4, typename Z4>
	 inline tmat4x3<T, P>::tmat4x3
	(
		X1 const & x1, Y1 const & y1, Z1 const & z1,
		X2 const & x2, Y2 const & y2, Z2 const & z2,
		X3 const & x3, Y3 const & y3, Z3 const & z3,
		X4 const & x4, Y4 const & y4, Z4 const & z4
	)
	{
		this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
		this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
		this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
		this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4));
	}
	
	template <typename T, precision P>
	template <typename V1, typename V2, typename V3, typename V4>
	 inline tmat4x3<T, P>::tmat4x3
	(
		tvec3<V1, P> const & v1,
		tvec3<V2, P> const & v2,
		tvec3<V3, P> const & v3,
		tvec3<V4, P> const & v4
	)
	{
		this->value[0] = col_type(v1);
		this->value[1] = col_type(v2);
		this->value[2] = col_type(v3);
		this->value[3] = col_type(v4);
	}

	
	

	template <typename T, precision P>
	template <typename U, precision Q>
	 inline tmat4x3<T, P>::tmat4x3(tmat4x3<U, Q> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P> 
	 inline tmat4x3<T, P>::tmat4x3(tmat2x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P> 
	 inline tmat4x3<T, P>::tmat4x3(tmat3x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat4x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(m[3]);
	}

	template <typename T, precision P> 
	 inline tmat4x3<T, P>::tmat4x3(tmat2x3<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P> 
	 inline tmat4x3<T, P>::tmat4x3(tmat3x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat2x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(0, 0, 1);
		this->value[3] = col_type(0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat4x2<T, P> const & m)
	{
		this->value[0] = col_type(m[0], 0);
		this->value[1] = col_type(m[1], 0);
		this->value[2] = col_type(m[2], 1);
		this->value[3] = col_type(m[3], 0);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P>::tmat4x3(tmat3x4<T, P> const & m)
	{
		this->value[0] = col_type(m[0]);
		this->value[1] = col_type(m[1]);
		this->value[2] = col_type(m[2]);
		this->value[3] = col_type(0);
	}

	
	






















		template <typename T, precision P>
		 inline  typename tmat4x3<T, P>::length_type tmat4x3<T, P>::length() const
		{
			return 4;
		}

		template <typename T, precision P>
		 inline typename tmat4x3<T, P>::col_type & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i)
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.inl", (unsigned)(268)), 0) );
			return this->value[i];
		}

		template <typename T, precision P>
		 inline typename tmat4x3<T, P>::col_type const & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i) const
		{
			(void)( (!!(i < this->length())) || (_wassert(L"i < this->length()", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.inl", (unsigned)(275)), 0) );
			return this->value[i];
		}
#line 279 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.inl"

	
	

	template <typename T, precision P>
	 inline tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<T, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<U, P> const & m)
	{
		this->value[0] = m[0];
		this->value[1] = m[1];
		this->value[2] = m[2];
		this->value[3] = m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator+=(U s)
	{
		this->value[0] += s;
		this->value[1] += s;
		this->value[2] += s;
		this->value[3] += s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator+=(tmat4x3<U, P> const & m)
	{
		this->value[0] += m[0];
		this->value[1] += m[1];
		this->value[2] += m[2];
		this->value[3] += m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator-=(U s)
	{
		this->value[0] -= s;
		this->value[1] -= s;
		this->value[2] -= s;
		this->value[3] -= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator-=(tmat4x3<U, P> const & m)
	{
		this->value[0] -= m[0];
		this->value[1] -= m[1];
		this->value[2] -= m[2];
		this->value[3] -= m[3];
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator*=(U s)
	{
		this->value[0] *= s;
		this->value[1] *= s;
		this->value[2] *= s;
		this->value[3] *= s;
		return *this;
	}

	template <typename T, precision P>
	template <typename U>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator/=(U s)
	{
		this->value[0] /= s;
		this->value[1] /= s;
		this->value[2] /= s;
		this->value[3] /= s;
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator++()
	{
		++this->value[0];
		++this->value[1];
		++this->value[2];
		++this->value[3];
		return *this;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> & tmat4x3<T, P>::operator--()
	{
		--this->value[0];
		--this->value[1];
		--this->value[2];
		--this->value[3];
		return *this;
	}

	
	

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s)
	{
		return tmat4x3<T, P>(
			m[0] + s,
			m[1] + s,
			m[2] + s,
			m[3] + s);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0] + m2[0],
			m1[1] + m2[1],
			m1[2] + m2[2],
			m1[3] + m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s)
	{
		return tmat4x3<T, P>(
			m[0] - s,
			m[1] - s,
			m[2] - s,
			m[3] - s);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0] - m2[0],
			m1[1] - m2[1],
			m1[2] - m2[2],
			m1[3] - m2[3]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s)
	{
		return tmat4x3<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m)
	{
		return tmat4x3<T, P>(
			m[0] * s,
			m[1] * s,
			m[2] * s,
			m[3] * s);
	}

	template <typename T, precision P>
	 inline typename tmat4x3<T, P>::col_type operator*
	(
		tmat4x3<T, P> const & m,
		typename tmat4x3<T, P>::row_type const & v)
	{
		return typename tmat4x3<T, P>::col_type(
			m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
			m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
			m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
	}

	template <typename T, precision P>
	 inline typename tmat4x3<T, P>::row_type operator*
	(
		typename tmat4x3<T, P>::col_type const & v,
		tmat4x3<T, P> const & m)
	{
		return typename tmat4x3<T, P>::row_type(
			v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
			v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
			v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
			v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
	}

	template <typename T, precision P>
	 inline tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2)
	{
		return tmat2x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat3x4<T, P> const & m2)
	{
		T const SrcA00 = m1[0][0];
		T const SrcA01 = m1[0][1];
		T const SrcA02 = m1[0][2];
		T const SrcA10 = m1[1][0];
		T const SrcA11 = m1[1][1];
		T const SrcA12 = m1[1][2];
		T const SrcA20 = m1[2][0];
		T const SrcA21 = m1[2][1];
		T const SrcA22 = m1[2][2];
		T const SrcA30 = m1[3][0];
		T const SrcA31 = m1[3][1];
		T const SrcA32 = m1[3][2];

		T const SrcB00 = m2[0][0];
		T const SrcB01 = m2[0][1];
		T const SrcB02 = m2[0][2];
		T const SrcB03 = m2[0][3];
		T const SrcB10 = m2[1][0];
		T const SrcB11 = m2[1][1];
		T const SrcB12 = m2[1][2];
		T const SrcB13 = m2[1][3];
		T const SrcB20 = m2[2][0];
		T const SrcB21 = m2[2][1];
		T const SrcB22 = m2[2][2];
		T const SrcB23 = m2[2][3];

		tmat3x3<T, P> Result(uninitialize);
		Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
		Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
		Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
		Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
		Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
		Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
		Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
		Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
		Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2)
	{
		return tmat4x3<T, P>(
			m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
			m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
			m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
			m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
			m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
			m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
			m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
			m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
			m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
			m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
			m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
			m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s)
	{
		return tmat4x3<T, P>(
			m[0] / s,
			m[1] / s,
			m[2] / s,
			m[3] / s);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m)
	{
		return tmat4x3<T, P>(
			s / m[0],
			s / m[1],
			s / m[2],
			s / m[3]);
	}

	
	template <typename T, precision P>
	 inline tmat4x3<T, P> const operator-(tmat4x3<T, P> const & m)
	{
		return tmat4x3<T, P>(
			-m[0],
			-m[1],
			-m[2],
			-m[3]);
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> const operator++(tmat4x3<T, P> const & m, int)
	{
		return tmat4x3<T, P>(
			m[0] + T(1),
			m[1] + T(1),
			m[2] + T(1),
			m[3] + T(1));
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> const operator--(tmat4x3<T, P> const & m, int)
	{
		return tmat4x3<T, P>(
			m[0] - T(1),
			m[1] - T(1),
			m[2] - T(1),
			m[3] - T(1));
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> tmat4x3<T, P>::operator++(int)
	{
		tmat4x3<T, P> Result(*this);
		++*this;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x3<T, P> tmat4x3<T, P>::operator--(int)
	{
		tmat4x3<T, P> Result(*this);
		--*this;
		return Result;
	}

	
	

	template <typename T, precision P>
	 inline bool operator==(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
	}

	template <typename T, precision P>
	 inline bool operator!=(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
	{
		return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
	}
} 
#line 211 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.hpp"
#line 212 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\type_mat4x3.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\mat4x3.hpp"

namespace glm
{
	
	
	
	
	
	typedef tmat4x3<float, lowp>		lowp_mat4x3;
	
	
	
	
	
	
	typedef tmat4x3<float, mediump>		mediump_mat4x3;
	
	
	
	
	
	
	typedef tmat4x3<float, highp>		highp_mat4x3;

}
#line 78 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"





#line 84 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"

namespace glm
{
	
	

	
	
	template<typename genType>
	 typename genType::value_type const * value_ptr(genType const & vec);

	
	
	template<typename T>
	 tvec2<T, defaultp> make_vec2(T const * const ptr);

	
	
	template<typename T>
	 tvec3<T, defaultp> make_vec3(T const * const ptr);

	
	
	template<typename T>
	 tvec4<T, defaultp> make_vec4(T const * const ptr);

	
	
	template<typename T>
	 tmat2x2<T, defaultp> make_mat2x2(T const * const ptr);

	
	
	template<typename T>
	 tmat2x3<T, defaultp> make_mat2x3(T const * const ptr);

	
	
	template<typename T>
	 tmat2x4<T, defaultp> make_mat2x4(T const * const ptr);

	
	
	template<typename T>
	 tmat3x2<T, defaultp> make_mat3x2(T const * const ptr);

	
	
	template<typename T>
	 tmat3x3<T, defaultp> make_mat3x3(T const * const ptr);

	
	
	template<typename T>
	 tmat3x4<T, defaultp> make_mat3x4(T const * const ptr);

	
	
	template<typename T>
	 tmat4x2<T, defaultp> make_mat4x2(T const * const ptr);

	
	
	template<typename T>
	 tmat4x3<T, defaultp> make_mat4x3(T const * const ptr);

	
	
	template<typename T>
	 tmat4x4<T, defaultp> make_mat4x4(T const * const ptr);
	
	
	
	template<typename T>
	 tmat2x2<T, defaultp> make_mat2(T const * const ptr);

	
	
	template<typename T>
	 tmat3x3<T, defaultp> make_mat3(T const * const ptr);
		
	
	
	template<typename T>
	 tmat4x4<T, defaultp> make_mat4(T const * const ptr);

	
	
	template<typename T>
	 tquat<T, defaultp> make_quat(T const * const ptr);

	
}

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.inl"


































namespace glm
{
	
	

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tvec2<T, P> const & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tvec2<T, P> & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tvec3<T, P> const & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tvec3<T, P> & vec
	)
	{
		return &(vec.x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(	
		tvec4<T, P> const & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(	
		tvec4<T, P> & vec
	)
	{
		return &(vec.x);
	}

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat2x2<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat2x2<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat3x3<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat3x3<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat4x4<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat4x4<T, P> & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat2x3<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat2x3<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat3x2<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat3x2<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat2x4<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat2x4<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat4x2<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(	
		tmat4x2<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat3x4<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tmat3x4<T, P> & mat
	)
	{
		return &(mat[0].x);
	}
		
	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tmat4x3<T, P> const & mat
	)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr(tmat4x3<T, P> & mat)
	{
		return &(mat[0].x);
	}

	
	
	template<typename T, precision P>
	 inline T const * value_ptr
	(
		tquat<T, P> const & q
	)
	{
		return &(q[0]);
	}

	
	
	template<typename T, precision P>
	 inline T * value_ptr
	(
		tquat<T, P> & q
	)
	{
		return &(q[0]);
	}

	
	
	template <typename T>
	 inline tvec2<T, defaultp> make_vec2(T const * const ptr)
	{
		tvec2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tvec2<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tvec3<T, defaultp> make_vec3(T const * const ptr)
	{
		tvec3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tvec3<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tvec4<T, defaultp> make_vec4(T const * const ptr)
	{
		tvec4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tvec4<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat2x2<T, defaultp> make_mat2x2(T const * const ptr)
	{
		tmat2x2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat2x2<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat2x3<T, defaultp> make_mat2x3(T const * const ptr)
	{
		tmat2x3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat2x3<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat2x4<T, defaultp> make_mat2x4(T const * const ptr)
	{
		tmat2x4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat2x4<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat3x2<T, defaultp> make_mat3x2(T const * const ptr)
	{
		tmat3x2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat3x2<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat3x3<T, defaultp> make_mat3x3(T const * const ptr)
	{
		tmat3x3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat3x3<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat3x4<T, defaultp> make_mat3x4(T const * const ptr)
	{
		tmat3x4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat3x4<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat4x2<T, defaultp> make_mat4x2(T const * const ptr)
	{
		tmat4x2<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat4x2<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat4x3<T, defaultp> make_mat4x3(T const * const ptr)
	{
		tmat4x3<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat4x3<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat4x4<T, defaultp> make_mat4x4(T const * const ptr)
	{
		tmat4x4<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tmat4x4<T, defaultp>));
		return Result;
	}

	
	
	template <typename T>
	 inline tmat2x2<T, defaultp> make_mat2(T const * const ptr)
	{
		return make_mat2x2(ptr);
	}

	
	
	template <typename T>
	 inline tmat3x3<T, defaultp> make_mat3(T const * const ptr)
	{
		return make_mat3x3(ptr);
	}
		
	
	
	template <typename T>
	 inline tmat4x4<T, defaultp> make_mat4(T const * const ptr)
	{
		return make_mat4x4(ptr);
	}

	
	
	template <typename T>
	 inline tquat<T, defaultp> make_quat(T const * const ptr)
	{
		tquat<T, defaultp> Result;
		memcpy(value_ptr(Result), ptr, sizeof(tquat<T, defaultp>));
		return Result;
	}

	
}

#line 179 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\type_ptr.hpp"
#line 15 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.hpp"

















































#pragma once










#line 62 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.hpp"

namespace glm
{
	
	

	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> translate(
		tmat4x4<T, P> const & m,
		tvec3<T, P> const & v);
		
	
	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> rotate(
		tmat4x4<T, P> const & m,
		T angle,
		tvec3<T, P> const & axis);

	
	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> scale(
		tmat4x4<T, P> const & m,
		tvec3<T, P> const & v);

	
	
	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> ortho(
		T left,
		T right,
		T bottom,
		T top,
		T zNear,
		T zFar);

	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> ortho(
		T left,
		T right,
		T bottom,
		T top);

	
	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> frustum(
		T left,
		T right,
		T bottom,
		T top,
		T ,
		T );

	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> perspective(
		T fovy,
		T aspect,
		T ,
		T );

	
	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> perspectiveFov(
		T fov,
		T width,
		T height,
		T ,
		T );

	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> infinitePerspective(
		T fovy, T aspect, T );

	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> tweakedInfinitePerspective(
		T fovy, T aspect, T );

	
	
	
	
	
	
	
	
	template <typename T>
	 tmat4x4<T, defaultp> tweakedInfinitePerspective(
		T fovy, T aspect, T , T ep);

	
	
	
	
	
	
	
	
	
	
	template <typename T, typename U, precision P>
	 tvec3<T, P> project(
		tvec3<T, P> const & obj,
		tmat4x4<T, P> const & model,
		tmat4x4<T, P> const & proj,
		tvec4<U, P> const & viewport);

	
	
	
	
	
	
	
	
	
	
	template <typename T, typename U, precision P>
	 tvec3<T, P> unProject(
		tvec3<T, P> const & win,
		tmat4x4<T, P> const & model,
		tmat4x4<T, P> const & proj,
		tvec4<U, P> const & viewport);

	
	
	
	
	
	
	
	
	template <typename T, precision P, typename U>
	 tmat4x4<T, P> pickMatrix(
		tvec2<T, P> const & center,
		tvec2<T, P> const & delta,
		tvec4<U, P> const & viewport);

	
	
	
	
	
	
	
	template <typename T, precision P>
	 tmat4x4<T, P> lookAt(
		tvec3<T, P> const & eye,
		tvec3<T, P> const & center,
		tvec3<T, P> const & up);

	
}

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.inl"


































#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\matrix.hpp"
































#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_matrix.hpp"











































#pragma once


















namespace glm{
namespace detail
{
	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec2, tvec2>
	{
		typedef tmat2x2<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec2, tvec3>
	{
		typedef tmat2x3<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec2, tvec4>
	{
		typedef tmat2x4<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec3, tvec2>
	{
		typedef tmat3x2<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec3, tvec3>
	{
		typedef tmat3x3<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec3, tvec4>
	{
		typedef tmat3x4<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec4, tvec2>
	{
		typedef tmat4x2<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec4, tvec3>
	{
		typedef tmat4x3<T, P> type;
	};

	template <typename T, precision P>
	struct outerProduct_trait<T, P, tvec4, tvec4>
	{
		typedef tmat4x4<T, P> type;
	};

}

	
	

	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class matType>
	 matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y);

	
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
	 typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r);

	
	
	
	
	
	

		template <typename T, precision P, template <typename, precision> class matType>
		 typename matType<T, P>::transpose_type transpose(matType<T, P> const & x);
#line 156 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_matrix.hpp"
	
	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class matType>
	 T determinant(matType<T, P> const & m);

	
	
	
	
	
	
	template <typename T, precision P, template <typename, precision> class matType>
	 matType<T, P> inverse(matType<T, P> const & m);

	
}

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_matrix.inl"



































namespace glm{
namespace detail
{
	template <template <class, precision> class matType, typename T, precision P>
	struct compute_transpose{};

	template <typename T, precision P>
	struct compute_transpose<tmat2x2, T, P>
	{
		 inline static tmat2x2<T, P> call(tmat2x2<T, P> const & m)
		{
			tmat2x2<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			return result;
		}
	};

	template <typename T, precision P>
	struct compute_transpose<tmat2x3, T, P>
	{
		 inline static tmat3x2<T, P> call(tmat2x3<T, P> const & m)
		{
			tmat3x2<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			return result;
		}
	};

	template <typename T, precision P>
	struct compute_transpose<tmat2x4, T, P>
	{
		 inline static tmat4x2<T, P> call(tmat2x4<T, P> const & m)
		{
			tmat4x2<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[3][0] = m[0][3];
			result[3][1] = m[1][3];
			return result;
		}
	};

	template <typename T, precision P>
	struct compute_transpose<tmat3x2, T, P>
	{
		 inline static tmat2x3<T, P> call(tmat3x2<T, P> const & m)
		{
			tmat2x3<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			return result;
		}
	};

	template <typename T, precision P>
	struct compute_transpose<tmat3x3, T, P>
	{
		 inline static tmat3x3<T, P> call(tmat3x3<T, P> const & m)
		{
			tmat3x3<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];

			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];

			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			return result;
		}
	};

	template <typename T, precision P>
	struct compute_transpose<tmat3x4, T, P>
	{
		 inline static tmat4x3<T, P> call(tmat3x4<T, P> const & m)
		{
			tmat4x3<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			result[3][0] = m[0][3];
			result[3][1] = m[1][3];
			result[3][2] = m[2][3];
			return result;
		}
	};

	template <typename T, precision P>
	struct compute_transpose<tmat4x2, T, P>
	{
		 inline static tmat2x4<T, P> call(tmat4x2<T, P> const & m)
		{
			tmat2x4<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[0][3] = m[3][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[1][3] = m[3][1];
			return result;
		}
	};

	template <typename T, precision P>
	struct compute_transpose<tmat4x3, T, P>
	{
		 inline static tmat3x4<T, P> call(tmat4x3<T, P> const & m)
		{
			tmat3x4<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[0][3] = m[3][0];
			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[1][3] = m[3][1];
			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			result[2][3] = m[3][2];
			return result;
		}
	};

	template <typename T, precision P>
	struct compute_transpose<tmat4x4, T, P>
	{
		 inline static tmat4x4<T, P> call(tmat4x4<T, P> const & m)
		{
			tmat4x4<T, P> result(uninitialize);
			result[0][0] = m[0][0];
			result[0][1] = m[1][0];
			result[0][2] = m[2][0];
			result[0][3] = m[3][0];

			result[1][0] = m[0][1];
			result[1][1] = m[1][1];
			result[1][2] = m[2][1];
			result[1][3] = m[3][1];

			result[2][0] = m[0][2];
			result[2][1] = m[1][2];
			result[2][2] = m[2][2];
			result[2][3] = m[3][2];

			result[3][0] = m[0][3];
			result[3][1] = m[1][3];
			result[3][2] = m[2][3];
			result[3][3] = m[3][3];
			return result;
		}
	};

	template <template <class, precision> class matType, typename T, precision P>
	struct compute_determinant{};

	template <typename T, precision P>
	struct compute_determinant<tmat2x2, T, P>
	{
		 inline static T call(tmat2x2<T, P> const & m)
		{
			return m[0][0] * m[1][1] - m[1][0] * m[0][1];
		}
	};

	template <typename T, precision P>
	struct compute_determinant<tmat3x3, T, P>
	{
		 inline static T call(tmat3x3<T, P> const & m)
		{
			return
				+ m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
				- m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
				+ m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		}
	};

	template <typename T, precision P>
	struct compute_determinant<tmat4x4, T, P>
	{
		 inline static T call(tmat4x4<T, P> const & m)
		{
			T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
			T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
			T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
			T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
			T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
			T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

			tvec4<T, P> DetCof(
				+ (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
				- (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
				+ (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
				- (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

			return
				m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
				m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
		}
	};
}

	template <typename T, precision P, template <typename, precision> class matType>
	 inline matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'matrixCompMult' only accept floating-point inputs");

		matType<T, P> result(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(result); ++i)
			result[i] = x[i] * y[i];
		return result;
	}

	template<typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
	 inline typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'outerProduct' only accept floating-point inputs");

		typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type m(uninitialize);
		for(detail::component_count_t i = 0; i < detail::component_count(m); ++i)
			m[i] = c * r[i];
		return m;
	}

	template <typename T, precision P, template <typename, precision> class matType>
	 inline typename matType<T, P>::transpose_type transpose(matType<T, P> const & m)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'transpose' only accept floating-point inputs");
		return detail::compute_transpose<matType, T, P>::call(m);
	}

	template <typename T, precision P, template <typename, precision> class matType>
	 inline T determinant(matType<T, P> const & m)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'determinant' only accept floating-point inputs");
		return detail::compute_determinant<matType, T, P>::call(m);
	}

	template <typename T, precision P, template <typename, precision> class matType>
	 inline matType<T, P> inverse(matType<T, P> const & m)
	{
		static_assert(std::numeric_limits<T>::is_iec559, "'inverse' only accept floating-point inputs");
		return detail::compute_inverse(m);
	}

}
#line 179 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\detail\\func_matrix.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\matrix.hpp"
#line 36 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.inl"

namespace glm
{
	template <typename T, precision P>
	 inline tmat4x4<T, P> translate
	(
		tmat4x4<T, P> const & m,
		tvec3<T, P> const & v
	)
	{
		tmat4x4<T, P> Result(m);
		Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
		return Result;
	}
	
	template <typename T, precision P>
	 inline tmat4x4<T, P> rotate
	(
		tmat4x4<T, P> const & m,
		T angle,
		tvec3<T, P> const & v
	)
	{
		T const a = angle;
		T const c = cos(a);
		T const s = sin(a);

		tvec3<T, P> axis(normalize(v));
		tvec3<T, P> temp((T(1) - c) * axis);

		tmat4x4<T, P> Rotate(uninitialize);
		Rotate[0][0] = c + temp[0] * axis[0];
		Rotate[0][1] = 0 + temp[0] * axis[1] + s * axis[2];
		Rotate[0][2] = 0 + temp[0] * axis[2] - s * axis[1];

		Rotate[1][0] = 0 + temp[1] * axis[0] - s * axis[2];
		Rotate[1][1] = c + temp[1] * axis[1];
		Rotate[1][2] = 0 + temp[1] * axis[2] + s * axis[0];

		Rotate[2][0] = 0 + temp[2] * axis[0] + s * axis[1];
		Rotate[2][1] = 0 + temp[2] * axis[1] - s * axis[0];
		Rotate[2][2] = c + temp[2] * axis[2];

		tmat4x4<T, P> Result(uninitialize);
		Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
		Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
		Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
		Result[3] = m[3];
		return Result;
	}
		
	template <typename T, precision P>
	 inline tmat4x4<T, P> rotate_slow
	(
		tmat4x4<T, P> const & m,
		T angle, 
		tvec3<T, P> const & v
	)
	{
		T const a = angle;
		T const c = cos(a);
		T const s = sin(a);
		tmat4x4<T, P> Result;

		tvec3<T, P> axis = normalize(v);

		Result[0][0] = c + (1 - c)      * axis.x     * axis.x;
		Result[0][1] = (1 - c) * axis.x * axis.y + s * axis.z;
		Result[0][2] = (1 - c) * axis.x * axis.z - s * axis.y;
		Result[0][3] = 0;

		Result[1][0] = (1 - c) * axis.y * axis.x - s * axis.z;
		Result[1][1] = c + (1 - c) * axis.y * axis.y;
		Result[1][2] = (1 - c) * axis.y * axis.z + s * axis.x;
		Result[1][3] = 0;

		Result[2][0] = (1 - c) * axis.z * axis.x + s * axis.y;
		Result[2][1] = (1 - c) * axis.z * axis.y - s * axis.x;
		Result[2][2] = c + (1 - c) * axis.z * axis.z;
		Result[2][3] = 0;

		Result[3] = tvec4<T, P>(0, 0, 0, 1);
		return m * Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> scale
	(
		tmat4x4<T, P> const & m,
		tvec3<T, P> const & v
	)
	{
		tmat4x4<T, P> Result(uninitialize);
		Result[0] = m[0] * v[0];
		Result[1] = m[1] * v[1];
		Result[2] = m[2] * v[2];
		Result[3] = m[3];
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> scale_slow
	(
		tmat4x4<T, P> const & m,
		tvec3<T, P> const & v
	)
	{
		tmat4x4<T, P> Result(T(1));
		Result[0][0] = v.x;
		Result[1][1] = v.y;
		Result[2][2] = v.z;
		return m * Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> ortho
	(
		T left,
		T right,
		T bottom,
		T top,
		T zNear,
		T zFar
	)
	{
		tmat4x4<T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		Result[3][2] = - (zFar + zNear) / (zFar - zNear);
		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> ortho
	(
		T left,
		T right,
		T bottom,
		T top
	)
	{
		tmat4x4<T, defaultp> Result(1);
		Result[0][0] = static_cast<T>(2) / (right - left);
		Result[1][1] = static_cast<T>(2) / (top - bottom);
		Result[2][2] = - static_cast<T>(1);
		Result[3][0] = - (right + left) / (right - left);
		Result[3][1] = - (top + bottom) / (top - bottom);
		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> frustum
	(
		T left,
		T right,
		T bottom,
		T top,
		T nearVal,
		T farVal
	)
	{
		tmat4x4<T, defaultp> Result(0);
		Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
		Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
		Result[2][0] = (right + left) / (right - left);
		Result[2][1] = (top + bottom) / (top - bottom);
		Result[2][2] = -(farVal + nearVal) / (farVal - nearVal);
		Result[2][3] = static_cast<T>(-1);
		Result[3][2] = -(static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> perspective
	(
		T fovy,
		T aspect,
		T zNear,
		T zFar
	)
	{
		(void)( (!!(abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0))) || (_wassert(L"abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.inl", (unsigned)(220)), 0) );

		T const tanHalfFovy = tan(fovy / static_cast<T>(2));

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
		Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
		Result[2][2] = - (zFar + zNear) / (zFar - zNear);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
		return Result;
	}
	
	template <typename T>
	 inline tmat4x4<T, defaultp> perspectiveFov
	(
		T fov,
		T width,
		T height,
		T zNear,
		T zFar
	)
	{
		(void)( (!!(width > static_cast<T>(0))) || (_wassert(L"width > static_cast<T>(0)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.inl", (unsigned)(243)), 0) );
		(void)( (!!(height > static_cast<T>(0))) || (_wassert(L"height > static_cast<T>(0)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.inl", (unsigned)(244)), 0) );
		(void)( (!!(fov > static_cast<T>(0))) || (_wassert(L"fov > static_cast<T>(0)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.inl", (unsigned)(245)), 0) );
	
		T const rad = fov;
		T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
		T const w = h * height / width; 

		tmat4x4<T, defaultp> Result(static_cast<T>(0));
		Result[0][0] = w;
		Result[1][1] = h;
		Result[2][2] = - (zFar + zNear) / (zFar - zNear);
		Result[2][3] = - static_cast<T>(1);
		Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> infinitePerspective
	(
		T fovy,
		T aspect,
		T zNear
	)
	{
		T const range = tan(fovy / T(2)) * zNear;
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		tmat4x4<T, defaultp> Result(T(0));
		Result[0][0] = (T(2) * zNear) / (right - left);
		Result[1][1] = (T(2) * zNear) / (top - bottom);
		Result[2][2] = - T(1);
		Result[2][3] = - T(1);
		Result[3][2] = - T(2) * zNear;
		return Result;
	}

	
	template <typename T>
	 inline tmat4x4<T, defaultp> tweakedInfinitePerspective
	(
		T fovy,
		T aspect,
		T zNear,
		T ep
	)
	{
		T const range = tan(fovy / T(2)) * zNear;	
		T const left = -range * aspect;
		T const right = range * aspect;
		T const bottom = -range;
		T const top = range;

		tmat4x4<T, defaultp> Result(T(0));
		Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
		Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
		Result[2][2] = ep - static_cast<T>(1);
		Result[2][3] = static_cast<T>(-1);
		Result[3][2] = (ep - static_cast<T>(2)) * zNear;
		return Result;
	}

	template <typename T>
	 inline tmat4x4<T, defaultp> tweakedInfinitePerspective
	(
		T fovy,
		T aspect,
		T zNear
	)
	{
		return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
	}

	template <typename T, typename U, precision P>
	 inline tvec3<T, P> project
	(
		tvec3<T, P> const & obj,
		tmat4x4<T, P> const & model,
		tmat4x4<T, P> const & proj,
		tvec4<U, P> const & viewport
	)
	{
		tvec4<T, P> tmp = tvec4<T, P>(obj, T(1));
		tmp = model * tmp;
		tmp = proj * tmp;

		tmp /= tmp.w;
		tmp = tmp * T(0.5) + T(0.5);
		tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
		tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

		return tvec3<T, P>(tmp);
	}

	template <typename T, typename U, precision P>
	 inline tvec3<T, P> unProject
	(
		tvec3<T, P> const & win,
		tmat4x4<T, P> const & model,
		tmat4x4<T, P> const & proj,
		tvec4<U, P> const & viewport
	)
	{
		tmat4x4<T, P> Inverse = inverse(proj * model);

		tvec4<T, P> tmp = tvec4<T, P>(win, T(1));
		tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
		tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
		tmp = tmp * T(2) - T(1);

		tvec4<T, P> obj = Inverse * tmp;
		obj /= obj.w;

		return tvec3<T, P>(obj);
	}

	template <typename T, precision P, typename U>
	 inline tmat4x4<T, P> pickMatrix
	(
		tvec2<T, P> const & center,
		tvec2<T, P> const & delta,
		tvec4<U, P> const & viewport
	)
	{
		(void)( (!!(delta.x > T(0) && delta.y > T(0))) || (_wassert(L"delta.x > T(0) && delta.y > T(0)", L"d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.inl", (unsigned)(370)), 0) );
		tmat4x4<T, P> Result(1.0f);

		if(!(delta.x > T(0) && delta.y > T(0)))
			return Result; 

		tvec3<T, P> Temp(
			(T(viewport[2]) - T(2) * (center.x - T(viewport[0]))) / delta.x,
			(T(viewport[3]) - T(2) * (center.y - T(viewport[1]))) / delta.y,
			T(0));

		
		Result = translate(Result, Temp);
		return scale(Result, tvec3<T, P>(T(viewport[2]) / delta.x, T(viewport[3]) / delta.y, T(1)));
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> lookAt
	(
		tvec3<T, P> const & eye,
		tvec3<T, P> const & center,
		tvec3<T, P> const & up
	)
	{
		tvec3<T, P> const f(normalize(center - eye));
		tvec3<T, P> const s(normalize(cross(f, up)));
		tvec3<T, P> const u(cross(s, f));

		tmat4x4<T, P> Result(1);
		Result[0][0] = s.x;
		Result[1][0] = s.y;
		Result[2][0] = s.z;
		Result[0][1] = u.x;
		Result[1][1] = u.y;
		Result[2][1] = u.z;
		Result[0][2] =-f.x;
		Result[1][2] =-f.y;
		Result[2][2] =-f.z;
		Result[3][0] =-dot(s, eye);
		Result[3][1] =-dot(u, eye);
		Result[3][2] = dot(f, eye);
		return Result;
	}
}
#line 305 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_transform.hpp"
#line 16 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_inverse.hpp"








































#pragma once










#line 53 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_inverse.hpp"

namespace glm
{
	
	

	
	
	
	
	
	template <typename genType> 
	 genType affineInverse(genType const & m);

	
	
	
	
	
	template <typename genType>
	 genType inverseTranspose(genType const & m);

	
}

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_inverse.inl"
































namespace glm
{
	template <typename T, precision P>
	 inline tmat3x3<T, P> affineInverse(tmat3x3<T, P> const & m)
	{
		tmat3x3<T, P> Result(m);
		Result[2] = tvec3<T, P>(0, 0, 1);
		Result = transpose(Result);
		tvec3<T, P> Translation = Result * tvec3<T, P>(-tvec2<T, P>(m[2]), m[2][2]);
		Result[2] = Translation;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> affineInverse(tmat4x4<T, P> const & m)
	{
		tmat4x4<T, P> Result(m);
		Result[3] = tvec4<T, P>(0, 0, 0, 1);
		Result = transpose(Result);
		tvec4<T, P> Translation = Result * tvec4<T, P>(-tvec3<T, P>(m[3]), m[3][3]);
		Result[3] = Translation;
		return Result;
	}

	template <typename T, precision P>
	 inline tmat2x2<T, P> inverseTranspose(tmat2x2<T, P> const & m)
	{
		T Determinant = m[0][0] * m[1][1] - m[1][0] * m[0][1];

		tmat2x2<T, P> Inverse(
			+ m[1][1] / Determinant,
			- m[0][1] / Determinant,
			- m[1][0] / Determinant,
			+ m[0][0] / Determinant);

		return Inverse;
	}

	template <typename T, precision P>
	 inline tmat3x3<T, P> inverseTranspose(tmat3x3<T, P> const & m)
	{
		T Determinant =
			+ m[0][0] * (m[1][1] * m[2][2] - m[1][2] * m[2][1])
			- m[0][1] * (m[1][0] * m[2][2] - m[1][2] * m[2][0])
			+ m[0][2] * (m[1][0] * m[2][1] - m[1][1] * m[2][0]);

		tmat3x3<T, P> Inverse(uninitialize);
		Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]);
		Inverse[0][1] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]);
		Inverse[0][2] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]);
		Inverse[1][0] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]);
		Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]);
		Inverse[1][2] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]);
		Inverse[2][0] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
		Inverse[2][1] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]);
		Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]);
		Inverse /= Determinant;

		return Inverse;
	}

	template <typename T, precision P>
	 inline tmat4x4<T, P> inverseTranspose(tmat4x4<T, P> const & m)
	{
		T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
		T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
		T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
		T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
		T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
		T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
		T SubFactor06 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
		T SubFactor07 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
		T SubFactor08 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
		T SubFactor09 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
		T SubFactor10 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
		T SubFactor11 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
		T SubFactor12 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
		T SubFactor13 = m[1][2] * m[2][3] - m[2][2] * m[1][3];
		T SubFactor14 = m[1][1] * m[2][3] - m[2][1] * m[1][3];
		T SubFactor15 = m[1][1] * m[2][2] - m[2][1] * m[1][2];
		T SubFactor16 = m[1][0] * m[2][3] - m[2][0] * m[1][3];
		T SubFactor17 = m[1][0] * m[2][2] - m[2][0] * m[1][2];
		T SubFactor18 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

		tmat4x4<T, P> Inverse(uninitialize);
		Inverse[0][0] = + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02);
		Inverse[0][1] = - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04);
		Inverse[0][2] = + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05);
		Inverse[0][3] = - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05);

		Inverse[1][0] = - (m[0][1] * SubFactor00 - m[0][2] * SubFactor01 + m[0][3] * SubFactor02);
		Inverse[1][1] = + (m[0][0] * SubFactor00 - m[0][2] * SubFactor03 + m[0][3] * SubFactor04);
		Inverse[1][2] = - (m[0][0] * SubFactor01 - m[0][1] * SubFactor03 + m[0][3] * SubFactor05);
		Inverse[1][3] = + (m[0][0] * SubFactor02 - m[0][1] * SubFactor04 + m[0][2] * SubFactor05);

		Inverse[2][0] = + (m[0][1] * SubFactor06 - m[0][2] * SubFactor07 + m[0][3] * SubFactor08);
		Inverse[2][1] = - (m[0][0] * SubFactor06 - m[0][2] * SubFactor09 + m[0][3] * SubFactor10);
		Inverse[2][2] = + (m[0][0] * SubFactor11 - m[0][1] * SubFactor09 + m[0][3] * SubFactor12);
		Inverse[2][3] = - (m[0][0] * SubFactor08 - m[0][1] * SubFactor10 + m[0][2] * SubFactor12);

		Inverse[3][0] = - (m[0][1] * SubFactor13 - m[0][2] * SubFactor14 + m[0][3] * SubFactor15);
		Inverse[3][1] = + (m[0][0] * SubFactor13 - m[0][2] * SubFactor16 + m[0][3] * SubFactor17);
		Inverse[3][2] = - (m[0][0] * SubFactor14 - m[0][1] * SubFactor16 + m[0][3] * SubFactor18);
		Inverse[3][3] = + (m[0][0] * SubFactor15 - m[0][1] * SubFactor17 + m[0][2] * SubFactor18);

		T Determinant =
			+ m[0][0] * Inverse[0][0]
			+ m[0][1] * Inverse[0][1]
			+ m[0][2] * Inverse[0][2]
			+ m[0][3] * Inverse[0][3];

		Inverse /= Determinant;

		return Inverse;
	}
}
#line 79 "d:\\users\\stasw\\documents\\virheimur\\game - client\\glm\\glm\\gtc\\matrix_inverse.hpp"
#line 17 "d:\\users\\stasw\\documents\\virheimur\\game - client\\graphics_header.h"

#line 6 "d:\\users\\stasw\\documents\\virheimur\\game - client\\text.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\imageloader.h"
#pragma once

#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\mouse.h"
#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4127)
namespace std {
		
template<class _Mylist,
	class _Base = _Iterator_base0>
	class _List_unchecked_const_iterator
		: public _Iterator012<bidirectional_iterator_tag,
			typename _Mylist::value_type,
			typename _Mylist::difference_type,
			typename _Mylist::const_pointer,
			typename _Mylist::const_reference,
			_Base>
	{	
public:
	typedef _List_unchecked_const_iterator<_Mylist, _Base> _Myiter;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mylist::_Nodeptr _Nodeptr;
	typedef typename _Mylist::value_type value_type;
	typedef typename _Mylist::difference_type difference_type;
	typedef typename _Mylist::const_pointer pointer;
	typedef typename _Mylist::const_reference reference;

	_List_unchecked_const_iterator()
		: _Ptr()
		{	
		}

	_List_unchecked_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
		: _Ptr(_Pnode)
		{	
		this->_Adopt(_Plist);
		}

	reference operator*() const
		{	
		return (_Mylist::_Myval(_Ptr));
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		_Ptr = _Mylist::_Nextnode(_Ptr);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		_Ptr = _Mylist::_Prevnode(_Ptr);
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	bool operator==(const _Myiter& _Right) const
		{	
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	_Nodeptr _Mynode() const
		{	
		return (_Ptr);
		}

	_Nodeptr _Ptr;	
	};

	
template<class _Mylist>
	class _List_unchecked_iterator
		: public _List_unchecked_const_iterator<_Mylist>
	{	
public:
	typedef _List_unchecked_iterator<_Mylist> _Myiter;
	typedef _List_unchecked_const_iterator<_Mylist> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mylist::_Nodeptr _Nodeptr;
	typedef typename _Mylist::value_type value_type;
	typedef typename _Mylist::difference_type difference_type;
	typedef typename _Mylist::pointer pointer;
	typedef typename _Mylist::reference reference;

	_List_unchecked_iterator()
		{	
		}

	_List_unchecked_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}
	};

	
template<class _Mylist>
	class _List_const_iterator
		: public _List_unchecked_const_iterator<_Mylist, _Iterator_base>
	{	
public:
	typedef _List_const_iterator<_Mylist> _Myiter;
	typedef _List_unchecked_const_iterator<_Mylist, _Iterator_base> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mylist::_Nodeptr _Nodeptr;
	typedef typename _Mylist::value_type value_type;
	typedef typename _Mylist::difference_type difference_type;
	typedef typename _Mylist::const_pointer pointer;
	typedef typename _Mylist::const_reference reference;

	_List_const_iterator()
		: _Mybase()
		{	
		}

	_List_const_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	typedef _List_unchecked_const_iterator<_Mylist> _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right._Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr, static_cast<const _Mylist *>(this->_Getcont())));
		}

	reference operator*() const
		{	
 
		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
		if (_Mycont == 0
			|| this->_Ptr == nullptr_t{}
			|| this->_Ptr == _Mycont->_Myhead)
			{	
			_Debug_message(L"list iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 211);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 212, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 212, 0); };
			}

 




#line 221 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		return (_Mylist::_Myval(this->_Ptr));
		}

	_Myiter& operator++()
		{	
 
		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
		if (_Mycont == 0
			|| this->_Ptr == nullptr_t{}
			|| this->_Ptr == _Mycont->_Myhead)
			{	
			_Debug_message(L"list iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 233);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 234, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 234, 0); };
			}

 




#line 243 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		this->_Ptr = _Mylist::_Nextnode(this->_Ptr);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		const auto _Mycont = static_cast<const _Mylist *>(this->_Getcont());
		if (_Mycont == 0
			|| this->_Ptr == nullptr_t{}
			|| (this->_Ptr = _Mylist::_Prevnode(this->_Ptr)) == _Mycont->_Myhead)
			{	
			_Debug_message(L"list iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 263);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 264, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 264, 0); };
			}

 








#line 277 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	bool operator==(const _Myiter& _Right) const
		{	
 
		if (this->_Getcont() != _Right._Getcont())
			{	
			_Debug_message(L"list iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 293);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 294, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 294, 0); };
			}

 

#line 300 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		return (this->_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}
	};

template<class _Mylist> inline
	typename _List_const_iterator<_Mylist>::_Unchecked_type
		_Unchecked(_List_const_iterator<_Mylist> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mylist> inline
	_List_const_iterator<_Mylist>&
		_Rechecked(_List_const_iterator<_Mylist>& _Iter,
			typename _List_const_iterator<_Mylist>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

	
template<class _Mylist>
	class _List_iterator
		: public _List_const_iterator<_Mylist>
	{	
public:
	typedef _List_iterator<_Mylist> _Myiter;
	typedef _List_const_iterator<_Mylist> _Mybase;
	typedef bidirectional_iterator_tag iterator_category;

	typedef typename _Mylist::_Nodeptr _Nodeptr;
	typedef typename _Mylist::value_type value_type;
	typedef typename _Mylist::difference_type difference_type;
	typedef typename _Mylist::pointer pointer;
	typedef typename _Mylist::reference reference;

	_List_iterator()
		{	
		}

	_List_iterator(_Nodeptr _Pnode, const _Mylist *_Plist)
		: _Mybase(_Pnode, _Plist)
		{	
		}

	typedef _List_unchecked_iterator<_Mylist> _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right._Ptr;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Unchecked_type(this->_Ptr, (_Mylist *)this->_Getcont()));
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--(*(_Mybase *)this);
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}
	};

template<class _Mylist> inline
	typename _List_iterator<_Mylist>::_Unchecked_type
		_Unchecked(_List_iterator<_Mylist> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Mylist> inline
	_List_iterator<_Mylist>&
		_Rechecked(_List_iterator<_Mylist>& _Iter,
			typename _List_iterator<_Mylist>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference,
	class _Nodeptr_type>
	struct _List_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	typedef _Nodeptr_type _Nodeptr;
	};

template<class _Value_type,
	class _Voidptr>
	struct _List_node
		{	
		_Voidptr _Next;	
		_Voidptr _Prev;	
		_Value_type _Myval;	

	private:
		_List_node& operator=(const _List_node&);
		};

template<class _Value_type>
	struct _List_node<_Value_type, void *>
		{	
		typedef _List_node<_Value_type, void *> *_Nodeptr;
		_Nodeptr _Next;	
		_Nodeptr _Prev;	
		_Value_type _Myval;	

	private:
		_List_node& operator=(const _List_node&);
		};

template<class _Ty>
	struct _List_simple_types
		: public _Simple_types<_Ty>
	{	
	typedef _List_node<_Ty, void *> _Node;
	typedef _Node *_Nodeptr;
	};

template<class _Ty,
	class _Alloc0>
	struct _List_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _List_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _Get_voidptr<_Alty, typename _Alty::pointer>::type
		_Voidptr;
	typedef _List_node<typename _Alty::value_type,
		_Voidptr> _Node;

	typedef typename _Alty::template rebind<_Node>::other _Alnod_type;
	typedef typename _Alnod_type::pointer _Nodeptr;
	typedef _Nodeptr& _Nodepref;

	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_List_simple_types<typename _Alty::value_type>,
		_List_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference,
			_Nodeptr> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _List_val
		: public _Container_base
	{	
public:
	typedef _List_val<_Val_types> _Myt;

	typedef typename _Val_types::_Nodeptr _Nodeptr;
	typedef _Nodeptr& _Nodepref;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _List_const_iterator<_Myt> const_iterator;
	typedef _List_iterator<_Myt> iterator;

	typedef _List_unchecked_const_iterator<_Myt> _Unchecked_const_iterator;
	typedef _List_unchecked_iterator<_Myt> _Unchecked_iterator;

	_List_val()
		: _Myhead(),
		_Mysize(0)
		{	
		}

	static _Nodepref _Nextnode(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Next);
		}

	static _Nodepref _Prevnode(_Nodeptr _Pnode)
		{	
		return ((_Nodepref)_Pnode->_Prev);
		}

	static reference _Myval(_Nodeptr _Pnode)
		{	
		return ((reference)_Pnode->_Myval);
		}

	_Nodeptr _Myhead;	
	size_type _Mysize;	
	};

		
template<class _Alloc_types>
	class _List_alloc
	{	
public:
	typedef _List_alloc<_Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alnod_type _Alty;
	typedef typename _Alloc_types::_Node _Node;
	typedef typename _Alloc_types::_Nodeptr _Nodeptr;

	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef _Nodeptr& _Nodepref;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _List_const_iterator<_List_val<_Val_types> > const_iterator;
	typedef _List_iterator<_List_val<_Val_types> > iterator;

	typedef _List_unchecked_const_iterator<_List_val<_Val_types> >
		_Unchecked_const_iterator;
	typedef _List_unchecked_iterator<_List_val<_Val_types> >
		_Unchecked_iterator;

	static _Nodepref _Nextnode(_Nodeptr _Pnode)
		{	
		return (_List_val<_Val_types>::_Nextnode(_Pnode));
		}

	static _Nodepref _Prevnode(_Nodeptr _Pnode)
		{	
		return (_List_val<_Val_types>::_Prevnode(_Pnode));
		}

	static reference _Myval(_Nodeptr _Pnode)
		{	
		return (_List_val<_Val_types>::_Myval(_Pnode));
		}

 






























#line 631 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"
	_List_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	
		_Myhead() = _Buyheadnode();
		try {
		_Alloc_proxy();
		} catch (...) {
		_Freeheadnode(_Myhead());
		throw;
		}
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
		_List_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	
		_Myhead() = _Buyheadnode();
		try {
		_Alloc_proxy();
		} catch (...) {
		_Freeheadnode(_Myhead());
		throw;
		}
		}

	~_List_alloc() noexcept
		{	
		_Freeheadnode(_Myhead());
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		_Pocca(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Free_proxy();
		_Pocma(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Myproxy() = _Unfancy(_Alproxy.allocate(1));
		_Alproxy.construct(_Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = &_Get_data();
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Orphan_all();
		_Alproxy.destroy(_Myproxy());
		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	
		return (_Get_data()._Myproxy);
		}
 #line 712 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

	_Nodeptr _Buyheadnode()
		{	
		return (_Buynode0(_Nodeptr(), _Nodeptr()));
		}

	void _Freeheadnode(_Nodeptr _Pnode)
		{	
		_Getal().destroy(
			::std:: addressof(_Nextnode(_Pnode)));
		_Getal().destroy(
			::std:: addressof(_Prevnode(_Pnode)));
		_Getal().deallocate(_Pnode, 1);
		}

	_Nodeptr _Buynode0(_Nodeptr _Next,
		_Nodeptr _Prev)
		{	
		_Nodeptr _Pnode = _Getal().allocate(1);

		if (_Next == _Nodeptr())
			{	
			_Next = _Pnode;
			_Prev = _Pnode;
			}
		try {
		_Getal().construct(
			::std:: addressof(_Nextnode(_Pnode)), _Next);
		_Getal().construct(
			::std:: addressof(_Prevnode(_Pnode)), _Prev);
		} catch (...) {
		_Getal().deallocate(_Pnode, 1);
		throw;
		}

		return (_Pnode);
		}

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_List_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second());
		}

	const _List_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second());
		}

	_Nodeptr& _Myhead() noexcept
		{	
		return (_Get_data()._Myhead);
		}

	const _Nodeptr& _Myhead() const noexcept
		{	
		return (_Get_data()._Myhead);
		}

	size_type& _Mysize() noexcept
		{	
		return (_Get_data()._Mysize);
		}

	const size_type& _Mysize() const noexcept
		{	
		return (_Get_data()._Mysize);
		}

private:
	_Compressed_pair<_Alty, _List_val<_Val_types> > _Mypair;
	};

		
template<class _Ty,
	class _Alloc>
	class _List_buy
		: public _List_alloc<_List_base_types<_Ty, _Alloc> >
	{	
public:
	typedef _List_buy<_Ty, _Alloc> _Myt;
	typedef _List_alloc<_List_base_types<_Ty, _Alloc> > _Mybase;
	typedef typename _Mybase::_Alty _Alty;
	typedef typename _Mybase::_Nodeptr _Nodeptr;

	_List_buy()
		: _Mybase()
		{	
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
		_List_buy(_Any_alloc&& _Al)
		: _Mybase(::std:: forward<_Any_alloc>(_Al))
		{	
		}

	template<class... _Valty>
		_Nodeptr _Buynode(_Nodeptr _Next, _Nodeptr _Prev,
			_Valty&&... _Val)
		{	
		_Nodeptr _Pnode = this->_Buynode0(_Next, _Prev);

		try {
		this->_Getal().construct(
			::std:: addressof(this->_Myval(_Pnode)),
				::std:: forward<_Valty>(_Val)...);
		} catch (...) {
		this->_Getal().deallocate(_Pnode, 1);
		throw;
		}

		return (_Pnode);
		}


	void _Freenode(_Nodeptr _Pnode)
		{	
		this->_Getal().destroy(
			::std:: addressof(this->_Nextnode(_Pnode)));
		this->_Getal().destroy(
			::std:: addressof(this->_Prevnode(_Pnode)));
		this->_Getal().destroy(
			::std:: addressof(this->_Myval(_Pnode)));
		this->_Getal().deallocate(_Pnode, 1);
		}
	};

		
template<class _Ty,
	class _Alloc = allocator<_Ty> >
	class list
		: public _List_buy<_Ty, _Alloc>
	{	
public:
	typedef list<_Ty, _Alloc> _Myt;
	typedef _List_buy<_Ty, _Alloc> _Mybase;
	typedef typename _Mybase::_Node _Node;
	typedef typename _Mybase::_Nodeptr _Nodeptr;
	typedef typename _Mybase::_Alty _Alty;

	typedef _Alloc allocator_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;
	typedef typename _Mybase::value_type value_type;

	typedef typename _Mybase::const_iterator const_iterator;
	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::_Unchecked_const_iterator
		_Unchecked_const_iterator;
	typedef typename _Mybase::_Unchecked_iterator
		_Unchecked_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	list()
		: _Mybase()
		{	
		}

	explicit list(const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		}

	explicit list(size_type _Count)
		: _Mybase()
		{	
		resize(_Count);
		}

	list(size_type _Count, const _Ty& _Val)
		: _Mybase()
		{	
		_Construct_n(_Count, _Val);
		}

	list(size_type _Count, const _Ty& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct_n(_Count, _Val);
		}

	list(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		try {
		insert(begin(), _Right.begin(), _Right.end());
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	list(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		try {
		insert(begin(), _Right.begin(), _Right.end());
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		list(_Iter _First, _Iter _Last)
		: _Mybase()
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		list(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last)
		{	
		try {
		insert(begin(), _First, _Last);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	void _Construct_n(size_type _Count,
		const _Ty& _Val)
		{	
		try {
		_Insert_n(_Unchecked_begin(), _Count, _Val);
		} catch (...) {
		_Tidy();
		throw;
		}
		}

	list(_Myt&& _Right)
		: _Mybase(::std:: move(_Right._Getal()))
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	list(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::is_always_equal::value)
		{	
		if (this != &_Right)
			{	
			clear();

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		this->_Swap_all(_Right);
		_Swap_adl(this->_Myhead(), _Right._Myhead());
		::std:: swap(this->_Mysize(), _Right._Mysize());
		}

	void push_front(_Ty&& _Val)
		{	
		_Insert(_Unchecked_begin(), ::std:: forward<_Ty>(_Val));
		}

	void push_back(_Ty&& _Val)
		{	
		_Insert(_Unchecked_end(), ::std:: forward<_Ty>(_Val));
		}

	iterator insert(const_iterator _Where, _Ty&& _Val)
		{	
		return (emplace(_Where, ::std:: forward<_Ty>(_Val)));
		}

	template<class... _Valty>
		void emplace_front(_Valty&&... _Val)
		{	
		_Insert(_Unchecked_begin(), ::std:: forward<_Valty>(_Val)...);
		}

	template<class... _Valty>
		void emplace_back(_Valty&&... _Val)
		{	
		_Insert(_Unchecked_end(), ::std:: forward<_Valty>(_Val)...);
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	
 
		if (_Where._Getcont() != &this->_Get_data())
			_Debug_message(L"list emplace iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1051);
 #line 1053 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		_Insert(_Where._Unchecked(), ::std:: forward<_Valty>(_Val)...);
		return (_Make_iter(--_Where));
		}

	template<class... _Valty>
		void _Insert(_Unchecked_const_iterator _Where,
		_Valty&&... _Val)
		{	
		_Nodeptr _Pnode = _Where._Mynode();
		_Nodeptr _Newnode =
			this->_Buynode(_Pnode, this->_Prevnode(_Pnode),
				::std:: forward<_Valty>(_Val)...);
		_Incsize(1);
		this->_Prevnode(_Pnode) = _Newnode;
		this->_Nextnode(this->_Prevnode(_Newnode)) = _Newnode;
		}


	list(::std:: initializer_list<_Ty> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		insert(begin(), _Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<_Ty> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(::std:: initializer_list<_Ty> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<_Ty> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~list() noexcept
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				clear();
				this->_Copy_alloc(_Right._Getal());
				}

			assign(_Right.begin(), _Right.end());
			}
		return (*this);
		}

	iterator begin() noexcept
		{	
		return (iterator(this->_Nextnode(this->_Myhead()),
			&this->_Get_data()));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(this->_Nextnode(this->_Myhead()),
			&this->_Get_data()));
		}

	iterator end() noexcept
		{	
		return (iterator(this->_Myhead(), &this->_Get_data()));
		}

	const_iterator end() const noexcept
		{	
		return (const_iterator(this->_Myhead(), &this->_Get_data()));
		}

	_Unchecked_iterator _Unchecked_begin()
		{	
		return (_Unchecked_iterator(this->_Nextnode(this->_Myhead()),
			&this->_Get_data()));
		}

	_Unchecked_const_iterator _Unchecked_begin() const
		{	
		return (_Unchecked_const_iterator(this->_Nextnode(this->_Myhead()),
			&this->_Get_data()));
		}

	_Unchecked_iterator _Unchecked_end()
		{	
		return (_Unchecked_iterator(this->_Myhead(), &this->_Get_data()));
		}

	_Unchecked_const_iterator _Unchecked_end() const
		{	
		return (_Unchecked_const_iterator(this->_Myhead(),
			&this->_Get_data()));
		}

	iterator _Make_iter(const_iterator _Where) const noexcept
		{	
		return (iterator(_Where._Ptr, &this->_Get_data()));
		}

	iterator _Make_iter(_Unchecked_const_iterator _Where) const
		{	
		return (iterator(_Where._Ptr, &this->_Get_data()));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void resize(size_type _Newsize)
		{	
		if (this->_Mysize() < _Newsize)
			{	
			size_type _Count = 0;
			try {
			for (; this->_Mysize() < _Newsize; ++_Count)
				_Insert(_Unchecked_end());
			} catch (...) {
			for (; 0 < _Count; --_Count)
				pop_back();	
			throw;
			}
			}
		else
			while (_Newsize < this->_Mysize())
				pop_back();
		}

	void resize(size_type _Newsize, const _Ty& _Val)
		{	
		if (this->_Mysize() < _Newsize)
			_Insert_n(_Unchecked_end(), _Newsize - this->_Mysize(), _Val);
		else
			while (_Newsize < this->_Mysize())
				pop_back();
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize());
		}

	size_type max_size() const noexcept
		{	
		return (this->_Getal().max_size());
		}

	bool empty() const noexcept
		{	
		return (this->_Mysize() == 0);
		}

	allocator_type get_allocator() const noexcept
		{	
		allocator_type _Ret(this->_Getal());
		return (_Ret);
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(--end()));
		}

	const_reference back() const
		{	
		return (*(--end()));
		}

	void push_front(const _Ty& _Val)
		{	
		_Insert(_Unchecked_begin(), _Val);
		}

	void pop_front()
		{	
		erase(begin());
		}

	void push_back(const _Ty& _Val)
		{	
		_Insert(_Unchecked_end(), _Val);
		}

	void pop_back()
		{	
		erase(--end());
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		iterator _Old = begin();
		try {
		for (; _First != _Last && _Old != end(); ++_First, (void)++_Old)
			_Reusenode(_Old, *_First);
		for (; _First != _Last; ++_First)
			_Insert(_Unchecked_end(), *_First);
		} catch (...) {
		clear();
		throw;
		}
		erase(_Old, end());
		}

	template<class _TArg>
		void _Reusenode(iterator _Where, _TArg&& _Arg)
		{	
		try {
		this->_Getal().destroy(
			::std:: addressof(this->_Myval(_Where._Ptr)));
		this->_Getal().construct(
			::std:: addressof(this->_Myval(_Where._Ptr)),
			::std:: forward<_TArg>(_Arg));
		} catch (...) {
		_Unlinknode(_Where);
		this->_Getal().destroy(
			::std:: addressof(this->_Nextnode(_Where._Ptr)));
		this->_Getal().destroy(
			::std:: addressof(this->_Prevnode(_Where._Ptr)));
		this->_Getal().deallocate(_Where._Ptr, 1);
		throw;
		}
		}

	void assign(size_type _Count, const _Ty& _Val)
		{	
		clear();
		_Insert_n(_Unchecked_begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const _Ty& _Val)
		{	
 
		if (_Where._Getcont() != &this->_Get_data())
			_Debug_message(L"list insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1349);
 #line 1351 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		_Insert(_Where._Unchecked(), _Val);
		return (_Make_iter(--_Where));
		}

	iterator insert(const_iterator _Where,
		size_type _Count, const _Ty& _Val)
		{	
 
		if (_Where._Getcont() != &this->_Get_data())
			_Debug_message(L"list insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1361);
 #line 1363 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		iterator _Prev = _Make_iter(_Where);
		if (_Prev == begin())
			{	
			_Insert_n(_Where._Unchecked(), _Count, _Val);
			return (begin());
			}
		else
			{	
			--_Prev;
			_Insert_n(_Where._Unchecked(), _Count, _Val);
			return (++_Prev);
			}
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
 
		if (_Where._Getcont() != &this->_Get_data())
			_Debug_message(L"list insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1385);
 #line 1387 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		iterator _Prev = _Make_iter(_Where);
		if (_Prev == begin())
			{	
			_Insert_range(_Where._Unchecked(), _First, _Last,
				_Iter_cat_t<_Iter>());
			return (begin());
			}
		else
			{	
			--_Prev;
			_Insert_range(_Where._Unchecked(), _First, _Last,
				_Iter_cat_t<_Iter>());
			return (++_Prev);
			}
		}

	template<class _Iter>
		void _Insert_range(_Unchecked_const_iterator _Where,
			_Iter _First, _Iter _Last, input_iterator_tag)
		{	
		size_type _Num = 0;

		try {
		for (; _First != _Last; ++_First, (void)++_Num)
			_Insert(_Where, *_First);
		} catch (...) {
		for (; 0 < _Num; --_Num)
			{	
			_Unchecked_const_iterator _Before = _Where;
			_Unchecked_erase(--_Before);
			}
		throw;
		}
		}

	template<class _Iter>
		void _Insert_range(_Unchecked_const_iterator _Where,
			_Iter _First, _Iter _Last, forward_iterator_tag)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1427);
		_Iter _Next = _First;

		try {
		for (; _First != _Last; ++_First)
			_Insert(_Where, *_First);
		} catch (...) {
		for (; _Next != _First; ++_Next)
			{	
			_Unchecked_const_iterator _Before = _Where;
			_Unchecked_erase(--_Before);
			}
		throw;
		}
		}

	_Nodeptr _Unlinknode(const_iterator _Where)
		{	
 
		if (_Where._Getcont() != &this->_Get_data()
			|| _Where._Ptr == this->_Myhead())
			_Debug_message(L"list erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1448);
		_Nodeptr _Pnode = (_Where)._Mynode();
		_Orphan_ptr(_Pnode);

 

#line 1455 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		this->_Nextnode(this->_Prevnode(_Pnode)) =
			this->_Nextnode(_Pnode);
		this->_Prevnode(this->_Nextnode(_Pnode)) =
			this->_Prevnode(_Pnode);

		--this->_Mysize();
		return (_Pnode);
		}

	iterator erase(const_iterator _Where)
		{	
		_Nodeptr _Pnode = _Unlinknode(_Where++);
		this->_Freenode(_Pnode);
		return (_Make_iter(_Where));
		}

	void _Unchecked_erase(_Unchecked_const_iterator _Where)
		{	
		_Nodeptr _Pnode = _Where._Mynode();

		this->_Nextnode(this->_Prevnode(_Pnode)) =
			this->_Nextnode(_Pnode);
		this->_Prevnode(this->_Nextnode(_Pnode)) =
			this->_Prevnode(_Pnode);
		this->_Freenode(_Pnode);
		--this->_Mysize();
		}

	iterator erase(const_iterator _First, const_iterator _Last)
		{	
		if (_First == begin() && _Last == end())
			{	
			clear();
			return (end());
			}
		else
			{	
			while (_First != _Last)
				_First = erase(_First);
			return (_Make_iter(_Last));
			}
		}

	void clear() noexcept
		{	
 

		this->_Orphan_ptr(nullptr);
 #line 1505 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"
		_Nodeptr _Pnode = this->_Nextnode(this->_Myhead());
		this->_Nextnode(this->_Myhead()) = this->_Myhead();
		this->_Prevnode(this->_Myhead()) = this->_Myhead();
		this->_Mysize() = 0;

		for (_Nodeptr _Pnext; _Pnode != this->_Myhead(); _Pnode = _Pnext)
			{	
			_Pnext = this->_Nextnode(_Pnode);
			this->_Freenode(_Pnode);
			}
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::is_always_equal::value)
		{	
		if (this != &_Right)
			{	
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			_Swap_adl(this->_Myhead(), _Right._Myhead());
			::std:: swap(this->_Mysize(), _Right._Mysize());
			}
		}

	void splice(const_iterator _Where, _Myt& _Right)
		{	
		if (this != &_Right && !_Right.empty())
			{	
			_Splice(_Where, _Right, _Right.begin(), _Right.end(),
				_Right._Mysize());
			}
		}

	void splice(const_iterator _Where, _Myt&& _Right)
		{	
		splice(_Where, (_Myt&)_Right);
		}

	void splice(const_iterator _Where, _Myt& _Right,
		const_iterator _First)
		{	
 
		if (_First == _Right.end())
			_Debug_message(L"list splice iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1548);
		else

 

#line 1554 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

			{	
			const_iterator _Last = _First;
			++_Last;
			if (this != &_Right
				|| (_Where != _First && _Where != _Last))
				_Splice(_Where, _Right, _First, _Last, 1);
			}
		}

	void splice(const_iterator _Where, _Myt&& _Right,
		const_iterator _First)
		{	
		splice(_Where, (_Myt&)_Right, _First);
		}

	void splice(const_iterator _Where,
		_Myt& _Right, const_iterator _First, const_iterator _Last)
		{	
		if (_First != _Last && (this != &_Right || _Where != _Last))
			{	
			size_type _Count = 0;

			if (this == &_Right)
				;	
			else if (_First == _Right.begin() && _Last == _Right.end())
				_Count = _Right._Mysize();	
			else
				{	
				const_iterator _Next = _First;

				for (; _Next != _Last; ++_Next, (void)++_Count)
					if (_Next == _Right.end())
						_Xlength_error("list<T> bad splice");
				}
			_Splice(_Where, _Right, _First, _Last, _Count);
			}
		}

	void splice(const_iterator _Where,
		_Myt&& _Right, const_iterator _First, const_iterator _Last)
		{	
		splice(_Where, (_Myt&)_Right, _First, _Last);
		}

	void remove(const _Ty& _Val)
		{	
		iterator _Val_it = end();

		for (iterator _First = begin(); _First != end(); )
			if (*_First == _Val)
				if (::std:: addressof(*_First) == ::std:: addressof(_Val))
					_Val_it = _First++;
				else
					_First = erase(_First);
			else
				++_First;

		if (_Val_it != end())
			erase(_Val_it);
		}

	template<class _Pr1>
		void remove_if(_Pr1 _Pred)
		{	
		_Remove_if(_Pred);
		}

	template<class _Pr1>
		void _Remove_if(_Pr1& _Pred)
		{	
		for (iterator _First = begin(); _First != end(); )
			if (_Pred(*_First))
				_First = erase(_First);
			else
				++_First;
		}

	void unique()
		{	
		unique(equal_to<>());
		}

	template<class _Pr2>
		void unique(_Pr2 _Pred)
		{	
		const _Nodeptr _Phead = this->_Myhead();
		_Nodeptr _Pprev = this->_Nextnode(_Phead);
		_Nodeptr _Pnode = this->_Nextnode(_Pprev);

		while (_Pnode != _Phead)
			if (_Pred(_Pprev->_Myval, _Pnode->_Myval))
				{	
				const _Nodeptr _Perase = _Pnode;
				_Pnode = this->_Nextnode(_Pnode);

				this->_Nextnode(_Pprev) = _Pnode;
				this->_Prevnode(_Pnode) = _Pprev;
				this->_Freenode(_Perase);

				--this->_Mysize();
				}
			else
				{	
				_Pprev = _Pnode;
				_Pnode = this->_Nextnode(_Pnode);
				}
		}

	void merge(_Myt& _Right)
		{	
		_Merge1(_Right, less<>());
		}

	void merge(_Myt&& _Right)
		{	
		_Merge1(_Right, less<>());
		}

	template<class _Pr2>
		void merge(_Myt& _Right, _Pr2 _Pred)
		{	
		_Merge1(_Right, _Pred);
		}

	template<class _Pr2>
		void merge(_Myt&& _Right, _Pr2 _Pred)
		{	
		_Merge1(_Right, _Pred);
		}

	template<class _Pr2>
		void _Merge1(_Myt& _Right, _Pr2&& _Pred)
		{	
		if (&_Right != this)
			{	
			iterator _First1 = begin(), _Last1 = end();
			iterator _First2 = _Right.begin(), _Last2 = _Right.end();
			_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1692);
			_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1693);

			while (_First1 != _Last1 && _First2 != _Last2)
				if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1696))
					{	
					iterator _Mid2 = _First2;
					_Splice(_First1, _Right, _First2, ++_Mid2, 1);
					_First2 = _Mid2;
					}
				else
					++_First1;

			if (_First2 != _Last2)
				_Splice(_Last1, _Right, _First2, _Last2,
					_Right._Mysize());	
			}
		}

	void sort()
		{	
		sort(less<>());
		}

	template<class _Pr2>
		void sort(_Pr2 _Pred)
		{	
		_Sort(begin(), end(), _Pred, this->_Mysize());
		}

	template<class _Pr2>
		iterator _Sort(iterator _First, iterator _Last, _Pr2& _Pred,
			size_type _Size)
		{	
			
		if (_Size < 2)
			return (_First);	

		iterator _Mid = ::std:: next(_First, _Size / 2);
		_First = _Sort(_First, _Mid, _Pred, _Size / 2);
		_Mid = _Sort(_Mid, _Last, _Pred, _Size - _Size / 2);
		iterator _Newfirst = _First;

		for (bool _Initial_loop = true; ; _Initial_loop = false)
			{	
			if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1737))
				{	
				if (_Initial_loop)
					_Newfirst = _Mid;	
				splice(_First, *this, _Mid++);
				if (_Mid == _Last)
					return (_Newfirst);	
				}
			else
				{	
				++_First;
				if (_First == _Mid)
					return (_Newfirst);	
				}
			}
		}

	void reverse() noexcept
		{	
		const _Nodeptr _Phead = this->_Myhead();
		_Nodeptr _Pnode = _Phead;

		for (; ; )
			{	
			const _Nodeptr _Pnext = this->_Nextnode(_Pnode);
			this->_Nextnode(_Pnode) = this->_Prevnode(_Pnode);
			this->_Prevnode(_Pnode) = _Pnext;

			if (_Pnext == _Phead)
				break;
			_Pnode = _Pnext;
			}
		}

	void _Splice(const_iterator _Where,
		_Myt& _Right, const_iterator _First, const_iterator _Last,
		size_type _Count)
		{	
 
		if (_Where._Getcont() != &this->_Get_data())
			_Debug_message(L"list splice iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1777);
		if (this->_Getal() != _Right._Getal())
			_Debug_message(L"list containers incompatible for splice", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1779);

		if (this != &_Right)
			{	
			_Lockit _Lock(3);

			const bool _One = _Count == 1;
			const bool _All = !_One && _Count == _Right.size();
			const bool _Some = !_One && !_All;

			_Nodeptr _Oldprev = this->_Prevnode(_First._Ptr);

			if (_Some)
				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
					_Ptr = this->_Nextnode(_Ptr))
					{	
					this->_Prevnode(_Ptr) = nullptr_t{};
					}

			const_iterator **_Pnext = (const_iterator **)_Right._Getpfirst();

			if (_Pnext == 0)
				_Debug_message(L"list container corrupted", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list", 1801);

			while (*_Pnext != 0)
				{	
				const_iterator& _Iter = **_Pnext;

				if ((_One && _Iter._Ptr == _First._Ptr)
					|| (_All && _Iter._Ptr != _Right._Myhead())
					|| (_Some && this->_Prevnode(_Iter._Ptr) == nullptr_t{}))
					{	
					*_Pnext = (const_iterator *)_Iter._Mynextiter;
					_Iter._Myproxy = this->_Myproxy();
					_Iter._Mynextiter = this->_Myproxy()->_Myfirstiter;
					this->_Myproxy()->_Myfirstiter = &_Iter;
					}
				else
					{	
					_Pnext = (const_iterator **)_Iter._Getpnext();
					}
				}

			if (_Some)
				for (_Nodeptr _Ptr = _First._Ptr; _Ptr != _Last._Ptr;
					_Ptr = this->_Nextnode(_Ptr))
					{	
					this->_Prevnode(_Ptr) = _Oldprev;
					_Oldprev = _Ptr;
					}
			}

 


#line 1835 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"

		_Splice_same(_Where, _Right, _First, _Last, _Count);
		}

	void _Splice_same(const_iterator _Where,
		_Myt& _Right, const_iterator _First, const_iterator _Last,
		size_type _Count)
		{	
		if (this != &_Right)
			{	
			_Incsize(_Count);
			_Right._Mysize() -= _Count;
			}
		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
			_Last._Mynode();
		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
			_Where._Mynode();
		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
			_First._Mynode();

		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
		this->_Prevnode(_Where._Mynode()) =
			this->_Prevnode(_Last._Mynode());
		this->_Prevnode(_Last._Mynode()) =
			this->_Prevnode(_First._Mynode());
		this->_Prevnode(_First._Mynode()) = _Pnode;
		}

	void _Unchecked_splice(_Unchecked_const_iterator _Where,
		_Unchecked_const_iterator _First,
		_Unchecked_const_iterator _Last)
		{	
		this->_Nextnode(this->_Prevnode(_First._Mynode())) =
			_Last._Mynode();
		this->_Nextnode(this->_Prevnode(_Last._Mynode())) =
			_Where._Mynode();
		this->_Nextnode(this->_Prevnode(_Where._Mynode())) =
			_First._Mynode();

		_Nodeptr _Pnode = this->_Prevnode(_Where._Mynode());
		this->_Prevnode(_Where._Mynode()) =
			this->_Prevnode(_Last._Mynode());
		this->_Prevnode(_Last._Mynode()) =
			this->_Prevnode(_First._Mynode());
		this->_Prevnode(_First._Mynode()) = _Pnode;
		}

	void _Tidy()
		{	
		clear();
		}

	void _Insert_n(_Unchecked_const_iterator _Where,
		size_type _Count, const _Ty& _Val)
		{	
		size_type _Countsave = _Count;

		try {
		for (; 0 < _Count; --_Count)
			_Insert(_Where, _Val);
		} catch (...) {
		for (; _Count < _Countsave; ++_Count)
			{	
			_Unchecked_const_iterator _Before = _Where;
			_Unchecked_erase(--_Before);
			}
		throw;
		}
		}

	void _Incsize(size_type _Count)
		{	
		if (max_size() - this->_Mysize() - 1 < _Count)
			_Xlength_error("list<T> too long");
		this->_Mysize() += _Count;
		}

 
	void _Orphan_ptr(_Nodeptr _Ptr)
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				{	
				if ((*_Pnext)->_Ptr == this->_Myhead()
					|| (_Ptr != nullptr_t{} && (*_Pnext)->_Ptr != _Ptr))
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
				}
		}
 #line 1931 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"
	};

		

template<class _Ty,
	class _Alloc> inline
	void swap(list<_Ty, _Alloc>& _Left, list<_Ty, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator==(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const list<_Ty, _Alloc>& _Left,
		const list<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1997 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"
#line 1998 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\list"






#line 4 "d:\\users\\stasw\\documents\\virheimur\\game - client\\mouse.h"

using namespace std;

class Mouse
{
private:
	Mouse();
	Mouse(Mouse&) = delete;
	Mouse& operator=(Mouse&) = delete;

	static Mouse instance;
public:
	static Mouse& Instanace()
	{
		static Mouse instance;
		return instance;
	}
	~Mouse() {}
	int GetMouseX() const;
	int GetMouseY() const;
	glm::vec2 GetMouseCoords() const;
	int GetWheelDelta() const;
	bool LeftIsPressed() const;
	bool RightIsPressed() const;
	bool IsInWindow() const { return isInWindow; }
	bool IsInRectangle(int Top, int Left, int Bot, int Right) const;

	void OnMouseMove(int x, int y);
	void OnWheelMove(int delta);
	void OnLeftPressed();
	void OnLeftReleased();
	void OnRightPressed();
	void OnRightReleased();
	void SetInWindow(const bool);

	void SetWindowSize(const int x, const int y);
	glm::vec2 GetWindowSize() const;
	list<int>& GetCommands();
	void PushCommand(int);

private:
	int x;
	int y;
	int z;
	int delta;
	bool leftIsPressed;
	bool rightIsPressed;
	bool isInWindow;
	glm::vec2 WindowSize;
	list<int> Commands;
};




























#line 4 "d:\\users\\stasw\\documents\\virheimur\\game - client\\imageloader.h"



#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shaderbuilder.h"
#pragma once
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"

#pragma once





 
  
 #line 11 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"

 
 
 

 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 28197)

namespace std {
template<class _Ty>
	struct default_delete;

template<class _Ty,
	class _Dx = default_delete<_Ty> >
	class unique_ptr;

	
class bad_weak_ptr
	: public ::std:: exception
	{	
public:
	bad_weak_ptr() noexcept
		{	
		}

	virtual const char * what() const throw()
		{	
		return ("bad_weak_ptr");
		}
	};

	
class _Ref_count_base
	{	
private:
	virtual void _Destroy() noexcept = 0;
	virtual void _Delete_this() noexcept = 0;

private:
	_Atomic_counter_t _Uses;
	_Atomic_counter_t _Weaks;

protected:
	_Ref_count_base()
		{	
		_Init_atomic_counter(_Uses, 1);
		_Init_atomic_counter(_Weaks, 1);
		}

public:
	virtual ~_Ref_count_base() noexcept
		{	
		}

	bool _Incref_nz()
		{	
		for (; ; )
			{	
 
			_Atomic_integral_t _Count =
				static_cast<volatile _Atomic_counter_t&>(_Uses);

			if (_Count == 0)
				return (false);

			if (static_cast<_Atomic_integral_t>(_InterlockedCompareExchange(
					reinterpret_cast<volatile long *>(&_Uses),
					_Count + 1, _Count)) == _Count)
				return (true);

 








#line 95 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"
			}
		}

	void _Incref()
		{	
		_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Uses));
		}

	void _Incwref()
		{	
		_InterlockedIncrement(reinterpret_cast<volatile long *>(&_Weaks));
		}

	void _Decref()
		{	
		if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Uses)) == 0)
			{	
			_Destroy();
			_Decwref();
			}
		}

	void _Decwref()
		{	
		if (_InterlockedDecrement(reinterpret_cast<volatile long *>(&_Weaks)) == 0)
			_Delete_this();
		}

	long _Use_count() const noexcept
		{	
		return (_Get_atomic_count(_Uses));
		}

	bool _Expired() const noexcept
		{	
		return (_Use_count() == 0);
		}

	virtual void *_Get_deleter(const  type_info&) const noexcept
		{	
		return (0);
		}
	};

	
template<class _Ty>
	class _Ref_count
	: public _Ref_count_base
	{	
public:
	_Ref_count(_Ty *_Px)
		: _Ref_count_base(), _Ptr(_Px)
		{	
		}

private:
	virtual void _Destroy() noexcept
		{	
		delete _Ptr;
		}

	virtual void _Delete_this() noexcept
		{	
		delete this;
		}

	_Ty * _Ptr;
	};

	
template<class _Ty,
	class _Dx>
	class _Ref_count_del
	: public _Ref_count_base
	{	
public:
	_Ref_count_del(_Ty *_Px, _Dx _Dt)
		: _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Dt, _Px)
		{	
		}

	virtual void *_Get_deleter(
		const  type_info& _Typeid) const noexcept
		{	
		return ((void *)(_Typeid == typeid(_Dx)
			? ::std:: addressof(_Mypair._Get_first()) : 0));
		}

private:
	virtual void _Destroy() noexcept
		{	
		_Mypair._Get_first()(_Mypair._Get_second());
		}

	virtual void _Delete_this() noexcept
		{	
		delete this;
		}

	_Compressed_pair<_Dx, _Ty *> _Mypair;
	};

	
template<class _Ty,
	class _Dx,
	class _Alloc>
	class _Ref_count_del_alloc
	: public _Ref_count_base
	{	
public:
	typedef _Ref_count_del_alloc<_Ty, _Dx, _Alloc> _Myt;
	typedef _Wrap_alloc<_Alloc> _Myalty0;
	typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;

	_Ref_count_del_alloc(_Ty *_Px, _Dx _Dt, const _Alloc& _Ax)
		: _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Dt,
			_One_then_variadic_args_t(), _Ax, _Px)
		{	
		}

	virtual void *_Get_deleter(
		const  type_info& _Typeid) const noexcept
		{	
		return ((void *)(_Typeid == typeid(_Dx)
			? ::std:: addressof(_Mypair._Get_first()) : 0));
		}

private:
	virtual void _Destroy() noexcept
		{	
		_Mypair._Get_first()(_Mypair._Get_second()._Get_second());
		}

	virtual void _Delete_this() noexcept
		{	
		_Myalty _Al = _Mypair._Get_second()._Get_first();
		_Al.destroy(this);
		_Al.deallocate(this, 1);
		}

	_Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Ty *> > _Mypair;
	};

	
template<class _Ty>
	class weak_ptr;
template<class _Ty>
	class shared_ptr;
template<class _Ty>
	class enable_shared_from_this;

template<class _Ty1,
	class _Ty2>
	void _Do_enable(_Ty1 *, enable_shared_from_this<_Ty2> *,
		_Ref_count_base *);

template<class _Ty>
	inline void _Enable_shared(_Ty *_Ptr, _Ref_count_base *_Refptr,
		typename _Ty::_EStype * = 0)
	{	
	if (_Ptr)
		_Do_enable(_Ptr,
			(enable_shared_from_this<typename _Ty::_EStype>*)_Ptr, _Refptr);
	}

inline void _Enable_shared(const volatile void *, const volatile void *)
	{	
	}

	
template<class _Ty>
	class _Ptr_base
	{	
public:
	typedef _Ptr_base<_Ty> _Myt;
	typedef _Ty element_type;

	constexpr _Ptr_base() noexcept
		: _Ptr(0), _Rep(0)
		{	
		}

	_Ptr_base(_Myt&& _Right)
		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
		{	
		_Right._Ptr = 0;
		_Right._Rep = 0;
		}

	template<class _Ty2>
		_Ptr_base(_Ptr_base<_Ty2>&& _Right)
		: _Ptr(_Right._Ptr), _Rep(_Right._Rep)
		{	
		_Right._Ptr = 0;
		_Right._Rep = 0;
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: move(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		_Swap(_Right);
		}

	long use_count() const noexcept
		{	
		return (_Rep ? _Rep->_Use_count() : 0);
		}

	void _Swap(_Ptr_base& _Right) noexcept
		{	
		::std:: swap(_Rep, _Right._Rep);
		::std:: swap(_Ptr, _Right._Ptr);
		}

	template<class _Ty2>
		bool owner_before(const _Ptr_base<_Ty2>& _Right) const
		{	
		return (_Rep < _Right._Rep);
		}

	void *_Get_deleter(const  type_info& _Typeid) const noexcept
		{	
		return (_Rep ? _Rep->_Get_deleter(_Typeid) : 0);
		}

	_Ty *_Get() const noexcept
		{	
		return (_Ptr);
		}

	bool _Expired() const noexcept
		{	
		return (!_Rep || _Rep->_Expired());
		}

	void _Decref()
		{	
		if (_Rep != 0)
			_Rep->_Decref();
		}

	void _Reset()
		{	
		_Reset(0, 0);
		}

	template<class _Ty2>
		void _Reset(const _Ptr_base<_Ty2>& _Other)
		{	
		_Reset(_Other._Ptr, _Other._Rep);
		}

	template<class _Ty2>
		void _Reset(const _Ptr_base<_Ty2>& _Other, bool _Throw)
		{	
		_Reset(_Other._Ptr, _Other._Rep, _Throw);
		}

 
	template<class _Ty2>
		void _Reset(auto_ptr<_Ty2>&& _Other)
		{	
		_Ty2 *_Px = _Other.get();
		_Reset0(_Px, new _Ref_count<_Ty>(_Px));
		_Other.release();
		_Enable_shared(_Px, _Rep);
		}
 #line 368 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"

	template<class _Ty2>
		void _Reset(_Ty *_Other_ptr, const _Ptr_base<_Ty2>& _Other)
		{	
		_Reset(_Other_ptr, _Other._Rep);
		}

	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
		{	
		if (_Other_rep)
			_Other_rep->_Incref();
		_Reset0(_Other_ptr, _Other_rep);
		}

	void _Reset(_Ty *_Other_ptr, _Ref_count_base *_Other_rep, bool _Throw)
		{	
			
			
		if (_Other_rep && _Other_rep->_Incref_nz())
			_Reset0(_Other_ptr, _Other_rep);
		else if (_Throw)
			throw bad_weak_ptr();
		}

	void _Reset0(_Ty *_Other_ptr, _Ref_count_base *_Other_rep)
		{	
		if (_Rep != 0)
			_Rep->_Decref();
		_Rep = _Other_rep;
		_Ptr = _Other_ptr;
		}

	void _Decwref()
		{	
		if (_Rep != 0)
			_Rep->_Decwref();
		}

	void _Resetw()
		{	
		_Resetw((_Ty *)0, 0);
		}

	template<class _Ty2>
		void _Resetw(const _Ptr_base<_Ty2>& _Other)
		{	
		_Resetw(_Other._Ptr, _Other._Rep);
		}

	template<class _Ty2>
		void _Resetw(_Ty2 *_Other_ptr, _Ref_count_base *_Other_rep)
		{	
		if (_Other_rep)
			_Other_rep->_Incwref();
		if (_Rep != 0)
			_Rep->_Decwref();
		_Rep = _Other_rep;
		_Ptr = const_cast<remove_cv_t<_Ty2> *>(_Other_ptr);
		}

private:
	_Ty *_Ptr;
	_Ref_count_base *_Rep;
	template<class _Ty0>
		friend class _Ptr_base;
	};

	
template<class _Ty>
	class shared_ptr
		: public _Ptr_base<_Ty>
	{	
public:
	typedef shared_ptr<_Ty> _Myt;
	typedef _Ptr_base<_Ty> _Mybase;

	constexpr shared_ptr() noexcept
		{	
		}

	template<class _Ux>
		explicit shared_ptr(_Ux *_Px)
		{	
		_Resetp(_Px);
		}

	template<class _Ux,
		class _Dx>
		shared_ptr(_Ux *_Px, _Dx _Dt)
		{	
		_Resetp(_Px, _Dt);
		}

	constexpr shared_ptr(nullptr_t) noexcept
		{	
		}

	template<class _Dx>
		shared_ptr(nullptr_t, _Dx _Dt)
		{	
		_Resetp((_Ty *)0, _Dt);
		}

	template<class _Dx,
		class _Alloc>
		shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax)
		{	
		_Resetp((_Ty *)0, _Dt, _Ax);
		}

	template<class _Ux,
		class _Dx,
		class _Alloc>
		shared_ptr(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
		{	
		_Resetp(_Px, _Dt, _Ax);
		}

	template<class _Ty2>
		shared_ptr(const shared_ptr<_Ty2>& _Right, _Ty *_Px) noexcept
		{	
		this->_Reset(_Px, _Right);
		}

	shared_ptr(const _Myt& _Other) noexcept
		{	
		this->_Reset(_Other);
		}

	template<class _Ty2,
		class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
			void>::type>
		shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept
		{	
		this->_Reset(_Other);
		}

	template<class _Ty2>
		explicit shared_ptr(const weak_ptr<_Ty2>& _Other,
			bool _Throw = true)
		{	
		this->_Reset(_Other, _Throw);
		}

 
	template<class _Ty2>
		shared_ptr(auto_ptr<_Ty2>&& _Other)
		{	
		this->_Reset(::std:: move(_Other));
		}
 #line 519 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"

	shared_ptr(_Myt&& _Right) noexcept
		: _Mybase(::std:: move(_Right))
		{	
		}

	template<class _Ty2,
		class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
			void>::type>
		shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept
		: _Mybase(::std:: move(_Right))
		{	
		}


	template<class _Ux,
		class _Dx,
		class = typename enable_if<is_convertible<
			typename unique_ptr<_Ux, _Dx>::pointer, _Ty *>::value,
			void>::type>
		shared_ptr(unique_ptr<_Ux, _Dx>&& _Right)
		{	
		_Resetp(_Right.release(), _Right.get_deleter());
		}

	template<class _Ux,
		class _Dx>
		_Myt& operator=(unique_ptr<_Ux, _Dx>&& _Right)
		{	
		shared_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right) noexcept
		{	
		shared_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		_Myt& operator=(shared_ptr<_Ty2>&& _Right) noexcept
		{	
		shared_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

	~shared_ptr() noexcept
		{	
		this->_Decref();
		}

	_Myt& operator=(const _Myt& _Right) noexcept
		{	
		shared_ptr(_Right).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		_Myt& operator=(const shared_ptr<_Ty2>& _Right) noexcept
		{	
		shared_ptr(_Right).swap(*this);
		return (*this);
		}

 
	template<class _Ty2>
		_Myt& operator=(auto_ptr<_Ty2>&& _Right)
		{	
		shared_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}
 #line 591 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"

	void reset() noexcept
		{	
		shared_ptr().swap(*this);
		}

	template<class _Ux>
		void reset(_Ux *_Px)
		{	
		shared_ptr(_Px).swap(*this);
		}

	template<class _Ux,
		class _Dx>
		void reset(_Ux *_Px, _Dx _Dt)
		{	
		shared_ptr(_Px, _Dt).swap(*this);
		}

	template<class _Ux,
		class _Dx,
		class _Alloc>
		void reset(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
		{	
		shared_ptr(_Px, _Dt, _Ax).swap(*this);
		}

	void swap(_Myt& _Other) noexcept
		{	
		this->_Swap(_Other);
		}

	_Ty *get() const noexcept
		{	
		return (this->_Get());
		}

	typename add_lvalue_reference<_Ty>::type operator*() const noexcept
		{	
		return (*this->_Get());
		}

	_Ty *operator->() const noexcept
		{	
		return (this->_Get());
		}

	bool unique() const noexcept
		{	
		return (this->use_count() == 1);
		}

	explicit operator bool() const noexcept
		{	
		return (this->_Get() != 0);
		}

private:
	template<class _Ux>
		void _Resetp(_Ux *_Px)
		{	
		try {	
		_Resetp0(_Px, new _Ref_count<_Ux>(_Px));
		} catch (...) {	
		delete _Px;
		throw;
		}
		}

	template<class _Ux,
		class _Dx>
		void _Resetp(_Ux *_Px, _Dx _Dt)
		{	
		try {	
		_Resetp0(_Px, new _Ref_count_del<_Ux, _Dx>(_Px, _Dt));
		} catch (...) {	
		_Dt(_Px);
		throw;
		}
		}

	template<class _Ux,
		class _Dx,
		class _Alloc>
		void _Resetp(_Ux *_Px, _Dx _Dt, _Alloc _Ax)
		{	
		typedef _Ref_count_del_alloc<_Ux, _Dx, _Alloc> _Refd;
		typedef _Wrap_alloc<_Alloc> _Alref0;
		typename _Alref0::template rebind<_Refd>::other _Alref(_Ax);

		try {	
		_Refd *_Pref = _Alref.allocate(1);
		_Alref.construct(_Pref, _Px, _Dt, _Ax);
		_Resetp0(_Px, _Pref);
		} catch (...) {	
		_Dt(_Px);
		throw;
		}
		}

public:
	template<class _Ux>
		void _Resetp0(_Ux *_Px, _Ref_count_base *_Rx)
		{	
		this->_Reset0(_Px, _Rx);
		_Enable_shared(_Px, _Rx);
		}
	};

template<class _Ty1,
	class _Ty2>
	bool operator==(const shared_ptr<_Ty1>& _Left,
		const shared_ptr<_Ty2>& _Right) noexcept
	{	
	return (_Left.get() == _Right.get());
	}

template<class _Ty1,
	class _Ty2>
	bool operator!=(const shared_ptr<_Ty1>& _Left,
		const shared_ptr<_Ty2>& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Ty2>
	bool operator<(const shared_ptr<_Ty1>& _Left,
		const shared_ptr<_Ty2>& _Right) noexcept
	{	
	return (less<decltype(_Always_false<_Ty1>::value
		? _Left.get() : _Right.get())>()(
			_Left.get(), _Right.get()));
	}

template<class _Ty1,
	class _Ty2>
	bool operator>=(const shared_ptr<_Ty1>& _Left,
		const shared_ptr<_Ty2>& _Right) noexcept
	{	
	return (!(_Left < _Right));
	}

template<class _Ty1,
	class _Ty2>
	bool operator>(const shared_ptr<_Ty1>& _Left,
		const shared_ptr<_Ty2>& _Right) noexcept
	{	
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Ty2>
	bool operator<=(const shared_ptr<_Ty1>& _Left,
		const shared_ptr<_Ty2>& _Right) noexcept
	{	
	return (!(_Right < _Left));
	}

template<class _Ty>
	bool operator==(const shared_ptr<_Ty>& _Left,
		nullptr_t) noexcept
	{	
	return (_Left.get() == (_Ty *)0);
	}

template<class _Ty>
	bool operator==(nullptr_t,
		const shared_ptr<_Ty>& _Right) noexcept
	{	
	return ((_Ty *)0 == _Right.get());
	}

template<class _Ty>
	bool operator!=(const shared_ptr<_Ty>& _Left,
		nullptr_t _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

template<class _Ty>
	bool operator!=(nullptr_t _Left,
		const shared_ptr<_Ty>& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

template<class _Ty>
	bool operator<(const shared_ptr<_Ty>& _Left,
		nullptr_t _Right) noexcept
	{	
	return (less<_Ty *>()(_Left.get(), (_Ty *)0));
	}

template<class _Ty>
	bool operator<(nullptr_t _Left,
		const shared_ptr<_Ty>& _Right) noexcept
	{	
	return (less<_Ty *>()((_Ty *)0, _Right.get()));
	}

template<class _Ty>
	bool operator>=(const shared_ptr<_Ty>& _Left,
		nullptr_t _Right) noexcept
	{	
	return (!(_Left < _Right));
	}

template<class _Ty>
	bool operator>=(nullptr_t _Left,
		const shared_ptr<_Ty>& _Right) noexcept
	{	
	return (!(_Left < _Right));
	}

template<class _Ty>
	bool operator>(const shared_ptr<_Ty>& _Left,
		nullptr_t _Right) noexcept
	{	
	return (_Right < _Left);
	}

template<class _Ty>
	bool operator>(nullptr_t _Left,
		const shared_ptr<_Ty>& _Right) noexcept
	{	
	return (_Right < _Left);
	}

template<class _Ty>
	bool operator<=(const shared_ptr<_Ty>& _Left,
		nullptr_t _Right) noexcept
	{	
	return (!(_Right < _Left));
	}

template<class _Ty>
	bool operator<=(nullptr_t _Left,
		const shared_ptr<_Ty>& _Right) noexcept
	{	
	return (!(_Right < _Left));
	}

template<class _Elem,
	class _Traits,
	class _Ty>
	basic_ostream<_Elem, _Traits>&
	operator<<(basic_ostream<_Elem, _Traits>& _Out,
		const shared_ptr<_Ty>& _Px)
	{	
	return (_Out << _Px.get());
	}

template<class _Ty>
	void swap(shared_ptr<_Ty>& _Left,
		shared_ptr<_Ty>& _Right) noexcept
	{	
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Ty2>
	shared_ptr<_Ty1>
		static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
	{	
	typedef typename shared_ptr<_Ty1>::element_type _Elem1;
	_Elem1 *_Ptr = static_cast<_Elem1 *>(_Other.get());
	return (shared_ptr<_Ty1>(_Other, _Ptr));
	}

template<class _Ty1,
	class _Ty2>
	shared_ptr<_Ty1>
		const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
	{	
	typedef typename shared_ptr<_Ty1>::element_type _Elem1;
	_Elem1 *_Ptr = const_cast<_Elem1 *>(_Other.get());
	return (shared_ptr<_Ty1>(_Other, _Ptr));
	}

template<class _Ty1,
	class _Ty2>
	shared_ptr<_Ty1>
		dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
	{	
	typedef typename shared_ptr<_Ty1>::element_type _Elem1;
	_Elem1 *_Ptr = dynamic_cast<_Elem1 *>(_Other.get());
	if (_Ptr)
		return (shared_ptr<_Ty1>(_Other, _Ptr));
	else
		return (shared_ptr<_Ty1>());
	}

template<class _Dx,
	class _Ty>
	_Dx *get_deleter(const shared_ptr<_Ty>& _Sx) noexcept
	{	
	return ((_Dx *)_Sx._Get_deleter(typeid(_Dx)));
	}

	
template<class _Ty>
	class _Ref_count_obj
	: public _Ref_count_base
	{	
public:
	template<class... _Types>
		_Ref_count_obj(_Types&&... _Args)
		: _Ref_count_base()
		{	
		::new ((void *)&_Storage) _Ty(::std:: forward<_Types>(_Args)...);
		}


	_Ty *_Getptr() const
		{	
		return ((_Ty *)&_Storage);
		}

private:
	virtual void _Destroy() noexcept
		{	
		_Getptr()->~_Ty();
		}

	virtual void _Delete_this() noexcept
		{	
		delete this;
		}

	typename aligned_union<1, _Ty>::type _Storage;
	};

	
template<class _Ty,
	class _Alloc>
	class _Ref_count_obj_alloc
	: public _Ref_count_base
	{	
public:
	typedef _Ref_count_obj_alloc<_Ty, _Alloc> _Myt;
	typedef _Wrap_alloc<_Alloc> _Myalty0;
	typedef typename _Myalty0::template rebind<_Myt>::other _Myalty;
	typedef typename aligned_union<1, _Ty>::type _Mystoragety;

	template<class... _Types>
		_Ref_count_obj_alloc(const _Alloc& _Al_arg, _Types&&... _Args)
		: _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), _Al_arg)
		{	
		::new ((void *)_Getptr()) _Ty(::std:: forward<_Types>(_Args)...);
		}


	_Ty *_Getptr() const
		{	
		return ((_Ty *)&_Mypair._Get_second());
		}

private:
	virtual void _Destroy() noexcept
		{	
		_Getptr()->~_Ty();
		}

	virtual void _Delete_this() noexcept
		{	
		_Myalty _Al = _Mypair._Get_first();
		_Al.destroy(this);
		_Al.deallocate(this, 1);
		}

	_Compressed_pair<_Myalty, _Mystoragety> _Mypair;
	};

	
template<class _Ty,
	class... _Types> inline
		shared_ptr<_Ty> make_shared(_Types&&... _Args)
	{	
	_Ref_count_obj<_Ty> *_Rx =
		new _Ref_count_obj<_Ty>(::std:: forward<_Types>(_Args)...);

	shared_ptr<_Ty> _Ret;
	_Ret._Resetp0(_Rx->_Getptr(), _Rx);
	return (_Ret);
	}

	
template<class _Ty,
	class _Alloc,
	class... _Types> inline
	shared_ptr<_Ty> allocate_shared(
		const _Alloc& _Al_arg, _Types&&... _Args)
	{	
	typedef _Ref_count_obj_alloc<_Ty, _Alloc> _Refoa;
	typedef _Wrap_alloc<_Alloc> _Alref0;
	typename _Alref0::template rebind<_Refoa>::other _Alref(_Al_arg);

	_Refoa *_Rx = _Alref.allocate(1);

	try {
		_Alref.construct(_Rx, _Al_arg, ::std:: forward<_Types>(_Args)...);
	} catch (...) {
		_Alref.deallocate(_Rx, 1);
	throw;
	}

	shared_ptr<_Ty> _Ret;
	_Ret._Resetp0(_Rx->_Getptr(), _Rx);
	return (_Ret);
	}


	
template<class _Ty>
	class weak_ptr
		: public _Ptr_base<_Ty>
	{	
public:
	typedef weak_ptr<_Ty> _Myt;
	typedef _Ptr_base<_Ty> _Mybase;

	constexpr weak_ptr() noexcept
		{	
		}

	weak_ptr(const weak_ptr& _Other) noexcept
		{	
		this->_Resetw(_Other);
		}

	template<class _Ty2,
		class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
			void>::type>
		weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept
		{	
		this->_Resetw(_Other);
		}

	template<class _Ty2,
		class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
			void>::type>
		weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept
		{	
		this->_Resetw(_Other.lock());
		}

	weak_ptr(_Myt&& _Other) noexcept
		: _Mybase(::std:: move(_Other))
		{	
		}

	template<class _Ty2,
		class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
			void>::type>
		weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept
		{	
		this->_Resetw(_Other.lock());
		_Other.reset();
		}

	~weak_ptr() noexcept
		{	
		this->_Decwref();
		}

	weak_ptr& operator=(const weak_ptr& _Right) noexcept
		{	
		this->_Resetw(_Right);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept
		{	
		this->_Resetw(_Right.lock());
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right) noexcept
		{	
		weak_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		_Myt& operator=(weak_ptr<_Ty2>&& _Right) noexcept
		{	
		weak_ptr(::std:: move(_Right)).swap(*this);
		return (*this);
		}

	template<class _Ty2>
		weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept
		{	
		this->_Resetw(_Right);
		return (*this);
		}

	void reset() noexcept
		{	
		this->_Resetw();
		}

	void swap(weak_ptr& _Other) noexcept
		{	
		this->_Swap(_Other);
		}

	bool expired() const noexcept
		{	
		return (this->_Expired());
		}

	shared_ptr<_Ty> lock() const noexcept
		{	
		return (shared_ptr<_Ty>(*this, false));
		}
	};

template<class _Ty>
	void swap(weak_ptr<_Ty>& _W1, weak_ptr<_Ty>& _W2) noexcept
	{	
	_W1.swap(_W2);
	}

	
template<class _Ty>
	class enable_shared_from_this
	{	
public:
	typedef _Ty _EStype;

	shared_ptr<_Ty> shared_from_this()
		{	
		return (shared_ptr<_Ty>(_Wptr));
		}

	shared_ptr<const _Ty> shared_from_this() const
		{	
		return (shared_ptr<const _Ty>(_Wptr));
		}

protected:
	constexpr enable_shared_from_this() noexcept
		{	
		}

	enable_shared_from_this(const enable_shared_from_this&) noexcept
		{	
		}

	enable_shared_from_this&
		operator=(const enable_shared_from_this&) noexcept
		{	
		return (*this);
		}

	~enable_shared_from_this() noexcept
		{	
		}

private:
	template<class _Ty1,
		class _Ty2>
		friend void _Do_enable(
			_Ty1 *,
			enable_shared_from_this<_Ty2>*,
			_Ref_count_base *);

	weak_ptr<_Ty> _Wptr;
	};

template<class _Ty1,
	class _Ty2>
	inline void _Do_enable(
		_Ty1 *_Ptr,
		enable_shared_from_this<_Ty2> *_Es,
		_Ref_count_base *_Refptr)
	{	
	_Es->_Wptr._Resetw(_Ptr, _Refptr);
	}
}

namespace std {
	

	
template<class _Ty>
	struct default_delete
	{	
	constexpr default_delete() noexcept = default;

	template<class _Ty2,
		class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value,
			void>::type>
		default_delete(const default_delete<_Ty2>&) noexcept
		{	
		}

	void operator()(_Ty *_Ptr) const noexcept
		{	
		static_assert(0 < sizeof (_Ty),
			"can't delete an incomplete type");
		delete _Ptr;
		}
	};

template<class _Ty>
	struct default_delete<_Ty[]>
	{	
	constexpr default_delete() noexcept = default;

	template<class _Uty,
		class = typename enable_if<is_convertible<_Uty(*)[], _Ty(*)[]>::value,
			void>::type>
		default_delete(const default_delete<_Uty[]>&) noexcept
		{	
		}

	template<class _Uty,
		class = typename enable_if<is_convertible<_Uty(*)[], _Ty(*)[]>::value,
			void>::type>
		void operator()(_Uty *_Ptr) const noexcept
		{	
		static_assert(0 < sizeof (_Uty),
			"can't delete an incomplete type");
		delete[] _Ptr;
		}
	};

		
template<class _Val,
	class _Ty>
	struct _Get_deleter_pointer_type
	{ template<class _Uty> static auto _Fn(int) -> _Identity<typename _Uty::pointer>; template<class _Uty> static auto _Fn(_Wrap_int) -> _Identity<_Val *>; typedef decltype(_Fn<_Ty>(0)) _Decltype; typedef typename _Decltype::type type; };
#line 1228 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"

	
template<class _Ty,
	class _Dx>
	class _Unique_ptr_base
	{	
public:
	typedef typename remove_reference<_Dx>::type _Dx_noref;
	typedef typename _Get_deleter_pointer_type<_Ty, _Dx_noref>::type pointer;

	template<class _Ptr2,
		class _Dx2>
		_Unique_ptr_base(_Ptr2 _Ptr, _Dx2&& _Dt)
		: _Mypair(_One_then_variadic_args_t(), ::std:: forward<_Dx2>(_Dt), _Ptr)
		{	
		}

	template<class _Ptr2>
		constexpr _Unique_ptr_base(_Ptr2 _Ptr)
		: _Mypair(_Zero_then_variadic_args_t(), _Ptr)
		{	
		}

	_Dx& get_deleter() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const _Dx& get_deleter() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	pointer& _Myptr() noexcept
		{	
		return (_Mypair._Get_second());
		}

	const pointer& _Myptr() const noexcept
		{	
		return (_Mypair._Get_second());
		}

	_Compressed_pair<_Dx, pointer> _Mypair;
	};

	
template<class _Ty,
	class _Dx>	
	class unique_ptr
		: public _Unique_ptr_base<_Ty, _Dx>
	{	
public:
	typedef unique_ptr<_Ty, _Dx> _Myt;
	typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
	typedef typename _Mybase::pointer pointer;
	typedef _Ty element_type;
	typedef _Dx deleter_type;

	using _Mybase::get_deleter;

	constexpr unique_ptr() noexcept
		: _Mybase(pointer())
		{	
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	constexpr unique_ptr(nullptr_t) noexcept
		: _Mybase(pointer())
		{	
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	_Myt& operator=(nullptr_t) noexcept
		{	
		reset();
		return (*this);
		}

	explicit unique_ptr(pointer _Ptr) noexcept
		: _Mybase(_Ptr)
		{	
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	unique_ptr(pointer _Ptr,
		typename _If<is_reference<_Dx>::value, _Dx,
			const typename remove_reference<_Dx>::type&>::type _Dt) noexcept
		: _Mybase(_Ptr, _Dt)
		{	
		}

	unique_ptr(pointer _Ptr,
		typename remove_reference<_Dx>::type&& _Dt) noexcept
		: _Mybase(_Ptr, ::std:: move(_Dt))
		{	
		static_assert(!is_reference<_Dx>::value,
			"unique_ptr constructed with reference to rvalue deleter");
		}

	unique_ptr(unique_ptr&& _Right) noexcept
		: _Mybase(_Right.release(),
			::std:: forward<_Dx>(_Right.get_deleter()))
		{	
		}

	template<class _Ty2,
		class _Dx2,
		class = typename enable_if<!is_array<_Ty2>::value
			&& is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer,
				pointer>::value
			&& (is_reference<_Dx>::value
				? is_same<_Dx2, _Dx>::value
				: is_convertible<_Dx2, _Dx>::value),
			void>::type>
		unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
			: _Mybase(_Right.release(),
				::std:: forward<_Dx2>(_Right.get_deleter()))
		{	
		}

 
	template<class _Ty2,
		class = typename enable_if<is_convertible<_Ty2 *, _Ty *>::value
			&& is_same<_Dx, default_delete<_Ty> >::value,
			void>::type>
		unique_ptr(auto_ptr<_Ty2>&& _Right) noexcept
			: _Mybase(_Right.release())
		{	
		}
 #line 1362 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"

	template<class _Ty2,
		class _Dx2>
		typename enable_if<!is_array<_Ty2>::value
			&& is_assignable<_Dx&, _Dx2&&>::value
			&& is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer,
				pointer>::value,
			_Myt&>::type
		operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
		{	
		reset(_Right.release());
		this->get_deleter() = ::std:: forward<_Dx2>(_Right.get_deleter());
		return (*this);
		}

	_Myt& operator=(_Myt&& _Right) noexcept
		{	
		if (this != &_Right)
			{	
			reset(_Right.release());
			this->get_deleter() = ::std:: forward<_Dx>(_Right.get_deleter());
			}
		return (*this);
		}

	void swap(_Myt& _Right) noexcept
		{	
		_Swap_adl(this->_Myptr(), _Right._Myptr());
		_Swap_adl(this->get_deleter(),
			_Right.get_deleter());
		}

	~unique_ptr() noexcept
		{	
		if (get() != pointer())
			this->get_deleter()(get());
		}

	typename add_lvalue_reference<_Ty>::type operator*() const
		{	
		return (*get());
		}

	pointer operator->() const noexcept
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	pointer get() const noexcept
		{	
		return (this->_Myptr());
		}

	explicit operator bool() const noexcept
		{	
		return (get() != pointer());
		}

	pointer release() noexcept
		{	
		pointer _Ans = get();
		this->_Myptr() = pointer();
		return (_Ans);
		}

	void reset(pointer _Ptr = pointer()) noexcept
		{	
		pointer _Old = get();
		this->_Myptr() = _Ptr;
		if (_Old != pointer())
			this->get_deleter()(_Old);
		}

	unique_ptr(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;
	};

	
template<class _Ty,
	class _Dx>
	class unique_ptr<_Ty[], _Dx>
		: public _Unique_ptr_base<_Ty, _Dx>
	{	
public:
	typedef unique_ptr<_Ty[], _Dx> _Myt;
	typedef _Unique_ptr_base<_Ty, _Dx> _Mybase;
	typedef typename _Mybase::pointer pointer;
	typedef _Ty element_type;
	typedef _Dx deleter_type;

	using _Mybase::get_deleter;

	constexpr unique_ptr() noexcept
		: _Mybase(pointer())
		{	
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	template<class _Uty>
		using _Enable_ctor_reset = enable_if_t<
			is_same<_Uty, pointer>::value
			|| (is_same<pointer, element_type *>::value
			&& is_pointer<_Uty>::value
			&& is_convertible<
				remove_pointer_t<_Uty>(*)[],
				element_type(*)[]
			>::value)>;

	template<class _Uty,
		class = _Enable_ctor_reset<_Uty> >
	explicit unique_ptr(_Uty _Ptr) noexcept
		: _Mybase(_Ptr)
		{	
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	template<class _Uty,
		class = _Enable_ctor_reset<_Uty> >
	unique_ptr(_Uty _Ptr,
		typename _If<is_reference<_Dx>::value, _Dx,
			const typename remove_reference<_Dx>::type&>::type _Dt) noexcept
		: _Mybase(_Ptr, _Dt)
		{	
		}

	template<class _Uty,
		class = _Enable_ctor_reset<_Uty> >
	unique_ptr(_Uty _Ptr,
		typename remove_reference<_Dx>::type&& _Dt) noexcept
		: _Mybase(_Ptr, ::std:: move(_Dt))
		{	
		static_assert(!is_reference<_Dx>::value,
			"unique_ptr constructed with reference to rvalue deleter");
		}

	unique_ptr(unique_ptr&& _Right) noexcept
		: _Mybase(_Right.release(),
			::std:: forward<_Dx>(_Right.get_deleter()))
		{	
		}

	_Myt& operator=(_Myt&& _Right) noexcept
		{	
		if (this != &_Right)
			{	
			reset(_Right.release());
			this->get_deleter() = ::std:: move(_Right.get_deleter());
			}
		return (*this);
		}

	template<class _Uty,
		class _Ex,
		bool _More,
		class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer,
		class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
		using _Enable_conversion = enable_if_t<
			is_array<_Uty>::value
			&& is_same<pointer, element_type *>::value
			&& is_same<_UP_pointer, _UP_element_type *>::value
			&& is_convertible<_UP_element_type(*)[], element_type(*)[]>::value
			&& _More>;

	template<class _Uty,
		class _Ex,
		class = _Enable_conversion<_Uty, _Ex,
			is_reference<_Dx>::value
			? is_same<_Ex, _Dx>::value
			: is_convertible<_Ex, _Dx>::value> >
		unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
			: _Mybase(_Right.release(),
				::std:: forward<_Ex>(_Right.get_deleter()))
		{	
		}

	template<class _Uty,
		class _Ex,
		class = _Enable_conversion<_Uty, _Ex,
			is_assignable<_Dx&, _Ex&&>::value> >
		_Myt& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept
		{	
		reset(_Right.release());
		this->get_deleter() = ::std:: forward<_Ex>(_Right.get_deleter());
		return (*this);
		}

	constexpr unique_ptr(nullptr_t) noexcept
		: _Mybase(pointer())
		{	
		static_assert(!is_pointer<_Dx>::value,
			"unique_ptr constructed with null deleter pointer");
		}

	_Myt& operator=(nullptr_t) noexcept
		{	
		reset();
		return (*this);
		}

	void reset(nullptr_t = nullptr_t{}) noexcept
		{	
		reset(pointer());
		}

	void swap(_Myt& _Right) noexcept
		{	
		_Swap_adl(this->_Myptr(), _Right._Myptr());
		_Swap_adl(this->get_deleter(), _Right.get_deleter());
		}

	~unique_ptr() noexcept
		{	
		_Delete();
		}

	_Ty& operator[](size_t _Idx) const
		{	
		return (get()[_Idx]);
		}

	pointer get() const noexcept
		{	
		return (this->_Myptr());
		}

	explicit operator bool() const noexcept
		{	
		return (get() != pointer());
		}

	pointer release() noexcept
		{	
		pointer _Ans = get();
		this->_Myptr() = pointer();
		return (_Ans);
		}

	template<class _Uty,
		class = _Enable_ctor_reset<_Uty> >
	void reset(_Uty _Ptr) noexcept
		{	
		pointer _Old = get();
		this->_Myptr() = _Ptr;
		if (_Old != pointer())
			this->get_deleter()(_Old);
		}

	unique_ptr(const _Myt&) = delete;

	_Myt& operator=(const _Myt&) = delete;

private:
	void _Delete()
		{	
		if (get() != pointer())
			this->get_deleter()(get());
		}
	};


	
template<class _Ty,
	class... _Types> inline
	typename enable_if<!is_array<_Ty>::value,
		unique_ptr<_Ty> >::type make_unique(_Types&&... _Args)
	{	
	return (unique_ptr<_Ty>(new _Ty(::std:: forward<_Types>(_Args)...)));
	}

template<class _Ty> inline
	typename enable_if<is_array<_Ty>::value && extent<_Ty>::value == 0,
		unique_ptr<_Ty> >::type make_unique(size_t _Size)
	{	
	typedef typename remove_extent<_Ty>::type _Elem;
	return (unique_ptr<_Ty>(new _Elem[_Size]()));
	}

template<class _Ty,
	class... _Types>
	typename enable_if<extent<_Ty>::value != 0,
		void>::type make_unique(_Types&&...) = delete;


template<class _Ty,
	class _Dx,
	class = enable_if_t<_Is_swappable<_Dx>::value>>
	void swap(unique_ptr<_Ty, _Dx>& _Left,
		unique_ptr<_Ty, _Dx>& _Right) noexcept
	{	
	_Left.swap(_Right);
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	
	return (_Left.get() == _Right.get());
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	
	typedef typename unique_ptr<_Ty1, _Dx1>::pointer _Ptr1;
	typedef typename unique_ptr<_Ty2, _Dx2>::pointer _Ptr2;
	typedef typename common_type<_Ptr1, _Ptr2>::type _Common;
	return (less<_Common>()(_Left.get(), _Right.get()));

	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty1,
	class _Dx1,
	class _Ty2,
	class _Dx2>
	bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left,
		const unique_ptr<_Ty2, _Dx2>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Dx>
	bool operator==(const unique_ptr<_Ty, _Dx>& _Left,
		nullptr_t) noexcept
	{	
	return (!_Left);
	}

template<class _Ty,
	class _Dx>
	bool operator==(nullptr_t,
		const unique_ptr<_Ty, _Dx>& _Right) noexcept
	{	
	return (!_Right);
	}

template<class _Ty,
	class _Dx>
	bool operator!=(const unique_ptr<_Ty, _Dx>& _Left,
		nullptr_t _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Dx>
	bool operator!=(nullptr_t _Left,
		const unique_ptr<_Ty, _Dx>& _Right) noexcept
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Dx>
	bool operator<(const unique_ptr<_Ty, _Dx>& _Left,
		nullptr_t _Right)
	{	
	typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
	return (less<_Ptr>()(_Left.get(), _Right));
	}

template<class _Ty,
	class _Dx>
	bool operator<(nullptr_t _Left,
		const unique_ptr<_Ty, _Dx>& _Right)
	{	
	typedef typename unique_ptr<_Ty, _Dx>::pointer _Ptr;
	return (less<_Ptr>()(_Left, _Right.get()));
	}

template<class _Ty,
	class _Dx>
	bool operator>=(const unique_ptr<_Ty, _Dx>& _Left,
		nullptr_t _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Ty,
	class _Dx>
	bool operator>=(nullptr_t _Left,
		const unique_ptr<_Ty, _Dx>& _Right)
	{	
	return (!(_Left < _Right));
	}

template<class _Ty,
	class _Dx>
	bool operator>(const unique_ptr<_Ty, _Dx>& _Left,
		nullptr_t _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Dx>
	bool operator>(nullptr_t _Left,
		const unique_ptr<_Ty, _Dx>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Dx>
	bool operator<=(const unique_ptr<_Ty, _Dx>& _Left,
		nullptr_t _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Dx>
	bool operator<=(nullptr_t _Left,
		const unique_ptr<_Ty, _Dx>& _Right)
	{	
	return (!(_Right < _Left));
	}

		

enum class pointer_safety {	
	relaxed,
	preferred,
	strict
	};

typedef pointer_safety _Pointer_safety;

inline void declare_reachable(void *)
	{	
	}

template<class _Ty> inline
	_Ty *undeclare_reachable(_Ty *_Ptr)
	{	
	return (_Ptr);
	}

inline void declare_no_pointers(char *, size_t)
	{	
	}

inline void undeclare_no_pointers(char *, size_t)
	{	
	}

inline _Pointer_safety get_pointer_safety() noexcept
	{	
	return (pointer_safety::relaxed);
	}


namespace tr1 {	
using ::std:: allocate_shared;
using ::std:: bad_weak_ptr;
using ::std:: const_pointer_cast;
using ::std:: dynamic_pointer_cast;
using ::std:: enable_shared_from_this;
using ::std:: get_deleter;
using ::std:: make_shared;
using ::std:: shared_ptr;
using ::std:: static_pointer_cast;
using ::std:: swap;
using ::std:: weak_ptr;
}	
#line 1866 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"

		
template<class _Ty = void>
	struct owner_less;	

template<class _Ty>
	struct owner_less<shared_ptr<_Ty> >
	{	
	typedef shared_ptr<_Ty> first_argument_type;
	typedef shared_ptr<_Ty> second_argument_type;
	typedef bool result_type;

	bool operator()(const shared_ptr<_Ty>& _Left,
		const shared_ptr<_Ty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}

	bool operator()(const shared_ptr<_Ty>& _Left,
		const weak_ptr<_Ty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}

	bool operator()(const weak_ptr<_Ty>& _Left,
		const shared_ptr<_Ty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}
	};

template<class _Ty>
	struct owner_less<weak_ptr<_Ty> >
	{	
	typedef weak_ptr<_Ty> first_argument_type;
	typedef weak_ptr<_Ty> second_argument_type;
	typedef bool result_type;

	bool operator()(const weak_ptr<_Ty>& _Left,
		const weak_ptr<_Ty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}

	bool operator()(const weak_ptr<_Ty>& _Left,
		const shared_ptr<_Ty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}

	bool operator()(const shared_ptr<_Ty>& _Left,
		const weak_ptr<_Ty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}
	};

template<>
	struct owner_less<void>
	{	
	typedef int is_transparent;

	template<class _Ty,
		class _Uty>
		bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}

	template<class _Ty,
		class _Uty>
		bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}

	template<class _Ty,
		class _Uty>
		bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}

	template<class _Ty,
		class _Uty>
		bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const
		{	
		return (_Left.owner_before(_Right));
		}
	};

	
template<class _Ty,
	class _Dx>
	struct hash<unique_ptr<_Ty, _Dx> >
	{	
	typedef unique_ptr<_Ty, _Dx> argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		typedef typename argument_type::pointer _Ptrtype;
		return (hash<_Ptrtype>()(_Keyval.get()));
		}
	};

template<class _Ty>
	struct hash<shared_ptr<_Ty> >
	{	
	typedef shared_ptr<_Ty> argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (hash<_Ty *>()(_Keyval.get()));
		}
	};

		
inline void *align(size_t _Bound, size_t _Size,
	void *& _Ptr, size_t& _Space) noexcept
	{	
	size_t _Off = (size_t)((uintptr_t)_Ptr & (_Bound - 1));
	if (0 < _Off)
		_Off = _Bound - _Off;	
	if (_Space < _Off || _Space - _Off < _Size)
		return (0);
	else
		{	
		_Ptr = (char *)_Ptr + _Off;
		_Space -= _Off;
		return (_Ptr);
		}
	}

		
struct _Shared_ptr_spin_lock
	{	
	_Shared_ptr_spin_lock()
		{	
		_Lock_shared_ptr_spin_lock();
		}

	~_Shared_ptr_spin_lock() noexcept
		{	
		_Unlock_shared_ptr_spin_lock();
		}
	};

template<class _Ty> inline
	bool atomic_is_lock_free(const shared_ptr<_Ty> *)
	{	
	return (false);
	}

template<class _Ty> inline
	shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty> *_Ptr,
		memory_order)
	{	
	_Shared_ptr_spin_lock _Lock;
	shared_ptr<_Ty> _Result = *_Ptr;
	return (_Result);
	}

template<class _Ty> inline
	shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty> *_Ptr)
	{	
	return (::std:: atomic_load_explicit(_Ptr, memory_order_seq_cst));
	}

template<class _Ty> inline
	void atomic_store_explicit(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other,
		memory_order)
	{	
	_Shared_ptr_spin_lock _Lock;
	_Ptr->swap(_Other);
	}

template<class _Ty> inline
	void atomic_store(shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)
	{	
	::std:: atomic_store_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst);
	}

template<class _Ty> inline
	shared_ptr<_Ty> atomic_exchange_explicit(
		shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other,
		memory_order)
	{	
	_Shared_ptr_spin_lock _Lock;
	_Ptr->swap(_Other);
	return (_Other);
	}

template<class _Ty> inline
	shared_ptr<_Ty> atomic_exchange(
		shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> _Other)
	{	
	return (::std:: atomic_exchange_explicit(_Ptr, ::std:: move(_Other), memory_order_seq_cst));
	}

template<class _Ty> inline
	bool atomic_compare_exchange_weak_explicit(
		shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value,
		memory_order, memory_order)
	{	
	shared_ptr<_Ty> _Old_exp;	
	_Shared_ptr_spin_lock _Lock;
	bool _Success = _Ptr->get() == _Exp->get()
		&& !_Ptr->owner_before(*_Exp)
		&& !_Exp->owner_before(*_Ptr);
	if (_Success)
		_Ptr->swap(_Value);
	else
		{	
		_Exp->swap(_Old_exp);
		*_Exp = *_Ptr;
		}
	return (_Success);
	}

template<class _Ty> inline
	bool atomic_compare_exchange_weak(
		shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp,
			shared_ptr<_Ty> _Value)
	{	
	return (::std:: atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std:: move(_Value),
		memory_order_seq_cst, memory_order_seq_cst));
	}

template<class _Ty> inline
	bool atomic_compare_exchange_strong_explicit(
		shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp, shared_ptr<_Ty> _Value,
		memory_order, memory_order)
	{	
	return (::std:: atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std:: move(_Value),
		memory_order_seq_cst, memory_order_seq_cst));
	}

template<class _Ty> inline
	bool atomic_compare_exchange_strong(
	shared_ptr<_Ty> *_Ptr, shared_ptr<_Ty> *_Exp,
		shared_ptr<_Ty> _Value)
	{	
	return (::std:: atomic_compare_exchange_strong_explicit(_Ptr, _Exp, ::std:: move(_Value),
		memory_order_seq_cst, memory_order_seq_cst));
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 2118 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"
#line 2119 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\memory"






#line 3 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shaderbuilder.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shader.h"
#pragma once
#pragma once

#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

namespace std {
 #pragma warning(disable: 4127)

extern __declspec(dllimport) FILE *__cdecl _Fiopen(
	const char *,
	ios_base::openmode, int);
extern __declspec(dllimport) FILE *__cdecl _Fiopen(
	const wchar_t *,
	ios_base::openmode, int);

 
extern __declspec(dllimport) FILE *__cdecl _Fiopen(
	const unsigned short *,
	ios_base::openmode, int);
 #line 28 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

		
template<class _Elem> inline
	bool _Fgetc(_Elem& _Ch, FILE *_File)
	{	
	return (fread(&_Ch, sizeof (_Elem), 1, _File) == 1);
	}

template<> inline bool _Fgetc(char& _Byte, FILE *_File)
	{	
	int _Meta;
	if ((_Meta = fgetc(_File)) == (-1))
		return (false);
	else
		{	
		_Byte = (char)_Meta;
		return (true);
		}
	}

template<> inline bool _Fgetc(wchar_t& _Wchar, FILE *_File)
	{	
	wint_t _Meta;
	if ((_Meta = :: fgetwc(_File)) == ((wint_t)(0xFFFF)))
		return (false);
	else
		{	
		_Wchar = (wchar_t)_Meta;
		return (true);
		}
	}

 
template<> inline bool _Fgetc(unsigned short& _Wchar, FILE *_File)
	{	
	wint_t _Meta;
	if ((_Meta = :: fgetwc(_File)) == ((wint_t)(0xFFFF)))
		return (false);
	else
		{	
		_Wchar = (unsigned short)_Meta;
		return (true);
		}
	}
 #line 73 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

		
template<class _Elem> inline
	bool _Fputc(_Elem _Ch, FILE *_File)
	{	
	return (fwrite(&_Ch, 1, sizeof (_Elem), _File) == sizeof (_Elem));
	}

template<> inline bool _Fputc(char _Byte, FILE *_File)
	{	
	return (fputc(_Byte, _File) != (-1));
	}

template<> inline bool _Fputc(wchar_t _Wchar, FILE *_File)
	{	
	return (:: fputwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}

 
template<> inline bool _Fputc(unsigned short _Wchar, FILE *_File)
	{	
	return (:: fputwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}
 #line 97 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

		
template<class _Elem> inline
	bool _Ungetc(const _Elem& _Ch, FILE *_File)
	{	
	return (false);
	}

template<> inline bool _Ungetc(const char& _Byte, FILE *_File)
	{	
	return (ungetc((unsigned char)_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const signed char& _Byte, FILE *_File)
	{	
	return (ungetc((unsigned char)_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const unsigned char& _Byte, FILE *_File)
	{	
	return (ungetc(_Byte, _File) != (-1));
	}

template<> inline bool _Ungetc(const wchar_t& _Wchar, FILE *_File)
	{	
	return (:: ungetwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}

 
template<> inline bool _Ungetc(const unsigned short& _Wchar, FILE *_File)
	{	
	return (:: ungetwc(_Wchar, _File) != ((wint_t)(0xFFFF)));
	}
 #line 131 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

		
template<class _Elem,
	class _Traits>
	class basic_filebuf
		: public basic_streambuf<_Elem, _Traits>
	{	
public:
	typedef basic_filebuf<_Elem, _Traits> _Myt;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef typename _Traits::state_type _Myst;
	typedef codecvt<_Elem, char, typename _Traits::state_type> _Cvt;

	basic_filebuf(FILE *_File = 0)
		: _Mysb()
		{	
		_Init(_File, _Newfl);
		}

	virtual  ~basic_filebuf() noexcept
		{	
		if (_Myfile != 0)
			_Reset_back();	
		if (_Closef)
			close();
		}

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_filebuf(_Uninitialized)
		: _Mysb(_Noinit)
		{	
		}

	basic_filebuf(_Myt&& _Right)
		{	
		_Init(_Right._Myfile, _Newfl);	
		_Init((FILE *)0, _Closefl);	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			
			FILE *_Myfile_sav = _Myfile;
			const _Cvt *_Pcvt_sav = _Pcvt;
			typename _Traits::state_type _State_sav = _State;
			bool _Wrotesome_sav = _Wrotesome;
			bool _Closef_sav = _Closef;
			bool _Set_eback_sav = _Mysb::eback() == &_Mychar;
			bool _Set_eback_live = _Mysb::gptr() == &_Mychar;

			_Elem *_Pfirst0 = _Mysb::pbase();
			_Elem *_Pnext0 = _Mysb::pptr();
			_Elem *_Pend = _Mysb::epptr();
			_Elem *_Gfirst0 = _Mysb::eback();
			_Elem *_Gnext0 = _Mysb::gptr();
			_Elem *_Gend = _Mysb::egptr();

			
			_Init(_Right._Myfile, _Right._Myfile != 0 ? _Openfl : _Newfl);
			_Mysb::setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
			if (_Right.eback() != &_Right._Mychar)
				_Mysb::setg(_Right.eback(), _Right.gptr(), _Right.egptr());
			else if (_Right.gptr() != &_Right._Mychar)
				_Mysb::setg(&_Mychar, &_Mychar + 1, &_Mychar + 1);
			else
				_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);

			_Pcvt = _Right._Pcvt;
			_State = _Right._State;
			_Wrotesome = _Right._Wrotesome;
			_Closef = _Right._Closef;

			
			_Right._Init(_Myfile_sav, _Myfile_sav != 0 ? _Openfl : _Newfl);
			_Right.setp(_Pfirst0, _Pnext0, _Pend);
			if (!_Set_eback_sav)
				_Right.setg(_Gfirst0, _Gnext0, _Gend);
			else if (!_Set_eback_live)
				_Right.setg(&_Right._Mychar, &_Right._Mychar + 1,
					&_Right._Mychar + 1);
			else
				_Right.setg(&_Right._Mychar, &_Right._Mychar,
					&_Right._Mychar + 1);

			_Right._Pcvt = _Pcvt_sav;
			_Right._State = _State_sav;
			_Right._Wrotesome = _Wrotesome_sav;
			_Right._Closef = _Closef_sav;

			
			::std:: swap(_Set_eback, _Right._Set_eback);
			::std:: swap(_Set_egptr, _Right._Set_egptr);

			::std:: swap(_Mychar, _Right._Mychar);
			::std:: swap(_Mysb::_Plocale, _Right._Plocale);
			}
		}

	basic_filebuf(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	enum _Initfl
		{	
		_Newfl, _Openfl, _Closefl};

	bool is_open() const
		{	
		return (_Myfile != 0);
		}

	_Myt *open(const char *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		FILE *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const string& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		return (open(_Str.c_str(), _Mode, _Prot));
		}

 
	_Myt *open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #line 288 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	_Myt *open(const wchar_t *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		FILE *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

	_Myt *open(const wstring& _Str,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		return (open(_Str.c_str(), _Mode, _Prot));
		}

 
	_Myt *open(const wchar_t *_Filename,
		ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #line 316 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

 
	_Myt *open(const unsigned short *_Filename,
		ios_base::openmode _Mode,
		int _Prot = (int)ios_base::_Openprot)
		{	
		FILE *_File;
		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)
			return (0);	

		_Init(_File, _Openfl);
		_Initcvt(&use_facet< _Cvt >(_Mysb::getloc()));
		return (this);	
		}

 
	_Myt *open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		return (open(_Filename, (ios_base::openmode)_Mode));
		}
 #line 338 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
 #line 339 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	_Myt *close()
		{	
		_Myt *_Ans = this;
		if (_Myfile == 0)
			_Ans = 0;
		else
			{	
			if (!_Endwrite())
				_Ans = 0;
			if (fclose(_Myfile) != 0)
				_Ans = 0;
			}
		_Init(0, _Closefl);
		return (_Ans);
		}

	virtual void  _Lock()
		{	
		if (_Myfile)
			:: _lock_file(_Myfile);
		}

	virtual void  _Unlock()
		{	
		if (_Myfile)
			:: _unlock_file(_Myfile);
		}

protected:
	virtual int_type  overflow(int_type _Meta =
		_Traits::eof())
		{	
		if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::not_eof(_Meta));	
		else if (_Mysb::pptr() != 0
			&& _Mysb::pptr() < _Mysb::epptr())
			{	
			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		else if (_Myfile == 0)
			return (_Traits::eof());	
		_Reset_back();	
		if (_Pcvt == 0)
			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)
				? _Meta : _Traits::eof());	
		else
			{	
			const int _STRING_INC = 8;
			const _Elem _Ch = _Traits::to_char_type(_Meta);
			const _Elem *_Src;
			char *_Dest;

			string _Str(_STRING_INC, '\0');
			for (; ; )
				switch (_Pcvt->out(_State,
					&_Ch, &_Ch + 1, _Src,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
				{	
				case codecvt_base::partial:
				case codecvt_base::ok:
					{	
					size_t _Count = _Dest - &*_Str.begin();
					if (0 < _Count && _Count !=
						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
						return (_Traits::eof());	

					_Wrotesome = true;	
					if (_Src != &_Ch)
						return (_Meta);	

					if (0 < _Count)
						;
					else if (_Str.size() < 4 * _STRING_INC)
						_Str.append(_STRING_INC, '\0');	
					else
						return (_Traits::eof());	
					break;
					}

				case codecvt_base::noconv:
					return (_Fputc(_Ch, _Myfile) ? _Meta
						: _Traits::eof());	

				default:
					return (_Traits::eof());	
				}
			}
	}

	virtual int_type  pbackfail(int_type _Meta =
		_Traits::eof())
		{	
		if (_Mysb::gptr() != 0
			&& _Mysb::eback() < _Mysb::gptr()
			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)
			|| _Traits::eq_int_type(_Traits::to_int_type(_Mysb::gptr()[-1]),
				_Meta)))
			{	
			_Mysb::_Gndec();
			return (_Traits::not_eof(_Meta));
			}
		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::eof());	
		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))
			return (_Meta);	
		else if (_Mysb::gptr() != &_Mychar)
			{	
			_Mychar = _Traits::to_char_type(_Meta);
			_Set_back();	
			return (_Meta);
			}
		else
			return (_Traits::eof());	
	}

	virtual int_type  underflow()
		{	
		int_type _Meta;
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(*_Mysb::gptr()));	
		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))
			return (_Meta);	
		else
			{	
			pbackfail(_Meta);
			return (_Meta);
			}
		}

	virtual int_type  uflow()
		{	
		if (_Mysb::gptr() != 0
			&& _Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(
				*_Mysb::_Gninc()));	
		else if (_Myfile == 0)
			return (_Traits::eof());	
		_Reset_back();	
		if (_Pcvt == 0)
			{	
			_Elem _Ch = 0;
			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)
				: _Traits::eof());
			}
		else
			{	
			string _Str;

			for (; ; )
				{	
				_Elem _Ch, *_Dest;
				const char *_Src;
				int _Nleft;
				int _Meta = fgetc(_Myfile);

				if (_Meta == (-1))
					return (_Traits::eof());	

				_Str.append(1, (char)_Meta);	
				switch (_Pcvt->in(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Src,
					&_Ch, &_Ch + 1, _Dest))
					{	
				case codecvt_base::partial:
				case codecvt_base::ok:
					if (_Dest != &_Ch)
						{	
						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);
						for (; 0 < _Nleft; )
							ungetc(_Src[--_Nleft], _Myfile);
						return (_Traits::to_int_type(_Ch));
						}
					else
						_Str.erase((size_t)0,	
							(size_t)(_Src - &*_Str.begin()));
					break;

				case codecvt_base::noconv:
					if (_Str.size() < sizeof (_Elem))
						break;	

					::memcpy_s((&_Ch), (sizeof (_Elem)), (&*_Str.begin()), (sizeof (_Elem)));	
#line 525 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

					return (_Traits::to_int_type(_Ch));	

				default:
					return (_Traits::eof());	
					}
				}
			}
		}

	virtual pos_type  seekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	
		fpos_t _Fileposition;

		if (_Mysb::gptr() == &_Mychar	
			&& _Way == ios_base::cur	
			&& _Pcvt == 0)	
			_Off -= (off_type)sizeof (_Elem);	

		if (_Myfile == 0 || !_Endwrite()
			|| ((_Off != 0 || _Way != ios_base::cur)
				&& _fseeki64(_Myfile, _Off, _Way) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	

		_Reset_back();	
		return (pos_type(_State, _Fileposition));	
#line 556 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
		}

	virtual pos_type  seekpos(pos_type _Pos,
		ios_base::openmode =
			(ios_base::openmode)(ios_base::in | ios_base::out))
		{	
		fpos_t _Fileposition = _Pos.seekpos();
		off_type _Off = (off_type)_Pos - (off_type)((long long)(_Fileposition));

		if (_Myfile == 0 || !_Endwrite()
			|| fsetpos(_Myfile, &_Fileposition) != 0
			|| (_Off != 0 && _fseeki64(_Myfile, _Off, 1) != 0)
			|| fgetpos(_Myfile, &_Fileposition) != 0)
			return (pos_type(_BADOFF));	

		_State = _Pos.state();

		_Reset_back();	
		return (pos_type(_State, _Fileposition));	
#line 576 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
		}

	virtual _Mysb * setbuf(_Elem *_Buffer, streamsize _Count)
		{	
		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,
			_Buffer == 0 && _Count == 0 ? 0x0004 : 0x0000,
			(size_t)_Count * sizeof (_Elem)) != 0)
			return (0);	
		else
			{	
			_Init(_Myfile, _Openfl);
			return (this);
			}
		}

	virtual int  sync()
		{	
		return (_Myfile == 0
			|| _Traits::eq_int_type(_Traits::eof(), overflow())
			|| 0 <= fflush(_Myfile) ? 0 : -1);
		}

	virtual void  imbue(const locale& _Loc)
		{	
		_Initcvt(&use_facet< _Cvt >(_Loc));
		}

	void _Init(FILE *_File, _Initfl _Which)
		{	
		 static _Myst _Stinit;	

		_Closef = _Which == _Openfl;
		_Wrotesome = false;

		_Mysb::_Init();	

 
  
  
 #line 616 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

  #pragma warning(push)
  #pragma warning(disable: 6240)	
		if (_File != 0 && sizeof (_Elem) == 1)
  #pragma warning(pop)

			{	
			_Elem **_Pb = 0;
			_Elem **_Pn = 0;
			int *_Nr = 0;

			::_get_stream_buffer_pointers(
				_File,
				reinterpret_cast<char***>(&_Pb),
				reinterpret_cast<char***>(&_Pn),
				&_Nr);
			int *_Nw = _Nr;

			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
			}

		_Myfile = _File;
		_State = _Stinit;
		_Pcvt = 0;	
		}

	bool _Endwrite()
		{	
		if (_Pcvt == 0 || !_Wrotesome)
			return (true);
		else
			{	
			const int _STRING_INC = 8;
			char *_Dest;
			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
				return (false);

			string _Str(_STRING_INC, '\0');
			for (; ; )
				switch (_Pcvt->unshift(_State,
					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
				{	
				case codecvt_base::ok:
					_Wrotesome = false;	

				case codecvt_base::partial:	
					{	
					size_t _Count = _Dest - &*_Str.begin();
					if (0 < _Count && _Count !=
						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
						return (false);	
					if (!_Wrotesome)
						return (true);
					if (_Count == 0)
						_Str.append(_STRING_INC, '\0');	
					break;
					}

				case codecvt_base::noconv:
					return (true);	

				default:
					return (false);	
				}
			}
		}

	void _Initcvt(const _Cvt *_Newpcvt)
		{	
		if (_Newpcvt->always_noconv())
			_Pcvt = 0;	
		else
			{	
			_Pcvt = _Newpcvt;
			_Mysb::_Init();	
			}
		}

private:
	const _Cvt *_Pcvt;	
	_Elem _Mychar;	
	bool _Wrotesome;	
	typename _Traits::state_type _State;	
	bool _Closef;	
	FILE *_Myfile;	

	void _Reset_back()
		{	
		if (_Mysb::eback() == &_Mychar)
			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
		}

	void _Set_back()
		{	
		if (_Mysb::eback() != &_Mychar)
			{	
			_Set_eback = _Mysb::eback();
			_Set_egptr = _Mysb::egptr();
			}
		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
		}

	_Elem *_Set_eback;	
	_Elem *_Set_egptr;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_filebuf<_Elem, _Traits>& _Left,
		basic_filebuf<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_ifstream
		: public basic_istream<_Elem, _Traits>
	{	
public:
	typedef basic_ifstream<_Elem, _Traits> _Myt;
	typedef basic_istream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ifstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_ifstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ifstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_ifstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 794 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	explicit basic_ifstream(FILE *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_ifstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ifstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 857 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

 
	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 876 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
 #line 877 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	virtual  ~basic_ifstream() noexcept
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 915 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_ifstream<_Elem, _Traits>& _Left,
		basic_ifstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_ofstream
		: public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_ofstream<_Elem, _Traits> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;

	basic_ofstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_ofstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_ofstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_ofstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 998 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	explicit basic_ofstream(FILE *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_ofstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_ofstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1061 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

 
	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1080 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
 #line 1081 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	virtual  ~basic_ofstream() noexcept
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1119 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
		}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_ofstream<_Elem, _Traits>& _Left,
		basic_ofstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits>
	class basic_fstream
		: public basic_iostream<_Elem, _Traits>
	{	
public:
	typedef basic_fstream<_Elem, _Traits> _Myt;
	typedef basic_iostream<_Elem, _Traits> _Mybase;
	typedef basic_filebuf<_Elem, _Traits> _Myfb;
	typedef basic_ios<_Elem, _Traits> _Myios;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	basic_fstream()
		: _Mybase(&_Filebuffer)
		{	
		}

	explicit basic_fstream(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

	explicit basic_fstream(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Str.c_str(), _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}

 
	explicit basic_fstream(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		: _Mybase(&_Filebuffer)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		}
 #line 1207 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	explicit basic_fstream(FILE *_File)
		: _Mybase(&_Filebuffer),
			_Filebuffer(_File)
		{	
		}

	basic_fstream(_Myt&& _Right)
		: _Mybase(&_Filebuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Filebuffer.close();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Filebuffer.swap(_Right._Filebuffer);
			}
		}

	basic_fstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	void open(const wchar_t *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const wstring& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1270 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

 
	void open(const unsigned short *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

 
	void open(const unsigned short *_Filename,
		ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1289 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
 #line 1290 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	virtual  ~basic_fstream() noexcept
		{	
		}

	_Myfb *rdbuf() const
		{	
		return ((_Myfb *)&_Filebuffer);
		}

	bool is_open() const
		{	
		return (_Filebuffer.is_open());
		}

	void open(const char *_Filename,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)
			_Myios::setstate(ios_base::failbit);
		else
			_Myios::clear();	
		}

	void open(const string& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out,
		int _Prot = (int)ios_base::_Openprot)
		{	
		open(_Str.c_str(), _Mode, _Prot);
		}

 
	void open(const char *_Filename, ios_base::open_mode _Mode)
		{	
		open(_Filename, (ios_base::openmode)_Mode);
		}
 #line 1328 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"

	void close()
		{	
		if (_Filebuffer.close() == 0)
			_Myios::setstate(ios_base::failbit);
	}

private:
	_Myfb _Filebuffer;	
	};

	
template<class _Elem,
	class _Traits> inline
	void swap(basic_fstream<_Elem, _Traits>& _Left,
		basic_fstream<_Elem, _Traits>& _Right)
	{	
	_Left.swap(_Right);
	}
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 1353 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"
#line 1354 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\fstream"






#line 5 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shader.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sstream"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
 #pragma warning(disable: 4251)

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_stringbuf
		: public basic_streambuf<_Elem, _Traits>
	{	
public:
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Myt;
	typedef _Alloc allocator_type;
	typedef basic_streambuf<_Elem, _Traits> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_stringbuf(ios_base::openmode _Mode =
		ios_base::in | ios_base::out)
		{	
		_Init(0, 0, _Getstate(_Mode));
		}

	explicit basic_stringbuf(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		_Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
		}

	basic_stringbuf(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Tidy();
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mysb::swap(_Right);
			::std:: swap(_Seekhigh, _Right._Seekhigh);
			::std:: swap(_Mystate, _Right._Mystate);
			_Swap_adl(_Al, _Right._Al);
			}
		}

	basic_stringbuf(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	virtual ~basic_stringbuf() noexcept
		{	
		_Tidy();
		}

	enum
		{	
		_Allocated = 1,	
		_Constant = 2,	
		_Noread = 4,	
		_Append = 8,	
		_Atend = 16};	
	typedef int _Strstate;

	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;

	_Mystr str() const
		{	
		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)
			{	
			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()
				? _Mysb::pptr() : _Seekhigh) - _Mysb::pbase());
			return (_Str);
			}
		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)
			{	
			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());
			return (_Str);
			}
		else
			{	
			_Mystr _Nul;
			return (_Nul);
			}
		}

	void str(const _Mystr& _Newstr)
		{	
		_Tidy();
		_Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
		}

protected:
	virtual int_type overflow(int_type _Meta = _Traits::eof())
		{	
		if (_Mystate & _Constant)
			return (_Traits::eof());	
		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))
			return (_Traits::not_eof(_Meta));	

		if (_Mystate & _Append
			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)
			_Mysb::setp(_Mysb::pbase(), _Seekhigh, _Mysb::epptr());

		if (_Mysb::pptr() != 0
			&& _Mysb::pptr() < _Mysb::epptr())
			{	
			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		else
			{	
			size_t _Oldsize = _Mysb::pptr() == 0
				? 0 : _Mysb::epptr() - _Mysb::eback();
			size_t _Newsize = _Oldsize;
			size_t _Inc = _Newsize / 2 < _MINSIZE
				? _MINSIZE : _Newsize / 2;	

			while (0 < _Inc && 2147483647 - _Inc < _Newsize)
				_Inc /= 2;	
			if (_Inc == 0)
				return (_Traits::eof());	

			_Newsize += _Inc;

			_Elem *_Newptr = _Al.allocate(_Newsize);
			_Elem *_Oldptr = _Mysb::eback();

			if (0 < _Oldsize)
				_Traits::copy(_Newptr, _Oldptr, _Oldsize);

			if (_Oldsize == 0)
				{	
				_Seekhigh = _Newptr;
				_Mysb::setp(_Newptr, _Newptr + _Newsize);
				if (_Mystate & _Noread)
					_Mysb::setg(_Newptr, 0, _Newptr);
				else
					_Mysb::setg(_Newptr, _Newptr, _Newptr + 1);
				}
			else
				{	
				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);
				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),
					_Newptr + (_Mysb::pptr() - _Oldptr),
					_Newptr + _Newsize);
				if (_Mystate & _Noread)
					_Mysb::setg(_Newptr, 0, _Newptr);
				else
					_Mysb::setg(_Newptr,
						_Newptr + (_Mysb::gptr() - _Oldptr),
						_Mysb::pptr() + 1);
				}

			if (_Mystate & _Allocated)
				_Al.deallocate(_Oldptr, _Oldsize);
			_Mystate |= _Allocated;

			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
			return (_Meta);
			}
		}

	virtual int_type pbackfail(int_type _Meta = _Traits::eof())
		{	
		if (_Mysb::gptr() == 0
			|| _Mysb::gptr() <= _Mysb::eback()
			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)
			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
			&& _Mystate & _Constant))
			return (_Traits::eof());	
		else
			{	
			_Mysb::gbump(-1);
			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))
				*_Mysb::gptr() = _Traits::to_char_type(_Meta);
			return (_Traits::not_eof(_Meta));
			}
		}

	virtual int_type underflow()
		{	
		if (_Mysb::gptr() == 0)
			return (_Traits::eof());	
		else if (_Mysb::gptr() < _Mysb::egptr())
			return (_Traits::to_int_type(*_Mysb::gptr()));	
		else if (_Mystate & _Noread || _Mysb::pptr() == 0
			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))
			return (_Traits::eof());	
		else
			{	
			if (_Seekhigh < _Mysb::pptr())
				_Seekhigh = _Mysb::pptr();
			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);
			return (_Traits::to_int_type(*_Mysb::gptr()));
			}
		}

	virtual pos_type seekoff(off_type _Off,
		ios_base::seekdir _Way,
		ios_base::openmode _Which = ios_base::in | ios_base::out)
		{	
		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
			_Seekhigh = _Mysb::pptr();	

		if (_Which & ios_base::in && _Mysb::gptr() != 0)
			{	
			if (_Way == ios_base::end)
				_Off += (off_type)(_Seekhigh - _Mysb::eback());
			else if (_Way == ios_base::cur
				&& (_Which & ios_base::out) == 0)
				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());
			else if (_Way != ios_base::beg)
				_Off = _BADOFF;

			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				{	
				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
				if (_Which & ios_base::out && _Mysb::pptr() != 0)
					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
						_Mysb::epptr());	
				}
			else
				_Off = _BADOFF;
			}
		else if (_Which & ios_base::out && _Mysb::pptr() != 0)
			{	
			if (_Way == ios_base::end)
				_Off += (off_type)(_Seekhigh - _Mysb::eback());
			else if (_Way == ios_base::cur)
				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());
			else if (_Way != ios_base::beg)
				_Off = _BADOFF;

			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				_Mysb::pbump((int)(_Mysb::eback()
					- _Mysb::pptr() + _Off));	
			else
				_Off = _BADOFF;
			}

		else if (_Off != 0)


			_Off = _BADOFF;	
		return (pos_type(_Off));
		}

	virtual pos_type seekpos(pos_type _Ptr,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		{	
		streamoff _Off = (streamoff)_Ptr;
		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())
			_Seekhigh = _Mysb::pptr();	

		if (_Off == _BADOFF)
			;
		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)
			{	
			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				{	
				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));
				if (_Mode & ios_base::out && _Mysb::pptr() != 0)
					_Mysb::setp(_Mysb::pbase(), _Mysb::gptr(),
						_Mysb::epptr());	
				}
			else
				_Off = _BADOFF;
			}
		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)
			{	
			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())
				_Mysb::pbump((int)(_Mysb::eback()
					- _Mysb::pptr() + _Off));	
			else
				_Off = _BADOFF;
			}
		else
			_Off = _BADOFF;	
		return (streampos(_Off));
		}

	void _Init(const _Elem *_Ptr,
		size_t _Count, _Strstate _State)
		{	
		_Seekhigh = 0;
		_Mystate = _State;

		if (_Count != 0
			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
			{	
			_Elem *_Pnew = _Al.allocate(_Count);
			_Traits::copy(_Pnew, _Ptr, _Count);
			_Seekhigh = _Pnew + _Count;

			if (!(_Mystate & _Noread))
				_Mysb::setg(_Pnew, _Pnew,
					_Pnew + _Count);	
			if (!(_Mystate & _Constant))
				{	
				_Mysb::setp(_Pnew,
					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
					_Pnew + _Count);
				if (_Mysb::gptr() == 0)
					_Mysb::setg(_Pnew, 0, _Pnew);
				}
			_Mystate |= _Allocated;
			}
		}

	void _Tidy()
		{	
		if (_Mystate & _Allocated)
			_Al.deallocate(_Mysb::eback(),
				(_Mysb::pptr() != 0 ? _Mysb::epptr()
					: _Mysb::egptr()) - _Mysb::eback());
		_Mysb::setg(0, 0, 0);
		_Mysb::setp(0, 0);
		_Seekhigh = 0;
		_Mystate &= ~_Allocated;
		}

private:
	enum
		{	
		_MINSIZE = 32};

	_Strstate _Getstate(ios_base::openmode _Mode)
		{	
		_Strstate _State = (_Strstate)0;
		if (!(_Mode & ios_base::in))
			_State |= _Noread;
		if (!(_Mode & ios_base::out))
			_State |= _Constant;
		if (_Mode & ios_base::app)
			_State |= _Append;
		if (_Mode & ios_base::ate)
			_State |= _Atend;
		return (_State);
		}

	_Elem *_Seekhigh;	
	_Strstate _Mystate;	
	allocator_type _Al;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_istringstream
		: public basic_istream<_Elem, _Traits>
	{	
public:
	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_istream<_Elem, _Traits> _Mybase;
	typedef _Alloc allocator_type;
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Mode | ios_base::in)
		{	
		}

	explicit basic_istringstream(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::in)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Str, _Mode | ios_base::in)
		{	
		}

	basic_istringstream(_Myt&& _Right)
		: _Mybase(&_Stringbuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Stringbuffer.str(_Mystr());
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Stringbuffer.swap(_Right._Stringbuffer);
			}
		}

	basic_istringstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	virtual ~basic_istringstream() noexcept
		{	
		}

	_Mysb *rdbuf() const
		{	
		return ((_Mysb *)&_Stringbuffer);
		}

	_Mystr str() const
		{	
		return (_Stringbuffer.str());
		}

	void str(const _Mystr& _Newstr)
		{	
		_Stringbuffer.str(_Newstr);
		}

private:
	_Mysb _Stringbuffer;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_ostringstream
		: public basic_ostream<_Elem, _Traits>
	{	
public:
	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_ostream<_Elem, _Traits> _Mybase;
	typedef _Alloc allocator_type;
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Mode | ios_base::out)
		{	
		}

	explicit basic_ostringstream(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Str, _Mode | ios_base::out)
		{	
		}

	basic_ostringstream(_Myt&& _Right)
		: _Mybase(&_Stringbuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Stringbuffer.str(_Mystr());
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Stringbuffer.swap(_Right._Stringbuffer);
			}
		}

	basic_ostringstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	virtual ~basic_ostringstream() noexcept
		{	
		}

	_Mysb *rdbuf() const
		{	
		return ((_Mysb *)&_Stringbuffer);
		}

	_Mystr str() const
		{	
		return (_Stringbuffer.str());
		}

	void str(const _Mystr& _Newstr)
		{	
		_Stringbuffer.str(_Newstr);
		}

private:
	_Mysb _Stringbuffer;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}

		
template<class _Elem,
	class _Traits,
	class _Alloc>
	class basic_stringstream
		: public basic_iostream<_Elem, _Traits>
	{	
public:
	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
	typedef basic_iostream<_Elem, _Traits> _Mybase;
	typedef _Elem char_type;
	typedef _Traits traits_type;
	typedef _Alloc allocator_type;
	typedef typename _Traits::int_type int_type;
	typedef typename _Traits::pos_type pos_type;
	typedef typename _Traits::off_type off_type;
	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;

	explicit basic_stringstream(ios_base::openmode _Mode =
		ios_base::in | ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Mode)
		{	
		}

	explicit basic_stringstream(const _Mystr& _Str,
		ios_base::openmode _Mode = ios_base::in | ios_base::out)
		: _Mybase(&_Stringbuffer),
			_Stringbuffer(_Str, _Mode)
		{	
		}

	basic_stringstream(_Myt&& _Right)
		: _Mybase(&_Stringbuffer)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			_Stringbuffer.str(_Mystr());
			this->swap(_Right);
			}
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			_Mybase::swap(_Right);
			_Stringbuffer.swap(_Right._Stringbuffer);
			}
		}

	basic_stringstream(const _Myt&) = delete;
	_Myt& operator=(const _Myt&) = delete;

	virtual ~basic_stringstream() noexcept
		{	
		}

	_Mysb *rdbuf() const
		{	
		return ((_Mysb *)&_Stringbuffer);
		}

	_Mystr str() const
		{	
		return (_Stringbuffer.str());
		}

	void str(const _Mystr& _Newstr)
		{	
		_Stringbuffer.str(_Newstr);
		}

private:
	_Mysb _Stringbuffer;	
	};

	
template<class _Elem,
	class _Traits,
	class _Alloc> inline
	void swap(basic_stringstream<_Elem, _Traits, _Alloc>& _Left,
		basic_stringstream<_Elem, _Traits, _Alloc>& _Right)
	{	
	_Left.swap(_Right);
	}
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 671 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sstream"
#line 672 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\sstream"





#line 6 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shader.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
namespace std {
  











		
 extern __declspec(dllimport) istream cin, *_Ptr_cin;
 extern __declspec(dllimport) ostream cout, *_Ptr_cout;
 extern __declspec(dllimport) ostream cerr, *_Ptr_cerr;
 extern __declspec(dllimport) ostream clog, *_Ptr_clog;

 extern __declspec(dllimport) wistream wcin, *_Ptr_wcin;
 extern __declspec(dllimport) wostream wcout, *_Ptr_wcout;
 extern __declspec(dllimport) wostream wcerr, *_Ptr_wcerr;
 extern __declspec(dllimport) wostream wclog, *_Ptr_wclog;

		
class __declspec(dllimport) _Winit {
public:
	__thiscall _Winit();
	__thiscall ~_Winit() noexcept;
private:
	 static int _Init_cnt;
	};
  #line 45 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"
}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 50 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"
#line 51 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\iostream"





#line 7 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shader.h"
#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

#pragma once






 #pragma pack(push,8)
 #pragma warning(push,3)
 
 

 #pragma warning(disable: 4127)
 #pragma warning(disable: 4244)

namespace std {
 

		
template<class _Myvec>
	class _Vector_const_iterator
		: public _Iterator012<random_access_iterator_tag,
			typename _Myvec::value_type,
			typename _Myvec::difference_type,
			typename _Myvec::const_pointer,
			typename _Myvec::const_reference,
			_Iterator_base>
	{	
public:
	typedef _Vector_const_iterator<_Myvec> _Myiter;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::const_pointer pointer;
	typedef typename _Myvec::const_reference reference;
	typedef typename _Myvec::pointer _Tptr;

	_Vector_const_iterator()
		: _Ptr()
		{	
		}

	_Vector_const_iterator(_Tptr _Parg, const _Container_base *_Pvector)
		: _Ptr(_Parg)
		{	
		this->_Adopt(_Pvector);
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		_Ptr = _Const_cast(_Right);
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (_Ptr);
		}

	reference operator*() const
		{	
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == _Tptr()
			|| _Ptr < _Mycont->_Myfirst
			|| _Mycont->_Mylast <= _Ptr)
			{	
			_Debug_message(L"vector iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 73);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 74, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 74, 0); };
			}

 




#line 83 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		;

		return (*_Ptr);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Mycont->_Mylast <= _Ptr)
			{	
			_Debug_message(L"vector iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 102);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 103, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 103, 0); };
			}

 




#line 112 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		++_Ptr;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
 
		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
		if (_Mycont == 0
			|| _Ptr == nullptr_t{}
			|| _Ptr <= _Mycont->_Myfirst)
			{	
			_Debug_message(L"vector iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 132);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 133, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 133, 0); };
			}

 




#line 142 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		--_Ptr;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
 
		if (_Off != 0)
			{
			const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
			if (_Mycont == 0
				|| _Ptr + _Off < _Mycont->_Myfirst
				|| _Mycont->_Mylast < _Ptr + _Off)
				{
				_Debug_message(L"vector iterator + offset out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 164);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 165, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 165, 0); };
				}
			}

 







#line 178 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		_Ptr += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr - _Right._Ptr);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr == _Right._Ptr);
		}

	bool operator!=(const _Myiter& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Myiter& _Right) const
		{	
		_Compat(_Right);
		return (_Ptr < _Right._Ptr);
		}

	bool operator>(const _Myiter& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Myiter& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Myiter& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Myiter& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			{
			_Debug_message(L"vector iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 248);
			{ (void)( (!!(("Standard C++ Libraries Invalid Argument" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 249, 0, L"%ls", L"\"Standard C++ Libraries Invalid Argument\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"invalid argument\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 249, 0); };
			}
		}

 









#line 264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	_Tptr _Ptr;	
	};

template<class _Myvec> inline
	typename _Vector_const_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_const_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec>&
		_Rechecked(_Vector_const_iterator<_Myvec>& _Iter,
			typename _Vector_const_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_const_iterator<_Myvec> operator+(
		typename _Vector_const_iterator<_Myvec>::difference_type _Off,
		_Vector_const_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Myvec>
	class _Vector_iterator
		: public _Vector_const_iterator<_Myvec>
	{	
public:
	typedef _Vector_iterator<_Myvec> _Myiter;
	typedef _Vector_const_iterator<_Myvec> _Mybase;
	typedef random_access_iterator_tag iterator_category;

	typedef typename _Myvec::value_type value_type;
	typedef typename _Myvec::difference_type difference_type;
	typedef typename _Myvec::pointer pointer;
	typedef typename _Myvec::reference reference;

	_Vector_iterator()
		{	
		}

	_Vector_iterator(pointer _Parg, const _Container_base *_Pvector)
		: _Mybase(_Parg, _Pvector)
		{	
		}

	typedef pointer _Unchecked_type;

	_Myiter& _Rechecked(_Unchecked_type _Right)
		{	
		this->_Ptr = _Right;
		return (*this);
		}

	_Unchecked_type _Unchecked() const
		{	
		return (this->_Ptr);
		}

	reference operator*() const
		{	
		return ((reference)**(_Mybase *)this);
		}

	pointer operator->() const
		{	
		return (pointer_traits<pointer>::pointer_to(**this));
		}

	_Myiter& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator++(int)
		{	
		_Myiter _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Myiter& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Myiter operator--(int)
		{	
		_Myiter _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Myiter& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Myiter operator+(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Myiter& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Myiter operator-(difference_type _Off) const
		{	
		_Myiter _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Myvec> inline
	typename _Vector_iterator<_Myvec>::_Unchecked_type
		_Unchecked(_Vector_iterator<_Myvec> _Iter)
	{	
	return (_Iter._Unchecked());
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec>&
		_Rechecked(_Vector_iterator<_Myvec>& _Iter,
			typename _Vector_iterator<_Myvec>
				::_Unchecked_type _Right)
	{	
	return (_Iter._Rechecked(_Right));
	}

template<class _Myvec> inline
	_Vector_iterator<_Myvec> operator+(
		typename _Vector_iterator<_Myvec>::difference_type _Off,
		_Vector_iterator<_Myvec> _Next)
	{	
	return (_Next += _Off);
	}

		
template<class _Value_type,
	class _Size_type,
	class _Difference_type,
	class _Pointer,
	class _Const_pointer,
	class _Reference,
	class _Const_reference>
	struct _Vec_iter_types
	{	
	typedef _Value_type value_type;
	typedef _Size_type size_type;
	typedef _Difference_type difference_type;
	typedef _Pointer pointer;
	typedef _Const_pointer const_pointer;
	typedef _Reference reference;
	typedef _Const_reference const_reference;
	};

template<class _Ty,
	class _Alloc0>
	struct _Vec_base_types
	{	
	typedef _Alloc0 _Alloc;
	typedef _Vec_base_types<_Ty, _Alloc> _Myt;

	typedef _Wrap_alloc<_Alloc> _Alty0;
	typedef typename _Alty0::template rebind<_Ty>::other _Alty;


	typedef typename _If<_Is_simple_alloc<_Alty>::value,
		_Simple_types<typename _Alty::value_type>,
		_Vec_iter_types<typename _Alty::value_type,
			typename _Alty::size_type,
			typename _Alty::difference_type,
			typename _Alty::pointer,
			typename _Alty::const_pointer,
			typename _Alty::reference,
			typename _Alty::const_reference> >::type
		_Val_types;
	};

		
template<class _Val_types>
	class _Vector_val
		: public _Container_base
	{	
public:
	typedef _Vector_val<_Val_types> _Myt;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Vector_iterator<_Myt> iterator;
	typedef _Vector_const_iterator<_Myt> const_iterator;

	_Vector_val()
		: _Myfirst(),
		_Mylast(),
		_Myend()
		{	
		}

	pointer _Myfirst;	
	pointer _Mylast;	
	pointer _Myend;	
	};

		
template<class _Alloc_types>
	class _Vector_alloc
	{	
public:
	typedef _Vector_alloc<_Alloc_types> _Myt;
	typedef typename _Alloc_types::_Alloc _Alloc;
	typedef typename _Alloc_types::_Alty _Alty;
	typedef typename _Alloc_types::_Val_types _Val_types;

	typedef typename _Val_types::value_type value_type;
	typedef typename _Val_types::size_type size_type;
	typedef typename _Val_types::difference_type difference_type;
	typedef typename _Val_types::pointer pointer;
	typedef typename _Val_types::const_pointer const_pointer;
	typedef typename _Val_types::reference reference;
	typedef typename _Val_types::const_reference const_reference;

	typedef _Vector_iterator<_Vector_val<_Val_types> > iterator;
	typedef _Vector_const_iterator<_Vector_val<_Val_types> > const_iterator;

 























#line 542 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
	_Vector_alloc()
		: _Mypair(_Zero_then_variadic_args_t())
		{	
		_Alloc_proxy();
		}

	template<class _Any_alloc,
		class = enable_if_t<!is_same<decay_t<_Any_alloc>, _Myt>::value> >
		_Vector_alloc(_Any_alloc&& _Al)
		: _Mypair(_One_then_variadic_args_t(),
			::std:: forward<_Any_alloc>(_Al))
		{	
		_Alloc_proxy();
		}

	~_Vector_alloc() noexcept
		{	
		_Free_proxy();
		}

	void _Copy_alloc(const _Alty& _Al)
		{	
		_Free_proxy();
		_Pocca(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Move_alloc(_Alty& _Al)
		{	
		_Free_proxy();
		_Pocma(_Getal(), _Al);
		_Alloc_proxy();
		}

	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Myproxy() = _Unfancy(_Alproxy.allocate(1));
		_Alproxy.construct(_Myproxy(), _Container_proxy());
		_Myproxy()->_Mycont = &_Get_data();
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Getal());
		_Orphan_all();
		_Alproxy.destroy(_Myproxy());
		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);
		_Myproxy() = 0;
		}

	_Iterator_base12 **_Getpfirst() const
		{	
		return (_Get_data()._Getpfirst());
		}

	_Container_proxy * & _Myproxy() noexcept
		{	
		return (_Get_data()._Myproxy);
		}

	_Container_proxy * const & _Myproxy() const noexcept
		{	
		return (_Get_data()._Myproxy);
		}
 #line 610 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	void _Orphan_all()
		{	
		_Get_data()._Orphan_all();
		}

	void _Swap_all(_Myt& _Right)
		{	
		_Get_data()._Swap_all(_Right._Get_data());
		}

	_Alty& _Getal() noexcept
		{	
		return (_Mypair._Get_first());
		}

	const _Alty& _Getal() const noexcept
		{	
		return (_Mypair._Get_first());
		}

	_Vector_val<_Val_types>& _Get_data() noexcept
		{	
		return (_Mypair._Get_second());
		}

	const _Vector_val<_Val_types>& _Get_data() const noexcept
		{	
		return (_Mypair._Get_second());
		}

	pointer& _Myfirst() noexcept
		{	
		return (_Get_data()._Myfirst);
		}

	const pointer& _Myfirst() const noexcept
		{	
		return (_Get_data()._Myfirst);
		}

	pointer& _Mylast() noexcept
		{	
		return (_Get_data()._Mylast);
		}

	const pointer& _Mylast() const noexcept
		{	
		return (_Get_data()._Mylast);
		}

	pointer& _Myend() noexcept
		{	
		return (_Get_data()._Myend);
		}

	const pointer& _Myend() const noexcept
		{	
		return (_Get_data()._Myend);
		}

private:
	_Compressed_pair<_Alty, _Vector_val<_Val_types> > _Mypair;
	};

		
template<class _Ty,
	class _Alloc = allocator<_Ty> >
	class vector
		: public _Vector_alloc<_Vec_base_types<_Ty, _Alloc> >
	{	
public:
	typedef vector<_Ty, _Alloc> _Myt;
	typedef _Vector_alloc<_Vec_base_types<_Ty, _Alloc> > _Mybase;
	typedef _Alloc allocator_type;

	typedef typename _Mybase::_Alty _Alty;

	typedef typename _Mybase::value_type value_type;
	typedef typename _Mybase::size_type size_type;
	typedef typename _Mybase::difference_type difference_type;
	typedef typename _Mybase::pointer pointer;
	typedef typename _Mybase::const_pointer const_pointer;
	typedef typename _Mybase::reference reference;
	typedef typename _Mybase::const_reference const_reference;

 
 

	typedef typename _Mybase::iterator iterator;
	typedef typename _Mybase::const_iterator const_iterator;

	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	vector() noexcept(is_nothrow_default_constructible<_Alloc>::value)
		: _Mybase()
		{	
		}

	explicit vector(const _Alloc& _Al) noexcept
		: _Mybase(_Al)
		{	
		}

	explicit vector(size_type _Count)
		: _Mybase()
		{	
		if (_Buy(_Count))
			{	
			try {
			_Uninitialized_default_fill_n(this->_Myfirst(), _Count,
				this->_Getal());
			this->_Mylast() += _Count;
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(size_type _Count, const value_type& _Val)
		: _Mybase()
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(size_type _Count, const value_type& _Val, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct_n(_Count, ::std:: addressof(_Val));
		}

	vector(const _Myt& _Right)

		: _Mybase(_Right._Getal().select_on_container_copy_construction())


		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		if (_Buy(_Right.size()))
			try {
			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),
				this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last)
		: _Mybase()
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Construct(_First, _Last);
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last)
		{	
		_Construct(_First, _Last, _Iter_cat_t<_Iter>());
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		try {

		for (; _First != _Last; ++_First)
			emplace_back(*_First);

		} catch (...) {
		_Tidy();
		throw;
		}
		}

	template<class _Iter>
		void _Construct(_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		if (_Buy(::std:: distance(_First, _Last)))
			{	
			try {
			this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	void _Construct_n(size_type _Count, const value_type *_Pval)
		{	
		if (_Buy(_Count))
			{	
			try {
			this->_Mylast() = _Ufill(this->_Myfirst(), _Count, _Pval);
			} catch (...) {
			_Tidy();
			throw;
			}
			}
		}

	vector(_Myt&& _Right) noexcept
		: _Mybase(::std:: move(_Right._Getal()))
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(_Al)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right));
		}

	_Myt& operator=(_Myt&& _Right)
		noexcept(_Alty::propagate_on_container_move_assignment::value || _Alty::is_always_equal::value)
#line 854 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
		{	
		if (this != &_Right)
			{	
			_Tidy();
			if (_Alty::propagate_on_container_move_assignment::value
				&& this->_Getal() != _Right._Getal())
				this->_Move_alloc(_Right._Getal());

			_Assign_rv(::std:: forward<_Myt>(_Right));
			}
		return (*this);
		}

	void _Assign_rv(_Myt&& _Right, true_type)
		{	
		this->_Swap_all((_Myt&)_Right);
		this->_Myfirst() = _Right._Myfirst();
		this->_Mylast() = _Right._Mylast();
		this->_Myend() = _Right._Myend();

		_Right._Myfirst() = pointer();
		_Right._Mylast() = pointer();
		_Right._Myend() = pointer();
		}

	void _Assign_rv(_Myt&& _Right, false_type)
		{	
		if (get_allocator() == _Right.get_allocator())
			_Assign_rv(::std:: forward<_Myt>(_Right), true_type());
		else
			_Construct(::std:: make_move_iterator(_Right.begin()),
				::std:: make_move_iterator(_Right.end()));
		}

	void _Assign_rv(_Myt&& _Right)
		{	
		_Assign_rv(::std:: forward<_Myt>(_Right),
			typename _Alty::propagate_on_container_move_assignment());
		}


	void push_back(value_type&& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - _Unfancy(this->_Myfirst());
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(_Unfancy(this->_Mylast()),
				::std:: forward<value_type>(this->_Myfirst()[_Idx]));
			++this->_Mylast();
			}
		else
			{	
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(_Unfancy(this->_Mylast()),
				::std:: forward<value_type>(_Val));
			++this->_Mylast();
			}
		}

	iterator insert(const_iterator _Where, _Ty&& _Val)
		{	
		return (emplace(_Where, ::std:: move(_Val)));
		}

	template<class... _Valty>
		void emplace_back(_Valty&&... _Val)
		{	
		if (this->_Mylast() == this->_Myend())
			_Reserve(1);
		_Orphan_range(this->_Mylast(), this->_Mylast());
		this->_Getal().construct(_Unfancy(this->_Mylast()),
			::std:: forward<_Valty>(_Val)...);
		++this->_Mylast();
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst();

 
		if (size() < _Off)
			_Debug_message(L"vector emplace iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 941);
 #line 943 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		emplace_back(::std:: forward<_Valty>(_Val)...);
		::std:: rotate(begin() + _Off, end() - 1, end());
		return (begin() + _Off);
		}


	vector(::std:: initializer_list<value_type> _Ilist,
		const _Alloc& _Al = allocator_type())
		: _Mybase(_Al)
		{	
		_Construct(_Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<value_type> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(::std:: initializer_list<value_type> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
		::std:: initializer_list<value_type> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() noexcept
		{	
		_Tidy();
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		if (this != &_Right)
			{	
			if (this->_Getal() != _Right._Getal()
				&& _Alty::propagate_on_container_copy_assignment::value)
				{	
				_Tidy();
				this->_Copy_alloc(_Right._Getal());
				}

			this->_Orphan_all();

			if (_Right.empty())
				clear();	
			else if (_Right.size() <= size())
				{	
				pointer _Ptr = _Copy_unchecked(_Right._Myfirst(),
					_Right._Mylast(), this->_Myfirst());	
				_Destroy(_Ptr, this->_Mylast());	
				this->_Mylast() = this->_Myfirst() + _Right.size();
				}
			else if (_Right.size() <= capacity())
				{	
				pointer _Ptr = _Right._Myfirst() + size();
				_Copy_unchecked(_Right._Myfirst(),
					_Ptr, this->_Myfirst());
				this->_Mylast() = _Ucopy(_Ptr, _Right._Mylast(),
					this->_Mylast());
				}
			else
				{	
				if (this->_Myfirst() != pointer())
					{	
					_Destroy(this->_Myfirst(), this->_Mylast());
					this->_Getal().deallocate(this->_Myfirst(),
						this->_Myend() - this->_Myfirst());
					}
				if (_Buy(_Right.size()))
					try {
					this->_Mylast() =
						_Ucopy(_Right._Myfirst(), _Right._Mylast(),
						this->_Myfirst());
					} catch (...) {
					_Tidy();
					throw;
					}
				}
			}
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		if (capacity() < _Count)
			{	
			if (max_size() < _Count)
				_Xlen();
			_Reallocate(_Count);
			}
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myend() - this->_Myfirst());
		}

	size_type _Unused_capacity() const noexcept
		{	
		return (this->_Myend() - this->_Mylast());
		}

	size_type _Has_unused_capacity() const noexcept
		{	
		return (this->_Myend() != this->_Mylast());
		}

	iterator begin() noexcept
		{	
		return (iterator(this->_Myfirst(), &this->_Get_data()));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(this->_Myfirst(), &this->_Get_data()));
		}

	iterator end() noexcept
		{	
		return (iterator(this->_Mylast(), &this->_Get_data()));
		}

	const_iterator end() const noexcept
		{	
		return (const_iterator(this->_Mylast(), &this->_Get_data()));
		}

	iterator _Make_iter(const_iterator _Where) const
		{	
		return (iterator(_Where._Ptr, &this->_Get_data()));
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if (_Has_unused_capacity())
			{	
			if (empty())
				_Tidy();
			else
				_Reallocate(size());
			}
		}

	void resize(size_type _Newsize)
		{	
		if (_Newsize < size())
			_Pop_back_n(size() - _Newsize);
		else if (size() < _Newsize)
			{	
			_Reserve(_Newsize - size());
			try {
			_Uninitialized_default_fill_n(this->_Mylast(), _Newsize - size(),
				this->_Getal());
			} catch (...) {
			_Tidy();
			throw;
			}
			this->_Mylast() += _Newsize - size();
			}
		}

	void resize(size_type _Newsize, const value_type& _Val)
		{	
		if (_Newsize < size())
			_Pop_back_n(size() - _Newsize);
		else if (size() < _Newsize)
			{	
			const value_type *_Ptr = ::std:: addressof(_Val);

			if (_Inside(_Ptr))
				{	
				const difference_type _Idx = _Ptr
					- _Unfancy(this->_Myfirst());
				_Reserve(_Newsize - size());
				_Ptr = _Unfancy(this->_Myfirst()) + _Idx;
				}
			else
				_Reserve(_Newsize - size());

			try {
			_Ufill(this->_Mylast(), _Newsize - size(), _Ptr);
			} catch (...) {
			_Tidy();
			throw;
			}
			this->_Mylast() += _Newsize - size();
			}
		}

	size_type size() const noexcept
		{	
		return (this->_Mylast() - this->_Myfirst());
		}

	size_type max_size() const noexcept
		{	
		return (this->_Getal().max_size());
		}

	bool empty() const noexcept
		{	
		return (this->_Myfirst() == this->_Mylast());
		}

	_Alloc get_allocator() const noexcept
		{	
		_Alloc _Ret(this->_Getal());
		return (_Ret);
		}

	const_reference at(size_type _Pos) const
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst() + _Pos));
		}

	reference at(size_type _Pos)
		{	
		if (size() <= _Pos)
			_Xran();
		return (*(this->_Myfirst() + _Pos));
		}

	const_reference operator[](size_type _Pos) const
		{	
 
		if (size() <= _Pos)
			{	
			_Debug_message(L"vector subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1218);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1219, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1219, 0); };
			}

 

#line 1225 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		return (*(this->_Myfirst() + _Pos));
		}

	reference operator[](size_type _Pos)
		{	
 
		if (size() <= _Pos)
			{	
			_Debug_message(L"vector subscript out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1234);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1235, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1235, 0); };
			}

 

#line 1241 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		return (*(this->_Myfirst() + _Pos));
		}

	_Ty * data() noexcept
		{	
		return (_Unfancy(this->_Myfirst()));
		}

	const _Ty * data() const noexcept
		{	
		return (_Unfancy(this->_Myfirst()));
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const value_type& _Val)
		{	
		if (_Inside(::std:: addressof(_Val)))
			{	
			size_type _Idx = ::std:: addressof(_Val) - _Unfancy(this->_Myfirst());
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(_Unfancy(this->_Mylast()),
				this->_Myfirst()[_Idx]);
			++this->_Mylast();
			}
		else
			{	
			if (this->_Mylast() == this->_Myend())
				_Reserve(1);
			_Orphan_range(this->_Mylast(), this->_Mylast());
			this->_Getal().construct(_Unfancy(this->_Mylast()),
				_Val);
			++this->_Mylast();
			}
		}

 
	void pop_back()
		{	
		if (empty())
			_Debug_message(L"vector empty before pop", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1302);
		else
			{	
			_Orphan_range(this->_Mylast() - 1, this->_Mylast());
			this->_Getal().destroy(_Unfancy(this->_Mylast() - 1));
			--this->_Mylast();
			}
		}

 





#line 1318 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		clear();
		_Assign(_First, _Last, _Iter_cat_t<_Iter>());
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last,
			input_iterator_tag)
		{	
		for (; _First != _Last; ++_First)
			emplace_back(*_First);
		}

	template<class _Iter>
		void _Assign(_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		size_type _Newsize = ::std:: distance(_First, _Last);

		if (capacity() < _Newsize)
			{	
			size_type _Newcapacity = _Grow_to(_Newsize);
			_Tidy();
			_Buy(_Newcapacity);
			}

		this->_Mylast() = _Ucopy(_First, _Last, this->_Myfirst());
		}

	void assign(size_type _Count, const value_type& _Val)
		{	
		clear();
		insert(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const _Ty& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const _Ty& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst();
		_Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				input_iterator_tag)
		{	
		size_type _Off = (_Where)._Ptr - this->_Myfirst();

 
		if (size() < _Off)
			_Debug_message(L"vector insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1388);
 #line 1390 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		if (_First != _Last)
			{	
			size_type _Oldsize = size();

			try {
			for (; _First != _Last; ++_First)
				push_back(*_First);	

			} catch (...) {
			erase(begin() + _Oldsize, end());
			throw;
			}

			::std:: rotate(begin() + _Off, begin() + _Oldsize, end());
			}
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				forward_iterator_tag)
		{	
 
		if (_Where._Getcont() != &this->_Get_data()
			|| (_Where)._Ptr < this->_Myfirst()
			|| this->_Mylast() < (_Where)._Ptr)
			_Debug_message(L"vector insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1417);
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1418);
 #line 1420 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		size_type _Count = ::std:: distance(_First, _Last);
		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			pointer _Ptr = _Newvec;

			try {
			_Ptr = _Umove(this->_Myfirst(), (_Where)._Ptr,
				_Newvec);	
			_Ptr = _Ucopy(_First, _Last, _Ptr);	
			_Umove((_Where)._Ptr, this->_Mylast(),
				_Ptr);	
			} catch (...) {
			_Destroy(_Newvec, _Ptr);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst() != pointer())
				{	
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(),
					this->_Myend() - this->_Myfirst());
				}

			this->_Orphan_all();
			this->_Myend() = _Newvec + _Capacity;
			this->_Mylast() = _Newvec + _Count;
			this->_Myfirst() = _Newvec;
			}
		else
			{	
			_Ucopy(_First, _Last, this->_Mylast());
			::std:: rotate((_Where)._Ptr, this->_Mylast(),
				this->_Mylast() + _Count);
			this->_Mylast() += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast());
			}
		}

 
	iterator erase(const_iterator _Where)
		{	
		if (_Where._Getcont() != &this->_Get_data()
			|| (_Where)._Ptr < this->_Myfirst()
			|| this->_Mylast() <= (_Where)._Ptr)
			_Debug_message(L"vector erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1474);
		_Move_unchecked((_Where)._Ptr + 1, this->_Mylast(), (_Where)._Ptr);
		_Destroy(this->_Mylast() - 1, this->_Mylast());
		_Orphan_range((_Where)._Ptr, this->_Mylast());
		--this->_Mylast();
		return (_Make_iter(_Where));
		}

 








#line 1492 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	
		if (_First_arg == begin() && _Last_arg == end())
			clear();
		else if (_First_arg != _Last_arg)
			{	
			iterator _First = _Make_iter(_First_arg);
			iterator _Last = _Make_iter(_Last_arg);

			if (_First != _Last)
				{	
 
				if (_Last < _First || _First._Getcont() != &this->_Get_data()
					|| (_First)._Ptr < this->_Myfirst()
					|| this->_Mylast() < (_Last)._Ptr)
					_Debug_message(L"vector erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1509);
				pointer _Ptr = _Move_unchecked((_Last)._Ptr, this->_Mylast(),
					(_First)._Ptr);
				_Orphan_range((_First)._Ptr, this->_Mylast());

 


#line 1518 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

				_Destroy(_Ptr, this->_Mylast());
				this->_Mylast() = _Ptr;
				}
			}
		return (_Make_iter(_First_arg));
		}

	void _Pop_back_n(size_type _Count)
		{	
		pointer _Ptr = this->_Mylast() - _Count;

 
		_Orphan_range(_Ptr, this->_Mylast());
 #line 1533 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		_Destroy(_Ptr, this->_Mylast());
		this->_Mylast() = _Ptr;
		}

	void clear() noexcept
		{	
		this->_Orphan_all();
		_Destroy(this->_Myfirst(), this->_Mylast());
		this->_Mylast() = this->_Myfirst();
		}

	void swap(_Myt& _Right)
		noexcept(_Alty::propagate_on_container_swap::value || _Alty::is_always_equal::value)
#line 1548 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
		{	
		if (this != &_Right)
			{	
			_Pocs(this->_Getal(), _Right._Getal());
			this->_Swap_all(_Right);
			_Swap_adl(this->_Myfirst(), _Right._Myfirst());
			_Swap_adl(this->_Mylast(), _Right._Mylast());
			_Swap_adl(this->_Myend(), _Right._Myend());
			}
		}

protected:
	bool _Buy(size_type _Capacity)
		{	
		this->_Myfirst() = pointer();
		this->_Mylast() = pointer();
		this->_Myend() = pointer();

		if (_Capacity == 0)
			return (false);
		else if (max_size() < _Capacity)
			_Xlen();	
		else
			{	
			this->_Myfirst() = this->_Getal().allocate(_Capacity);
			this->_Mylast() = this->_Myfirst();
			this->_Myend() = this->_Myfirst() + _Capacity;
			}
		return (true);
		}

	void _Destroy(pointer _First, pointer _Last)
		{	
		_Destroy_range(_First, _Last, this->_Getal());
		}

	size_type _Grow_to(size_type _Count) const
		{	
		size_type _Capacity = capacity();

		_Capacity = max_size() - _Capacity / 2 < _Capacity
			? 0 : _Capacity + _Capacity / 2;	
		if (_Capacity < _Count)
			_Capacity = _Count;
		return (_Capacity);
		}

	bool _Inside(const value_type *_Ptr) const
		{	
		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);
		}

	void _Reallocate(size_type _Count)
		{	
		pointer _Ptr = this->_Getal().allocate(_Count);

		try {
		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
		} catch (...) {
		this->_Getal().deallocate(_Ptr, _Count);
		throw;
		}

		size_type _Size = size();
		if (this->_Myfirst() != pointer())
			{	
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(),
				this->_Myend() - this->_Myfirst());
			}

		this->_Orphan_all();
		this->_Myend() = _Ptr + _Count;
		this->_Mylast() = _Ptr + _Size;
		this->_Myfirst() = _Ptr;
		}

	void _Reserve(size_type _Count)
		{	
		if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();
			_Reallocate(_Grow_to(size() + _Count));
			}
		}

	void _Tidy()
		{	
		if (this->_Myfirst() != pointer())
			{	
			this->_Orphan_all();
			_Destroy(this->_Myfirst(), this->_Mylast());
			this->_Getal().deallocate(this->_Myfirst(),
				this->_Myend() - this->_Myfirst());
			this->_Myfirst() = pointer();
			this->_Mylast() = pointer();
			this->_Myend() = pointer();
			}
		}

	template<class _Iter>
		pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		return (_Uninitialized_copy(_First, _Last,
			_Ptr, this->_Getal()));
		}

	template<class _Iter>
		pointer _Umove(_Iter _First, _Iter _Last, pointer _Ptr)
		{	
		return (_Uninitialized_move(_First, _Last,
			_Ptr, this->_Getal()));
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const value_type& _Val)
		{	
 
		if (_Where._Getcont() != &this->_Get_data()
			|| (_Where)._Ptr < this->_Myfirst()
			|| this->_Mylast() < (_Where)._Ptr)
			_Debug_message(L"vector insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1670);
 #line 1672 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		size_type _Off = (_Where)._Ptr - this->_Myfirst();
		if (_Count == 0)
			;
		else if (_Unused_capacity() < _Count)
			{	
			if (max_size() - size() < _Count)
				_Xlen();	

			size_type _Capacity = _Grow_to(size() + _Count);
			pointer _Newvec = this->_Getal().allocate(_Capacity);
			size_type _Whereoff = (_Where)._Ptr - this->_Myfirst();
			int _Ncopied = 0;

			try {
			_Ufill(_Newvec + _Whereoff, _Count,
				::std:: addressof(_Val));	
			++_Ncopied;
			_Umove(this->_Myfirst(), (_Where)._Ptr,
				_Newvec);	
			++_Ncopied;
			_Umove((_Where)._Ptr, this->_Mylast(),
				_Newvec + (_Whereoff + _Count));	
			} catch (...) {
			if (1 < _Ncopied)
				_Destroy(_Newvec, _Newvec + _Whereoff);
			if (0 < _Ncopied)
				_Destroy(_Newvec + _Whereoff, _Newvec + _Whereoff + _Count);
			this->_Getal().deallocate(_Newvec, _Capacity);
			throw;
			}

			_Count += size();
			if (this->_Myfirst() != pointer())
				{	
				_Destroy(this->_Myfirst(), this->_Mylast());
				this->_Getal().deallocate(this->_Myfirst(),
					this->_Myend() - this->_Myfirst());
				}

			this->_Orphan_all();
			this->_Myend() = _Newvec + _Capacity;
			this->_Mylast() = _Newvec + _Count;
			this->_Myfirst() = _Newvec;
			}
		else if ((size_type)(this->_Mylast() - (_Where)._Ptr)
			< _Count)
			{	
			value_type _Tmp = _Val;	

			_Umove((_Where)._Ptr, this->_Mylast(),
				(_Where)._Ptr + _Count);	

			try {
			_Ufill(this->_Mylast(),
				_Count - (this->_Mylast() - (_Where)._Ptr),
				::std:: addressof(_Tmp));	
			} catch (...) {
			_Destroy((_Where)._Ptr + _Count,
				this->_Mylast() + _Count);
			throw;
			}

			this->_Mylast() += _Count;
			_Orphan_range((_Where)._Ptr, this->_Mylast());
			::std:: fill((_Where)._Ptr, this->_Mylast() - _Count,
				_Tmp);	
			}
		else
			{	
			value_type _Tmp = _Val;	

			pointer _Oldend = this->_Mylast();
			this->_Mylast() = _Umove(_Oldend - _Count, _Oldend,
				this->_Mylast());	

			_Orphan_range((_Where)._Ptr, this->_Mylast());
			_Move_backward_unchecked((_Where)._Ptr, _Oldend - _Count,
				_Oldend);	
			::std:: fill((_Where)._Ptr,
				(_Where)._Ptr + _Count, _Tmp);	
			}
		return (begin() + _Off);
		}

	pointer _Ufill(pointer _Ptr, size_type _Count, const value_type *_Pval)
		{	
		_Uninitialized_fill_n(_Ptr, _Count, _Pval, this->_Getal());
		return (_Ptr + _Count);
		}

	[[noreturn]] void _Xlen() const
		{	
		_Xlength_error("vector<T> too long");
		}

	[[noreturn]] void _Xran() const
		{	
		_Xout_of_range("invalid vector<T> subscript");
		}

 
	void _Orphan_range(pointer _First, pointer _Last) const
		{	
		_Lockit _Lock(3);
		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			{	
			while (*_Pnext != 0)
				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
			}
		}

 



#line 1796 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
	};

		

template<class _Ty,
	class _Alloc> inline
	void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right)
		noexcept(noexcept(_Left.swap(_Right)))
	{	
	_Left.swap(_Right);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator==(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left.begin(), _Left.end(), _Right.begin()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator!=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (::std:: lexicographical_compare(_Left.begin(), _Left.end(),
		_Right.begin(), _Right.end()));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (_Right < _Left);
	}

template<class _Ty,
	class _Alloc> inline
	bool operator<=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Right < _Left));
	}

template<class _Ty,
	class _Alloc> inline
	bool operator>=(const vector<_Ty, _Alloc>& _Left,
		const vector<_Ty, _Alloc>& _Right)
	{	
	return (!(_Left < _Right));
	}




typedef unsigned int _Vbase;	
const int _VBITS = 8 * sizeof (_Vbase);	

		
template<class _Alloc>
	class _Vb_iter_base
		: public _Iterator012<random_access_iterator_tag,
			bool,
			typename _Alloc::difference_type,
			bool *,
			bool,
			_Iterator_base>
	{	
public:
	typedef typename _Alloc::size_type _Sizet;
	typedef vector<bool, _Alloc> _Mycont;

	_Vb_iter_base()
		: _Myptr(0), _Myoff(0)
		{	
		}

	_Vb_iter_base(const _Vbase *_Ptr, _Sizet _Off,
		const _Container_base *_Mypvbool)
		: _Myptr(_Ptr), _Myoff(_Off)
		{	
		this->_Adopt(_Mypvbool);
		}

	void _Advance(_Sizet _Off)
		{	
		_Myoff += _Off;
		_Myptr += _Myoff / _VBITS;
		_Myoff %= _VBITS;
		}

	int _Valid(_Sizet _Inc) const
		{	
 
		const auto _Cont = static_cast<const _Mycont *>(this->_Getcont());
		_Sizet _Mysize = _Cont->_Mysize;

		_Inc += _Myoff;
		_Inc += _VBITS * (_Myptr - _Cont->_Myvec.data());
		return (_Inc < _Mysize ? -1 : _Inc == _Mysize ? 0 : +1);

 


#line 1911 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
		}

	const _Vbase *_Myptr;
	_Sizet _Myoff;
	};

		
template<class _Alloc>
	class _Vb_reference
		: public _Vb_iter_base<_Alloc>
	{	
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_reference<_Alloc> _Mytype;

	_Vb_reference() noexcept
		{	
		}

public:
	_Vb_reference(const _Mybase& _Right)
		: _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
		{	
		}

	_Mytype& operator=(const _Mytype& _Right) noexcept
		{	
		return (*this = bool(_Right));
		}

	_Mytype& operator=(bool _Val) noexcept
		{	
		if (_Val)
			*(_Vbase *)_Getptr() |= _Mask();
		else
			*(_Vbase *)_Getptr() &= (~_Mask());	
		return (*this);
		}

	void flip() noexcept
		{	
		*(_Vbase *)_Getptr() ^= _Mask();
		}

	operator bool() const noexcept
		{	
		return ((*_Getptr() & _Mask()) != 0);
		}

	const _Vbase *_Getptr() const
		{	
 
		if (this->_Getcont() == 0
			|| this->_Myptr == 0
			|| 0 <= this->_Valid(0))
			{	
			_Debug_message(L"vector<bool> iterator not dereferencable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1966);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1967, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 1967, 0); };
			}

 


#line 1974 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		return (this->_Myptr);
		}

protected:
	_Vbase _Mask() const
		{	
		return ((_Vbase)(1) << this->_Myoff);
		}
	};

template<class _Alloc> inline
	void swap(_Vb_reference<_Alloc> _Left,
		_Vb_reference<_Alloc> _Right)
	{	
	bool _Val = _Left;	
	_Left = _Right;
	_Right = _Val;
	}

		
template<class _Alloc>
	class _Vb_const_iterator
		: public _Vb_iter_base<_Alloc>
	{	
public:
	typedef _Vb_iter_base<_Alloc> _Mybase;
	typedef _Vb_const_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef const_reference *pointer;
	typedef const_reference reference;

	_Vb_const_iterator()
		{	
		}

	_Vb_const_iterator(const _Vbase *_Ptr, const _Container_base *_Mypvbool)
		: _Mybase(_Ptr, 0, _Mypvbool)
		{	
		}

	const_reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		_Inc();
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		_Dec();
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		if (_Off < 0 && this->_Myoff < 0 - (size_type)_Off)
			{	
			this->_Myoff += _Off;
			this->_Myptr -= 1 + ((size_type)(-1) - this->_Myoff) / _VBITS;
			this->_Myoff %= _VBITS;
			}
		else
			{	
			this->_Myoff += _Off;
			this->_Myptr += this->_Myoff / _VBITS;
			this->_Myoff %= _VBITS;
			}
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(
		const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (_VBITS * (this->_Myptr - _Right._Myptr)
			+ (difference_type)this->_Myoff
			- (difference_type)_Right._Myoff);
		}

	const_reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}

	bool operator==(const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (this->_Myptr == _Right._Myptr
			&& this->_Myoff == _Right._Myoff);
		}

	bool operator!=(const _Mytype& _Right) const
		{	
		return (!(*this == _Right));
		}

	bool operator<(const _Mytype& _Right) const
		{	
		_Compat(_Right);
		return (this->_Myptr < _Right._Myptr
			|| (this->_Myptr == _Right._Myptr
				&& this->_Myoff < _Right._Myoff));
		}

	bool operator>(const _Mytype& _Right) const
		{	
		return (_Right < *this);
		}

	bool operator<=(const _Mytype& _Right) const
		{	
		return (!(_Right < *this));
		}

	bool operator>=(const _Mytype& _Right) const
		{	
		return (!(*this < _Right));
		}

 
	void _Compat(const _Mytype& _Right) const
		{	
		if (this->_Getcont() != _Right._Getcont())
			_Debug_message(L"vector<bool> iterators incompatible", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2140);
		}

 









#line 2154 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	void _Dec()
		{	
		if (this->_Myoff != 0)
			--this->_Myoff;
		else
			{	
 
			if (this->_Getcont() == 0 || 0 < this->_Valid((size_type)-1))
				{	
				_Debug_message(L"vector<bool> iterator not decrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2164);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2165, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2165, 0); };
				}

 


#line 2172 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

			this->_Myoff = _VBITS - 1;
			--this->_Myptr;
			}
		}

	void _Inc()
		{	
		if (this->_Myoff < _VBITS - 1)
			++this->_Myoff;
		else
			{	
 
			if (this->_Getcont() == 0 || 0 < this->_Valid(1))
				{	
				_Debug_message(L"vector<bool> iterator not incrementable", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2187);
				{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2188, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2188, 0); };
				}

 


#line 2195 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

			this->_Myoff = 0;
			++this->_Myptr;
			}
		}
	};

template<class _Alloc> inline
	_Vb_const_iterator<_Alloc> operator+(
		typename _Alloc::difference_type _Off,
		_Vb_const_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_const_iterator<_Alloc> >
		: public true_type
	{	
	};

	
template<class _Alloc>
	class _Vb_iterator
		: public _Vb_const_iterator<_Alloc>
	{	
public:
	typedef _Vb_const_iterator<_Alloc> _Mybase;
	typedef _Vb_iterator<_Alloc> _Mytype;

	typedef _Vb_reference<_Alloc> _Reft;
	typedef bool const_reference;

	typedef random_access_iterator_tag iterator_category;
	typedef bool value_type;
	typedef typename _Alloc::size_type size_type;
	typedef typename _Alloc::difference_type difference_type;
	typedef _Reft *pointer;
	typedef _Reft reference;

	_Vb_iterator()
		{	
		}

	_Vb_iterator(_Vbase *_Ptr, _Container_base *_Mypvbool)
		: _Mybase(_Ptr, _Mypvbool)
		{	
		}

	reference operator*() const
		{	
		return (_Reft(*this));
		}

	_Mytype& operator++()
		{	
		++*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator++(int)
		{	
		_Mytype _Tmp = *this;
		++*this;
		return (_Tmp);
		}

	_Mytype& operator--()
		{	
		--*(_Mybase *)this;
		return (*this);
		}

	_Mytype operator--(int)
		{	
		_Mytype _Tmp = *this;
		--*this;
		return (_Tmp);
		}

	_Mytype& operator+=(difference_type _Off)
		{	
		*(_Mybase *)this += _Off;
		return (*this);
		}

	_Mytype operator+(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp += _Off);
		}

	_Mytype& operator-=(difference_type _Off)
		{	
		return (*this += -_Off);
		}

	_Mytype operator-(difference_type _Off) const
		{	
		_Mytype _Tmp = *this;
		return (_Tmp -= _Off);
		}

	difference_type operator-(const _Mybase& _Right) const
		{	
		return (*(_Mybase *)this - _Right);
		}

	reference operator[](difference_type _Off) const
		{	
		return (*(*this + _Off));
		}
	};

template<class _Alloc> inline
	_Vb_iterator<_Alloc> operator+(typename _Alloc::difference_type _Off,
		_Vb_iterator<_Alloc> _Right)
		{	
		return (_Right += _Off);
		}

template<class _Alloc>
	struct _Is_checked_helper<_Vb_iterator<_Alloc> >
		: public true_type
	{	
	};

		
template<class _Alloc>
	class _Vb_val
		: public _Container_base
	{	
public:
	typedef vector<_Vbase, _Alloc> _Vectype;
	typedef typename _Vectype::_Alty _Alty;
	typedef typename _Alty::size_type size_type;

	_Vb_val(size_type _Count, const bool& _Val)
		: _Myvec(_Nw(_Count), (_Vbase) (_Val ? -1 : 0))
		{	
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
		: _Myvec(_Nw(_Count), (_Vbase)(_Val ? -1 : 0), _Al)
		{	
		_Alloc_proxy();
		_Mysize = 0;
		}

	_Vb_val(const _Vb_val& _Right)
		: _Myvec(_Right._Myvec),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
		: _Myvec(_Right._Myvec, _Al),
			_Mysize(_Right._Mysize)
		{	
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec)),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	_Vb_val(_Vb_val&& _Right, const _Alloc& _Al)
		: _Myvec(::std:: forward<_Vectype>(_Right._Myvec), _Al),
			_Mysize(_Right._Mysize)
		{	
		_Right._Mysize = 0;
		_Alloc_proxy();
		}

	~_Vb_val() noexcept
		{	
		_Free_proxy();
		}

 








#line 2391 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
	void _Alloc_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Myvec._Getal());
		this->_Myproxy = _Unfancy(_Alproxy.allocate(1));
		_Alproxy.construct(this->_Myproxy, _Container_proxy());
		this->_Myproxy->_Mycont = this;
		}

	void _Free_proxy()
		{	
		typename _Alty::template rebind<_Container_proxy>::other
			_Alproxy(_Myvec._Getal());
		this->_Orphan_all();
		_Alproxy.destroy(this->_Myproxy);
		_Alproxy.deallocate(_Alproxy.address(*this->_Myproxy), 1);
		this->_Myproxy = 0;
		}
 #line 2410 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	static size_type _Nw(size_type _Count)
		{	
		return ((_Count + _VBITS - 1) / _VBITS);
		}

	_Vectype _Myvec;	
	typename _Alty::size_type _Mysize;	
	};

		

template<class _Alloc>
	class vector<bool, _Alloc>
		: public _Vb_val<_Alloc>
	{	
public:
	typedef vector<bool, _Alloc> _Myt;
	typedef _Vb_val<_Alloc> _Mybase;
	typedef typename _Mybase::_Alty _Alty;
	typedef typename _Mybase::_Vectype _Vectype;

	typedef typename _Alty::size_type size_type;
	typedef typename _Alty::difference_type difference_type;
	typedef bool _Ty;
	typedef _Alloc allocator_type;

	typedef _Vb_reference<_Alty> reference;
	typedef bool const_reference;
	typedef bool value_type;

	typedef reference _Reft;
	typedef _Vb_const_iterator<_Alty> const_iterator;
	typedef _Vb_iterator<_Alty> iterator;

	typedef iterator pointer;
	typedef const_iterator const_pointer;
	typedef ::std:: reverse_iterator<iterator> reverse_iterator;
	typedef ::std:: reverse_iterator<const_iterator> const_reverse_iterator;

	static const int _VBITS = ::std:: _VBITS;
	enum {_EEN_VBITS = _VBITS};	
	vector()
		: _Mybase(0, false)
		{	
		}

	explicit vector(const _Alloc& _Al)
		: _Mybase(0, false, _Al)
		{	
		}

	explicit vector(size_type _Count, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, false, _Al)
		{	
		_Trim(_Count);
		}

	vector(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc())
		: _Mybase(_Count, _Val, _Al)
		{	
		_Trim(_Count);
		}

	vector(const _Myt& _Right)
		: _Mybase(_Right)
		{	
		}

	vector(const _Myt& _Right, const _Alloc& _Al)
		: _Mybase(_Right, _Al)
		{	
		}

	template<class _Iter,
		class = typename enable_if<_Is_iterator<_Iter>::value,
			void>::type>
		vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
		: _Mybase(0, false, _Al)
		{	
		_BConstruct(_First, _Last);
		}

	template<class _Iter>
		void _BConstruct(_Iter _First, _Iter _Last)
		{	
		insert(begin(), _First, _Last);
		}

	vector(_Myt&& _Right)
		: _Mybase(::std:: forward<_Myt>(_Right))
		{	
		}

	vector(_Myt&& _Right, const _Alloc& _Al)
		: _Mybase(::std:: forward<_Myt>(_Right), _Al)
		{	
		}

	_Myt& operator=(_Myt&& _Right)
		{	
		if (this != &_Right)
			{	
			clear();

			if (_Alty::propagate_on_container_move_assignment::value
				&& this->get_allocator() != _Right.get_allocator())
				{	
				this->_Free_proxy();
				this->_Myvec = ::std:: move(_Right._Myvec);
				this->_Alloc_proxy();
				}
			else
				this->_Myvec = ::std:: move(_Right._Myvec);


			this->_Mysize = _Right._Mysize;
			_Right._Mysize = 0;
			}
		return (*this);
		}

	template<class... _Valty>
		void emplace_back(_Valty&&... _Val)
		{	
		bool _Tmp(::std:: forward<_Valty>(_Val)...);
		push_back(_Tmp);
		}

	template<class... _Valty>
		iterator emplace(const_iterator _Where, _Valty&&... _Val)
		{	
		bool _Tmp(::std:: forward<_Valty>(_Val)...);
		return (insert(_Where, _Tmp));
		}


	vector(::std:: initializer_list<bool> _Ilist,
			const _Alloc& _Al = allocator_type())
		: _Mybase(0, false, _Al)
		{	
		insert(begin(), _Ilist.begin(), _Ilist.end());
		}

	_Myt& operator=(::std:: initializer_list<bool> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		return (*this);
		}

	void assign(::std:: initializer_list<bool> _Ilist)
		{	
		assign(_Ilist.begin(), _Ilist.end());
		}

	iterator insert(const_iterator _Where,
			::std:: initializer_list<bool> _Ilist)
		{	
		return (insert(_Where, _Ilist.begin(), _Ilist.end()));
		}

	~vector() noexcept
		{	
		}

	_Myt& operator=(const _Myt& _Right)
		{	
		this->_Mysize = _Right._Mysize;
		this->_Myvec = _Right._Myvec;
		return (*this);
		}

	void reserve(size_type _Count)
		{	
		this->_Myvec.reserve(this->_Nw(_Count));
		}

	size_type capacity() const noexcept
		{	
		return (this->_Myvec.capacity() * _VBITS);
		}

	iterator begin() noexcept
		{	
		return (iterator(this->_Myvec.data(), this));
		}

	const_iterator begin() const noexcept
		{	
		return (const_iterator(this->_Myvec.data(), this));
		}

	iterator end() noexcept
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	const_iterator end() const noexcept
		{	
		const_iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += this->_Mysize;
		return (_Tmp);
		}

	const_iterator cbegin() const noexcept
		{	
		return (begin());
		}

	const_iterator cend() const noexcept
		{	
		return (end());
		}

	const_reverse_iterator crbegin() const noexcept
		{	
		return (rbegin());
		}

	const_reverse_iterator crend() const noexcept
		{	
		return (rend());
		}

	void shrink_to_fit()
		{	
		if (this->_Myvec._Has_unused_capacity())
			{	
			_Myt _Tmp(*this);
			swap(_Tmp);
			}
		}

	iterator _Make_iter(const_iterator _Where)
		{	
		iterator _Tmp = begin();
		if (0 < this->_Mysize)
			_Tmp += _Where - begin();
		return (_Tmp);
		}

	reverse_iterator rbegin() noexcept
		{	
		return (reverse_iterator(end()));
		}

	const_reverse_iterator rbegin() const noexcept
		{	
		return (const_reverse_iterator(end()));
		}

	reverse_iterator rend() noexcept
		{	
		return (reverse_iterator(begin()));
		}

	const_reverse_iterator rend() const noexcept
		{	
		return (const_reverse_iterator(begin()));
		}

	void resize(size_type _Newsize, bool _Val = false)
		{	
		if (size() < _Newsize)
			_Insert_n(end(), _Newsize - size(), _Val);
		else if (_Newsize < size())
			erase(begin() + _Newsize, end());
		}

	size_type size() const noexcept
		{	
		return (this->_Mysize);
		}

	size_type max_size() const noexcept
		{	
		const size_type _Maxsize = this->_Myvec.max_size();
		return (_Maxsize < (size_type)(-1) / _VBITS
			? _Maxsize * _VBITS : (size_type)(-1));
		}

	bool empty() const noexcept
		{	
		return (size() == 0);
		}

	_Alloc get_allocator() const noexcept
		{	
		_Alloc _Ret(this->_Myvec.get_allocator());
		return (_Ret);
		}

	const_reference at(size_type _Off) const
		{	
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	reference at(size_type _Off)
		{	
		if (size() <= _Off)
			_Xran();
		return ((*this)[_Off]);
		}

	const_reference operator[](size_type _Off) const
		{	
		const_iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	reference operator[](size_type _Off)
		{	
		iterator _It = begin();
		_It._Advance(_Off);
		return (*_It);
		}

	reference front()
		{	
		return (*begin());
		}

	const_reference front() const
		{	
		return (*begin());
		}

	reference back()
		{	
		return (*(end() - 1));
		}

	const_reference back() const
		{	
		return (*(end() - 1));
		}

	void push_back(const bool& _Val)
		{	
		insert(end(), _Val);
		}

	void pop_back()
		{	
		erase(end() - 1);
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			void>::type
		assign(_Iter _First, _Iter _Last)
		{	
		erase(begin(), end());
		insert(begin(), _First, _Last);
		}

	void assign(size_type _Count, const bool& _Val)
		{	
		erase(begin(), end());
		_Insert_n(begin(), _Count, _Val);
		}

	iterator insert(const_iterator _Where, const bool& _Val)
		{	
		return (_Insert_n(_Where, (size_type)1, _Val));
		}

	iterator insert(const_iterator _Where, size_type _Count,
		const bool& _Val)
		{	
		return (_Insert_n(_Where, _Count, _Val));
		}

	template<class _Iter>
		typename enable_if<_Is_iterator<_Iter>::value,
			iterator>::type
		insert(const_iterator _Where, _Iter _First, _Iter _Last)
		{	
		size_type _Off = _Where - begin();
		_Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
		return (begin() + _Off);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
				input_iterator_tag)
		{	
		size_type _Off = _Where - begin();

		for (; _First != _Last; ++_First, (void)++_Off)
			insert(begin() + _Off, *_First);
		}

	template<class _Iter>
		void _Insert(const_iterator _Where,
			_Iter _First, _Iter _Last,
			forward_iterator_tag)
		{	
		_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2816);
		size_type _Count = ::std:: distance(_First, _Last);
		size_type _Off = _Insert_x(_Where, _Count);
		::std:: copy(_First, _Last, begin() + _Off);
		}

	iterator erase(const_iterator _Where_arg)
		{	
		iterator _Where = _Make_iter(_Where_arg);
		size_type _Off = _Where - begin();

 
		if (end() <= _Where)
			_Debug_message(L"vector<bool> erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2829);
		::std:: copy(_Where + 1, end(), _Where);
		_Orphan_range(_Off, this->_Mysize);

 

#line 2836 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		_Trim(this->_Mysize - 1);
		return (begin() + _Off);
		}

	iterator erase(const_iterator _First_arg,
		const_iterator _Last_arg)
		{	
		iterator _First = _Make_iter(_First_arg);
		iterator _Last = _Make_iter(_Last_arg);
		size_type _Off = _First - begin();

		if (_First != _Last)
			{	
 
			if (_Last < _First || end() < _Last)
				_Debug_message(L"vector<bool> erase iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2852);
			iterator _Next = ::std:: copy(_Last, end(), _First);
			size_type _Newsize = _Next - begin();
			_Orphan_range(_Newsize, this->_Mysize);
			_Trim(_Newsize);

 


#line 2862 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
			}
		return (begin() + _Off);
		}

	void clear() noexcept
		{	
		erase(begin(), end());
		}

	void flip() noexcept
		{	
		for (typename _Vectype::iterator _Next = this->_Myvec.begin();
			_Next != this->_Myvec.end(); ++_Next)
			*_Next = (_Vbase)~*_Next;
		_Trim(this->_Mysize);
		}

	void swap(_Myt& _Right)
		{	
		if (this != &_Right)
			{	
			this->_Swap_all(_Right);
			this->_Myvec.swap(_Right._Myvec);
			::std:: swap(this->_Mysize, _Right._Mysize);
			}
		}

	static void swap(reference _Left, reference _Right) noexcept
		{	
		bool _Val = _Left;	

		_Left = _Right;
		_Right = _Val;
		}

	size_t hash() const
		{	
		return (_Hash_seq((const unsigned char *)this->_Myvec.data(),
			this->_Myvec.size() * sizeof (_Vbase)));
		}

	iterator _Insert_n(const_iterator _Where,
		size_type _Count, const bool& _Val)
		{	
		size_type _Off = _Insert_x(_Where, _Count);
		::std:: fill(begin() + _Off, begin() + (_Off + _Count), _Val);
		return (begin() + _Off);
		}

	size_type _Insert_x(const_iterator _Where, size_type _Count)
		{	
		size_type _Off = _Where - begin();

 
		if (end() < _Where)
			_Debug_message(L"vector<bool> insert iterator outside range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector", 2917);
		bool _Realloc = capacity() - size() < _Count;
 #line 2920 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

		if (_Count == 0)
			;
		else if (max_size() - size() < _Count)
			_Xlen();	
		else
			{	
			this->_Myvec.resize(this->_Nw(size() + _Count), 0);
			if (empty())
				this->_Mysize += _Count;
			else
				{	
				iterator _Oldend = end();
				this->_Mysize += _Count;
				::std:: copy_backward(begin() + _Off, _Oldend, end());
				}

 
			_Orphan_range(_Realloc ? 0 : _Off, this->_Mysize);
 #line 2940 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
			}
		return (_Off);
		}

 
	void _Orphan_range(size_type _Offlo, size_type _Offhi) const
		{	
		typedef _Vb_iter_base<_Alty> _Myiterbase;

		_Lockit _Lock(3);
		auto _Base = const_cast<_Vbase *>(this->_Myvec.data());

		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();
		if (_Pnext != 0)
			while (*_Pnext != 0)
				{	
				size_type _Off = _VBITS * ((*_Pnext)->_Myptr - _Base)
					+ (*_Pnext)->_Myoff;
				if (_Off < _Offlo || _Offhi < _Off)
					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();
				else
					{	
					(*_Pnext)->_Clrcont();
					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();
					}
				}
		}

 



#line 2973 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"

	void _Trim(size_type _Size)
		{	
		if (max_size() < _Size)
			_Xlen();	
		size_type _Words = this->_Nw(_Size);

		if (_Words < this->_Myvec.size())
			this->_Myvec.erase(this->_Myvec.begin() + _Words,
				this->_Myvec.end());
		this->_Mysize = _Size;
		_Size %= _VBITS;
		if (0 < _Size)
			this->_Myvec[_Words - 1] &= ((_Vbase)(1) << _Size) - 1;
		}

	[[noreturn]] void _Xlen() const
		{	
		_Xlength_error("vector<bool> too long");
		}

	[[noreturn]] void _Xran() const
		{	
		_Xout_of_range("invalid vector<bool> subscript");
		}
	};

template<class _Alloc> inline
	bool operator==(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (_Left.size() == _Right.size()
		&& ::std:: equal(_Left._Myvec.begin(), _Left._Myvec.end(),
			_Right._Myvec.begin()));
	}

template<class _Alloc> inline
	bool operator!=(const vector<bool, _Alloc>& _Left,
		const vector<bool, _Alloc>& _Right)
	{	
	return (!(_Left == _Right));
	}

	
template<class _Alloc>
	struct hash<vector<bool, _Alloc> >
	{	
	typedef vector<bool, _Alloc> argument_type;
	typedef size_t result_type;

	size_t operator()(const argument_type& _Keyval) const
		{	
		return (_Keyval.hash());
		}
	};
}

 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3034 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"
#line 3035 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\vector"






#line 8 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shader.h"




using namespace std;
class Shader
{
public:
	
	GLuint ProgramID;
	
	Shader();
	~Shader();
	Shader(string vertexPath,string fragmentPath);
	Shader(string vertexPath, string geometryPath, string fragmentPath);
	Shader(string vertexShader, string geometryShader, string fragmentShader, bool);
	enum class ImageType {
		Wire,
		Triangle
	};
	struct ShaderInfo {
		int NumDiffuse = 0;
		int NumNormalMap = 0;
		int NumSpecular = 0;
		int NumDisplacement = 0;
		bool HasMaterial = false;
		Shader::ImageType imageType = Shader::ImageType::Triangle;

		vector<GLuint> DiffuseTextures;
		vector<GLuint> NormalMaps;
	};

	static Shader* ConstructShader(ShaderInfo shaderInfo);
	
	void Use();
	static bool LoadShaders();
	void Reload();
	static Shader& At(string ID);
	static void ReloadAll();
private:
	Shader* ConstructShaderNS(ShaderInfo shaderInfo);
	GLuint CompileVertexShader();
	GLuint CompileGeometryShader();
	GLuint CompileFragmentShader();

	string ConstructVertexShader();
	string ConstructGeometryShader();
	string ConstructFragmentShader();

	string FileToText(string Path);
	void TextToFile(string Text,string Path);
	void OutputFinalShader(string Text, string Path);
	ShaderInfo shaderInfo;
	void InitializeShaderProgram(string Path, GLuint shaderID);
	static map<string, Shader*> mapShader;
	string VertexShaderPath, GeometryShaderPath, FragmentShaderPath;

};
#line 4 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shaderbuilder.h"

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\importer.hpp"




















































#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"

















































#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\memory.h"







#pragma once



#line 51 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"
















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































#line 1010 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\math.h"

#line 52 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"





#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"

















































	
	

















	



#line 74 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"



#line 78 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"




#line 83 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"




#line 88 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"

	
	




























	




	
	
	












#line 140 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"


#line 143 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"

	



	














#line 164 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"





#line 170 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"


	


































#line 208 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"






#line 215 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"
	
	




	 









	
	



	


#line 240 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"



#line 244 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"

	
	
	


























#line 275 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"


#line 278 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"

#line 280 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\defs.h"
#line 58 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"


#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.h"


















































#line 52 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.h"

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"

























#pragma pack(push,1)









#line 37 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#pragma warning (disable : 4103) 
#line 43 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#line 54 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.h"



template<typename TReal> class aiMatrix3x3t;
template<typename TReal> class aiMatrix4x4t;



template <typename TReal>
class aiVector3t 
{
public:

	aiVector3t () : x(), y(), z() {}
	aiVector3t (TReal _x, TReal _y, TReal _z) : x(_x), y(_y), z(_z) {}
	explicit aiVector3t (TReal _xyz) : x(_xyz), y(_xyz), z(_xyz) {}
	aiVector3t (const aiVector3t& o) : x(o.x), y(o.y), z(o.z) {}

public:

	
	const aiVector3t& operator += (const aiVector3t& o);
	const aiVector3t& operator -= (const aiVector3t& o);
	const aiVector3t& operator *= (TReal f);
	const aiVector3t& operator /= (TReal f);

	
	aiVector3t& operator *= (const aiMatrix3x3t<TReal>& mat);
	aiVector3t& operator *= (const aiMatrix4x4t<TReal>& mat);

	
	TReal operator[](unsigned int i) const;
	TReal& operator[](unsigned int i);

	
	bool operator== (const aiVector3t& other) const;
	bool operator!= (const aiVector3t& other) const;
	bool operator < (const aiVector3t& other) const;

	bool Equal(const aiVector3t& other, TReal epsilon = 1e-6) const;

	template <typename TOther>
	operator aiVector3t<TOther> () const;

public:

	



	void Set( TReal pX, TReal pY, TReal pZ);

	

	TReal SquareLength() const;


	

	TReal Length() const;


	
	aiVector3t& Normalize();

	
	



	const aiVector3t SymMul(const aiVector3t& o);

	TReal x, y, z;	
} ;


typedef aiVector3t<float> aiVector3D;








#line 140 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.h"

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"

















#pragma pack( pop )
#line 20 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"



#line 142 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.h"





#line 148 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.h"

#line 150 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.h"
#line 61 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector2.h"


















































#line 52 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector2.h"

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"

























#pragma pack(push,1)









#line 37 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#pragma warning (disable : 4103) 
#line 43 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#line 54 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector2.h"






template <typename TReal>
class aiVector2t
{
public:

	aiVector2t () : x(), y() {}
	aiVector2t (TReal _x, TReal _y) : x(_x), y(_y) {}
	explicit aiVector2t (TReal _xyz) : x(_xyz), y(_xyz) {}
	aiVector2t (const aiVector2t& o) : x(o.x), y(o.y) {}

public:

	void Set( TReal pX, TReal pY);
	TReal SquareLength() const ;
	TReal Length() const ;
	aiVector2t& Normalize();

public:

	const aiVector2t& operator += (const aiVector2t& o);
	const aiVector2t& operator -= (const aiVector2t& o);
	const aiVector2t& operator *= (TReal f);
	const aiVector2t& operator /= (TReal f);

	TReal operator[](unsigned int i) const;
	TReal& operator[](unsigned int i);

	bool operator== (const aiVector2t& other) const;
	bool operator!= (const aiVector2t& other) const;

	bool Equal(const aiVector2t& other, TReal epsilon = 1e-6) const;

	aiVector2t& operator= (TReal f);
	const aiVector2t SymMul(const aiVector2t& o);

	template <typename TOther>
	operator aiVector2t<TOther> () const;

	TReal x, y;	
} ;

typedef aiVector2t<float> aiVector2D;







#line 110 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector2.h"

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"

















#pragma pack( pop )
#line 20 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"



#line 112 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector2.h"

#line 114 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector2.h"
#line 62 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\color4.h"














































#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"

























#pragma pack(push,1)









#line 37 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#pragma warning (disable : 4103) 
#line 43 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#line 48 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\color4.h"







template <typename TReal>
class aiColor4t
{
public:
	aiColor4t () : r(), g(), b(), a() {}
	aiColor4t (TReal _r, TReal _g, TReal _b, TReal _a) 
		: r(_r), g(_g), b(_b), a(_a) {}
	aiColor4t (TReal _r) : r(_r), g(_r), b(_r), a(_r) {}
	aiColor4t (const aiColor4t& o) 
		: r(o.r), g(o.g), b(o.b), a(o.a) {}

public:
	
	const aiColor4t& operator += (const aiColor4t& o);
	const aiColor4t& operator -= (const aiColor4t& o);
	const aiColor4t& operator *= (TReal f);
	const aiColor4t& operator /= (TReal f);

public:
	
	bool operator == (const aiColor4t& other) const;
	bool operator != (const aiColor4t& other) const;
	bool operator <  (const aiColor4t& other) const;

	
	inline TReal operator[](unsigned int i) const;
	inline TReal& operator[](unsigned int i);

	
	inline bool IsBlack() const;

public:

	
	TReal r, g, b, a;
} ;  

typedef aiColor4t<float> aiColor4D;







#line 101 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\color4.h"

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"

















#pragma pack( pop )
#line 20 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"



#line 103 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\color4.h"

#line 105 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\color4.h"
#line 63 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix3x3.h"















































#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"

























#pragma pack(push,1)









#line 37 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#pragma warning (disable : 4103) 
#line 43 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#line 49 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix3x3.h"



template <typename T> class aiMatrix4x4t;
template <typename T> class aiVector2t;










template <typename TReal>
class aiMatrix3x3t
{
public:

	aiMatrix3x3t () :	
		a1(static_cast<TReal>(1.0f)), a2(), a3(), 
		b1(), b2(static_cast<TReal>(1.0f)), b3(), 
		c1(), c2(), c3(static_cast<TReal>(1.0f)) {}

	aiMatrix3x3t (	TReal _a1, TReal _a2, TReal _a3,
					TReal _b1, TReal _b2, TReal _b3,
					TReal _c1, TReal _c2, TReal _c3) :	
		a1(_a1), a2(_a2), a3(_a3), 
		b1(_b1), b2(_b2), b3(_b3), 
		c1(_c1), c2(_c2), c3(_c3)
	{}

public:

	
	aiMatrix3x3t& operator *= (const aiMatrix3x3t& m);
	aiMatrix3x3t  operator  * (const aiMatrix3x3t& m) const;

	
	TReal* operator[]       (unsigned int p_iIndex);
	const TReal* operator[] (unsigned int p_iIndex) const;

	
	bool operator== (const aiMatrix4x4t<TReal>& m) const;
	bool operator!= (const aiMatrix4x4t<TReal>& m) const;

	bool Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon = 1e-6) const;

	template <typename TOther>
	operator aiMatrix3x3t<TOther> () const;

public:

	
	


	explicit aiMatrix3x3t( const aiMatrix4x4t<TReal>& pMatrix);

	
	

	aiMatrix3x3t& Transpose();

	
	



	aiMatrix3x3t& Inverse();
	TReal Determinant() const;

public:
	
	




	static aiMatrix3x3t& RotationZ(TReal a, aiMatrix3x3t& out);

	
	






	static aiMatrix3x3t& Rotation( TReal a, 
		const aiVector3t<TReal>& axis, aiMatrix3x3t& out);

	
	




	static aiMatrix3x3t& Translation( const aiVector2t<TReal>& v, aiMatrix3x3t& out);

	
	







	static aiMatrix3x3t& FromToMatrix(const aiVector3t<TReal>& from, 
		const aiVector3t<TReal>& to, aiMatrix3x3t& out);

public:


	TReal a1, a2, a3;
	TReal b1, b2, b3;
	TReal c1, c2, c3;
} ;

typedef aiMatrix3x3t<float> aiMatrix3x3;










#line 182 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix3x3.h"

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"

















#pragma pack( pop )
#line 20 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"



#line 184 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix3x3.h"

#line 186 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix3x3.h"
#line 64 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix4x4.h"














































#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"

























#pragma pack(push,1)









#line 37 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#pragma warning (disable : 4103) 
#line 43 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#line 48 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix4x4.h"



template<typename TReal> class aiMatrix3x3t;
template<typename TReal> class aiQuaterniont;











template<typename TReal>
class aiMatrix4x4t
{
public:
	
	
	aiMatrix4x4t ();

	
	aiMatrix4x4t (	TReal _a1, TReal _a2, TReal _a3, TReal _a4,
					TReal _b1, TReal _b2, TReal _b3, TReal _b4,
					TReal _c1, TReal _c2, TReal _c3, TReal _c4,
					TReal _d1, TReal _d2, TReal _d3, TReal _d4);


	
	explicit aiMatrix4x4t( const aiMatrix3x3t<TReal>& m);
	
	




	aiMatrix4x4t(const aiVector3t<TReal>& scaling, const aiQuaterniont<TReal>& rotation,
		const aiVector3t<TReal>& position);

public:

	
	TReal* operator[]       (unsigned int p_iIndex);
	const TReal* operator[] (unsigned int p_iIndex) const;

	
	bool operator== (const aiMatrix4x4t& m) const;
	bool operator!= (const aiMatrix4x4t& m) const;

	bool Equal(const aiMatrix4x4t& m, TReal epsilon = 1e-6) const;

	
	aiMatrix4x4t& operator *= (const aiMatrix4x4t& m);
	aiMatrix4x4t  operator *  (const aiMatrix4x4t& m) const;

	template <typename TOther>
	operator aiMatrix4x4t<TOther> () const;

public:

	
	
	aiMatrix4x4t& Transpose();

	
	



	aiMatrix4x4t& Inverse();
	TReal Determinant() const;


	
	


	inline bool IsIdentity() const;

	
	





	void Decompose (aiVector3t<TReal>& scaling, aiQuaterniont<TReal>& rotation,
		aiVector3t<TReal>& position) const;

	
	





	void DecomposeNoScaling (aiQuaterniont<TReal>& rotation,
		aiVector3t<TReal>& position) const;


	
	




	aiMatrix4x4t& FromEulerAnglesXYZ(TReal x, TReal y, TReal z);
	aiMatrix4x4t& FromEulerAnglesXYZ(const aiVector3t<TReal>& blubb);

public:
	
	




	static aiMatrix4x4t& RotationX(TReal a, aiMatrix4x4t& out);

	
	




	static aiMatrix4x4t& RotationY(TReal a, aiMatrix4x4t& out);

	
	




	static aiMatrix4x4t& RotationZ(TReal a, aiMatrix4x4t& out);

	
	





	static aiMatrix4x4t& Rotation(TReal a, const aiVector3t<TReal>& axis, 
		aiMatrix4x4t& out);

	
	




	static aiMatrix4x4t& Translation( const aiVector3t<TReal>& v, aiMatrix4x4t& out);

	
	




	static aiMatrix4x4t& Scaling( const aiVector3t<TReal>& v, aiMatrix4x4t& out);

	
	







	static aiMatrix4x4t& FromToMatrix(const aiVector3t<TReal>& from, 
		const aiVector3t<TReal>& to, aiMatrix4x4t& out);

public:

	TReal a1, a2, a3, a4;
	TReal b1, b2, b3, b4;
	TReal c1, c2, c3, c4;
	TReal d1, d2, d3, d4;

} ; 

typedef aiMatrix4x4t<float> aiMatrix4x4;











#line 245 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix4x4.h"

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"

















#pragma pack( pop )
#line 20 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"



#line 247 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix4x4.h"

#line 249 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix4x4.h"
#line 65 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\quaternion.h"
















































template <typename TReal> class aiVector3t;
template <typename TReal> class aiMatrix3x3t;



template <typename TReal>
class aiQuaterniont
{
public:
	aiQuaterniont() : w(1.0), x(), y(), z() {}
	aiQuaterniont(TReal pw, TReal px, TReal py, TReal pz) 
		: w(pw), x(px), y(py), z(pz) {}

	
	aiQuaterniont( const aiMatrix3x3t<TReal>& pRotMatrix);

	
	aiQuaterniont( TReal rotx, TReal roty, TReal rotz);

	
	aiQuaterniont( aiVector3t<TReal> axis, TReal angle);

	
	aiQuaterniont( aiVector3t<TReal> normalized);

	
	aiMatrix3x3t<TReal> GetMatrix() const;

public:

	bool operator== (const aiQuaterniont& o) const;
	bool operator!= (const aiQuaterniont& o) const;

	bool Equal(const aiQuaterniont& o, TReal epsilon = 1e-6) const;

public:

	
	aiQuaterniont& Normalize();

	
	aiQuaterniont& Conjugate ();

	
	aiVector3t<TReal> Rotate (const aiVector3t<TReal>& in);

	
	aiQuaterniont operator* (const aiQuaterniont& two) const;

public:

	





	static void Interpolate( aiQuaterniont& pOut, const aiQuaterniont& pStart, 
		const aiQuaterniont& pEnd, TReal pFactor);

public:

	
	TReal w, x, y, z;	
} ;

typedef aiQuaterniont<float> aiQuaternion;







#line 124 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\quaternion.h"


#line 127 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\quaternion.h"
#line 66 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"






namespace Assimp	{
	
namespace Intern		{
	
	










	

	struct  AllocateFromAssimpHeap	{
		

		
		void *operator new    ( size_t num_bytes) ;
		void *operator new    ( size_t num_bytes, const std::nothrow_t& ) throw();
		void  operator delete ( void* data);

		
		void *operator new[]    ( size_t num_bytes) ;
		void *operator new[]    ( size_t num_bytes, const std::nothrow_t& )  throw();
		void  operator delete[] ( void* data);

	}; 
#line 104 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
} 
	
} 

extern "C" {
#line 110 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"



const size_t MAXLEN = 1024;


#line 117 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"

























#pragma pack(push,1)









#line 37 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#pragma warning (disable : 4103) 
#line 43 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#line 119 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"




struct aiPlane
{

	aiPlane () : a(0.f), b(0.f), c(0.f), d(0.f) {}
	aiPlane (float _a, float _b, float _c, float _d) 
		: a(_a), b(_b), c(_c), d(_d) {}

	aiPlane (const aiPlane& o) : a(o.a), b(o.b), c(o.c), d(o.d) {}

#line 133 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"

	
	float a,b,c,d;
} ; 




struct aiRay
{

	aiRay () {}
	aiRay (const aiVector3D& _pos, const aiVector3D& _dir)
		: pos(_pos), dir(_dir) {}

	aiRay (const aiRay& o) : pos (o.pos), dir (o.dir) {}

#line 151 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"

	
	 aiVector3D pos, dir;
} ; 




struct aiColor3D
{

	aiColor3D () : r(0.0f), g(0.0f), b(0.0f) {}
	aiColor3D (float _r, float _g, float _b) : r(_r), g(_g), b(_b) {}
	aiColor3D (float _r) : r(_r), g(_r), b(_r) {}
	aiColor3D (const aiColor3D& o) : r(o.r), g(o.g), b(o.b) {}
	
	
	
	bool operator == (const aiColor3D& other) const
		{return r == other.r && g == other.g && b == other.b;}

	
	
	bool operator != (const aiColor3D& other) const
		{return r != other.r || g != other.g || b != other.b;}

	
	
	bool operator < (const aiColor3D& other) const {
		return r < other.r || (
			r == other.r && (g < other.g ||
				(g == other.g && b < other.b)
			)
		);
	}

	
	aiColor3D operator+(const aiColor3D& c) const {
		return aiColor3D(r+c.r,g+c.g,b+c.b);
	}

	
	aiColor3D operator-(const aiColor3D& c) const {
		return aiColor3D(r-c.r,g-c.g,b-c.b);
	}

	
	aiColor3D operator*(const aiColor3D& c) const {
		return aiColor3D(r*c.r,g*c.g,b*c.b);
	}
	
	
	aiColor3D operator*(float f) const {
		return aiColor3D(r*f,g*f,b*f);
	}

	
	float operator[](unsigned int i) const {
		return *(&r + i);
	}

	
	float& operator[](unsigned int i) {
		return *(&r + i);
	}

	
	bool IsBlack() const {
		static const float epsilon = 10e-3f;
		return fabs( r ) < epsilon && fabs( g ) < epsilon && fabs( b ) < epsilon;
	}

#line 224 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"

	
	float r, g, b;
} ;  
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"

















#pragma pack( pop )
#line 20 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"



#line 229 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"






















struct aiString
{

	
	aiString() :
		length(0) 
	{
		data[0] = '\0';


		
		memset(data+1,27,MAXLEN-1);
#line 264 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
	}

	
	aiString(const aiString& rOther) : 
		length(rOther.length) 
	{
		
		length = length>=MAXLEN?MAXLEN-1:length;
		memcpy( data, rOther.data, length);
		data[length] = '\0';
	}

	
	explicit aiString(const std::string& pString) : 
		length(pString.length()) 
	{
		length = length>=MAXLEN?MAXLEN-1:length;
		memcpy( data, pString.c_str(), length);
		data[length] = '\0';
	}

	
	void Set( const std::string& pString) {
		if( pString.length() > MAXLEN - 1) {
			return;
		}
		length = pString.length();
		memcpy( data, pString.c_str(), length);
		data[length] = 0;
	}

	
	void Set( const char* sz) {
		const size_t len = ::strlen(sz);
		if( len > MAXLEN - 1) {
			return;
		}
		length = len;
		memcpy( data, sz, len);
		data[len] = 0;
	}

	
	aiString& operator = (const char* sz) {
		Set(sz);
		return *this;
	}

	
	aiString& operator = ( const std::string& pString) {
		Set(pString);
		return *this;
	}

	
	bool operator==(const aiString& other) const {
		return  (length == other.length && 0 == memcmp(data,other.data,length));
	}

	
	bool operator!=(const aiString& other) const {
		return  (length != other.length || 0 != memcmp(data,other.data,length));
	}

	
	void Append (const char* app)	{
		const size_t len = ::strlen(app);
		if (!len) {
			return;
		}
		if (length + len >= MAXLEN) {
			return;
		}

		memcpy(&data[length],app,len+1);
		length += len;
	}

	
	void Clear ()	{
		length  = 0;
		data[0] = '\0';


		
		memset(data+1,27,MAXLEN-1);
#line 351 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
	}

	
	const char* C_Str() const {
		return data;
	}

#line 359 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"

	


	size_t length;

	
	char data[MAXLEN];
} ;  






typedef enum aiReturn
{
	
	aiReturn_SUCCESS = 0x0,

	
	aiReturn_FAILURE = -0x1,

	


	aiReturn_OUTOFMEMORY = -0x3,

	


	_AI_ENFORCE_ENUM_SIZE = 0x7fffffff 
} aiReturn;  










enum aiOrigin
{
	
	aiOrigin_SET = 0x0,	

	
	aiOrigin_CUR = 0x1,		

	
	aiOrigin_END = 0x2,

	


	_AI_ORIGIN_ENFORCE_ENUM_SIZE = 0x7fffffff 
}; 







enum aiDefaultLogStream	
{
	
	aiDefaultLogStream_FILE = 0x1,

	
	aiDefaultLogStream_STDOUT = 0x2,

	
	aiDefaultLogStream_STDERR = 0x4,

	


	aiDefaultLogStream_DEBUGGER = 0x8,

	


	_AI_DLS_ENFORCE_ENUM_SIZE = 0x7fffffff 
}; 












struct aiMemoryInfo
{


	
	aiMemoryInfo()
		: textures   (0)
		, materials  (0)
		, meshes     (0)
		, nodes      (0)
		, animations (0)
		, cameras	 (0)
		, lights	 (0)
		, total      (0)
	{}

#line 475 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"

	
	unsigned int textures;

	
	unsigned int materials;

	
	unsigned int meshes;

	
	unsigned int nodes;

	
	unsigned int animations;

	
	unsigned int cameras;

	
	unsigned int lights;

	
	unsigned int total;
}; 


}
#line 504 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"


#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector2.inl"





















































template <typename TReal>
template <typename TOther>
aiVector2t<TReal>::operator aiVector2t<TOther> () const {
	return aiVector2t<TOther>(static_cast<TOther>(x),static_cast<TOther>(y));
}

template <typename TReal>
void aiVector2t<TReal>::Set( TReal pX, TReal pY) { 
	x = pX; y = pY;
}


template <typename TReal>
TReal aiVector2t<TReal>::SquareLength() const {
	return x*x + y*y; 
}


template <typename TReal>
TReal aiVector2t<TReal>::Length() const {
	return ::sqrt( SquareLength());
}


template <typename TReal>
aiVector2t<TReal>& aiVector2t<TReal>::Normalize() { 
	*this /= Length(); 
	return *this;
}


template <typename TReal>
const aiVector2t<TReal>& aiVector2t<TReal>::operator += (const aiVector2t& o) {
	x += o.x; y += o.y;  
	return *this; 
}


template <typename TReal>
const aiVector2t<TReal>& aiVector2t<TReal>::operator -= (const aiVector2t& o) {
	x -= o.x; y -= o.y;  
	return *this; 
}


template <typename TReal>
const aiVector2t<TReal>& aiVector2t<TReal>::operator *= (TReal f) { 
	x *= f; y *= f;  
	return *this; 
}


template <typename TReal>
const aiVector2t<TReal>& aiVector2t<TReal>::operator /= (TReal f) {
	x /= f; y /= f;  
	return *this; 
}


template <typename TReal>
TReal aiVector2t<TReal>::operator[](unsigned int i) const {
	return *(&x + i);
}


template <typename TReal>
TReal& aiVector2t<TReal>::operator[](unsigned int i) {
	return *(&x + i);
}


template <typename TReal>
bool aiVector2t<TReal>::operator== (const aiVector2t& other) const {
	return x == other.x && y == other.y;
}


template <typename TReal>
bool aiVector2t<TReal>::operator!= (const aiVector2t& other) const {
	return x != other.x || y != other.y;
}


template<typename TReal>
bool aiVector2t<TReal>::Equal(const aiVector2t& other, TReal epsilon) const {
	return
		std::abs(x - other.x) <= epsilon &&
		std::abs(y - other.y) <= epsilon;
}


template <typename TReal>
aiVector2t<TReal>& aiVector2t<TReal>::operator= (TReal f)	{
	x = y = f;
	return *this;
}


template <typename TReal>
const aiVector2t<TReal> aiVector2t<TReal>::SymMul(const aiVector2t& o) {
	return aiVector2t(x*o.x,y*o.y);
}




template <typename TReal>
inline aiVector2t<TReal> operator + (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2)
{
	return aiVector2t<TReal>( v1.x + v2.x, v1.y + v2.y);
}



template <typename TReal>
inline aiVector2t<TReal> operator - (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2)
{
	return aiVector2t<TReal>( v1.x - v2.x, v1.y - v2.y);
}



template <typename TReal>
inline TReal operator * (const aiVector2t<TReal>& v1, const aiVector2t<TReal>& v2)
{
	return v1.x*v2.x + v1.y*v2.y;
}



template <typename TReal>
inline aiVector2t<TReal> operator * ( TReal f, const aiVector2t<TReal>& v)
{
	return aiVector2t<TReal>( f*v.x, f*v.y);
}



template <typename TReal>
inline aiVector2t<TReal> operator * ( const aiVector2t<TReal>& v, TReal f)
{
	return aiVector2t<TReal>( f*v.x, f*v.y);
}



template <typename TReal>
inline aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, TReal f)
{

	return v * (1/f);
}



template <typename TReal>
inline aiVector2t<TReal> operator / ( const aiVector2t<TReal>& v, const aiVector2t<TReal>& v2)
{
	return aiVector2t<TReal>(v.x / v2.x,v.y / v2.y);
}



template <typename TReal>
inline aiVector2t<TReal> operator - ( const aiVector2t<TReal>& v)
{
	return aiVector2t<TReal>( -v.x, -v.y);
}

#line 224 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector2.inl"
#line 225 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector2.inl"
#line 507 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.inl"






















































template <typename TReal>
inline aiVector3t<TReal> operator * (const aiMatrix3x3t<TReal>& pMatrix, const aiVector3t<TReal>& pVector)
{
	aiVector3t<TReal> res;
	res.x = pMatrix.a1 * pVector.x + pMatrix.a2 * pVector.y + pMatrix.a3 * pVector.z;
	res.y = pMatrix.b1 * pVector.x + pMatrix.b2 * pVector.y + pMatrix.b3 * pVector.z;
	res.z = pMatrix.c1 * pVector.x + pMatrix.c2 * pVector.y + pMatrix.c3 * pVector.z;
	return res;
}



template <typename TReal>
inline aiVector3t<TReal> operator * (const aiMatrix4x4t<TReal>& pMatrix, const aiVector3t<TReal>& pVector)
{
	aiVector3t<TReal> res;
	res.x = pMatrix.a1 * pVector.x + pMatrix.a2 * pVector.y + pMatrix.a3 * pVector.z + pMatrix.a4;
	res.y = pMatrix.b1 * pVector.x + pMatrix.b2 * pVector.y + pMatrix.b3 * pVector.z + pMatrix.b4;
	res.z = pMatrix.c1 * pVector.x + pMatrix.c2 * pVector.y + pMatrix.c3 * pVector.z + pMatrix.c4;
	return res;
}

template <typename TReal>
template <typename TOther>
aiVector3t<TReal>::operator aiVector3t<TOther> () const {
	return aiVector3t<TOther>(static_cast<TOther>(x),static_cast<TOther>(y),static_cast<TOther>(z));
}

template <typename TReal>
__forceinline void aiVector3t<TReal>::Set( TReal pX, TReal pY, TReal pZ) { 
	x = pX; y = pY; z = pZ; 
}

template <typename TReal>
__forceinline TReal aiVector3t<TReal>::SquareLength() const {
	return x*x + y*y + z*z; 
}

template <typename TReal>
__forceinline TReal aiVector3t<TReal>::Length() const {
	return ::sqrt( SquareLength()); 
}

template <typename TReal>
__forceinline aiVector3t<TReal>& aiVector3t<TReal>::Normalize() { 
	*this /= Length(); return *this;
}

template <typename TReal>
__forceinline const aiVector3t<TReal>& aiVector3t<TReal>::operator += (const aiVector3t<TReal>& o) {
	x += o.x; y += o.y; z += o.z; return *this; 
}

template <typename TReal>
__forceinline const aiVector3t<TReal>& aiVector3t<TReal>::operator -= (const aiVector3t<TReal>& o) {
	x -= o.x; y -= o.y; z -= o.z; return *this;
}

template <typename TReal>
__forceinline const aiVector3t<TReal>& aiVector3t<TReal>::operator *= (TReal f) {
	x *= f; y *= f; z *= f; return *this; 
}

template <typename TReal>
__forceinline const aiVector3t<TReal>& aiVector3t<TReal>::operator /= (TReal f) {
	x /= f; y /= f; z /= f; return *this; 
}

template <typename TReal>
__forceinline aiVector3t<TReal>& aiVector3t<TReal>::operator *= (const aiMatrix3x3t<TReal>& mat){
	return(*this =  mat * (*this));
}

template <typename TReal>
__forceinline aiVector3t<TReal>& aiVector3t<TReal>::operator *= (const aiMatrix4x4t<TReal>& mat){
	return(*this = mat * (*this));
}

template <typename TReal>
__forceinline TReal aiVector3t<TReal>::operator[](unsigned int i) const {
	return *(&x + i);
}

template <typename TReal>
__forceinline TReal& aiVector3t<TReal>::operator[](unsigned int i) {
	return *(&x + i);
}

template <typename TReal>
__forceinline bool aiVector3t<TReal>::operator== (const aiVector3t<TReal>& other) const {
	return x == other.x && y == other.y && z == other.z;
}

template <typename TReal>
__forceinline bool aiVector3t<TReal>::operator!= (const aiVector3t<TReal>& other) const {
	return x != other.x || y != other.y || z != other.z;
}

template<typename TReal>
__forceinline bool aiVector3t<TReal>::Equal(const aiVector3t<TReal>& other, TReal epsilon) const {
	return
		std::abs(x - other.x) <= epsilon &&
		std::abs(y - other.y) <= epsilon &&
		std::abs(z - other.z) <= epsilon;
}

template <typename TReal>
__forceinline bool aiVector3t<TReal>::operator < (const aiVector3t<TReal>& other) const {
	return x != other.x ? x < other.x : y != other.y ? y < other.y : z < other.z;
}

template <typename TReal>
__forceinline const aiVector3t<TReal> aiVector3t<TReal>::SymMul(const aiVector3t<TReal>& o) {
	return aiVector3t<TReal>(x*o.x,y*o.y,z*o.z);
}


template <typename TReal>
__forceinline aiVector3t<TReal> operator + (const aiVector3t<TReal>& v1, const aiVector3t<TReal>& v2)	{
	return aiVector3t<TReal>( v1.x + v2.x, v1.y + v2.y, v1.z + v2.z);
}


template <typename TReal>
__forceinline aiVector3t<TReal> operator - (const aiVector3t<TReal>& v1, const aiVector3t<TReal>& v2)	{
	return aiVector3t<TReal>( v1.x - v2.x, v1.y - v2.y, v1.z - v2.z);
}


template <typename TReal>
__forceinline TReal operator * (const aiVector3t<TReal>& v1, const aiVector3t<TReal>& v2)	{
	return v1.x*v2.x + v1.y*v2.y + v1.z*v2.z;
}


template <typename TReal>
__forceinline aiVector3t<TReal> operator * ( TReal f, const aiVector3t<TReal>& v)	{
	return aiVector3t<TReal>( f*v.x, f*v.y, f*v.z);
}


template <typename TReal>
__forceinline  aiVector3t<TReal> operator * ( const aiVector3t<TReal>& v, TReal f)	{
	return aiVector3t<TReal>( f*v.x, f*v.y, f*v.z);
}


template <typename TReal>
__forceinline  aiVector3t<TReal> operator / ( const aiVector3t<TReal>& v, TReal f)	{
	return v * (1/f);
}


template <typename TReal>
__forceinline  aiVector3t<TReal> operator / ( const aiVector3t<TReal>& v, const aiVector3t<TReal>& v2)	{
	return aiVector3t<TReal>(v.x / v2.x,v.y / v2.y,v.z / v2.z);
}


template <typename TReal>
__forceinline  aiVector3t<TReal> operator ^ ( const aiVector3t<TReal>& v1, const aiVector3t<TReal>& v2)	{
	return aiVector3t<TReal>( v1.y*v2.z - v1.z*v2.y, v1.z*v2.x - v1.x*v2.z, v1.x*v2.y - v1.y*v2.x);
}


template <typename TReal>
__forceinline  aiVector3t<TReal> operator - ( const aiVector3t<TReal>& v)	{
	return aiVector3t<TReal>( -v.x, -v.y, -v.z);
}



#line 228 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.inl"
#line 229 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\vector3.inl"
#line 508 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\color4.inl"



















































template <typename TReal>
__forceinline const aiColor4t<TReal>& aiColor4t<TReal>::operator += (const aiColor4t<TReal>& o) {
	r += o.r; g += o.g; b += o.b; a += o.a; 
	return *this; 
}

template <typename TReal>
__forceinline const aiColor4t<TReal>& aiColor4t<TReal>::operator -= (const aiColor4t<TReal>& o) {
	r -= o.r; g -= o.g; b -= o.b; a -= o.a; 
	return *this;
}

template <typename TReal>
__forceinline const aiColor4t<TReal>& aiColor4t<TReal>::operator *= (TReal f) {
	r *= f; g *= f; b *= f; a *= f; 
	return *this; 
}

template <typename TReal>
__forceinline const aiColor4t<TReal>& aiColor4t<TReal>::operator /= (TReal f) {
	r /= f; g /= f; b /= f; a /= f; 
	return *this; 
}

template <typename TReal>
__forceinline TReal aiColor4t<TReal>::operator[](unsigned int i) const {
	return *(&r + i);
}

template <typename TReal>
__forceinline TReal& aiColor4t<TReal>::operator[](unsigned int i) {
	return *(&r + i);
}

template <typename TReal>
__forceinline bool aiColor4t<TReal>::operator== (const aiColor4t<TReal>& other) const {
	return r == other.r && g == other.g && b == other.b && a == other.a;
}

template <typename TReal>
__forceinline bool aiColor4t<TReal>::operator!= (const aiColor4t<TReal>& other) const {
	return r != other.r || g != other.g || b != other.b || a != other.a;
}

template <typename TReal>
__forceinline bool aiColor4t<TReal>::operator< (const aiColor4t<TReal>& other) const {
	return r < other.r || (
		r == other.r && (
			g < other.g || (
				g == other.g && (
					b < other.b || (
						b == other.b && (
							a < other.a
						)
					)
				)
			)
		)
	);
}

template <typename TReal>
__forceinline aiColor4t<TReal> operator + (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)	{
	return aiColor4t<TReal>( v1.r + v2.r, v1.g + v2.g, v1.b + v2.b, v1.a + v2.a);
}

template <typename TReal>
__forceinline aiColor4t<TReal> operator - (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)	{
	return aiColor4t<TReal>( v1.r - v2.r, v1.g - v2.g, v1.b - v2.b, v1.a - v2.a);
}

template <typename TReal>
__forceinline aiColor4t<TReal> operator * (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)	{
	return aiColor4t<TReal>( v1.r * v2.r, v1.g * v2.g, v1.b * v2.b, v1.a * v2.a);
}

template <typename TReal>
__forceinline aiColor4t<TReal> operator / (const aiColor4t<TReal>& v1, const aiColor4t<TReal>& v2)	{
	return aiColor4t<TReal>( v1.r / v2.r, v1.g / v2.g, v1.b / v2.b, v1.a / v2.a);
}

template <typename TReal>
__forceinline aiColor4t<TReal> operator * ( TReal f, const aiColor4t<TReal>& v)	{
	return aiColor4t<TReal>( f*v.r, f*v.g, f*v.b, f*v.a);
}

template <typename TReal>
__forceinline  aiColor4t<TReal> operator * ( const aiColor4t<TReal>& v, TReal f)	{
	return aiColor4t<TReal>( f*v.r, f*v.g, f*v.b, f*v.a);
}

template <typename TReal>
__forceinline  aiColor4t<TReal> operator / ( const aiColor4t<TReal>& v, TReal f)	{
	return v * (1/f);
}

template <typename TReal>
__forceinline  aiColor4t<TReal> operator / ( TReal f,const aiColor4t<TReal>& v)	{
	return aiColor4t<TReal>(f,f,f,f)/v;
}

template <typename TReal>
__forceinline  aiColor4t<TReal> operator + ( const aiColor4t<TReal>& v, TReal f)	{
	return aiColor4t<TReal>( f+v.r, f+v.g, f+v.b, f+v.a);
}

template <typename TReal>
__forceinline  aiColor4t<TReal> operator - ( const aiColor4t<TReal>& v, TReal f)	{
	return aiColor4t<TReal>( v.r-f, v.g-f, v.b-f, v.a-f);
}

template <typename TReal>
__forceinline  aiColor4t<TReal> operator + ( TReal f, const aiColor4t<TReal>& v)	{
	return aiColor4t<TReal>( f+v.r, f+v.g, f+v.b, f+v.a);
}

template <typename TReal>
__forceinline  aiColor4t<TReal> operator - ( TReal f, const aiColor4t<TReal>& v)	{
	return aiColor4t<TReal>( f-v.r, f-v.g, f-v.b, f-v.a);
}


template <typename TReal>
inline bool aiColor4t<TReal> :: IsBlack() const	{
	
	static const TReal epsilon = 10e-3f;
	return fabs( r ) < epsilon && fabs( g ) < epsilon && fabs( b ) < epsilon;
}

#line 182 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\color4.inl"
#line 183 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\color4.inl"
#line 509 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\quaternion.inl"





















































template<typename TReal>
bool aiQuaterniont<TReal>::operator== (const aiQuaterniont& o) const
{
	return x == o.x && y == o.y && z == o.z && w == o.w;
}


template<typename TReal>
bool aiQuaterniont<TReal>::operator!= (const aiQuaterniont& o) const
{
	return !(*this == o);
}


template<typename TReal>
inline bool aiQuaterniont<TReal>::Equal(const aiQuaterniont& o, TReal epsilon) const {
	return
		std::abs(x - o.x) <= epsilon &&
		std::abs(y - o.y) <= epsilon &&
		std::abs(z - o.z) <= epsilon &&
		std::abs(w - o.w) <= epsilon;
}



template<typename TReal>
inline aiQuaterniont<TReal>::aiQuaterniont( const aiMatrix3x3t<TReal> &pRotMatrix)
{
	TReal t = pRotMatrix.a1 + pRotMatrix.b2 + pRotMatrix.c3;

	
	if( t > static_cast<TReal>(0))
	{
		TReal s = sqrt(1 + t) * static_cast<TReal>(2.0);
		x = (pRotMatrix.c2 - pRotMatrix.b3) / s;
		y = (pRotMatrix.a3 - pRotMatrix.c1) / s;
		z = (pRotMatrix.b1 - pRotMatrix.a2) / s;
		w = static_cast<TReal>(0.25) * s;
	} 
	else if( pRotMatrix.a1 > pRotMatrix.b2 && pRotMatrix.a1 > pRotMatrix.c3 )  
	{	
		
		TReal s = sqrt( static_cast<TReal>(1.0) + pRotMatrix.a1 - pRotMatrix.b2 - pRotMatrix.c3) * static_cast<TReal>(2.0);
		x = static_cast<TReal>(0.25) * s;
		y = (pRotMatrix.b1 + pRotMatrix.a2) / s;
		z = (pRotMatrix.a3 + pRotMatrix.c1) / s;
		w = (pRotMatrix.c2 - pRotMatrix.b3) / s;
	} 
	else if( pRotMatrix.b2 > pRotMatrix.c3) 
	{ 
		
		TReal s = sqrt( static_cast<TReal>(1.0) + pRotMatrix.b2 - pRotMatrix.a1 - pRotMatrix.c3) * static_cast<TReal>(2.0);
		x = (pRotMatrix.b1 + pRotMatrix.a2) / s;
		y = static_cast<TReal>(0.25) * s;
		z = (pRotMatrix.c2 + pRotMatrix.b3) / s;
		w = (pRotMatrix.a3 - pRotMatrix.c1) / s;
	} else 
	{ 
		
		TReal s = sqrt( static_cast<TReal>(1.0) + pRotMatrix.c3 - pRotMatrix.a1 - pRotMatrix.b2) * static_cast<TReal>(2.0);
		x = (pRotMatrix.a3 + pRotMatrix.c1) / s;
		y = (pRotMatrix.c2 + pRotMatrix.b3) / s;
		z = static_cast<TReal>(0.25) * s;
		w = (pRotMatrix.b1 - pRotMatrix.a2) / s;
	}
}



template<typename TReal>
inline aiQuaterniont<TReal>::aiQuaterniont( TReal fPitch, TReal fYaw, TReal fRoll )
{
	const TReal fSinPitch(sin(fPitch*static_cast<TReal>(0.5)));
	const TReal fCosPitch(cos(fPitch*static_cast<TReal>(0.5)));
	const TReal fSinYaw(sin(fYaw*static_cast<TReal>(0.5)));
	const TReal fCosYaw(cos(fYaw*static_cast<TReal>(0.5)));
	const TReal fSinRoll(sin(fRoll*static_cast<TReal>(0.5)));
	const TReal fCosRoll(cos(fRoll*static_cast<TReal>(0.5)));
	const TReal fCosPitchCosYaw(fCosPitch*fCosYaw);
	const TReal fSinPitchSinYaw(fSinPitch*fSinYaw);
	x = fSinRoll * fCosPitchCosYaw     - fCosRoll * fSinPitchSinYaw;
	y = fCosRoll * fSinPitch * fCosYaw + fSinRoll * fCosPitch * fSinYaw;
	z = fCosRoll * fCosPitch * fSinYaw - fSinRoll * fSinPitch * fCosYaw;
	w = fCosRoll * fCosPitchCosYaw     + fSinRoll * fSinPitchSinYaw;
}



template<typename TReal>
inline aiMatrix3x3t<TReal> aiQuaterniont<TReal>::GetMatrix() const
{
	aiMatrix3x3t<TReal> resMatrix;
	resMatrix.a1 = static_cast<TReal>(1.0) - static_cast<TReal>(2.0) * (y * y + z * z);
	resMatrix.a2 = static_cast<TReal>(2.0) * (x * y - z * w);
	resMatrix.a3 = static_cast<TReal>(2.0) * (x * z + y * w);
	resMatrix.b1 = static_cast<TReal>(2.0) * (x * y + z * w);
	resMatrix.b2 = static_cast<TReal>(1.0) - static_cast<TReal>(2.0) * (x * x + z * z);
	resMatrix.b3 = static_cast<TReal>(2.0) * (y * z - x * w);
	resMatrix.c1 = static_cast<TReal>(2.0) * (x * z - y * w);
	resMatrix.c2 = static_cast<TReal>(2.0) * (y * z + x * w);
	resMatrix.c3 = static_cast<TReal>(1.0) - static_cast<TReal>(2.0) * (x * x + y * y);

	return resMatrix;
}



template<typename TReal>
inline aiQuaterniont<TReal>::aiQuaterniont( aiVector3t<TReal> axis, TReal angle)
{
	axis.Normalize();

	const TReal sin_a = sin( angle / 2 );
	const TReal cos_a = cos( angle / 2 );
	x    = axis.x * sin_a;
	y    = axis.y * sin_a;
	z    = axis.z * sin_a;
	w    = cos_a;
}


template<typename TReal>
inline aiQuaterniont<TReal>::aiQuaterniont( aiVector3t<TReal> normalized)
{
	x = normalized.x;
	y = normalized.y;
	z = normalized.z;

	const TReal t = static_cast<TReal>(1.0) - (x*x) - (y*y) - (z*z);

	if (t < static_cast<TReal>(0.0)) {
		w = static_cast<TReal>(0.0);
	}
	else w = sqrt (t);
}





template<typename TReal>
inline void aiQuaterniont<TReal>::Interpolate( aiQuaterniont& pOut, const aiQuaterniont& pStart, const aiQuaterniont& pEnd, TReal pFactor)
{
	
	TReal cosom = pStart.x * pEnd.x + pStart.y * pEnd.y + pStart.z * pEnd.z + pStart.w * pEnd.w;

	
	aiQuaterniont end = pEnd;
	if( cosom < static_cast<TReal>(0.0))
	{
		cosom = -cosom;
		end.x = -end.x;   
		end.y = -end.y;
		end.z = -end.z;
		end.w = -end.w;
	} 

	
	TReal sclp, sclq;
	if( (static_cast<TReal>(1.0) - cosom) > static_cast<TReal>(0.0001)) 
	{
		
		TReal omega, sinom;
		omega = acos( cosom); 
		sinom = sin( omega);
		sclp  = sin( (static_cast<TReal>(1.0) - pFactor) * omega) / sinom;
		sclq  = sin( pFactor * omega) / sinom;
	} else
	{
		
		sclp = static_cast<TReal>(1.0) - pFactor;
		sclq = pFactor;
	}

	pOut.x = sclp * pStart.x + sclq * end.x;
	pOut.y = sclp * pStart.y + sclq * end.y;
	pOut.z = sclp * pStart.z + sclq * end.z;
	pOut.w = sclp * pStart.w + sclq * end.w;
}


template<typename TReal>
inline aiQuaterniont<TReal>& aiQuaterniont<TReal>::Normalize()
{
	
	const TReal mag = sqrt(x*x + y*y + z*z + w*w);
	if (mag)
	{
		const TReal invMag = static_cast<TReal>(1.0)/mag;
		x *= invMag;
		y *= invMag;
		z *= invMag;
		w *= invMag;
	}
	return *this;
}


template<typename TReal>
inline aiQuaterniont<TReal> aiQuaterniont<TReal>::operator* (const aiQuaterniont& t) const
{
	return aiQuaterniont(w*t.w - x*t.x - y*t.y - z*t.z,
		w*t.x + x*t.w + y*t.z - z*t.y,
		w*t.y + y*t.w + z*t.x - x*t.z,
		w*t.z + z*t.w + x*t.y - y*t.x);
}


template<typename TReal>
inline aiQuaterniont<TReal>& aiQuaterniont<TReal>::Conjugate ()
{
	x = -x;
	y = -y;
	z = -z;
	return *this;
}


template<typename TReal>
inline aiVector3t<TReal> aiQuaterniont<TReal>::Rotate (const aiVector3t<TReal>& v)
{
	aiQuaterniont q2(0.f,v.x,v.y,v.z), q = *this, qinv = q;
	q.Conjugate();

	q = q*q2*qinv;
	return aiVector3t<TReal>(q.x,q.y,q.z);

}

#line 284 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\quaternion.inl"
#line 285 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\quaternion.inl"
#line 510 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix3x3.inl"



















































#line 1 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

#pragma once





 #pragma pack(push,8)
 #pragma warning(push,3)
 
 
 #pragma warning(disable: 4244 28309 28285)

namespace std {
		
const int _ISORT_MAX = 32;	

template<class _Iter1,
	class _Iter2,
	class _UIter1,
	class _UIter2> inline
	pair<_Iter1, _Iter2>
		_Rechecked_both(_Iter1 _Dest1, _Iter2 _Dest2, pair<_UIter1, _UIter2> _Src)
	{	
	return (pair<_Iter1, _Iter2>(
		_Rechecked(_Dest1, _Src.first),
		_Rechecked(_Dest2, _Src.second)
		));
	}

 
template<class _Iter1,
	class _Iter2> inline
	pair<decltype(_Unchecked(::std:: declval<_Iter1>())), decltype(_Unchecked(::std:: declval<_Iter2>()))>
		_Unchecked_both(pair<_Iter1, _Iter2> _Src)
	{	
	return (pair<decltype(_Unchecked(::std:: declval<_Iter1>())), decltype(_Unchecked(::std:: declval<_Iter2>()))>(
		_Unchecked(_Src.first),
		_Unchecked(_Src.second)));
	}

template<class _Iter1,
	class _Iter2> inline
	pair<decltype(_Unchecked(::std:: declval<_Iter1>())), _Iter2>
		_Unchecked_first(pair<_Iter1, _Iter2> _Src)
	{	
	return (pair<decltype(_Unchecked(::std:: declval<_Iter1>())), _Iter2>(
		_Unchecked(_Src.first),
		_Src.second));
	}

template<class _Iter1,
	class _Iter2> inline
	pair<_Iter1, decltype(_Unchecked(::std:: declval<_Iter2>()))>
		_Unchecked_second(pair<_Iter1, _Iter2> _Src)
	{	
	return (pair<_Iter1, decltype(_Unchecked(::std:: declval<_Iter2>()))>(
		_Src.first,
		_Unchecked(_Src.second)));
	}
 #line 62 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _Fn1> inline
	void _For_each_unchecked(_InIt _First, _InIt _Last, _Fn1& _Func)
	{	
	for (; _First != _Last; ++_First)
		_Func(*_First);
	}

template<class _InIt,
	class _Fn1> inline
	_Fn1 for_each(_InIt _First, _InIt _Last, _Fn1 _Func)
	{	
	_Debug_range_ptr(_First, _Last, _Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 76);
	_For_each_unchecked(_Unchecked(_First), _Unchecked(_Last), _Func);
	return (_Func);
	}

		
template<class _InIt,
	class _Pr> inline
	_InIt _Find_if_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			break;
	return (_First);
	}

template<class _InIt,
	class _Pr> inline
	_InIt find_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 96);
	return (_Rechecked(_First,
		_Find_if_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Adjacent_find_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
	{	
	if (_First != _Last)
		for (_FwdIt _Firstb; (void)(_Firstb = _First), ++_First != _Last; )
			if (_Pred(*_Firstb, *_First))
				return (_Firstb);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 117);
	_Debug_pointer_if(_First != _Last && ::std:: next(_First) != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 118);
	return (_Rechecked(_First,
		_Adjacent_find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt adjacent_find(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: adjacent_find(_First, _Last, equal_to<>()));
	}

		
template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		_Count_if_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
	{	
	typename iterator_traits<_InIt>::difference_type _Count = 0;

	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			++_Count;
	return (_Count);
	}

template<class _InIt,
	class _Pr> inline
	typename iterator_traits<_InIt>::difference_type
		count_if(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 149);
	return (_Count_if_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch_unchecked(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr& _Pred)
	{	
	for (; _First1 != _Last1 && _Pred(*_First1, *_First2); )
		{	
		++_First1;
		++_First2;
		}

	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	auto _Mismatch_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _Pr& _Pred, input_iterator_tag, input_iterator_tag)
			-> pair<_InIt1, decltype(_Unchecked_idl0(_First2))>
	{	
	return (_Mismatch_unchecked(_First1, _Last1,
		_Unchecked_idl0(_First2), _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, decltype(_Unchecked(::std:: declval<_InIt2>()))>
		_Mismatch_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr& _Pred, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_First2) + ((_Last1) - (_First1)));
	return (_Mismatch_unchecked(_First1, _Last1, _Unchecked(_First2), _Pred));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr& _Pred)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 199);
	_Debug_pointer_if(_First1 != _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 200);
	return (_Rechecked_both(_First1, _First2,
		_Mismatch_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
			_First2, _Pred, _Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>())));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "mismatch" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
	return (_Mismatch_no_deprecate(_First1, _Last1, _First2, _Pred));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _Pr,
	class = enable_if_t<!is_same<_InTy *, _Pr>::value>> inline
	pair<_InIt1, _InTy *>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InTy (&_First2)[_InSize], _Pr _Pred)
	{	
	return (_Unchecked_second(_Mismatch_no_deprecate(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Pred)));
	}
 #line 231 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2)
	{	
	return (::std:: mismatch(_First1, _Last1, _First2,
		equal_to<>()));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize> inline
	pair<_InIt1, _InTy *>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InTy (&_First2)[_InSize])
	{	
	return (::std:: mismatch(_First1, _Last1, _First2,
		equal_to<>()));
	}
 #line 255 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		_Mismatch_unchecked(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2
		&& _Pred(*_First1, *_First2); )
		{	
		++_First1;
		++_First2;
		}

	return (pair<_InIt1, _InIt2>(_First1, _First2));
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 281);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 282);
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 283);
	return (_Rechecked_both(_First1, _First2,
		_Mismatch_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred)));
	}

		
template<class _InIt1,
	class _InIt2> inline
	pair<_InIt1, _InIt2>
		mismatch(_InIt1 _First1, _InIt1 _Last1,
			_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: mismatch(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _InIt,
	class _Pr> inline
	bool _All_of_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool all_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 315);
	return (_All_of_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt,
	class _Pr> inline
	bool _Any_of_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (true);
	return (false);
	}

template<class _InIt,
	class _Pr> inline
	bool any_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 334);
	return (_Any_of_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt,
	class _Pr> inline
	bool _None_of_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool none_of(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 353);
	return (_None_of_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _InIt,
	class _Pr> inline
	_InIt _Find_if_not_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;
	return (_First);
	}

template<class _InIt,
	class _Pr> inline
	_InIt find_if_not(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 372);
	return (_Rechecked(_First,
		_Find_if_not_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 387);
			*_Dest++ = *_First;
			}

	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Copy_if_no_deprecate(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr& _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 400);
	return (_Rechecked(_Dest,
		_Copy_if_unchecked(_Unchecked(_First), _Unchecked(_Last),
		_Unchecked_idl0(_Dest), _Pred)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt copy_if(_InIt _First, _InIt _Last, _OutIt _Dest,
		_Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "copy_if" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Copy_if_no_deprecate(_First, _Last, _Dest, _Pred));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *copy_if(_InIt _First, _InIt _Last, _OutTy (&_Dest)[_OutSize],
		_Pr _Pred)
	{	
	return (_Unchecked(
		_Copy_if_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 429 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy_unchecked(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			{	
			_Debug_pointer(_Dest1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 442);
			*_Dest1++ = *_First;
			}
		else
			{	
			_Debug_pointer(_Dest2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 447);
			*_Dest2++ = *_First;
			}

	return (pair<_OutIt1, _OutIt2>(_Dest1, _Dest2));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		_Partition_copy_no_deprecate(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr& _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 462);
	return (_Rechecked_both(_Dest1, _Dest2,
		_Partition_copy_unchecked(_Unchecked(_First), _Unchecked(_Last),
		_Unchecked_idl0(_Dest1), _Unchecked_idl0(_Dest2), _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutIt1, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutIt2 _Dest2, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "partition_copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } };
	(_Unchecked_iterators::_Deprecate(_Is_checked(_Dest1)));
	(_Unchecked_iterators::_Deprecate(_Is_checked(_Dest2)));
	return (_Partition_copy_no_deprecate(_First, _Last, _Dest1, _Dest2, _Pred));
	}

 
template<class _InIt,
	class _OutTy1,
	size_t _OutSize1,
	class _OutIt2,
	class _Pr> inline
	pair<_OutTy1 *, _OutIt2>
		partition_copy(_InIt _First, _InIt _Last,
			_OutTy1 (&_Dest1)[_OutSize1], _OutIt2 _Dest2, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "partition_copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest2)));
	return (_Unchecked_first(
		_Partition_copy_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy1, _OutSize1>(_Dest1), _Dest2, _Pred)));
	}

template<class _InIt,
	class _OutIt1,
	class _OutTy2,
	size_t _OutSize2,
	class _Pr> inline
	pair<_OutIt1, _OutTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_OutIt1 _Dest1, _OutTy2 (&_Dest2)[_OutSize2], _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "partition_copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest1)));
	return (_Unchecked_second(
		_Partition_copy_no_deprecate(_First, _Last,
			_Dest1, _Array_iterator<_OutTy2, _OutSize2>(_Dest2), _Pred)));
	}

template<class _InIt,
	class _OutTy1,
	size_t _OutSize1,
	class _OutTy2,
	size_t _OutSize2,
	class _Pr> inline
	pair<_OutTy1 *, _OutTy2 *>
		partition_copy(_InIt _First, _InIt _Last,
			_OutTy1 (&_Dest1)[_OutSize1], _OutTy2 (&_Dest2)[_OutSize2],
			_Pr _Pred)
	{	
	return (_Unchecked_both(
		_Partition_copy_no_deprecate(_First, _Last,
				_Array_iterator<_OutTy1, _OutSize1>(_Dest1),
				_Array_iterator<_OutTy2, _OutSize2>(_Dest2), _Pred)));
	}
 #line 530 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _Pr> inline
	bool _Is_partitioned_unchecked(_InIt _First, _InIt _Last, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			break;	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			return (false);	
	return (true);
	}

template<class _InIt,
	class _Pr> inline
	bool is_partitioned(_InIt _First, _InIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 549);
	return (_Is_partitioned_unchecked(_Unchecked(_First), _Unchecked(_Last),
		_Pred));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Partition_point_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
	{	
	_Iter_diff_t<_FwdIt> _Count = ::std:: distance(_First, _Last);
	while (0 < _Count)
		{	
		_Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Pred(*_Mid))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}

	return (_First);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition_point(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 582);
	return (_Rechecked(_First,
		_Partition_point_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Search_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
		forward_iterator_tag, forward_iterator_tag)
	{	
	for (; ; ++_First1)
		{	
		_FwdIt1 _Mid1 = _First1;
		for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
			if (_Mid2 == _Last2)
				return (_First1);
			else if (_Mid1 == _Last1)
				return (_Last1);
			else if (!_Pred(*_Mid1, *_Mid2))
				break;
		}
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Search_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	_Iter_diff_t<_FwdIt1> _Count1 = _Last1 - _First1;
	_Iter_diff_t<_FwdIt2> _Count2 = _Last2 - _First2;

	for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
		{	
		_FwdIt1 _Mid1 = _First1;
		for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1, (void)++_Mid2)
			if (_Mid2 == _Last2)
				return (_First1);
			else if (!_Pred(*_Mid1, *_Mid2))
				break;
		}

	return (_Last1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 637);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 638);
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 639);
	return (_Rechecked(_First1,
		_Search_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred,
			_Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>())));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 search(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: search(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt _Search_n_unchecked(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr& _Pred, forward_iterator_tag)
	{	
	if (_Count <= 0)
		return (_First);

	for (; _First != _Last; ++_First)
		if (_Pred(*_First, _Val))
			{	
			_FwdIt _Mid = _First;

			for (_Diff _Count1 = _Count; ; )
				if (--_Count1 == 0)
					return (_First);	
				else if (++_Mid == _Last)
					return (_Last);	
				else if (!_Pred(*_Mid, _Val))
					{	
					break;
					}

			_First = _Mid;	
			}

	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt _Search_n_unchecked(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr& _Pred, random_access_iterator_tag)
	{	
	if (_Count <= 0)
		return (_First);

	_FwdIt _Oldfirst = _First;
	for (_Diff _Inc = 0; _Count <= _Last - _Oldfirst; )
		{	
		_First = _Oldfirst + _Inc;
		if (_Pred(*_First, _Val))
			{	
			_Diff _Count1 = _Count;
			_FwdIt _Mid = _First;

			for (; _Oldfirst != _First && _Pred(_First[-1], _Val);
				--_First)
				--_Count1;	

			if (_Count1 <= _Last - _Mid)
				for (; ; )
					{	
					if (--_Count1 == 0)
						return (_First);	
					else if (!_Pred(*++_Mid, _Val))
						{	
						break;
						}
					}
			_Oldfirst = ++_Mid;	
			_Inc = 0;
			}
		else
			{	
			_Oldfirst = _First + 1;
			_Inc = _Count - 1;
			}
		}

	return (_Last);
	}

template<class _FwdIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	_FwdIt search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 741);
	return (_Rechecked(_First,
		_Search_n_unchecked(_Unchecked(_First), _Unchecked(_Last), _Count, _Val,
			_Pred, _Iter_cat_t<_FwdIt>())));
	}

		
template<class _FwdIt,
	class _Diff,
	class _Ty> inline
	_FwdIt search_n(_FwdIt _First, _FwdIt _Last,
		_Diff _Count, const _Ty& _Val)
	{	
	return (::std:: search_n(_First, _Last, _Count, _Val,
		equal_to<>()));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_end_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred)
	{	
	_Iter_diff_t<_FwdIt1> _Count1 = ::std:: distance(_First1, _Last1);
	_Iter_diff_t<_FwdIt2> _Count2 = ::std:: distance(_First2, _Last2);
	_FwdIt1 _Ans = _Last1;

	if (0 < _Count2)
		{	
		_Debug_pointer_if(_Count2 <= _Count1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 771);
		for (; _Count2 <= _Count1; ++_First1, (void)--_Count1)
			{	
			_FwdIt1 _Mid1 = _First1;
			for (_FwdIt2 _Mid2 = _First2; ; ++_Mid1)
				if (!_Pred(*_Mid1, *_Mid2))
					break;
				else if (++_Mid2 == _Last2)
					{	
					_Ans = _First1;
					break;
					}
			}
		}

	return (_Ans);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 795);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 796);
	return (_Rechecked(_First1,
		_Find_end_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred)));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_end(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: find_end(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 _Find_first_of_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr& _Pred)
	{	
	for (; _First1 != _Last1; ++_First1)
		for (_FwdIt2 _Mid2 = _First2; _Mid2 != _Last2; ++_Mid2)
			if (_Pred(*_First1, *_Mid2))
				return (_First1);
	return (_First1);
	}

template<class _FwdIt1,
	class _FwdIt2,
	class _Pr> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 832);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 833);
	_Debug_pointer_if(_First1 != _Last1 && _First2 != _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 834);
	return (_Rechecked(_First1,
		_Find_first_of_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred)));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt1 find_first_of(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _First2, _FwdIt2 _Last2)
	{	
	return (::std:: find_first_of(_First1, _Last1, _First2, _Last2,
		equal_to<>()));
	}

		
template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_Dest)
		::std:: iter_swap(_First1, _Dest);
	return (_Dest);
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges1(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest,
		forward_iterator_tag, forward_iterator_tag)
	{	
	return (_Rechecked(_Dest,
		_Swap_ranges_unchecked(_First1, _Last1, _Unchecked_idl0(_Dest))));
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 _Swap_ranges1(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last1) - (_First1)));
	return (_Rechecked(_Dest,
		_Swap_ranges_unchecked(_First1, _Last1, _Unchecked(_Dest))));
	}

template<class _FwdIt1,
	class _FwdIt2> inline
	_FwdIt2 swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_FwdIt2 _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "swap_ranges" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range_ptr(_First1, _Last1, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 888);
	return (_Swap_ranges1(_Unchecked(_First1), _Unchecked(_Last1),
		_Dest, _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>()));
	}

 
template<class _FwdIt1,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *swap_ranges(_FwdIt1 _First1, _FwdIt1 _Last1,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: swap_ranges(_First1, _Last1,
		_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 905 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1& _Func)
	{	
	for (; _First != _Last; ++_First, (void)++_Dest)
		*_Dest = _Func(*_First);
	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1& _Func,
		input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Transform_unchecked(_First, _Last, _Unchecked_idl0(_Dest), _Func)));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1& _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Transform_unchecked(_First, _Last, _Unchecked(_Dest), _Func)));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt _Transform_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1& _Func)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 947);
	_Debug_pointer_if(_First != _Last, _Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 948);
	return (_Transform_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Func, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
	}

template<class _InIt,
	class _OutIt,
	class _Fn1> inline
	_OutIt transform(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Fn1 _Func)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "transform" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Transform_no_deprecate(_First, _Last, _Dest, _Func));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Fn1> inline
	_OutTy *transform(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Fn1 _Func)
	{	
	return (_Unchecked(
		_Transform_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}
 #line 976 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2& _Func)
	{	
	for (; _First1 != _Last1; ++_First1, (void)++_First2, ++_Dest)
		*_Dest = _Func(*_First1, *_First2);
	return (_Dest);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform_no_deprecate2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2& _Func,
		input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Transform_unchecked(_First1, _Last1, _First2, _Unchecked_idl0(_Dest), _Func)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform_no_deprecate2(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2& _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last1) - (_First1)));
	return (_Rechecked(_Dest,
		_Transform_unchecked(_First1, _Last1, _First2, _Unchecked(_Dest), _Func)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2& _Func,
		input_iterator_tag, input_iterator_tag)
	{	
	return (_Transform_no_deprecate2(_First1, _Last1,
		_Unchecked_idl0(_First2), _Dest, _Func,
		_Iter_cat_t<_InIt1>(), _Iter_cat_t<_OutIt>()));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2& _Func,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_First2) + ((_Last1) - (_First1)));
	return (_Transform_no_deprecate2(_First1, _Last1,
		_Unchecked(_First2), _Dest, _Func,
		_Iter_cat_t<_InIt1>(), _Iter_cat_t<_OutIt>()));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt _Transform_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2& _Func)
	{	
	_Debug_range_ptr(_First1, _Last1, _First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1049);
	_Debug_pointer_if(_First1 != _Last1, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1050);
	_Debug_pointer_if(_First1 != _Last1, _Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1051);
	return (_Transform_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
		_First2, _Dest, _Func,
		_Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>()));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutIt _Dest, _Fn2 _Func)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "transform" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } };
	(_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
	(_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Transform_no_deprecate(_First1, _Last1, _First2, _Dest, _Func));
	}

 
template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _OutIt,
	class _Fn2> inline
	_OutIt transform(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _OutIt _Dest, _Fn2 _Func)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "transform" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Transform_no_deprecate(_First1, _Last1,
		_Array_iterator<_InTy, _InSize>(_First2), _Dest, _Func));
	}

template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Fn2> inline
	_OutTy *transform(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _OutTy (&_Dest)[_OutSize], _Fn2 _Func)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "transform" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_First2)));
	return (_Unchecked(
		_Transform_no_deprecate(_First1, _Last1,
			_First2, _Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}

template<class _InIt1,
	class _InTy,
	size_t _InSize,
	class _OutTy,
	size_t _OutSize,
	class _Fn2> inline
	_OutTy *transform(_InIt1 _First1, _InIt1 _Last1,
		_InTy (&_First2)[_InSize], _OutTy (&_Dest)[_OutSize], _Fn2 _Func)
	{	
	return (_Unchecked(
		_Transform_no_deprecate(_First1, _Last1,
			_Array_iterator<_InTy, _InSize>(_First2),
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Func)));
	}
 #line 1113 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Ty> inline
	void _Replace_unchecked(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	for (; _First != _Last; ++_First)
		if (*_First == _Oldval)
			*_First = _Newval;
	}

template<class _FwdIt,
	class _Ty> inline
	void replace(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Oldval, const _Ty& _Newval)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1130);
	_Replace_unchecked(_Unchecked(_First), _Unchecked(_Last),
		_Oldval, _Newval);
	}

		
template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void _Replace_if_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		if (_Pred(*_First))
			*_First = _Val;
	}

template<class _FwdIt,
	class _Pr,
	class _Ty> inline
	void replace_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred, const _Ty& _Val)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1151);
	_Replace_if_unchecked(_Unchecked(_First), _Unchecked(_Last),
		_Pred, _Val);
	}

		
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	
	for (; _First != _Last; ++_First, (void)++_Dest)
		*_Dest = *_First == _Oldval ? _Newval : *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Replace_copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest),
		_Oldval, _Newval)));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Replace_copy1(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Replace_copy_unchecked(_First, _Last, _Unchecked(_Dest),
		_Oldval, _Newval)));
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt replace_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Oldval, const _Ty& _Newval)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "replace_copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1200);
	return (_Replace_copy1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Oldval, _Newval,
		_Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Ty> inline
	_OutTy *replace_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], const _Ty& _Oldval, const _Ty& _Newval)
	{	
	return (_Unchecked(
		::std:: replace_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Oldval, _Newval)));
	}
 #line 1219 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr& _Pred, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First, (void)++_Dest)
		*_Dest = _Pred(*_First) ? _Val : *_First;
	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr& _Pred, const _Ty& _Val,
		input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Replace_copy_if_unchecked(_First, _Last, _Unchecked_idl0(_Dest), _Pred, _Val)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if_no_deprecate1(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr& _Pred, const _Ty& _Val,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Replace_copy_if_unchecked(_First, _Last, _Unchecked(_Dest), _Pred, _Val)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt _Replace_copy_if_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr& _Pred, const _Ty& _Val)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1265);
	_Debug_pointer_if(_First != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1266);
	return (_Replace_copy_if_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Pred, _Val,
		_Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
	}

template<class _InIt,
	class _OutIt,
	class _Pr,
	class _Ty> inline
	_OutIt replace_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred, const _Ty& _Val)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "replace_copy_if" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Replace_copy_if_no_deprecate(_First, _Last, _Dest, _Pred, _Val));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr,
	class _Ty> inline
	_OutTy *replace_copy_if(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred, const _Ty& _Val)
	{	
	return (_Unchecked(
		_Replace_copy_if_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred, _Val)));
	}
 #line 1297 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Fn0> inline
	void _Generate_unchecked(_FwdIt _First, _FwdIt _Last, _Fn0& _Func)
	{	
	for (; _First != _Last; ++_First)
		*_First = _Func();
	}

template<class _FwdIt,
	class _Fn0> inline
	void generate(_FwdIt _First, _FwdIt _Last, _Fn0 _Func)
	{	
	_Debug_range_ptr(_First, _Last, _Func, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1311);
	_Generate_unchecked(_Unchecked(_First), _Unchecked(_Last), _Func);
	}

		
template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt _Generate_n_unchecked(_OutIt _Dest, _Diff _Count, _Fn0& _Func)
	{	
	for (; 0 < _Count; --_Count, (void)++_Dest)
		*_Dest = _Func();
	return (_Dest);
	}

template<class _OutIt,
	class _Diff,
	class _Fn0> inline
	_OutIt generate_n(_OutIt _Dest, _Diff _Count, _Fn0 _Func)
	{	
	return (_Rechecked(_Dest,
		_Generate_n_unchecked(_Unchecked_n(_Dest, _Count), _Count, _Func)));
	}

 
template<class _OutTy,
	size_t _OutSize,
	class _Diff,
	class _Fn0> inline
	_OutTy *generate_n(_OutTy (&_Dest)[_OutSize], _Diff _Count, _Fn0 _Func)
	{	
	_Debug_array_size2(_Dest, _Count, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1342);
	return (_Generate_n_unchecked(_Dest, _Count, _Func));
	}
 #line 1346 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt _Remove_copy_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	for (; _First != _Last; ++_First)
		if (!(*_First == _Val))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1357);
			*_Dest++ = *_First;
			}

	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Ty> inline
	_OutIt remove_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, const _Ty& _Val)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "remove_copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1371);
	return (_Rechecked(_Dest,
		_Remove_copy_unchecked(_Unchecked(_First), _Unchecked(_Last),
		_Unchecked_idl0(_Dest), _Val)));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Ty> inline
	_OutTy *remove_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], const _Ty& _Val)
	{	
	return (_Unchecked(
		::std:: remove_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Val)));
	}
 #line 1390 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr& _Pred)
	{	
	for (; _First != _Last; ++_First)
		if (!_Pred(*_First))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1401);
			*_Dest++ = *_First;
			}

	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Remove_copy_if_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr& _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1414);
	return (_Rechecked(_Dest,
		_Remove_copy_if_unchecked(_Unchecked(_First), _Unchecked(_Last),
		_Unchecked_idl0(_Dest), _Pred)));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt remove_copy_if(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "remove_copy_if" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Remove_copy_if_no_deprecate(_First, _Last, _Dest, _Pred));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *remove_copy_if(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		_Remove_copy_if_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 1443 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Ty> inline
	_FwdIt _Remove_unchecked(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_First = _Find_unchecked(_First, _Last, _Val);
	_FwdIt _Next = _First;
	if (_First != _Last)
		{
		for (++_First; _First != _Last; ++_First)
			if (!(*_First == _Val))
				*_Next++ = ::std:: move(*_First);
		}

	return (_Next);
	}

template<class _FwdIt,
	class _Ty> inline
	_FwdIt remove(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1465);
	return (_Rechecked(_First,
		_Remove_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Remove_if_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
	{	
	_First = _Find_if_unchecked(_First, _Last, _Pred);
	_FwdIt _Next = _First;
	if (_First != _Last)
		{
		for (++_First; _First != _Last; ++_First)
		if (!_Pred(*_First))
			*_Next++ = ::std:: move(*_First);
		}

	return (_Next);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt remove_if(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1491);
	return (_Rechecked(_First,
		_Remove_if_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Unique_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
	{	
	if (_First != _Last)
		for (_FwdIt _Firstb; (void)(_Firstb = _First), ++_First != _Last; )
			if (_Pred(*_Firstb, *_First))
				{	
				for (; ++_First != _Last; )
					if (!_Pred(*_Firstb, *_First))
						*++_Firstb = ::std:: move(*_First);
				return (++_Firstb);
				}

	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1518);
	_Debug_pointer_if(_First != _Last && ::std:: next(_First) != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1519);
	return (_Rechecked(_First,
		_Unique_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt unique(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: unique(_First, _Last, equal_to<>()));
	}

		
template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy_unchecked(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr& _Pred, input_iterator_tag)
	{	
	if (_First != _Last)
		{
		_Iter_value_t<_InIt> _Val = *_First;

		for (*_Dest++ = _Val; ++_First != _Last; )
			if (!_Pred(_Val, *_First))
				{	
				_Val = *_First;
				*_Dest++ = _Val;
				}
		}

	return (_Dest);
	}

template<class _FwdIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy_unchecked(_FwdIt _First, _FwdIt _Last,
		_OutIt _Dest, _Pr& _Pred, forward_iterator_tag)
	{	
	if (_First != _Last)
		{
		_FwdIt _Firstb = _First;

		for (*_Dest++ = *_Firstb; ++_First != _Last; )
			if (!_Pred(*_Firstb, *_First))
				{	
				_Firstb = _First;
				*_Dest++ = *_Firstb;
				}
		}

	return (_Dest);
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt _Unique_copy_no_deprecate(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr& _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1580);
	_Debug_pointer_if(_First != _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1581);
	return (_Rechecked(_Dest,
		_Unique_copy_unchecked(_Unchecked(_First), _Unchecked(_Last),
			_Unchecked_idl0(_Dest), _Pred, _Iter_cat_t<_InIt>())));
	}

template<class _InIt,
	class _OutIt,
	class _Pr> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last,
		_OutIt _Dest, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "unique_copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Unique_copy_no_deprecate(_First, _Last, _Dest, _Pred));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *unique_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		_Unique_copy_no_deprecate(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 1610 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt,
	class _OutIt> inline
	_OutIt unique_copy(_InIt _First, _InIt _Last, _OutIt _Dest)
	{	
	return (::std:: unique_copy(_First, _Last, _Dest,
		equal_to<>()));
	}

 
template<class _InIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *unique_copy(_InIt _First, _InIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: unique_copy(_First, _Last, _Dest,
		equal_to<>()));
	}
 #line 1631 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy_unchecked(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	
	for (; _First != _Last; ++_Dest)
		*_Dest = *--_Last;
	return (_Dest);
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy1(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		bidirectional_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Reverse_copy_unchecked(_First, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt _Reverse_copy1(_BidIt _First, _BidIt _Last,
		_OutIt _Dest,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Reverse_copy_unchecked(_First, _Last, _Unchecked(_Dest))));
	}

template<class _BidIt,
	class _OutIt> inline
	_OutIt reverse_copy(_BidIt _First, _BidIt _Last,
		_OutIt _Dest)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "reverse_copy" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	_Debug_range_ptr(_First, _Last, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1670);
	return (_Reverse_copy1(_Unchecked(_First), _Unchecked(_Last),
		_Dest, _Iter_cat_t<_BidIt>(), _Iter_cat_t<_OutIt>()));
	}

 
template<class _BidIt,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *reverse_copy(_BidIt _First, _BidIt _Last,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (_Unchecked(
		::std:: reverse_copy(_First, _Last,
			_Array_iterator<_OutTy, _OutSize>(_Dest))));
	}
 #line 1687 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _OutIt> inline
	_OutIt _Rotate_copy_unchecked(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		_OutIt _Dest)
	{	
	_Dest = _Copy_unchecked(_Mid, _Last, _Dest);
	return (_Copy_unchecked(_First, _Mid, _Dest));
	}

template<class _FwdIt,
	class _OutIt> inline
	_OutIt _Rotate_copy1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		_OutIt _Dest, forward_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Rotate_copy_unchecked(_First, _Mid, _Last, _Unchecked_idl0(_Dest))));
	}

template<class _FwdIt,
	class _OutIt> inline
	_OutIt _Rotate_copy1(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		_OutIt _Dest, random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last) - (_First)));
	return (_Rechecked(_Dest,
		_Rotate_copy_unchecked(_First, _Mid, _Last, _Unchecked(_Dest))));
	}

template<class _FwdIt,
	class _OutIt> inline
	_OutIt rotate_copy(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
		_OutIt _Dest)
	{	
	_Debug_range(_First, _Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1722);
	_Debug_range(_Mid, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1723);
	return (_Rotate_copy1(_Unchecked(_First), _Unchecked(_Mid),
		_Unchecked(_Last), _Dest, _Iter_cat_t<_FwdIt>(), _Iter_cat_t<_OutIt>()));
	}

		
template<class _RanIt,
	class _Fn1> inline
	void _Random_shuffle_unchecked(_RanIt _First, _RanIt _Last, _Fn1& _Func)
	{	
	if (_Last - _First < 2)
		return;

	_RanIt _Next = _First;
	for (_Iter_diff_t<_RanIt> _Index = 2; ++_Next != _Last; ++_Index)
		{	
		_Iter_diff_t<_RanIt> _Off = _Func(_Index);

 
		if (_Off < 0 || _Index <= _Off)
			{	
			_Debug_message(L"random value out of range", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1744);
			{ (void)( (!!(("Standard C++ Libraries Out of Range" && 0))) || (1 != _CrtDbgReportW(2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1745, 0, L"%ls", L"\"Standard C++ Libraries Out of Range\" && 0")) || (__debugbreak(), 0) ); ::_invalid_parameter(L"\"out of range\"", __LPREFIX( __FUNCTION__), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1745, 0); };
			}

 

#line 1751 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		::std:: iter_swap(_Next, _First + _Off);
		}
	}

template<class _RanIt,
	class _Fn1> inline
	void _Random_shuffle1(_RanIt _First, _RanIt _Last, _Fn1& _Func)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1760);
	_Random_shuffle_unchecked(_Unchecked(_First), _Unchecked(_Last), _Func);
	}

template<class _RanIt,
	class _Urng> inline
	void shuffle(_RanIt _First, _RanIt _Last, _Urng&& _Func)
	{	
	typedef typename iterator_traits<_RanIt>::difference_type _Diff;
	typedef typename remove_reference<_Urng>::type _Urng0;
	_Rng_from_urng<_Diff, _Urng0> _Rng(_Func);
	_Random_shuffle1(_First, _Last, _Rng);
	}

 
		
template<class _RanIt,
	class _Fn1> inline
	void random_shuffle(_RanIt _First, _RanIt _Last, _Fn1&& _Func)
	{	
	_Random_shuffle1(_First, _Last, _Func);
	}

	
struct _Rand_urng_from_func
	{	
	typedef unsigned int result_type;

	static result_type (min)()
		{	
		return (0);
		}

	static result_type (max)()
		{	
		return (0x7fff);
		}

	result_type operator()()
		{	
		return (:: rand());
		}
	};

		
template<class _RanIt> inline
	void random_shuffle(_RanIt _First, _RanIt _Last)
	{	
	_Rand_urng_from_func _Func;
	::std:: shuffle(_First, _Last, _Func);
	}
 #line 1812 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Partition_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred,
		forward_iterator_tag)
	{	
	while (_First != _Last && _Pred(*_First))
		++_First;	

	if (_First == _Last)
		return (_First);	

	for (_FwdIt _Next = ::std:: next(_First); _Next != _Last; ++_Next)
		if (_Pred(*_Next))
			::std:: iter_swap(_First++, _Next);	

	return (_First);
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt _Partition_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred,
		bidirectional_iterator_tag)
	{	
	for (; ; ++_First)
		{	
		for (; _First != _Last && _Pred(*_First); ++_First)
			;	
		if (_First == _Last)
			break;	

		for (; _First != --_Last && !_Pred(*_Last); )
			;	
		if (_First == _Last)
			break;	

		::std:: iter_swap(_First, _Last);	
		}

	return (_First);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt partition(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1859);
	return (_Rechecked(_First,
		_Partition_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred,
			_Iter_cat_t<_FwdIt>())));
	}

		
template<class _BidIt,
	class _Diff,
	class _Ty> inline
	_BidIt _Buffered_rotate_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2, _Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count1 == 0 || _Count2 == 0)
		{	
		::std:: advance(_First, _Count2);
		return (_First);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		_Move_unchecked(_First, _Mid, _Tempbuf._Init());
		_Move_unchecked(_Mid, _Last, _First);
		return (_Move_backward_unchecked(_Tempbuf._First(), _Tempbuf._Last(),
			_Last));
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		_Move_unchecked(_Mid, _Last, _Tempbuf._Init());
		_Move_backward_unchecked(_First, _Mid, _Last);
		return (_Move_unchecked(_Tempbuf._First(), _Tempbuf._Last(), _First));
		}
	else
		{	
		return (_Rotate_unchecked(_First, _Mid, _Last));
		}
	}

template<class _BidIt,
	class _Pr,
	class _Diff,
	class _Ty> inline
	_BidIt _Stable_partition_unchecked1(_BidIt _First, _BidIt _Last, _Pr& _Pred,
		_Diff _Count, _Temp_iterator<_Ty>& _Tempbuf)
	{	
	if (_Count == 0)
		return (_First);
	else if (_Count == 1)
		return (_Pred(*_First) ? _Last : _First);
	else if (_Count <= _Tempbuf._Maxlen())
		{	
		_BidIt _Next = _First;
		for (_Tempbuf._Init(); _First != _Last; ++_First)
			if (_Pred(*_First))
				*_Next++ = ::std:: move(*_First);
			else
				*_Tempbuf++ = ::std:: move(*_First);

		_Move_unchecked(_Tempbuf._First(), _Tempbuf._Last(), _Next);	
		return (_Next);
		}
	else
		{	
		_BidIt _Mid = _First;
		::std:: advance(_Mid, _Count / 2);

		_BidIt _Left = _Stable_partition_unchecked1(_First, _Mid, _Pred,
			_Count / 2, _Tempbuf);	
		_BidIt _Right = _Stable_partition_unchecked1(_Mid, _Last, _Pred,
			_Count - _Count / 2, _Tempbuf);	

		_Diff _Count1 = ::std:: distance(_Left, _Mid);
		_Diff _Count2 = ::std:: distance(_Mid, _Right);

		return (_Buffered_rotate_unchecked(_Left, _Mid, _Right,
			_Count1, _Count2, _Tempbuf));	
		}
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt _Stable_partition_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
	{	
	if (_First == _Last)
		return (_First);
	_Iter_diff_t<_BidIt> _Count = ::std:: distance(_First, _Last);
	_Temp_iterator<_Iter_value_t<_BidIt>> _Tempbuf(_Count);
	return (_Stable_partition_unchecked1(_First, _Last, _Pred, _Count, _Tempbuf));
	}

template<class _BidIt,
	class _Pr> inline
	_BidIt stable_partition(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1952);
	return (_Rechecked(_First,
		_Stable_partition_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

 
		
template<class _RanIt,
	class _Pr> inline
	void _Debug_heap(_RanIt _First, _RanIt _Last, _Pr& _Pred)
	{	
	if (_First != _Last)
		for (_RanIt _Root = _First; ++_First != _Last; ++_Root)
			{	
			if (_Debug_lt_pred(_Pred, *_Root, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1966))
				_Debug_message(L"invalid heap", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1967);
			else if (++_First == _Last)
				break;
			else if (_Debug_lt_pred(_Pred, *_Root, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1970))
				_Debug_message(L"invalid heap", L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1971);
			}
	}

  


 

#line 1981 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Push_heap_by_index(_RanIt _First, _Diff _Hole,
		_Diff _Top, _Ty&& _Val, _Pr& _Pred)
	{	
	for (_Diff _Idx = (_Hole - 1) / 2;
		_Top < _Hole && _Debug_lt_pred(_Pred, *(_First + _Idx), _Val, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 1991);
		_Idx = (_Hole - 1) / 2)
		{	
		*(_First + _Hole) = ::std:: move(*(_First + _Idx));
		_Hole = _Idx;
		}

	*(_First + _Hole) = ::std:: move(_Val);	
	}

template<class _RanIt,
	class _Pr> inline
	void _Push_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
	{	
	typedef _Iter_diff_t<_RanIt> _Diff;
	_Diff _Count = _Last - _First;
	if (2 <= _Count)
		{
		_Iter_value_t<_RanIt> _Val = ::std:: move(*--_Last);
		_Push_heap_by_index(_First, --_Count, _Diff(0), ::std:: move(_Val), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void push_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2018);
	_Push_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void push_heap(_RanIt _First, _RanIt _Last)
	{	
	::std:: push_heap(_First, _Last, less<>());
	}

		
template<class _RanIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Pop_heap_hole_by_index(_RanIt _First, _Diff _Hole, _Diff _Bottom,
		_Ty&& _Val, _Pr& _Pred)
	{	
		
	const _Diff _Top = _Hole;
	_Diff _Idx = _Hole;

	
	
	const _Diff _Max_sequence_non_leaf = (_Bottom - 1) / 2;
	while (_Idx < _Max_sequence_non_leaf)
		{	
		_Idx = 2 * _Idx + 2;
		if (_Debug_lt_pred(_Pred, *(_First + _Idx), *(_First + (_Idx - 1)), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2047))
			--_Idx;
		*(_First + _Hole) = ::std:: move(*(_First + _Idx));
		_Hole = _Idx;
		}

	if (_Idx == _Max_sequence_non_leaf && _Bottom % 2 == 0)
		{	
		*(_First + _Hole) = ::std:: move(*(_First + (_Bottom - 1)));
		_Hole = _Bottom - 1;
		}

	_Push_heap_by_index(_First, _Hole, _Top, ::std:: move(_Val), _Pred);
	}

template<class _RanIt,
	class _Ty,
	class _Pr> inline
	void _Pop_heap_hole_unchecked(_RanIt _First, _RanIt _Last, _RanIt _Dest,
		_Ty&& _Val, _Pr& _Pred)
	{	
		
		
	*_Dest = ::std:: move(*_First);
	_Pop_heap_hole_by_index(_First, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Last - _First),
		::std:: move(_Val), _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void _Pop_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
	{	
	if (2 <= _Last - _First)
		{
		--_Last;
		_Iter_value_t<_RanIt> _Val = ::std:: move(*_Last);
		_Pop_heap_hole_unchecked(_First, _Last, _Last,
			::std:: move(_Val), _Pred);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void pop_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2092);
	_Debug_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	_Pop_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void pop_heap(_RanIt _First, _RanIt _Last)
	{	
	::std:: pop_heap(_First, _Last, less<>());
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Make_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
	{	
	_Iter_diff_t<_RanIt> _Bottom = _Last - _First;
	if (2 <= _Bottom)
		{
		for (_Iter_diff_t<_RanIt> _Hole = _Bottom / 2; 0 < _Hole; )
			{	
			--_Hole;
			_Iter_value_t<_RanIt> _Val = ::std:: move(*(_First + _Hole));
			_Pop_heap_hole_by_index(_First, _Hole, _Bottom,
				::std:: move(_Val), _Pred);
			}
		}
	}

template<class _RanIt,
	class _Pr> inline
	void make_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2126);
	_Make_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void make_heap(_RanIt _First, _RanIt _Last)
	{	
	::std:: make_heap(_First, _Last, less<>());
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Sort_heap_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
	{	
	for (; 2 <= _Last - _First; --_Last)
		_Pop_heap_unchecked(_First, _Last, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void sort_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2150);
	_Debug_pointer_if(2 <= _Last - _First, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2151);
	_Debug_heap(_Unchecked(_First), _Unchecked(_Last), _Pred);
	_Sort_heap_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void sort_heap(_RanIt _First, _RanIt _Last)
	{	
	::std:: sort_heap(_First, _Last, less<>());
	}

		
template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt _Lower_bound_unchecked(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr& _Pred)
	{	
	_Iter_diff_t<_FwdIt> _Count = ::std:: distance(_First, _Last);

	while (0 < _Count)
		{	
		_Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Pred(*_Mid, _Val))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}

	return (_First);
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2196);
	return (_Rechecked(_First,
		_Lower_bound_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred)));
	}

		
template<class _FwdIt,
	class _Ty> inline
	_FwdIt lower_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	return (::std:: lower_bound(_First, _Last, _Val, less<>()));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt _Upper_bound_unchecked(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr& _Pred)
	{	
	_Iter_diff_t<_FwdIt> _Count = ::std:: distance(_First, _Last);

	while (0 < _Count)
		{	
		_Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (!_Pred(_Val, *_Mid))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else
			_Count = _Count2;
		}

	return (_First);
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2242);
	return (_Rechecked(_First,
		_Upper_bound_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred)));
	}

		
template<class _FwdIt,
	class _Ty> inline
	_FwdIt upper_bound(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	return (::std:: upper_bound(_First, _Last, _Val, less<>()));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		_Equal_range_unchecked(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Pr& _Pred)
	{	
	_Iter_diff_t<_FwdIt> _Count = ::std:: distance(_First, _Last);

	while (0 < _Count)
		{	
		_Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
		_FwdIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Debug_lt_pred(_Pred, *_Mid, _Val, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2271))
			{	
			_First = ++_Mid;
			_Count -= _Count2 + 1;
			}
		else if (_Pred(_Val, *_Mid))
			_Count = _Count2;	
		else
			{	
			_FwdIt _First2 = _Lower_bound_unchecked(_First, _Mid, _Val, _Pred);
			::std:: advance(_First, _Count);
			_FwdIt _Last2 = _Upper_bound_unchecked(++_Mid, _First, _Val, _Pred);
			return (pair<_FwdIt, _FwdIt>(_First2, _Last2));
			}
		}

	return (pair<_FwdIt, _FwdIt>(_First, _First));	
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2297);
	return (_Rechecked_both(_First, _Last,
		_Equal_range_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val, _Pred)));
	}

		
template<class _FwdIt,
	class _Ty> inline
	pair<_FwdIt, _FwdIt>
		equal_range(_FwdIt _First, _FwdIt _Last,
			const _Ty& _Val)
	{	
	return (::std:: equal_range(_First, _Last, _Val, less<>()));
	}

		
template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	bool _Binary_search_unchecked(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr& _Pred)
	{	
	_First = _Lower_bound_unchecked(_First, _Last, _Val, _Pred);
	return (_First != _Last && !_Pred(_Val, *_First));
	}

template<class _FwdIt,
	class _Ty,
	class _Pr> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last,
		const _Ty& _Val, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2329);
	return (_Binary_search_unchecked(_Unchecked(_First), _Unchecked(_Last),
		_Val, _Pred));
	}

		
template<class _FwdIt,
	class _Ty> inline
	bool binary_search(_FwdIt _First, _FwdIt _Last, const _Ty& _Val)
	{	
	return (::std:: binary_search(_First, _Last, _Val, less<>()));
	}

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr& _Pred)
	{	
	if (_First1 != _Last1 && _First2 != _Last2)
		for (; ; )
			{	
			if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2354))
				{
				*_Dest++ = *_First2++;
				if (_First2 == _Last2)
					break;
				}
			else
				{
				*_Dest++ = *_First1++;
				if (_First1 == _Last1)
					break;
				}
			}

	_Dest = _Copy_unchecked(_First1, _Last1, _Dest);	
	return (_Copy_unchecked(_First2, _Last2, _Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr& _Pred, input_iterator_tag,
		input_iterator_tag, _Any_tag)
	{	
	return (_Rechecked(_Dest,
		_Merge_unchecked(_First1, _Last1, _First2, _Last2, _Unchecked_idl0(_Dest), _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr& _Pred, random_access_iterator_tag,
		random_access_iterator_tag, random_access_iterator_tag)
	{	
	static_cast<void>((_Dest) + ((_Last1 - _First1) + (_Last2 - _First2)));
	return (_Rechecked(_Dest,
		_Merge_unchecked(_First1, _Last1, _First2, _Last2, _Unchecked(_Dest), _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Merge_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr& _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2407);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2408);
	_Debug_pointer_if(_First1 != _Last1 || _First2 != _Last2, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2409);
	return (_Merge_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Dest, _Pred,
		_Iter_cat_t<_InIt1>(), _Iter_cat_t<_InIt2>(), _Iter_cat_t<_OutIt>()));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "merge" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Merge_no_deprecate(_First1, _Last1, _First2, _Last2, _Dest, _Pred));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		_Merge_no_deprecate(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 2444 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (::std:: merge(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *merge(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: merge(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}
 #line 2470 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _BidIt1,
	class _BidIt2,
	class _BidIt3,
	class _Pr> inline
	_BidIt3 _Buffered_merge_backward_unchecked(_BidIt1 _First1, _BidIt1 _Last1,
		_BidIt2 _First2, _BidIt2 _Last2, _BidIt3 _Dest, _Pr& _Pred,
		bool _In_place = false)
	{	
	if (_First1 != _Last1 && _First2 != _Last2)
		for (; ; )
			{	
			if (_Debug_lt_pred(_Pred, *--_Last2, *--_Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2483))
				{
				*--_Dest = ::std:: move(*_Last1);
				++_Last2;
				if (_First1 == _Last1)
					break;
				}
			else
				{
				*--_Dest = ::std:: move(*_Last2);
				++_Last1;
				if (_First2 == _Last2)
					break;
				}
			}

	_Dest = _Move_backward_unchecked(_First2, _Last2, _Dest);	
	if (!_In_place)
		_Dest = _Move_backward_unchecked(_First1, _Last1, _Dest);
	return (_Dest);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Buffered_merge_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr& _Pred, bool _In_place = false)
	{	
	if (_First1 != _Last1 && _First2 != _Last2)
		for (; ; )
			{	
			if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2516))
				{	
				*_Dest++ = ::std:: move(*_First2++);
				if (_First2 == _Last2)
					break;
				}
			else
				{	
				*_Dest++ = ::std:: move(*_First1++);
				if (_First1 == _Last1)
					break;
				}
			}

	_Dest = _Move_unchecked(_First1, _Last1, _Dest);	
	if (!_In_place)
		_Dest = _Move_unchecked(_First2, _Last2, _Dest);
	return (_Dest);
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last,
		_Diff _Count1, _Diff _Count2,
			_Temp_iterator<_Ty>& _Tempbuf, _Pr& _Pred)
	{	
	if (_Count1 == 0 || _Count2 == 0)
		;	
	else if (_Count1 + _Count2 == 2)
		{	
		if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2548))
			::std:: iter_swap(_First, _Mid);
		}
	else if (_Count1 <= _Count2 && _Count1 <= _Tempbuf._Maxlen())
		{	
		_Move_unchecked(_First, _Mid, _Tempbuf._Init());
		_Buffered_merge_unchecked(_Tempbuf._First(), _Tempbuf._Last(),
			_Mid, _Last, _First, _Pred, true);
		}
	else if (_Count2 <= _Tempbuf._Maxlen())
		{	
		_Move_unchecked(_Mid, _Last, _Tempbuf._Init());
		_Buffered_merge_backward_unchecked(_First, _Mid,
			_Tempbuf._First(), _Tempbuf._Last(), _Last, _Pred, true);
		}
	else
		{	
		_BidIt _Firstn, _Lastn;
		_Diff _Count1n, _Count2n;
		if (_Count2 < _Count1)
			{	
			_Count1n = _Count1 / 2;
			_Firstn = _First;
			::std:: advance(_Firstn, _Count1n);
			_Lastn = _Lower_bound_unchecked(_Mid, _Last, *_Firstn, _Pred);
			_Count2n = ::std:: distance(_Mid, _Lastn);
			}
		else
			{	
			_Count2n = _Count2 / 2;
			_Lastn = _Mid;
			::std:: advance(_Lastn, _Count2n);
			_Firstn = _Upper_bound_unchecked(_First, _Mid, *_Lastn, _Pred);
			_Count1n = ::std:: distance(_First, _Firstn);
			}
		_BidIt _Midn = _Buffered_rotate_unchecked(_Firstn, _Mid, _Lastn,
			_Count1 - _Count1n, _Count2n, _Tempbuf);	
		_Buffered_merge_unchecked(_First, _Firstn, _Midn,
			_Count1n, _Count2n, _Tempbuf, _Pred);	
		_Buffered_merge_unchecked(_Midn, _Lastn, _Last,
			_Count1 - _Count1n, _Count2 - _Count2n, _Tempbuf, _Pred);
		}
	}

template<class _BidIt,
	class _Pr> inline
	void _Inplace_merge_unchecked(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr& _Pred)
	{	
	if (_First != _Mid && _Mid != _Last)
		{
		_Iter_diff_t<_BidIt> _Count1 = ::std:: distance(_First, _Mid);
		_Iter_diff_t<_BidIt> _Count2 = ::std:: distance(_Mid, _Last);
		_Temp_iterator<_Iter_value_t<_BidIt>> _Tempbuf(_Count1 < _Count2 ? _Count1 : _Count2);
		_Buffered_merge_unchecked(_First, _Mid, _Last,
			_Count1, _Count2, _Tempbuf, _Pred);
		}
	}

template<class _BidIt,
	class _Pr> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_order(_First, _Mid, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2610);
	_Debug_order(_Mid, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2611);
	_Inplace_merge_unchecked(
		_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred);
	}

		
template<class _BidIt> inline
	void inplace_merge(_BidIt _First, _BidIt _Mid, _BidIt _Last)
	{	
	::std:: inplace_merge(_First, _Mid, _Last, less<>());
	}

		
template<class _BidIt,
	class _Pr> inline
	void _Insertion_sort_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
	{	
	if (_First != _Last)
		for (_BidIt _Next = _First; ++_Next != _Last; )
			{	
			_BidIt _Next1 = _Next;
			_Iter_value_t<_BidIt> _Val = ::std:: move(*_Next);

			if (_Debug_lt_pred(_Pred, _Val, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2634))
				{	
				_Move_backward_unchecked(_First, _Next, ++_Next1);
				*_First = ::std:: move(_Val);
				}
			else
				{	
				for (_BidIt _First1 = _Next1;
					_Debug_lt_pred(_Pred, _Val, *--_First1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2642);
					_Next1 = _First1)
					*_Next1 = ::std:: move(*_First1);	
				*_Next1 = ::std:: move(_Val);	
				}
			}
	}

template<class _RanIt,
	class _Pr> inline
	void _Med3_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr& _Pred)
	{	
	if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2654))
		::std:: iter_swap(_Mid, _First);
	if (_Debug_lt_pred(_Pred, *_Last, *_Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2656))
		{	
		::std:: iter_swap(_Last, _Mid);
		if (_Debug_lt_pred(_Pred, *_Mid, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2659))
			::std:: iter_swap(_Mid, _First);
		}
	}

template<class _RanIt,
	class _Pr> inline
	void _Guess_median_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr& _Pred)
	{	
	if (40 < _Last - _First)
		{	
		size_t _Step = (_Last - _First + 1) / 8;
		_Med3_unchecked(_First, _First + _Step, _First + 2 * _Step, _Pred);
		_Med3_unchecked(_Mid - _Step, _Mid, _Mid + _Step, _Pred);
		_Med3_unchecked(_Last - 2 * _Step, _Last - _Step, _Last, _Pred);
		_Med3_unchecked(_First + _Step, _Mid, _Last - _Step, _Pred);
		}
	else
		_Med3_unchecked(_First, _Mid, _Last, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	pair<_RanIt, _RanIt>
		_Partition_by_median_guess_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
	{	
	_RanIt _Mid = _First + (_Last - _First) / 2;
	_Guess_median_unchecked(_First, _Mid, _Last - 1, _Pred);
	_RanIt _Pfirst = _Mid;
	_RanIt _Plast = _Pfirst + 1;

	while (_First < _Pfirst
		&& !_Debug_lt_pred(_Pred, *(_Pfirst - 1), *_Pfirst, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2691)
		&& !_Pred(*_Pfirst, *(_Pfirst - 1)))
		--_Pfirst;
	while (_Plast < _Last
		&& !_Debug_lt_pred(_Pred, *_Plast, *_Pfirst, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2695)
		&& !_Pred(*_Pfirst, *_Plast))
		++_Plast;

	_RanIt _Gfirst = _Plast;
	_RanIt _Glast = _Pfirst;

	for (; ; )
		{	
		for (; _Gfirst < _Last; ++_Gfirst)
			if (_Debug_lt_pred(_Pred, *_Pfirst, *_Gfirst, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2705))
				;
			else if (_Pred(*_Gfirst, *_Pfirst))
				break;
			else if (_Plast++ != _Gfirst)
				::std:: iter_swap(_Plast - 1, _Gfirst);
		for (; _First < _Glast; --_Glast)
			if (_Debug_lt_pred(_Pred, *(_Glast - 1), *_Pfirst, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2712))
				;
			else if (_Pred(*_Pfirst, *(_Glast - 1)))
				break;
			else if (--_Pfirst != _Glast - 1)
				::std:: iter_swap(_Pfirst, _Glast - 1);
		if (_Glast == _First && _Gfirst == _Last)
			return (pair<_RanIt, _RanIt>(_Pfirst, _Plast));

		if (_Glast == _First)
			{	
			if (_Plast != _Gfirst)
				::std:: iter_swap(_Pfirst, _Plast);
			++_Plast;
			::std:: iter_swap(_Pfirst++, _Gfirst++);
			}
		else if (_Gfirst == _Last)
			{	
			if (--_Glast != --_Pfirst)
				::std:: iter_swap(_Glast, _Pfirst);
			::std:: iter_swap(_Pfirst, --_Plast);
			}
		else
			::std:: iter_swap(_Gfirst++, --_Glast);
		}
	}

template<class _RanIt,
	class _Diff,
	class _Pr> inline
	void _Sort_unchecked1(_RanIt _First, _RanIt _Last, _Diff _Ideal, _Pr& _Pred)
	{	
	_Diff _Count;
	while (_ISORT_MAX < (_Count = _Last - _First) && 0 < _Ideal)
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Partition_by_median_guess_unchecked(_First, _Last, _Pred);
		_Ideal /= 2, _Ideal += _Ideal / 2;	

		if (_Mid.first - _First < _Last - _Mid.second)
			{	
			_Sort_unchecked1(_First, _Mid.first, _Ideal, _Pred);
			_First = _Mid.second;
			}
		else
			{	
			_Sort_unchecked1(_Mid.second, _Last, _Ideal, _Pred);
			_Last = _Mid.first;
			}
		}

	if (_ISORT_MAX < _Count)
		{	
		_Make_heap_unchecked(_First, _Last, _Pred);
		_Sort_heap_unchecked(_First, _Last, _Pred);
		}
	else if (2 <= _Count)
		_Insertion_sort_unchecked(_First, _Last, _Pred);	
	}

template<class _RanIt,
	class _Pr> inline
	void _Sort_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
	{	
	_Sort_unchecked1(_First, _Last, _Last - _First, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void sort(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2783);
	_Sort_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void sort(_RanIt _First, _RanIt _Last)
	{	
	::std:: sort(_First, _Last, less<>());
	}

		
template<class _BidIt,
	class _OutIt,
	class _Diff,
	class _Pr> inline
	void _Chunked_merge_unchecked(_BidIt _First, _BidIt _Last, _OutIt _Dest,
		_Diff _Chunk, _Diff _Count, _Pr& _Pred)
	{	
	for (_Diff _Chunk2 = _Chunk * 2; _Chunk2 <= _Count; _Count -= _Chunk2)
		{	
		_BidIt _Mid1 = _First;
		::std:: advance(_Mid1, _Chunk);
		_BidIt _Mid2 = _Mid1;
		::std:: advance(_Mid2, _Chunk);

		_Dest = _Buffered_merge_unchecked(_First, _Mid1, _Mid1, _Mid2, _Dest, _Pred);
		_First = _Mid2;
		}

	if (_Count <= _Chunk)
		_Move_unchecked(_First, _Last, _Dest);	
	else
		{	
		_BidIt _Mid1 = _First;
		::std:: advance(_Mid1, _Chunk);

		_Buffered_merge_unchecked(_First, _Mid1, _Mid1, _Last, _Dest, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Buffered_merge_sort_unchecked(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr& _Pred)
	{	
	_BidIt _Mid = _First;
	for (_Diff _Nleft = _Count; _ISORT_MAX <= _Nleft; _Nleft -= _ISORT_MAX)
		{	
		_BidIt _Midn = _Mid;
		::std:: advance(_Midn, (int)_ISORT_MAX);

		_Insertion_sort_unchecked(_Mid, _Midn, _Pred);
		_Mid = _Midn;
		}
	_Insertion_sort_unchecked(_Mid, _Last, _Pred);	

	for (_Diff _Chunk = _ISORT_MAX; _Chunk < _Count; _Chunk *= 2)
		{	
		_Chunked_merge_unchecked(_First, _Last, _Tempbuf._Init(),
			_Chunk, _Count, _Pred);
		_Chunked_merge_unchecked(_Tempbuf._First(), _Tempbuf._Last(), _First,
			_Chunk *= 2, _Count, _Pred);
		}
	}

template<class _BidIt,
	class _Diff,
	class _Ty,
	class _Pr> inline
	void _Stable_sort_unchecked1(_BidIt _First, _BidIt _Last, _Diff _Count,
		_Temp_iterator<_Ty>& _Tempbuf, _Pr& _Pred)
	{	
	if (_Count <= _ISORT_MAX)
		_Insertion_sort_unchecked(_First, _Last, _Pred);	
	else
		{	
		_Diff _Count2 = (_Count + 1) / 2;
		_BidIt _Mid = _First;
		::std:: advance(_Mid, _Count2);

		if (_Count2 <= _Tempbuf._Maxlen())
			{	
			_Buffered_merge_sort_unchecked(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Buffered_merge_sort_unchecked(_Mid, _Last, _Count - _Count2,
				_Tempbuf, _Pred);
			}
		else
			{	
			_Stable_sort_unchecked1(_First, _Mid, _Count2, _Tempbuf, _Pred);
			_Stable_sort_unchecked1(_Mid, _Last, _Count - _Count2, _Tempbuf, _Pred);
			}

		_Buffered_merge_unchecked(_First, _Mid, _Last,
			_Count2, _Count - _Count2, _Tempbuf, _Pred);	
		}
	}

template<class _BidIt,
	class _Pr> inline
	void _Stable_sort_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
	{	
	if (_First != _Last)
		{
		_Iter_diff_t<_BidIt> _Count = ::std:: distance(_First, _Last);
		_Temp_iterator<_Iter_value_t<_BidIt>> _Tempbuf((_Count + 1) / 2);
		_Stable_sort_unchecked1(_First, _Last, _Count, _Tempbuf, _Pred);
		}
	}

template<class _BidIt,
	class _Pr> inline
	void stable_sort(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2899);
	_Stable_sort_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred);
	}

		
template<class _BidIt> inline
	void stable_sort(_BidIt _First, _BidIt _Last)
	{	
	::std:: stable_sort(_First, _Last, less<>());
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Partial_sort_unchecked(_RanIt _First, _RanIt _Mid, _RanIt _Last,
		_Pr& _Pred)
	{	
	if (_First == _Mid)
		return;	
	_Make_heap_unchecked(_First, _Mid, _Pred);
	for (_RanIt _Next = _Mid; _Next < _Last; ++_Next)
		if (_Debug_lt_pred(_Pred, *_Next, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2920))
			{	
			_Iter_value_t<_RanIt> _Val = ::std:: move(*_Next);
			_Pop_heap_hole_unchecked(_First, _Mid, _Next, ::std:: move(_Val), _Pred);
			}
	_Sort_heap_unchecked(_First, _Mid, _Pred);
	}

template<class _RanIt,
	class _Pr> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2932);
	_Debug_range(_Mid, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2933);
	_Debug_pointer_if(2 <= _Last - _First, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2934);
	_Partial_sort_unchecked(
		_Unchecked(_First), _Unchecked(_Mid), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void partial_sort(_RanIt _First, _RanIt _Mid, _RanIt _Last)
	{	
	::std:: partial_sort(_First, _Mid, _Last, less<>());
	}

		
template<class _InIt,
	class _RanIt,
	class _Pr> inline
	_RanIt _Partial_sort_copy_unchecked(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr& _Pred)
	{	
	_RanIt _Mid2 = _First2;
	if (_First1 != _Last1 && _First2 != _Last2)
		{
		for (; _First1 != _Last1 && _Mid2 != _Last2; ++_First1, (void)++_Mid2)
			*_Mid2 = *_First1;	
		_Make_heap_unchecked(_First2, _Mid2, _Pred);

		for (; _First1 != _Last1; ++_First1)
			if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2961))
				_Pop_heap_hole_by_index(_First2, _Iter_diff_t<_RanIt>(0), _Iter_diff_t<_RanIt>(_Mid2 - _First2),
					_Iter_value_t<_InIt>(*_First1), _Pred);	

		_Sort_heap_unchecked(_First2, _Mid2, _Pred);
		}

	return (_Mid2);
	}

template<class _InIt,
	class _RanIt,
	class _Pr> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2, _Pr _Pred)
	{	
	_Debug_range(_First1, _Last1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2977);
	_Debug_range(_First2, _Last2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 2978);
	return (_Rechecked(_First2,
		_Partial_sort_copy_unchecked(
			_Unchecked(_First1), _Unchecked(_Last1),
			_Unchecked(_First2), _Unchecked(_Last2), _Pred)));
	}

		
template<class _InIt,
	class _RanIt> inline
	_RanIt partial_sort_copy(_InIt _First1, _InIt _Last1,
		_RanIt _First2, _RanIt _Last2)
	{	
	return (::std:: partial_sort_copy(_First1, _Last1, _First2, _Last2,
		less<>()));
	}

		
template<class _RanIt,
	class _Pr> inline
	void _Nth_element_unchecked(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr& _Pred)
	{	
	if (_Nth == _Last)
		return;	

	for (; _ISORT_MAX < _Last - _First; )
		{	
		pair<_RanIt, _RanIt> _Mid =
			_Partition_by_median_guess_unchecked(_First, _Last, _Pred);

		if (_Mid.second <= _Nth)
			_First = _Mid.second;
		else if (_Mid.first <= _Nth)
			return;	
		else
			_Last = _Mid.first;
		}

	_Insertion_sort_unchecked(_First, _Last, _Pred);	
	}

template<class _RanIt,
	class _Pr> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Nth, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3023);
	_Debug_range(_Nth, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3024);
	_Debug_pointer_if(2 <= _Last - _First, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3025);
	_Nth_element_unchecked(
		_Unchecked(_First), _Unchecked(_Nth), _Unchecked(_Last), _Pred);
	}

		
template<class _RanIt> inline
	void nth_element(_RanIt _First, _RanIt _Nth, _RanIt _Last)
	{	
	::std:: nth_element(_First, _Nth, _Last, less<>());
	}

		
template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool _Includes_unchecked(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr& _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First2, *_First1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3045))
			return (false);
		else if (_Pred(*_First1, *_First2))
			++_First1;
		else
			{	
			++_First1;
			++_First2;
			}

	return (_First2 == _Last2);
	}

template<class _InIt1,
	class _InIt2,
	class _Pr> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3064);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3065);
	return (_Includes_unchecked(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2), _Pred));
	}

		
template<class _InIt1,
	class _InIt2> inline
	bool includes(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2)
	{	
	return (::std:: includes(_First1, _Last1, _First2, _Last2,
		less<>()));
	}

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr& _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3089))
			{	
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			{	
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	
			*_Dest++ = *_First1;
			++_First1;
			++_First2;
			}
	_Dest = _Copy_no_deprecate(_First1, _Last1, _Dest);
	return (_Copy_no_deprecate(_First2, _Last2, _Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_union_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr& _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3116);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3117);
	_Debug_pointer_if(_First1 != _Last1 || _First2 != _Last2, _Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3118);
	return (_Rechecked(_Dest,
		_Set_union_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Unchecked_idl0(_Dest), _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "set_union" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Set_union_no_deprecate(_First1, _Last1, _First2, _Last2, _Dest, _Pred));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		_Set_union_no_deprecate(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 3151 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return (::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_union(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: set_union(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}
 #line 3175 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr& _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3185))
			++_First1;
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3191);
			*_Dest++ = *_First1++;
			++_First2;
			}

	return (_Dest);
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_intersection_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr& _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3206);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3207);
	return (_Rechecked(_Dest,
		_Set_intersection_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Unchecked_idl0(_Dest), _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "set_intersection" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Set_intersection_no_deprecate(_First1, _Last1, _First2, _Last2, _Dest, _Pred));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		_Set_intersection_no_deprecate(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 3240 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutIt _Dest)
	{	
	return (::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_intersection(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2, _OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: set_intersection(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}
 #line 3264 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr& _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3275))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3277);
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			++_First2;
		else
			{	
			++_First1;
			++_First2;
			}

	return (_Copy_no_deprecate(_First1, _Last1, _Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_difference_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr& _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3300);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3301);
	return (_Rechecked(_Dest,
		_Set_difference_no_deprecate1(_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Unchecked_idl0(_Dest), _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "set_difference" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Set_difference_no_deprecate(_First1, _Last1, _First2, _Last2, _Dest, _Pred));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		_Set_difference_no_deprecate(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 3336 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: set_difference(_First1, _Last1, _First2, _Last2, _Dest,
		less<>()));
	}
 #line 3362 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference_no_deprecate1(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr& _Pred)
	{	
	for (; _First1 != _Last1 && _First2 != _Last2; )
		if (_Debug_lt_pred(_Pred, *_First1, *_First2, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3373))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3375);
			*_Dest++ = *_First1;
			++_First1;
			}
		else if (_Pred(*_First2, *_First1))
			{	
			_Debug_pointer(_Dest, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3381);
			*_Dest++ = *_First2;
			++_First2;
			}
		else
			{	
			++_First1;
			++_First2;
			}
	_Dest = _Copy_no_deprecate(_First1, _Last1, _Dest);
	return (_Copy_no_deprecate(_First2, _Last2, _Dest));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt _Set_symmetric_difference_no_deprecate(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr& _Pred)
	{	
	_Debug_order(_First1, _Last1, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3402);
	_Debug_order(_First2, _Last2, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3403);
	return (_Rechecked(_Dest,
		_Set_symmetric_difference_no_deprecate1(
		_Unchecked(_First1), _Unchecked(_Last1),
		_Unchecked(_First2), _Unchecked(_Last2),
		_Unchecked_idl0(_Dest), _Pred)));
	}

template<class _InIt1,
	class _InIt2,
	class _OutIt,
	class _Pr> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest, _Pr _Pred)
	{	
	struct _Unchecked_iterators { static void __declspec(deprecated("Call to 'std::" "set_symmetric_difference" "' with parameters that may be unsafe - " "this call relies on the caller to check that the passed values are correct. " "To disable this warning, use -D_SCL_SECURE_NO_WARNINGS. " "See documentation on how to use Visual C++ 'Checked Iterators'")) _Deprecate(false_type) { } static void _Deprecate(true_type) { } }; (_Unchecked_iterators::_Deprecate(_Is_checked(_Dest)));
	return (_Set_symmetric_difference_no_deprecate(
		_First1, _Last1, _First2, _Last2, _Dest, _Pred));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize,
	class _Pr> inline
	_OutTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize], _Pr _Pred)
	{	
	return (_Unchecked(
		_Set_symmetric_difference_no_deprecate(_First1, _Last1,
			_First2, _Last2,
			_Array_iterator<_OutTy, _OutSize>(_Dest), _Pred)));
	}
 #line 3440 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _InIt1,
	class _InIt2,
	class _OutIt> inline
	_OutIt set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutIt _Dest)
	{	
	return (::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		_Dest, less<>()));
	}

 
template<class _InIt1,
	class _InIt2,
	class _OutTy,
	size_t _OutSize> inline
	_OutTy *set_symmetric_difference(_InIt1 _First1, _InIt1 _Last1,
		_InIt2 _First2, _InIt2 _Last2,
		_OutTy (&_Dest)[_OutSize])
	{	
	return (::std:: set_symmetric_difference(_First1, _Last1, _First2, _Last2,
		_Dest, less<>()));
	}
 #line 3466 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Max_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
	{	
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Debug_lt_pred(_Pred, *_Found, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3475))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3484);
	return (_Rechecked(_First,
		_Max_element_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt max_element(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: max_element(_First, _Last, less<>()));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Min_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
	{	
	_FwdIt _Found = _First;
	if (_First != _Last)
		for (; ++_First != _Last; )
			if (_Debug_lt_pred(_Pred, *_First, *_Found, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3504))
				_Found = _First;
	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3513);
	return (_Rechecked(_First,
		_Min_element_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	_FwdIt min_element(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: min_element(_First, _Last, less<>()));
	}

		
template<class _FwdIt,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		_Minmax_element_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
	{	
	pair<_FwdIt, _FwdIt> _Found(_First, _First);

	if (_First != _Last)
		for (; ++_First != _Last; )
			{	
			_FwdIt _Next = _First;
			if (++_Next == _Last)
				{	
				if (_Debug_lt_pred(_Pred, *_First, *_Found.first, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3539))
					_Found.first = _First;
				else if (!_Debug_lt_pred(_Pred, *_First, *_Found.second, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3541))
					_Found.second = _First;
				}
			else
				{	
				if (_Debug_lt_pred(_Pred, *_Next, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3546))
					{	
					if (_Debug_lt_pred(_Pred, *_Next, *_Found.first, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3548))
						_Found.first = _Next;
					if (!_Debug_lt_pred(_Pred, *_First, *_Found.second, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3550))
						_Found.second = _First;
					}
				else
					{	
					if (_Debug_lt_pred(_Pred, *_First, *_Found.first, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3555))
						_Found.first = _First;
					if (!_Debug_lt_pred(_Pred, *_Next, *_Found.second, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3557))
						_Found.second = _Next;
					}
				_First = _Next;
				}
			}

	return (_Found);
	}

template<class _FwdIt,
	class _Pr> inline
	pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3572);
	return (_Rechecked_both(_First, _Last,
		_Minmax_element_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

		
template<class _FwdIt> inline
	pair<_FwdIt, _FwdIt>
		minmax_element(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: minmax_element(_First, _Last, less<>()));
	}

		
template<class _Ty,
	class _Pr> inline
	constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right,
		_Pr _Pred)
		noexcept(noexcept(_Debug_lt_pred(_Pred, _Left, _Right, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3590)))
	{	
	return (_Debug_lt_pred(_Pred, _Left, _Right, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3592) ? _Right : _Left);
	}

template<class _Ty,
	class _Pr> inline
		
	_Ty (max)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
	{	
	const _Ty *_Res = _Max_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pred);
	return (*_Res);
	}

		
template<class _Ty> inline

	 

	constexpr const _Ty& (max)(const _Ty& _Left, const _Ty& _Right)
		noexcept(noexcept(_Debug_lt(_Left, _Right, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3610)))
	{	
	return (_Debug_lt(_Left, _Right, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3612) ? _Right : _Left);
	}

template<class _Ty> inline
		
	_Ty (max)(::std:: initializer_list<_Ty> _Ilist)
	{	
	return ((::std:: max)(_Ilist, less<>()));
	}

		
template<class _Ty,
	class _Pr> inline
	constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right,
		_Pr _Pred)
		noexcept(noexcept(_Debug_lt_pred(_Pred, _Right, _Left, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3627)))
	{	
	return (_Debug_lt_pred(_Pred, _Right, _Left, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3629) ? _Right : _Left);
	}

template<class _Ty,
	class _Pr> inline
		
	_Ty (min)(::std:: initializer_list<_Ty> _Ilist, _Pr _Pred)
	{	
	const _Ty *_Res = _Min_element_unchecked(_Ilist.begin(), _Ilist.end(), _Pred);
	return (*_Res);
	}

		
template<class _Ty> inline

	 

	constexpr const _Ty& (min)(const _Ty& _Left, const _Ty& _Right)
		noexcept(noexcept(_Debug_lt(_Right, _Left, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3647)))
	{	
	return (_Debug_lt(_Right, _Left, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3649) ? _Right : _Left);
	}

template<class _Ty> inline
		
	_Ty (min)(::std:: initializer_list<_Ty> _Ilist)
	{	
	return ((::std:: min)(_Ilist, less<>()));
	}


		
template<class _Ty,
	class _Pr> inline
	constexpr pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right, _Pr _Pred)
	{	
	return (_Pred(_Right, _Left)
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

template<class _Ty,
	class _Pr> inline
		
	pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist,
		_Pr _Pred)
	{	
	pair<const _Ty *, const _Ty *> _Res = _Minmax_element_unchecked(
		_Ilist.begin(), _Ilist.end(), _Pred);
	return (pair<_Ty, _Ty>(*_Res.first, *_Res.second));
	}

		
template<class _Ty> inline
	constexpr pair<const _Ty&, const _Ty&>
		minmax(const _Ty& _Left, const _Ty& _Right)
	{	
	return (_Right < _Left
		? pair<const _Ty&, const _Ty&>(_Right, _Left)
		: pair<const _Ty&, const _Ty&>(_Left, _Right));
	}

template<class _Ty> inline
		
	pair<_Ty, _Ty> minmax(::std:: initializer_list<_Ty> _Ilist)
	{	
	return (::std:: minmax(_Ilist, less<>()));
	}

		
template<class _BidIt,
	class _Pr> inline
	bool _Next_permutation_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
	{	
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Debug_lt_pred(_Pred, *--_Next, *_Next1, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3711))
			{	
			_BidIt _Mid = _Last;
			for (; !_Debug_lt_pred(_Pred, *_Next, *--_Mid, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3714); )
				;
			::std:: iter_swap(_Next, _Mid);
			_Reverse_unchecked(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			_Reverse_unchecked(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool next_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3733);
	return (_Next_permutation_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _BidIt> inline
	bool next_permutation(_BidIt _First, _BidIt _Last)
	{	
	return (::std:: next_permutation(_First, _Last, less<>()));
	}

		
template<class _BidIt,
	class _Pr> inline
	bool _Prev_permutation_unchecked(_BidIt _First, _BidIt _Last, _Pr& _Pred)
	{	
	_BidIt _Next = _Last;
	if (_First == _Last || _First == --_Next)
		return (false);

	for (; ; )
		{	
		_BidIt _Next1 = _Next;
		if (_Debug_lt_pred(_Pred, *_Next1, *--_Next, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3756))
			{	
			_BidIt _Mid = _Last;
			for (; !_Debug_lt_pred(_Pred, *--_Mid, *_Next, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3759); )
				;
			::std:: iter_swap(_Next, _Mid);
			_Reverse_unchecked(_Next1, _Last);
			return (true);
			}

		if (_Next == _First)
			{	
			_Reverse_unchecked(_First, _Last);
			return (false);
			}
		}
	}

template<class _BidIt,
	class _Pr> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last, _Pr _Pred)
	{	
	_Debug_range_ptr(_First, _Last, _Pred, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3778);
	return (_Prev_permutation_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred));
	}

		
template<class _BidIt> inline
	bool prev_permutation(_BidIt _First, _BidIt _Last)
	{	
	return (::std:: prev_permutation(_First, _Last, less<>()));
	}

		
template<class _RanIt,
	class _Pr> inline
	_RanIt _Is_heap_until_unchecked(_RanIt _First, _RanIt _Last, _Pr& _Pred)
	{	
	_Iter_diff_t<_RanIt> _Size = _Last - _First;

	if (2 <= _Size)
		for (_Iter_diff_t<_RanIt> _Off = 0; ++_Off < _Size; )
			if (_Debug_lt_pred(_Pred, *(_First + (_Off - 1) / 2), *(_First + _Off), L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3799))
#line 3800 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
				return (_First + _Off);
	return (_Last);
	}

template<class _RanIt,
	class _Pr> inline
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3808);
	return (_Rechecked(_First,
		_Is_heap_until_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

template<class _RanIt,
	class _Pr> inline
	bool is_heap(_RanIt _First, _RanIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3817);
	return (_Is_heap_until_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred) == _Unchecked(_Last));
	}

		
template<class _RanIt> inline
	_RanIt is_heap_until(_RanIt _First, _RanIt _Last)
	{	
	return (::std:: is_heap_until(_First, _Last, less<>()));
	}

template<class _RanIt> inline
	bool is_heap(_RanIt _First, _RanIt _Last)
	{	
	return (::std:: is_heap(_First, _Last, less<>()));
	}

		
template<class _FwdIt,
	class _Pr> inline
	_FwdIt _Is_sorted_until_unchecked(_FwdIt _First, _FwdIt _Last, _Pr& _Pred)
	{	
	if (_First != _Last)
		for (_FwdIt _Next = _First; ++_Next != _Last; ++_First)
			if (_Debug_lt_pred(_Pred, *_Next, *_First, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3841))
				return (_Next);
	return (_Last);
	}

template<class _FwdIt,
	class _Pr> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3850);
	return (_Rechecked(_First,
		_Is_sorted_until_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred)));
	}

template<class _FwdIt,
	class _Pr> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last, _Pr _Pred)
	{	
	_Debug_range(_First, _Last, L"c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm", 3859);
	return (_Is_sorted_until_unchecked(_Unchecked(_First), _Unchecked(_Last), _Pred) == _Unchecked(_Last));
	}

		
template<class _FwdIt> inline
	_FwdIt is_sorted_until(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: is_sorted_until(_First, _Last, less<>()));
	}

template<class _FwdIt> inline
	bool is_sorted(_FwdIt _First, _FwdIt _Last)
	{	
	return (::std:: is_sorted(_First, _Last, less<>()));
	}































#line 3907 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"

}
 
 #pragma warning(pop)
 #pragma pack(pop)
#line 3913 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"
#line 3914 "c:\\program files (x86)\\microsoft visual studio 14.0\\vc\\include\\algorithm"






#line 53 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix3x3.inl"





template <typename TReal>
inline aiMatrix3x3t<TReal>::aiMatrix3x3t( const aiMatrix4x4t<TReal>& pMatrix)
{
	a1 = pMatrix.a1; a2 = pMatrix.a2; a3 = pMatrix.a3;
	b1 = pMatrix.b1; b2 = pMatrix.b2; b3 = pMatrix.b3;
	c1 = pMatrix.c1; c2 = pMatrix.c2; c3 = pMatrix.c3;
}


template <typename TReal>
inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::operator *= (const aiMatrix3x3t<TReal>& m)
{
	*this = aiMatrix3x3t<TReal>(m.a1 * a1 + m.b1 * a2 + m.c1 * a3,
		m.a2 * a1 + m.b2 * a2 + m.c2 * a3,
		m.a3 * a1 + m.b3 * a2 + m.c3 * a3,
		m.a1 * b1 + m.b1 * b2 + m.c1 * b3,
		m.a2 * b1 + m.b2 * b2 + m.c2 * b3,
		m.a3 * b1 + m.b3 * b2 + m.c3 * b3,
		m.a1 * c1 + m.b1 * c2 + m.c1 * c3,
		m.a2 * c1 + m.b2 * c2 + m.c2 * c3,
		m.a3 * c1 + m.b3 * c2 + m.c3 * c3);
	return *this;
}


template <typename TReal>
template <typename TOther>
aiMatrix3x3t<TReal>::operator aiMatrix3x3t<TOther> () const
{
	return aiMatrix3x3t<TOther>(static_cast<TOther>(a1),static_cast<TOther>(a2),static_cast<TOther>(a3),
		static_cast<TOther>(b1),static_cast<TOther>(b2),static_cast<TOther>(b3),
		static_cast<TOther>(c1),static_cast<TOther>(c2),static_cast<TOther>(c3));
}


template <typename TReal>
inline aiMatrix3x3t<TReal> aiMatrix3x3t<TReal>::operator* (const aiMatrix3x3t<TReal>& m) const
{
	aiMatrix3x3t<TReal> temp( *this);
	temp *= m;
	return temp;
}


template <typename TReal>
inline TReal* aiMatrix3x3t<TReal>::operator[] (unsigned int p_iIndex)
{
	return &this->a1 + p_iIndex * 3;
}


template <typename TReal>
inline const TReal* aiMatrix3x3t<TReal>::operator[] (unsigned int p_iIndex) const
{
	return &this->a1 + p_iIndex * 3;
}


template <typename TReal>
inline bool aiMatrix3x3t<TReal>::operator== (const aiMatrix4x4t<TReal>& m) const
{
	return a1 == m.a1 && a2 == m.a2 && a3 == m.a3 &&
		   b1 == m.b1 && b2 == m.b2 && b3 == m.b3 &&
		   c1 == m.c1 && c2 == m.c2 && c3 == m.c3;
}


template <typename TReal>
inline bool aiMatrix3x3t<TReal>::operator!= (const aiMatrix4x4t<TReal>& m) const
{
	return !(*this == m);
}


template<typename TReal>
inline bool aiMatrix3x3t<TReal>::Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon) const {
	return
		std::abs(a1 - m.a1) <= epsilon &&
		std::abs(a2 - m.a2) <= epsilon &&
		std::abs(a3 - m.a3) <= epsilon &&
		std::abs(b1 - m.b1) <= epsilon &&
		std::abs(b2 - m.b2) <= epsilon &&
		std::abs(b3 - m.b3) <= epsilon &&
		std::abs(c1 - m.c1) <= epsilon &&
		std::abs(c2 - m.c2) <= epsilon &&
		std::abs(c3 - m.c3) <= epsilon;
}


template <typename TReal>
inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Transpose()
{
	
	std::swap( (TReal&)a2, (TReal&)b1);
	std::swap( (TReal&)a3, (TReal&)c1);
	std::swap( (TReal&)b3, (TReal&)c2);
	return *this;
}


template <typename TReal>
inline TReal aiMatrix3x3t<TReal>::Determinant() const
{
	return a1*b2*c3 - a1*b3*c2 + a2*b3*c1 - a2*b1*c3 + a3*b1*c2 - a3*b2*c1;
}


template <typename TReal>
inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Inverse()
{
	
	TReal det = Determinant();
	if(det == static_cast<TReal>(0.0)) 
	{
		
		
		
		
		const TReal nan = std::numeric_limits<TReal>::quiet_NaN();
		*this = aiMatrix3x3t<TReal>( nan,nan,nan,nan,nan,nan,nan,nan,nan);

		return *this;
	}

	TReal invdet = static_cast<TReal>(1.0) / det;

	aiMatrix3x3t<TReal> res;
	res.a1 = invdet  * (b2 * c3 - b3 * c2);
	res.a2 = -invdet * (a2 * c3 - a3 * c2);
	res.a3 = invdet  * (a2 * b3 - a3 * b2);
	res.b1 = -invdet * (b1 * c3 - b3 * c1);
	res.b2 = invdet  * (a1 * c3 - a3 * c1);
	res.b3 = -invdet * (a1 * b3 - a3 * b1);
	res.c1 = invdet  * (b1 * c2 - b2 * c1);
	res.c2 = -invdet * (a1 * c2 - a2 * c1);
	res.c3 = invdet  * (a1 * b2 - a2 * b1);
	*this = res;

	return *this;
}


template <typename TReal>
inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::RotationZ(TReal a, aiMatrix3x3t<TReal>& out)
{
	out.a1 = out.b2 = ::cos(a);
	out.b1 = ::sin(a);
	out.a2 = - out.b1;

	out.a3 = out.b3 = out.c1 = out.c2 = 0.f;
	out.c3 = 1.f;

	return out;
}



template <typename TReal>
inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Rotation( TReal a, const aiVector3t<TReal>& axis, aiMatrix3x3t<TReal>& out)
{
  TReal c = cos( a), s = sin( a), t = 1 - c;
  TReal x = axis.x, y = axis.y, z = axis.z;

  
  out.a1 = t*x*x + c;   out.a2 = t*x*y - s*z; out.a3 = t*x*z + s*y;
  out.b1 = t*x*y + s*z; out.b2 = t*y*y + c;   out.b3 = t*y*z - s*x;
  out.c1 = t*x*z - s*y; out.c2 = t*y*z + s*x; out.c3 = t*z*z + c;

  return out;
}


template <typename TReal>
inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::Translation( const aiVector2t<TReal>& v, aiMatrix3x3t<TReal>& out)
{
	out = aiMatrix3x3t<TReal>();
	out.a3 = v.x;
	out.b3 = v.y;
	return out;
}











template <typename TReal>
inline aiMatrix3x3t<TReal>& aiMatrix3x3t<TReal>::FromToMatrix(const aiVector3t<TReal>& from, 
	const aiVector3t<TReal>& to, aiMatrix3x3t<TReal>& mtx)
{
	const TReal e = from * to;
	const TReal f = (e < 0)? -e:e;

	if (f > static_cast<TReal>(1.0) - static_cast<TReal>(0.00001))     
	{
		aiVector3D u,v;     
		aiVector3D x;       

		x.x = (from.x > 0.0)? from.x : -from.x;
		x.y = (from.y > 0.0)? from.y : -from.y;
		x.z = (from.z > 0.0)? from.z : -from.z;

		if (x.x < x.y)
		{
			if (x.x < x.z)
			{
				x.x = static_cast<TReal>(1.0); x.y = x.z = static_cast<TReal>(0.0);
			}
			else
			{
				x.z = static_cast<TReal>(1.0); x.y = x.z = static_cast<TReal>(0.0);
			}
		}
		else
		{
			if (x.y < x.z)
			{
				x.y = static_cast<TReal>(1.0); x.x = x.z = static_cast<TReal>(0.0);
			}
			else
			{
				x.z = static_cast<TReal>(1.0); x.x = x.y = static_cast<TReal>(0.0);
			}
		}

		u.x = x.x - from.x; u.y = x.y - from.y; u.z = x.z - from.z;
		v.x = x.x - to.x;   v.y = x.y - to.y;   v.z = x.z - to.z;

		const TReal c1 = static_cast<TReal>(2.0) / (u * u);
		const TReal c2 = static_cast<TReal>(2.0) / (v * v);
		const TReal c3 = c1 * c2  * (u * v);

		for (unsigned int i = 0; i < 3; i++) 
		{
			for (unsigned int j = 0; j < 3; j++) 
			{
				mtx[i][j] =  - c1 * u[i] * u[j] - c2 * v[i] * v[j]
					+ c3 * v[i] * u[j];
			}
			mtx[i][i] += static_cast<TReal>(1.0);
		}
	}
	else  
	{
		const aiVector3D v = from ^ to;
		
		const TReal h = static_cast<TReal>(1.0)/(static_cast<TReal>(1.0) + e);      
		const TReal hvx = h * v.x;
		const TReal hvz = h * v.z;
		const TReal hvxy = hvx * v.y;
		const TReal hvxz = hvx * v.z;
		const TReal hvyz = hvz * v.y;
		mtx[0][0] = e + hvx * v.x;
		mtx[0][1] = hvxy - v.z;
		mtx[0][2] = hvxz + v.y;

		mtx[1][0] = hvxy + v.z;
		mtx[1][1] = e + h * v.y * v.y;
		mtx[1][2] = hvyz - v.x;

		mtx[2][0] = hvxz - v.y;
		mtx[2][1] = hvyz + v.x;
		mtx[2][2] = e + hvz * v.z;
	}
	return mtx;
}


#line 332 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix3x3.inl"
#line 333 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix3x3.inl"
#line 511 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix4x4.inl"




























































#line 62 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix4x4.inl"


template <typename TReal>
aiMatrix4x4t<TReal> ::aiMatrix4x4t () :
	a1(1.0f), a2(), a3(), a4(),
	b1(), b2(1.0f), b3(), b4(),
	c1(), c2(), c3(1.0f), c4(),
	d1(), d2(), d3(), d4(1.0f)
{

}


template <typename TReal>
aiMatrix4x4t<TReal> ::aiMatrix4x4t (TReal _a1, TReal _a2, TReal _a3, TReal _a4,
			  TReal _b1, TReal _b2, TReal _b3, TReal _b4,
			  TReal _c1, TReal _c2, TReal _c3, TReal _c4,
			  TReal _d1, TReal _d2, TReal _d3, TReal _d4) :
	a1(_a1), a2(_a2), a3(_a3), a4(_a4),
	b1(_b1), b2(_b2), b3(_b3), b4(_b4),
	c1(_c1), c2(_c2), c3(_c3), c4(_c4),
	d1(_d1), d2(_d2), d3(_d3), d4(_d4)
{

}


template <typename TReal>
template <typename TOther>
aiMatrix4x4t<TReal>::operator aiMatrix4x4t<TOther> () const
{
	return aiMatrix4x4t<TOther>(static_cast<TOther>(a1),static_cast<TOther>(a2),static_cast<TOther>(a3),static_cast<TOther>(a4),
		static_cast<TOther>(b1),static_cast<TOther>(b2),static_cast<TOther>(b3),static_cast<TOther>(b4),
		static_cast<TOther>(c1),static_cast<TOther>(c2),static_cast<TOther>(c3),static_cast<TOther>(c4),
		static_cast<TOther>(d1),static_cast<TOther>(d2),static_cast<TOther>(d3),static_cast<TOther>(d4));
}



template <typename TReal>
inline aiMatrix4x4t<TReal>::aiMatrix4x4t (const aiMatrix3x3t<TReal>& m)
{
	a1 = m.a1; a2 = m.a2; a3 = m.a3; a4 = static_cast<TReal>(0.0);
	b1 = m.b1; b2 = m.b2; b3 = m.b3; b4 = static_cast<TReal>(0.0);
	c1 = m.c1; c2 = m.c2; c3 = m.c3; c4 = static_cast<TReal>(0.0);
	d1 = static_cast<TReal>(0.0); d2 = static_cast<TReal>(0.0); d3 = static_cast<TReal>(0.0); d4 = static_cast<TReal>(1.0);
}


template <typename TReal>
inline aiMatrix4x4t<TReal>::aiMatrix4x4t (const aiVector3t<TReal>& scaling, const aiQuaterniont<TReal>& rotation, const aiVector3t<TReal>& position)
{
	
	aiMatrix3x3t<TReal> m = rotation.GetMatrix();

	a1 = m.a1 * scaling.x;
	a2 = m.a2 * scaling.x;
	a3 = m.a3 * scaling.x;
	a4 = position.x;

	b1 = m.b1 * scaling.y;
	b2 = m.b2 * scaling.y;
	b3 = m.b3 * scaling.y;
	b4 = position.y;
	
	c1 = m.c1 * scaling.z;
	c2 = m.c2 * scaling.z;
	c3 = m.c3 * scaling.z;
	c4= position.z;

	d1 = static_cast<TReal>(0.0);
	d2 = static_cast<TReal>(0.0);
	d3 = static_cast<TReal>(0.0);
	d4 = static_cast<TReal>(1.0);
}


template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::operator *= (const aiMatrix4x4t<TReal>& m)
{
	*this = aiMatrix4x4t<TReal>(
		m.a1 * a1 + m.b1 * a2 + m.c1 * a3 + m.d1 * a4,
		m.a2 * a1 + m.b2 * a2 + m.c2 * a3 + m.d2 * a4,
		m.a3 * a1 + m.b3 * a2 + m.c3 * a3 + m.d3 * a4,
		m.a4 * a1 + m.b4 * a2 + m.c4 * a3 + m.d4 * a4,
		m.a1 * b1 + m.b1 * b2 + m.c1 * b3 + m.d1 * b4,
		m.a2 * b1 + m.b2 * b2 + m.c2 * b3 + m.d2 * b4,
		m.a3 * b1 + m.b3 * b2 + m.c3 * b3 + m.d3 * b4,
		m.a4 * b1 + m.b4 * b2 + m.c4 * b3 + m.d4 * b4,
		m.a1 * c1 + m.b1 * c2 + m.c1 * c3 + m.d1 * c4,
		m.a2 * c1 + m.b2 * c2 + m.c2 * c3 + m.d2 * c4,
		m.a3 * c1 + m.b3 * c2 + m.c3 * c3 + m.d3 * c4,
		m.a4 * c1 + m.b4 * c2 + m.c4 * c3 + m.d4 * c4,
		m.a1 * d1 + m.b1 * d2 + m.c1 * d3 + m.d1 * d4,
		m.a2 * d1 + m.b2 * d2 + m.c2 * d3 + m.d2 * d4,
		m.a3 * d1 + m.b3 * d2 + m.c3 * d3 + m.d3 * d4,
		m.a4 * d1 + m.b4 * d2 + m.c4 * d3 + m.d4 * d4);
	return *this;
}


template <typename TReal>
inline aiMatrix4x4t<TReal> aiMatrix4x4t<TReal>::operator* (const aiMatrix4x4t<TReal>& m) const
{
	aiMatrix4x4t<TReal> temp( *this);
	temp *= m;
	return temp;
}



template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Transpose()
{
	
	std::swap( (TReal&)b1, (TReal&)a2);
	std::swap( (TReal&)c1, (TReal&)a3);
	std::swap( (TReal&)c2, (TReal&)b3);
	std::swap( (TReal&)d1, (TReal&)a4);
	std::swap( (TReal&)d2, (TReal&)b4);
	std::swap( (TReal&)d3, (TReal&)c4);
	return *this;
}



template <typename TReal>
inline TReal aiMatrix4x4t<TReal>::Determinant() const
{
	return a1*b2*c3*d4 - a1*b2*c4*d3 + a1*b3*c4*d2 - a1*b3*c2*d4
		+ a1*b4*c2*d3 - a1*b4*c3*d2 - a2*b3*c4*d1 + a2*b3*c1*d4
		- a2*b4*c1*d3 + a2*b4*c3*d1 - a2*b1*c3*d4 + a2*b1*c4*d3
		+ a3*b4*c1*d2 - a3*b4*c2*d1 + a3*b1*c2*d4 - a3*b1*c4*d2
		+ a3*b2*c4*d1 - a3*b2*c1*d4 - a4*b1*c2*d3 + a4*b1*c3*d2
		- a4*b2*c3*d1 + a4*b2*c1*d3 - a4*b3*c1*d2 + a4*b3*c2*d1;
}


template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Inverse()
{
	
	const TReal det = Determinant();
	if(det == static_cast<TReal>(0.0))
	{
		
		
		
		const TReal nan = std::numeric_limits<TReal>::quiet_NaN();
		*this = aiMatrix4x4t<TReal>(
			nan,nan,nan,nan,
			nan,nan,nan,nan,
			nan,nan,nan,nan,
			nan,nan,nan,nan);

		return *this;
	}

	const TReal invdet = static_cast<TReal>(1.0) / det;

	aiMatrix4x4t<TReal> res;
	res.a1 = invdet  * (b2 * (c3 * d4 - c4 * d3) + b3 * (c4 * d2 - c2 * d4) + b4 * (c2 * d3 - c3 * d2));
	res.a2 = -invdet * (a2 * (c3 * d4 - c4 * d3) + a3 * (c4 * d2 - c2 * d4) + a4 * (c2 * d3 - c3 * d2));
	res.a3 = invdet  * (a2 * (b3 * d4 - b4 * d3) + a3 * (b4 * d2 - b2 * d4) + a4 * (b2 * d3 - b3 * d2));
	res.a4 = -invdet * (a2 * (b3 * c4 - b4 * c3) + a3 * (b4 * c2 - b2 * c4) + a4 * (b2 * c3 - b3 * c2));
	res.b1 = -invdet * (b1 * (c3 * d4 - c4 * d3) + b3 * (c4 * d1 - c1 * d4) + b4 * (c1 * d3 - c3 * d1));
	res.b2 = invdet  * (a1 * (c3 * d4 - c4 * d3) + a3 * (c4 * d1 - c1 * d4) + a4 * (c1 * d3 - c3 * d1));
	res.b3 = -invdet * (a1 * (b3 * d4 - b4 * d3) + a3 * (b4 * d1 - b1 * d4) + a4 * (b1 * d3 - b3 * d1));
	res.b4 = invdet  * (a1 * (b3 * c4 - b4 * c3) + a3 * (b4 * c1 - b1 * c4) + a4 * (b1 * c3 - b3 * c1));
	res.c1 = invdet  * (b1 * (c2 * d4 - c4 * d2) + b2 * (c4 * d1 - c1 * d4) + b4 * (c1 * d2 - c2 * d1));
	res.c2 = -invdet * (a1 * (c2 * d4 - c4 * d2) + a2 * (c4 * d1 - c1 * d4) + a4 * (c1 * d2 - c2 * d1));
	res.c3 = invdet  * (a1 * (b2 * d4 - b4 * d2) + a2 * (b4 * d1 - b1 * d4) + a4 * (b1 * d2 - b2 * d1));
	res.c4 = -invdet * (a1 * (b2 * c4 - b4 * c2) + a2 * (b4 * c1 - b1 * c4) + a4 * (b1 * c2 - b2 * c1));
	res.d1 = -invdet * (b1 * (c2 * d3 - c3 * d2) + b2 * (c3 * d1 - c1 * d3) + b3 * (c1 * d2 - c2 * d1));
	res.d2 = invdet  * (a1 * (c2 * d3 - c3 * d2) + a2 * (c3 * d1 - c1 * d3) + a3 * (c1 * d2 - c2 * d1));
	res.d3 = -invdet * (a1 * (b2 * d3 - b3 * d2) + a2 * (b3 * d1 - b1 * d3) + a3 * (b1 * d2 - b2 * d1));
	res.d4 = invdet  * (a1 * (b2 * c3 - b3 * c2) + a2 * (b3 * c1 - b1 * c3) + a3 * (b1 * c2 - b2 * c1));
	*this = res;

	return *this;
}


template <typename TReal>
inline TReal* aiMatrix4x4t<TReal>::operator[](unsigned int p_iIndex)
{
	
	return &this->a1 + p_iIndex * 4;
}


template <typename TReal>
inline const TReal* aiMatrix4x4t<TReal>::operator[](unsigned int p_iIndex) const
{
	
	return &this->a1 + p_iIndex * 4;
}


template <typename TReal>
inline bool aiMatrix4x4t<TReal>::operator== (const aiMatrix4x4t<TReal>& m) const
{
	return (a1 == m.a1 && a2 == m.a2 && a3 == m.a3 && a4 == m.a4 &&
			b1 == m.b1 && b2 == m.b2 && b3 == m.b3 && b4 == m.b4 &&
			c1 == m.c1 && c2 == m.c2 && c3 == m.c3 && c4 == m.c4 &&
			d1 == m.d1 && d2 == m.d2 && d3 == m.d3 && d4 == m.d4);
}


template <typename TReal>
inline bool aiMatrix4x4t<TReal>::operator!= (const aiMatrix4x4t<TReal>& m) const
{
	return !(*this == m);
}


template<typename TReal>
inline bool aiMatrix4x4t<TReal>::Equal(const aiMatrix4x4t<TReal>& m, TReal epsilon) const {
	return
		std::abs(a1 - m.a1) <= epsilon &&
		std::abs(a2 - m.a2) <= epsilon &&
		std::abs(a3 - m.a3) <= epsilon &&
		std::abs(a4 - m.a4) <= epsilon &&
		std::abs(b1 - m.b1) <= epsilon &&
		std::abs(b2 - m.b2) <= epsilon &&
		std::abs(b3 - m.b3) <= epsilon &&
		std::abs(b4 - m.b4) <= epsilon &&
		std::abs(c1 - m.c1) <= epsilon &&
		std::abs(c2 - m.c2) <= epsilon &&
		std::abs(c3 - m.c3) <= epsilon &&
		std::abs(c4 - m.c4) <= epsilon &&
		std::abs(d1 - m.d1) <= epsilon &&
		std::abs(d2 - m.d2) <= epsilon &&
		std::abs(d3 - m.d3) <= epsilon &&
		std::abs(d4 - m.d4) <= epsilon;
}


template <typename TReal>
inline void aiMatrix4x4t<TReal>::Decompose (aiVector3t<TReal>& scaling, aiQuaterniont<TReal>& rotation,
	aiVector3t<TReal>& position) const
{
	const aiMatrix4x4t<TReal>& _this = *this;

	
	position.x = _this[0][3];
	position.y = _this[1][3];
	position.z = _this[2][3];

	
	aiVector3t<TReal> vRows[3] = {
		aiVector3t<TReal>(_this[0][0],_this[1][0],_this[2][0]),
		aiVector3t<TReal>(_this[0][1],_this[1][1],_this[2][1]),
		aiVector3t<TReal>(_this[0][2],_this[1][2],_this[2][2])
	};

	
	scaling.x = vRows[0].Length();
	scaling.y = vRows[1].Length();
	scaling.z = vRows[2].Length();

	
	if (Determinant() < 0) {
		scaling.x = -scaling.x;
		scaling.y = -scaling.y;
		scaling.z = -scaling.z;
	}

	
	if(scaling.x)
	{
		vRows[0] /= scaling.x;
	}
	if(scaling.y)
	{
		vRows[1] /= scaling.y;
	}
	if(scaling.z)
	{
		vRows[2] /= scaling.z;
	}

	
	aiMatrix3x3t<TReal> m(vRows[0].x,vRows[1].x,vRows[2].x,
		vRows[0].y,vRows[1].y,vRows[2].y,
		vRows[0].z,vRows[1].z,vRows[2].z);

	
	rotation = aiQuaterniont<TReal>(m);
}


template <typename TReal>
inline void aiMatrix4x4t<TReal>::DecomposeNoScaling (aiQuaterniont<TReal>& rotation,
	aiVector3t<TReal>& position) const
{
	const aiMatrix4x4t<TReal>& _this = *this;

	
	position.x = _this[0][3];
	position.y = _this[1][3];
	position.z = _this[2][3];

	
	rotation = aiQuaterniont<TReal>((aiMatrix3x3t<TReal>)_this);
}


template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromEulerAnglesXYZ(const aiVector3t<TReal>& blubb)
{
	return FromEulerAnglesXYZ(blubb.x,blubb.y,blubb.z);
}


template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromEulerAnglesXYZ(TReal x, TReal y, TReal z)
{
	aiMatrix4x4t<TReal>& _this = *this;

	TReal cr = cos( x );
	TReal sr = sin( x );
	TReal cp = cos( y );
	TReal sp = sin( y );
	TReal cy = cos( z );
	TReal sy = sin( z );

	_this.a1 = cp*cy ;
	_this.a2 = cp*sy;
	_this.a3 = -sp ;

	TReal srsp = sr*sp;
	TReal crsp = cr*sp;

	_this.b1 = srsp*cy-cr*sy ;
	_this.b2 = srsp*sy+cr*cy ;
	_this.b3 = sr*cp ;

	_this.c1 =  crsp*cy+sr*sy ;
	_this.c2 =  crsp*sy-sr*cy ;
	_this.c3 = cr*cp ;

	return *this;
}


template <typename TReal>
inline bool aiMatrix4x4t<TReal>::IsIdentity() const
{
	
	const static TReal epsilon = 10e-3f;

	return (a2 <= epsilon && a2 >= -epsilon &&
			a3 <= epsilon && a3 >= -epsilon &&
			a4 <= epsilon && a4 >= -epsilon &&
			b1 <= epsilon && b1 >= -epsilon &&
			b3 <= epsilon && b3 >= -epsilon &&
			b4 <= epsilon && b4 >= -epsilon &&
			c1 <= epsilon && c1 >= -epsilon &&
			c2 <= epsilon && c2 >= -epsilon &&
			c4 <= epsilon && c4 >= -epsilon &&
			d1 <= epsilon && d1 >= -epsilon &&
			d2 <= epsilon && d2 >= -epsilon &&
			d3 <= epsilon && d3 >= -epsilon &&
			a1 <= 1.f+epsilon && a1 >= 1.f-epsilon &&
			b2 <= 1.f+epsilon && b2 >= 1.f-epsilon &&
			c3 <= 1.f+epsilon && c3 >= 1.f-epsilon &&
			d4 <= 1.f+epsilon && d4 >= 1.f-epsilon);
}


template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationX(TReal a, aiMatrix4x4t<TReal>& out)
{
	




	out = aiMatrix4x4t<TReal>();
	out.b2 = out.c3 = cos(a);
	out.b3 = -(out.c2 = sin(a));
	return out;
}


template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationY(TReal a, aiMatrix4x4t<TReal>& out)
{
	





	out = aiMatrix4x4t<TReal>();
	out.a1 = out.c3 = cos(a);
	out.c1 = -(out.a3 = sin(a));
	return out;
}


template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::RotationZ(TReal a, aiMatrix4x4t<TReal>& out)
{
	




	out = aiMatrix4x4t<TReal>();
	out.a1 = out.b2 = cos(a);
	out.a2 = -(out.b1 = sin(a));
	return out;
}



template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Rotation( TReal a, const aiVector3t<TReal>& axis, aiMatrix4x4t<TReal>& out)
{
  TReal c = cos( a), s = sin( a), t = 1 - c;
  TReal x = axis.x, y = axis.y, z = axis.z;

  
  out.a1 = t*x*x + c;   out.a2 = t*x*y - s*z; out.a3 = t*x*z + s*y;
  out.b1 = t*x*y + s*z; out.b2 = t*y*y + c;   out.b3 = t*y*z - s*x;
  out.c1 = t*x*z - s*y; out.c2 = t*y*z + s*x; out.c3 = t*z*z + c;
  out.a4 = out.b4 = out.c4 = static_cast<TReal>(0.0);
  out.d1 = out.d2 = out.d3 = static_cast<TReal>(0.0);
  out.d4 = static_cast<TReal>(1.0);

  return out;
}


template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Translation( const aiVector3t<TReal>& v, aiMatrix4x4t<TReal>& out)
{
	out = aiMatrix4x4t<TReal>();
	out.a4 = v.x;
	out.b4 = v.y;
	out.c4 = v.z;
	return out;
}


template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::Scaling( const aiVector3t<TReal>& v, aiMatrix4x4t<TReal>& out)
{
	out = aiMatrix4x4t<TReal>();
	out.a1 = v.x;
	out.b2 = v.y;
	out.c3 = v.z;
	return out;
}











template <typename TReal>
inline aiMatrix4x4t<TReal>& aiMatrix4x4t<TReal>::FromToMatrix(const aiVector3t<TReal>& from,
	const aiVector3t<TReal>& to, aiMatrix4x4t<TReal>& mtx)
{
	aiMatrix3x3t<TReal> m3;
	aiMatrix3x3t<TReal>::FromToMatrix(from,to,m3);
	mtx = aiMatrix4x4t<TReal>(m3);
	return mtx;
}

#line 540 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix4x4.inl"
#line 541 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\matrix4x4.inl"
#line 512 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 513 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\types.h"
#line 54 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\importer.hpp"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"















































































































#line 113 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"























#line 137 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"






































































































































































#line 304 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"















#line 320 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"













#line 334 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"













#line 348 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"














#line 363 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"




















enum aiComponent
{
	



	aiComponent_NORMALS = 0x2u,
#line 391 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"

	



	aiComponent_TANGENTS_AND_BITANGENTS = 0x4u,
#line 398 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"

	

	aiComponent_COLORS = 0x8,

	

	aiComponent_TEXCOORDS = 0x10,

	


	aiComponent_BONEWEIGHTS = 0x20,

	


	aiComponent_ANIMATIONS = 0x40,

	
	aiComponent_TEXTURES = 0x80,

	


	aiComponent_LIGHTS = 0x100,

	


	aiComponent_CAMERAS = 0x200,

	
	aiComponent_MESHES = 0x400,

	

	aiComponent_MATERIALS = 0x800,


	


	_aiComponent_Force32Bit = 0x9fffffff
#line 443 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"
};













































































































































































































































































































































































































































#line 874 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\config.h"

#line 55 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\importer.hpp"

namespace Assimp	{
	
	
	class Importer;
	class Exporter; 
	class IOStream;
	class IOSystem;
	class ProgressHandler;

	
	
	
	
	
	
	class BaseImporter;
	class BaseProcess;
	class SharedPostProcessInfo;
	class BatchLoader; 

	
	
	class ImporterPimpl;
	class ExporterPimpl; 
} 



struct aiScene;


struct aiImporterDesc;


namespace Assimp	{

























class  Importer	{

public:

	
	




	Importer();

	
	





	Importer(const Importer& other);

	
	


	~Importer();


	
	







	aiReturn RegisterLoader(BaseImporter* pImp);

	
	







	aiReturn UnregisterLoader(BaseImporter* pImp);

	
	









	aiReturn RegisterPPStep(BaseProcess* pImp);

	
	







	aiReturn UnregisterPPStep(BaseProcess* pImp);


	
	












	void SetPropertyInteger(const char* szName, int iValue, 
		bool* bWasExisting = 0);

	
	





	void SetPropertyBool(const char* szName, bool value, bool* bWasExisting = 0)	{
		SetPropertyInteger(szName,value,bWasExisting);
	}

	
	


	void SetPropertyFloat(const char* szName, float fValue, 
		bool* bWasExisting = 0);

	
	


	void SetPropertyString(const char* szName, const std::string& sValue, 
		bool* bWasExisting = 0);

	
	


	void SetPropertyMatrix(const char* szName, const aiMatrix4x4& sValue, 
		bool* bWasExisting = 0);

	
	











	int GetPropertyInteger(const char* szName, 
		int iErrorReturn = 0xffffffff) const;

	
	





	bool GetPropertyBool(const char* szName, bool bErrorReturn = false) const {
		return GetPropertyInteger(szName,bErrorReturn)!=0;
	}

	
	


	float GetPropertyFloat(const char* szName, 
		float fErrorReturn = 10e10f) const;

	
	




	const std::string GetPropertyString(const char* szName,
		const std::string& sErrorReturn = "") const;

	
	




	const aiMatrix4x4 GetPropertyMatrix(const char* szName,
		const aiMatrix4x4& sErrorReturn = aiMatrix4x4()) const;

	
	













	void SetIOHandler( IOSystem* pIOHandler);

	
	






	IOSystem* GetIOHandler() const;

	
	




	bool IsDefaultIOHandler() const;

	
	









	void SetProgressHandler ( ProgressHandler* pHandler );

	
	






	ProgressHandler* GetProgressHandler() const;

	
	




	bool IsDefaultProgressHandler() const;

	
	










	bool ValidateFlags(unsigned int pFlags) const;

	
	




















	const aiScene* ReadFile(
		const char* pFile, 
		unsigned int pFlags);

	
	



































	const aiScene* ReadFileFromMemory( 
		const void* pBuffer,
		size_t pLength,
		unsigned int pFlags,
		const char* pHint = "");

	
	
















	const aiScene* ApplyPostProcessing(unsigned int pFlags);

	
	




	const aiScene* ReadFile(
		const std::string& pFile, 
		unsigned int pFlags);

	
	




	void FreeScene( );

	
	







	const char* GetErrorString() const;

	
	


	const aiScene* GetScene() const;

	
	

















	aiScene* GetOrphanedScene();




	
	





	bool IsExtensionSupported(const char* szExtension) const;

	
	




	inline bool IsExtensionSupported(const std::string& szExtension) const;

	
	








	void GetExtensionList(aiString& szOut) const;

	
	




	inline void GetExtensionList(std::string& szOut) const;

	
	
	size_t GetImporterCount() const;

	
	






	const aiImporterDesc* GetImporterInfo(size_t index) const;

	
	




	BaseImporter* GetImporter(size_t index) const;

	
	








	BaseImporter* GetImporter (const char* szExtension) const;

	
	






	size_t GetImporterIndex (const char* szExtension) const;




	
	







	void GetMemoryRequirements(aiMemoryInfo& in) const;

	
	





	void SetExtraVerbose(bool bDo);


	
	
	ImporterPimpl* Pimpl() { return pimpl; };
	const ImporterPimpl* Pimpl() const { return pimpl; };

protected:

	
	ImporterPimpl* pimpl;
}; 









__forceinline const aiScene* Importer::ReadFile( const std::string& pFile,unsigned int pFlags){
	return ReadFile(pFile.c_str(),pFlags);
}

__forceinline void Importer::GetExtensionList(std::string& szOut) const	{
	aiString s;
	GetExtensionList(s);
	szOut = s.data;
}

__forceinline bool Importer::IsExtensionSupported(const std::string& szExtension) const	{
	return IsExtensionSupported(szExtension.c_str());
}

} 
#line 660 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\importer.hpp"

#line 6 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shaderbuilder.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"
















































#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\texture.h"
























































extern "C" {
#line 59 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\texture.h"











#line 71 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\texture.h"


#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"

























#pragma pack(push,1)









#line 37 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#pragma warning (disable : 4103) 
#line 43 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#line 74 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\texture.h"






struct aiTexel
{
	unsigned char b,g,r,a;


	
	bool operator== (const aiTexel& other) const
	{
		return b == other.b && r == other.r &&
			   g == other.g && a == other.a;
	}

	
	bool operator!= (const aiTexel& other) const
	{
		return b != other.b || r != other.r ||
			   g != other.g || a != other.a;
	}

	
	operator aiColor4D() const
	{
		return aiColor4D(r/255.f,g/255.f,b/255.f,a/255.f);
	}
#line 105 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\texture.h"

} ;

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"

















#pragma pack( pop )
#line 20 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"



#line 109 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\texture.h"











struct aiTexture
{
	





	unsigned int mWidth;

	




	unsigned int mHeight;

	











	char achFormatHint[4];

	








	 aiTexel* pcData;



	
	
	
	
	
	bool CheckFormat(const char* s) const
	{
		return (0 == ::strncmp(achFormatHint,s,3));
	}

	
	aiTexture ()
		: mWidth  (0)
		, mHeight (0)
		, pcData  (0)
	{
		achFormatHint[0] = achFormatHint[1] = 0;
		achFormatHint[2] = achFormatHint[3] = 0;
	}

	
	~aiTexture ()
	{
		delete[] pcData;
	}
#line 190 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\texture.h"
};



}
#line 196 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\texture.h"

#line 198 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\texture.h"
#line 50 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"



















































extern "C" {
#line 54 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"












#line 67 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"






#line 74 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"






#line 81 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"






#line 88 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"






#line 95 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"






#line 102 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"























struct aiFace
{
	
	
	unsigned int mNumIndices; 

	
	unsigned int* mIndices;   



	
	aiFace()
      : mNumIndices( 0 )
      , mIndices( 0 )
	{
	}

	
	~aiFace()
	{
		delete [] mIndices;
	}

	
	aiFace( const aiFace& o)
      : mIndices( 0 )
	{
		*this = o;
	}

	
	aiFace& operator = ( const aiFace& o)
	{
		if (&o == this)
			return *this;

		delete[] mIndices;
		mNumIndices = o.mNumIndices;
		if (mNumIndices) {
			mIndices = new unsigned int[mNumIndices];
			::memcpy( mIndices, o.mIndices, mNumIndices * sizeof( unsigned int));
		}
		else {
			mIndices = 0;
		}
		return *this;
	}

	
	
	bool operator== (const aiFace& o) const
	{
		if (mIndices == o.mIndices)return true;
		else if (mIndices && mNumIndices == o.mNumIndices)
		{
			for (unsigned int i = 0;i < this->mNumIndices;++i)
				if (mIndices[i] != o.mIndices[i])return false;
			return true;
		}
		return false;
	}

	
	
	bool operator != (const aiFace& o) const
	{
		return !(*this == o);
	}
#line 195 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"
}; 





struct aiVertexWeight
{
	
	unsigned int mVertexId;

	
	
	float mWeight;     



	
	aiVertexWeight() { }

	
	
	
	aiVertexWeight( unsigned int pID, float pWeight) 
		: mVertexId( pID), mWeight( pWeight) 
	{  }

#line 223 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"
};









struct aiBone
{
	
	 aiString mName;

	
	
	unsigned int mNumWeights;

	
	 aiVertexWeight* mWeights;

	
	 aiMatrix4x4 mOffsetMatrix;



	
	aiBone()
      : mNumWeights( 0 )
      , mWeights( 0 )
	{
	}

	
	aiBone(const aiBone& other)
      : mName( other.mName )
      , mNumWeights( other.mNumWeights )
      , mOffsetMatrix( other.mOffsetMatrix )
	{
		if (other.mWeights && other.mNumWeights)
		{
			mWeights = new aiVertexWeight[mNumWeights];
			::memcpy(mWeights,other.mWeights,mNumWeights * sizeof(aiVertexWeight));
		}
	}

	
	~aiBone()
	{
		delete [] mWeights;
	}
#line 276 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"
};










enum aiPrimitiveType
{
	




	aiPrimitiveType_POINT       = 0x1,

	




	aiPrimitiveType_LINE        = 0x2,

	



	aiPrimitiveType_TRIANGLE    = 0x4,

	






	aiPrimitiveType_POLYGON     = 0x8,


	



	_aiPrimitiveType_Force32Bit = 2147483647
#line 325 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"
}; 


















struct aiAnimMesh
{
	





	 aiVector3D* mVertices;

	
	 aiVector3D* mNormals;

	
	 aiVector3D* mTangents;

	
	 aiVector3D* mBitangents;

	
	 aiColor4D* mColors[0x8];

	
	 aiVector3D* mTextureCoords[0x8];

	







	unsigned int mNumVertices;



	aiAnimMesh()
		: mVertices( 0 )
		, mNormals( 0 )
		, mTangents( 0 )
		, mBitangents( 0 )
		, mNumVertices( 0 )
	{
		
		for( unsigned int a = 0; a < 0x8; a++){
			mTextureCoords[a] = 0;
		}
		for( unsigned int a = 0; a < 0x8; a++) {
			mColors[a] = 0;
		}
	}
	
	~aiAnimMesh()
	{
		delete [] mVertices; 
		delete [] mNormals;
		delete [] mTangents;
		delete [] mBitangents;
		for( unsigned int a = 0; a < 0x8; a++) {
			delete [] mTextureCoords[a];
		}
		for( unsigned int a = 0; a < 0x8; a++) {
			delete [] mColors[a];
		}
	}

	
 
	bool HasPositions() const {
		return mVertices != 0; 
	}

	
 
	bool HasNormals() const { 
		return mNormals != 0; 
	}

	

 
	bool HasTangentsAndBitangents() const { 
		return mTangents != 0; 
	}

	

 
	bool HasVertexColors( unsigned int pIndex) const	{ 
		return pIndex >= 0x8 ? false : mColors[pIndex] != 0; 
	}

	

 
	bool HasTextureCoords( unsigned int pIndex) const	{ 
		return pIndex >= 0x8 ? false : mTextureCoords[pIndex] != 0; 
	}

#line 445 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"
};





















struct aiMesh
{
	




	unsigned int mPrimitiveTypes;

	



	unsigned int mNumVertices;

	



	unsigned int mNumFaces;

	



	 aiVector3D* mVertices;

	



















	 aiVector3D* mNormals;

	











	 aiVector3D* mTangents;

	






	 aiVector3D* mBitangents;

	




	 aiColor4D* mColors[0x8];

	



	 aiVector3D* mTextureCoords[0x8];

	






	unsigned int mNumUVComponents[0x8];

	





	 aiFace* mFaces;

	


	unsigned int mNumBones;

	



	 aiBone** mBones;

	




	unsigned int mMaterialIndex;

	










	 aiString mName;


	
	unsigned int mNumAnimMeshes;

	


	 aiAnimMesh** mAnimMeshes;




	
	aiMesh()
		: mPrimitiveTypes( 0 )
		, mNumVertices( 0 )
		, mNumFaces( 0 )
		, mVertices( 0 )
		, mNormals( 0 )
		, mTangents( 0 )
		, mBitangents( 0 )
		, mFaces( 0 )
		, mNumBones( 0 )
		, mBones( 0 )
		, mMaterialIndex( 0 )
		, mNumAnimMeshes( 0 )
		, mAnimMeshes( 0 )
	{
		for( unsigned int a = 0; a < 0x8; a++)
		{
			mNumUVComponents[a] = 0;
			mTextureCoords[a] = 0;
		}
      
		for( unsigned int a = 0; a < 0x8; a++)
			mColors[a] = 0;
	}

	
	~aiMesh()
	{
		delete [] mVertices; 
		delete [] mNormals;
		delete [] mTangents;
		delete [] mBitangents;
		for( unsigned int a = 0; a < 0x8; a++) {
			delete [] mTextureCoords[a];
		}
		for( unsigned int a = 0; a < 0x8; a++) {
			delete [] mColors[a];
		}

		
		if (mNumBones && mBones)	{
			for( unsigned int a = 0; a < mNumBones; a++) {
				delete mBones[a];
			}
			delete [] mBones;
		}

		if (mNumAnimMeshes && mAnimMeshes)	{
			for( unsigned int a = 0; a < mNumAnimMeshes; a++) {
				delete mAnimMeshes[a];
			}
			delete [] mAnimMeshes;
		}

		delete [] mFaces;
	}

	
	
	
	bool HasPositions() const 
		{ return mVertices != 0 && mNumVertices > 0; }

	
	
	bool HasFaces() const 
		{ return mFaces != 0 && mNumFaces > 0; }

	
	bool HasNormals() const 
		{ return mNormals != 0 && mNumVertices > 0; }

	
	
	
	
	bool HasTangentsAndBitangents() const 
		{ return mTangents != 0 && mBitangents != 0 && mNumVertices > 0; }

	
	
	bool HasVertexColors( unsigned int pIndex) const
	{ 
		if( pIndex >= 0x8) 
			return false; 
		else 
			return mColors[pIndex] != 0 && mNumVertices > 0; 
	}

	
	
	bool HasTextureCoords( unsigned int pIndex) const
	{ 
		if( pIndex >= 0x8) 
			return false; 
		else 
			return mTextureCoords[pIndex] != 0 && mNumVertices > 0; 
	}

	
	unsigned int GetNumUVChannels() const 
	{
		unsigned int n = 0;
		while (n < 0x8 && mTextureCoords[n])++n;
		return n;
	}

	
	unsigned int GetNumColorChannels() const 
	{
		unsigned int n = 0;
		while (n < 0x8 && mColors[n])++n;
		return n;
	}

	
	inline bool HasBones() const
		{ return mBones != 0 && mNumBones > 0; }

#line 733 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"
};



}
#line 739 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"
#line 740 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\mesh.h"

#line 51 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\light.h"



















































extern "C" {
#line 54 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\light.h"




enum aiLightSourceType
{
	aiLightSource_UNDEFINED     = 0x0,

	
	
	
	aiLightSource_DIRECTIONAL   = 0x1,

	
	
	
	aiLightSource_POINT         = 0x2,

	
	
	
	
	aiLightSource_SPOT          = 0x3,


	



	_aiLightSource_Force32Bit = 2147483647
#line 85 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\light.h"
};














struct aiLight
{
	





	 aiString mName;

	



	 aiLightSourceType mType;

	




	 aiVector3D mPosition;

	





	 aiVector3D mDirection;

	









	float mAttenuationConstant;

	









	float mAttenuationLinear;

	









	float mAttenuationQuadratic;

	





	 aiColor3D mColorDiffuse;

	





	 aiColor3D mColorSpecular;

	







	 aiColor3D mColorAmbient;

	





	float mAngleInnerCone;

	









	float mAngleOuterCone;



	aiLight()
		:	mType                 (aiLightSource_UNDEFINED)
		,	mAttenuationConstant  (0.f)
		,   mAttenuationLinear    (1.f)
		,   mAttenuationQuadratic (0.f)
		,	mAngleInnerCone       ((float)((3.141592653589793238462643383279 ) * 2.0))
		,	mAngleOuterCone       ((float)((3.141592653589793238462643383279 ) * 2.0))
	{
	}

#line 226 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\light.h"
};


}
#line 231 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\light.h"


#line 234 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\light.h"
#line 52 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\camera.h"



















































extern "C" {
#line 54 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\camera.h"












































struct aiCamera
{
	





	 aiString mName;

	




	 aiVector3D mPosition;


	







	 aiVector3D mUp;


	






	 aiVector3D mLookAt;


	





	float mHorizontalFOV;

	




	float mClipPlaneNear;

	







	float mClipPlaneFar;


	






	float mAspect;



	aiCamera()
		: mUp				(0.f,1.f,0.f)
		, mLookAt			(0.f,0.f,1.f)
		, mHorizontalFOV	(0.25f * (float)(3.141592653589793238462643383279 ))
		, mClipPlaneNear	(0.1f)
		, mClipPlaneFar		(1000.f)
		, mAspect			(0.f)
	{}

	


	void GetCameraMatrix (aiMatrix4x4& out) const 
	{
		

		
		aiVector3D zaxis = mLookAt;     zaxis.Normalize();
		aiVector3D yaxis = mUp;         yaxis.Normalize();
		aiVector3D xaxis = mUp^mLookAt; xaxis.Normalize();

		out.a4 = -(xaxis * mPosition);
		out.b4 = -(yaxis * mPosition);
		out.c4 = -(zaxis * mPosition);

		out.a1 = xaxis.x;
		out.a2 = xaxis.y;
		out.a3 = xaxis.z;
		
		out.b1 = yaxis.x;
		out.b2 = yaxis.y;
		out.b3 = yaxis.z;

		out.c1 = zaxis.x;
		out.c2 = zaxis.y;
		out.c3 = zaxis.z;

		out.d1 = out.d2 = out.d3 = 0.f;
		out.d4 = 1.f;
	}

#line 216 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\camera.h"
};



}
#line 222 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\camera.h"

#line 224 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\camera.h"
#line 53 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"



















































extern "C" {
#line 54 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"























enum aiTextureOp
{
	
	aiTextureOp_Multiply = 0x0,

	
	aiTextureOp_Add = 0x1,

	
	aiTextureOp_Subtract = 0x2,

	
	aiTextureOp_Divide = 0x3,

	
	aiTextureOp_SmoothAdd = 0x4,

	
	aiTextureOp_SignedAdd = 0x5,


	




	_aiTextureOp_Force32Bit = 2147483647
#line 105 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
	
};






enum aiTextureMapMode
{
    

    aiTextureMapMode_Wrap = 0x0,

    


    aiTextureMapMode_Clamp = 0x1,

	


    aiTextureMapMode_Decal = 0x3,

    


    aiTextureMapMode_Mirror = 0x2,

	 




	_aiTextureMapMode_Force32Bit = 2147483647
#line 141 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
	
};










enum aiTextureMapping
{
    





    aiTextureMapping_UV = 0x0,

	 
    aiTextureMapping_SPHERE = 0x1,

	 
    aiTextureMapping_CYLINDER = 0x2,

	 
    aiTextureMapping_BOX = 0x3,

	 
    aiTextureMapping_PLANE = 0x4,

	 
    aiTextureMapping_OTHER = 0x5,


	 




	_aiTextureMapping_Force32Bit = 2147483647
#line 186 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
	
};
















enum aiTextureType
{
	





	aiTextureType_NONE = 0x0,



    


    aiTextureType_DIFFUSE = 0x1,

	


    aiTextureType_SPECULAR = 0x2,

	


    aiTextureType_AMBIENT = 0x3,

	


    aiTextureType_EMISSIVE = 0x4,

	




    aiTextureType_HEIGHT = 0x5,

	





    aiTextureType_NORMALS = 0x6,

	






    aiTextureType_SHININESS = 0x7,

	




    aiTextureType_OPACITY = 0x8,

	




    aiTextureType_DISPLACEMENT = 0x9,

	






    aiTextureType_LIGHTMAP = 0xA,

	




    aiTextureType_REFLECTION = 0xB,

	





    aiTextureType_UNKNOWN = 0xC,


	 




	_aiTextureType_Force32Bit = 2147483647
#line 306 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
	
};















enum aiShadingMode
{
    


    aiShadingMode_Flat = 0x1,

    

    aiShadingMode_Gouraud =	0x2,

    

    aiShadingMode_Phong = 0x3,

    

    aiShadingMode_Blinn	= 0x4,

    



    aiShadingMode_Toon = 0x5,

    




    aiShadingMode_OrenNayar = 0x6,

    




    aiShadingMode_Minnaert = 0x7,

    



    aiShadingMode_CookTorrance = 0x8,

    

    aiShadingMode_NoShading = 0x9,

	 

    aiShadingMode_Fresnel = 0xa,


	 




	_aiShadingMode_Force32Bit = 2147483647
#line 384 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
	
};













enum aiTextureFlags
{
	

	aiTextureFlags_Invert = 0x1,

	








	aiTextureFlags_UseAlpha = 0x2,

	




	aiTextureFlags_IgnoreAlpha = 0x4,
	
	 




	  _aiTextureFlags_Force32Bit = 2147483647
#line 430 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
	
};


















enum aiBlendMode
{
	





	aiBlendMode_Default = 0x0,

	






	aiBlendMode_Additive = 0x1,

	
	

	 




	_aiBlendMode_Force32Bit = 2147483647
#line 479 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
	
};


#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"

























#pragma pack(push,1)









#line 37 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#pragma warning (disable : 4103) 
#line 43 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\pushpack1.h"




#line 484 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"











struct aiUVTransform
{
	



	 aiVector2D mTranslation;

	



	 aiVector2D mScaling;

	





	float mRotation;



	aiUVTransform()
		:	mScaling	(1.f,1.f)
		,	mRotation	(0.f)
	{
		
	}
#line 526 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"

} ;

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"

















#pragma pack( pop )
#line 20 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\compiler\\poppack1.h"



#line 530 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"






enum aiPropertyTypeInfo
{
    





    aiPTI_Float   = 0x1,

    




    aiPTI_String  = 0x3,

    





    aiPTI_Integer = 0x4,


    

    aiPTI_Buffer  = 0x5,


	 



	 _aiPTI_Force32Bit = 2147483647
#line 573 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
};





















struct aiMaterialProperty
{
    


     aiString mKey;

	



	unsigned int mSemantic;

	


	unsigned int mIndex;

    


    unsigned int mDataLength;

    






     aiPropertyTypeInfo mType;

    


    char* mData;



	aiMaterialProperty()
		: mSemantic( 0 )
		, mIndex( 0 )
		, mDataLength( 0 )
		, mType( aiPTI_Float )
		, mData( 0 )
	{
	}

	~aiMaterialProperty()	{
		delete[] mData;
	}

#line 648 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
};



} 
#line 654 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"











struct  aiMaterial


#line 669 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
{



public:

	aiMaterial();
	~aiMaterial();

	
    










    template <typename Type>
    aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx, Type* pOut, unsigned int* pMax) const;

	aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx, int* pOut, unsigned int* pMax) const;

	aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx, float* pOut, unsigned int* pMax) const;

    
    








	template <typename Type>
	aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx,Type& pOut) const;


	aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx, int& pOut) const;

	aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx, float& pOut) const;

	aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx, aiString& pOut) const;

	aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx, aiColor3D& pOut) const;

	aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx, aiColor4D& pOut) const;

	aiReturn Get(const char* pKey,unsigned int type,
		unsigned int idx, aiUVTransform& pOut) const;

	
	



	unsigned int GetTextureCount(aiTextureType type) const;

	
	

























	
	aiReturn GetTexture(aiTextureType type,
		unsigned int  index,
		 aiString* path,
		aiTextureMapping* mapping	= 0,
		unsigned int* uvindex		= 0,
		float* blend				   = 0,
		aiTextureOp* op				= 0,
		aiTextureMapMode* mapmode	= 0) const; 


	


	
	








	aiReturn AddBinaryProperty (const void* pInput,
		unsigned int pSizeInBytes,
		const char* pKey,
		unsigned int type ,
		unsigned int index ,
		aiPropertyTypeInfo pType);

	
	






	aiReturn AddProperty (const aiString* pInput,
		const char* pKey,
		unsigned int type  = 0,
		unsigned int index = 0);

	
	





	template<class TYPE>
	aiReturn AddProperty (const TYPE* pInput,
		unsigned int pNumValues,
		const char* pKey,
		unsigned int type  = 0,
		unsigned int index = 0);

	aiReturn AddProperty (const aiVector3D* pInput,
		unsigned int pNumValues,
		const char* pKey,
		unsigned int type  = 0,
		unsigned int index = 0);

	aiReturn AddProperty (const aiColor3D* pInput,
		unsigned int pNumValues,
		const char* pKey,
		unsigned int type  = 0,
		unsigned int index = 0);

	aiReturn AddProperty (const aiColor4D* pInput,
		unsigned int pNumValues,
		const char* pKey,
		unsigned int type  = 0,
		unsigned int index = 0);

	aiReturn AddProperty (const int* pInput,
		unsigned int pNumValues,
		const char* pKey,
		unsigned int type  = 0,
		unsigned int index = 0);

	aiReturn AddProperty (const float* pInput,
		unsigned int pNumValues,
		const char* pKey,
		unsigned int type  = 0,
		unsigned int index = 0);

	aiReturn AddProperty (const aiUVTransform* pInput,
		unsigned int pNumValues,
		const char* pKey,
		unsigned int type  = 0,
		unsigned int index = 0);

	
	



	aiReturn RemoveProperty (const char* pKey,
		unsigned int type  = 0,
		unsigned int index = 0);

	
	


	void Clear();

	
	



	static void CopyPropertyList(aiMaterial* pcDest, 
		const aiMaterial* pcSrc);


#line 886 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"

    
     aiMaterialProperty** mProperties;

    
    unsigned int mNumProperties;

	 
    unsigned int mNumAllocated;
};



extern "C" {
#line 901 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"



























































































































































































































































































































































































































































  aiReturn aiGetMaterialProperty(
	 const  aiMaterial* pMat, 
    const char* pKey,
	 unsigned int type,
    unsigned int  index,
    const  aiMaterialProperty** pPropOut);



























  aiReturn aiGetMaterialFloatArray(
	 const  aiMaterial* pMat, 
    const char* pKey,
	 unsigned int type,
    unsigned int index,
    float* pOut,
    unsigned int* pMax);























inline aiReturn aiGetMaterialFloat(const aiMaterial* pMat, 
	const char* pKey,
	unsigned int type,
   unsigned int index,
	float* pOut)
{
	return aiGetMaterialFloatArray(pMat,pKey,type,index,pOut,(unsigned int*)0x0);
}







#line 1423 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"







  aiReturn aiGetMaterialIntegerArray(const  aiMaterial* pMat, 
    const char* pKey,
	 unsigned int  type,
	 unsigned int  index,
    int* pOut,
    unsigned int* pMax);









inline aiReturn aiGetMaterialInteger(const  aiMaterial* pMat, 
	const char* pKey,
	unsigned int type,
   unsigned int index,
	int* pOut)
{
	return aiGetMaterialIntegerArray(pMat,pKey,type,index,pOut,(unsigned int*)0x0);
}







#line 1461 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"








  aiReturn aiGetMaterialColor(const  aiMaterial* pMat, 
    const char* pKey,
	 unsigned int type,
    unsigned int index,
	  aiColor4D* pOut);







  aiReturn aiGetMaterialUVTransform(const  aiMaterial* pMat, 
    const char* pKey,
	 unsigned int type,
    unsigned int index,
	  aiUVTransform* pOut);







  aiReturn aiGetMaterialString(const  aiMaterial* pMat, 
    const char* pKey,
	 unsigned int type,
    unsigned int index,
     aiString* pOut);








 unsigned int aiGetMaterialTextureCount(const  aiMaterial* pMat,  
	 aiTextureType type);



































 aiReturn aiGetMaterialTexture(const  aiMaterial* mat,
	aiTextureType type,
    unsigned int  index,
    aiString* path,
	aiTextureMapping* mapping	= 0,
    unsigned int* uvindex		= 0,
    float* blend				= 0,
    aiTextureOp* op				= 0,
	aiTextureMapMode* mapmode	= 0,
	unsigned int* flags         = 0); 











#line 1565 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"


}

#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.inl"



















































inline aiReturn aiMaterial::GetTexture( aiTextureType type,
   unsigned int  index,
    aiString* path,
   aiTextureMapping* mapping	,
   unsigned int* uvindex		,
   float* blend				   ,
   aiTextureOp* op				,
   aiTextureMapMode* mapmode	) const
{
	return ::aiGetMaterialTexture(this,type,index,path,mapping,uvindex,blend,op,mapmode);
}


inline unsigned int aiMaterial::GetTextureCount(aiTextureType type) const
{
	return ::aiGetMaterialTextureCount(this,type);
}


template <typename Type>
inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx, Type* pOut,
	unsigned int* pMax) const
{
	unsigned int iNum = pMax ? *pMax : 1;

	const aiMaterialProperty* prop;
	const aiReturn ret = ::aiGetMaterialProperty(this,pKey,type,idx,
		(const aiMaterialProperty**)&prop);
	if ( aiReturn_SUCCESS == ret )	{

		if (prop->mDataLength < sizeof(Type)*iNum) {
			return aiReturn_FAILURE;
		}

		if (prop->mType != aiPTI_Buffer) {
			return aiReturn_FAILURE;
		}

		iNum = std::min((size_t)iNum,prop->mDataLength / sizeof(Type));
		::memcpy(pOut,prop->mData,iNum * sizeof(Type));
		if (pMax) {
			*pMax = iNum;
		}
	}
	return ret;
}


template <typename Type>
inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx,Type& pOut) const
{
	const aiMaterialProperty* prop;
	const aiReturn ret = ::aiGetMaterialProperty(this,pKey,type,idx,
		(const aiMaterialProperty**)&prop);
	if ( aiReturn_SUCCESS == ret )	{

		if (prop->mDataLength < sizeof(Type)) {
			return aiReturn_FAILURE;
		}

		if (prop->mType != aiPTI_Buffer) {
			return aiReturn_FAILURE;
		}

		::memcpy(&pOut,prop->mData,sizeof(Type));
	}
	return ret;
}


inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx,float* pOut,
	unsigned int* pMax) const
{
	return ::aiGetMaterialFloatArray(this,pKey,type,idx,pOut,pMax);
}

inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx,int* pOut,
	unsigned int* pMax) const
{
	return ::aiGetMaterialIntegerArray(this,pKey,type,idx,pOut,pMax);
}

inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx,float& pOut) const
{
	return aiGetMaterialFloat(this,pKey,type,idx,&pOut);
}

inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx,int& pOut) const
{
	return aiGetMaterialInteger(this,pKey,type,idx,&pOut);
}

inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx,aiColor4D& pOut) const
{
	return aiGetMaterialColor(this,pKey,type,idx,&pOut);
}

inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx,aiColor3D& pOut) const
{
	aiColor4D c;
	const aiReturn ret = aiGetMaterialColor(this,pKey,type,idx,&c);
	pOut = aiColor3D(c.r,c.g,c.b);
	return ret;
}

inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx,aiString& pOut) const
{
	return aiGetMaterialString(this,pKey,type,idx,&pOut);
}

inline aiReturn aiMaterial::Get(const char* pKey,unsigned int type,
	unsigned int idx,aiUVTransform& pOut) const
{
	return aiGetMaterialUVTransform(this,pKey,type,idx,&pOut);
}



template<class TYPE>
aiReturn aiMaterial::AddProperty (const TYPE* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(TYPE),
		pKey,type,index,aiPTI_Buffer);
}


inline aiReturn aiMaterial::AddProperty(const float* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(float),
		pKey,type,index,aiPTI_Float);
}


inline aiReturn aiMaterial::AddProperty(const aiUVTransform* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(aiUVTransform),
		pKey,type,index,aiPTI_Float);
}


inline aiReturn aiMaterial::AddProperty(const aiColor4D* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(aiColor4D),
		pKey,type,index,aiPTI_Float);
}


inline aiReturn aiMaterial::AddProperty(const aiColor3D* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(aiColor3D),
		pKey,type,index,aiPTI_Float);
}


inline aiReturn aiMaterial::AddProperty(const aiVector3D* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(aiVector3D),
		pKey,type,index,aiPTI_Float);
}


inline aiReturn aiMaterial::AddProperty(const int* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(int),
		pKey,type,index,aiPTI_Integer);
}









template<>
inline aiReturn aiMaterial::AddProperty<float>(const float* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(float),
		pKey,type,index,aiPTI_Float);
}


template<>
inline aiReturn aiMaterial::AddProperty<aiUVTransform>(const aiUVTransform* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(aiUVTransform),
		pKey,type,index,aiPTI_Float);
}


template<>
inline aiReturn aiMaterial::AddProperty<aiColor4D>(const aiColor4D* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(aiColor4D),
		pKey,type,index,aiPTI_Float);
}


template<>
inline aiReturn aiMaterial::AddProperty<aiColor3D>(const aiColor3D* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(aiColor3D),
		pKey,type,index,aiPTI_Float);
}


template<>
inline aiReturn aiMaterial::AddProperty<aiVector3D>(const aiVector3D* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(aiVector3D),
		pKey,type,index,aiPTI_Float);
}


template<>
inline aiReturn aiMaterial::AddProperty<int>(const int* pInput,
	const unsigned int pNumValues,
	const char* pKey,
	unsigned int type,
	unsigned int index)
{
	return AddBinaryProperty((const void*)pInput,
		pNumValues * sizeof(int),
		pKey,type,index,aiPTI_Integer);
}



#line 351 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.inl"
#line 1570 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"

#line 1572 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"
#line 1573 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\material.h"

#line 54 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"




















































extern "C" {
#line 55 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"



struct aiVectorKey
{
	
	double mTime;     
	
	
	 aiVector3D mValue; 



	
	aiVectorKey(){}

	
	aiVectorKey(double time, const aiVector3D& value)
		:	mTime	(time)
		,	mValue	(value)
	{}


	typedef aiVector3D elem_type;

	
	bool operator == (const aiVectorKey& o) const {
		return o.mValue == this->mValue;
	}
	bool operator != (const aiVectorKey& o) const {
		return o.mValue != this->mValue;
	}

	
	bool operator < (const aiVectorKey& o) const {
		return mTime < o.mTime;
	}
	bool operator > (const aiVectorKey& o) const {
		return mTime > o.mTime;
	}
#line 96 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"
};




struct aiQuatKey
{
	
	double mTime;     

	
	 aiQuaternion mValue; 


	aiQuatKey(){
	}

	
	aiQuatKey(double time, const aiQuaternion& value)
		:	mTime	(time)
		,	mValue	(value)
	{}

	typedef aiQuaternion elem_type;

	
	bool operator == (const aiQuatKey& o) const {
		return o.mValue == this->mValue;
	}
	bool operator != (const aiQuatKey& o) const {
		return o.mValue != this->mValue;
	}

	
	bool operator < (const aiQuatKey& o) const {
		return mTime < o.mTime;
	}
	bool operator > (const aiQuatKey& o) const {
		return mTime > o.mTime;
	}
#line 137 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"
};



struct aiMeshKey 
{
	
	double mTime;

	



	unsigned int mValue;



	aiMeshKey() {
	}

	
	aiMeshKey(double time, const unsigned int value)
		:	mTime	(time)
		,	mValue	(value)
	{}

	typedef unsigned int elem_type;

	
	bool operator == (const aiMeshKey& o) const {
		return o.mValue == this->mValue;
	}
	bool operator != (const aiMeshKey& o) const {
		return o.mValue != this->mValue;
	}

	
	bool operator < (const aiMeshKey& o) const {
		return mTime < o.mTime;
	}
	bool operator > (const aiMeshKey& o) const {
		return mTime > o.mTime;
	}

#line 182 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"
};





enum aiAnimBehaviour
{
	
	aiAnimBehaviour_DEFAULT  = 0x0,  

	
	aiAnimBehaviour_CONSTANT = 0x1,

	

	aiAnimBehaviour_LINEAR   = 0x2,

	



	aiAnimBehaviour_REPEAT   = 0x3,



	


	_aiAnimBehaviour_Force32Bit = 2147483647
#line 213 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"
};
















struct aiNodeAnim
{
	

	 aiString mNodeName;

	
	unsigned int mNumPositionKeys;

	




	 aiVectorKey* mPositionKeys;

	
	unsigned int mNumRotationKeys;

	





	 aiQuatKey* mRotationKeys;


	
	unsigned int mNumScalingKeys;

	




	 aiVectorKey* mScalingKeys;


	




	 aiAnimBehaviour mPreState;

	




	 aiAnimBehaviour mPostState;


	aiNodeAnim()
	{
		mNumPositionKeys = 0; mPositionKeys = 0; 
		mNumRotationKeys = 0; mRotationKeys = 0; 
		mNumScalingKeys  = 0; mScalingKeys  = 0; 

		mPreState = mPostState = aiAnimBehaviour_DEFAULT;
	}

	~aiNodeAnim()
	{
		delete [] mPositionKeys;
		delete [] mRotationKeys;
		delete [] mScalingKeys;
	}
#line 300 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"
};







struct aiMeshAnim
{
	



	 aiString mName;

	
	unsigned int mNumKeys;

	
	 aiMeshKey* mKeys;



	aiMeshAnim()
		: mNumKeys()
		, mKeys()
	{}

	~aiMeshAnim()
	{
		delete[] mKeys;
	}

#line 335 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"
};




struct aiAnimation
{
	


	 aiString mName;

	
	double mDuration;

	
	double mTicksPerSecond;

	

	unsigned int mNumChannels;

	

	 aiNodeAnim** mChannels;


	

	unsigned int mNumMeshChannels;

	

	 aiMeshAnim** mMeshChannels;


	aiAnimation()
		: mDuration(-1.)
		, mTicksPerSecond()
		, mNumChannels()
		, mChannels()
		, mNumMeshChannels()
		, mMeshChannels()
	{
	}

	~aiAnimation()
	{
		
		if (mNumChannels && mChannels)	{
			for( unsigned int a = 0; a < mNumChannels; a++) {
				delete mChannels[a];
			}

		delete [] mChannels;
		}
		if (mNumMeshChannels && mMeshChannels)	{
			for( unsigned int a = 0; a < mNumMeshChannels; a++) {
				delete mMeshChannels[a];
			}

		delete [] mMeshChannels;
		}
	}
#line 400 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"
};


}



namespace Assimp {






template <typename T>
struct Interpolator		
{	
	
	




	void operator () (T& out,const T& a, const T& b, float d) const {
		out = a + (b-a)*d;
	}
}; 



template <>
struct Interpolator	<aiQuaternion>	{	
	void operator () (aiQuaternion& out,const aiQuaternion& a, 
		const aiQuaternion& b, float d) const
	{
		aiQuaternion::Interpolate(out,a,b,d);
	}
}; 

template <>
struct Interpolator	<unsigned int>	{	
	void operator () (unsigned int& out,unsigned int a, 
		unsigned int b, float d) const
	{
		out = d>0.5f ? b : a;
	}
}; 

template <>
struct Interpolator	 <aiVectorKey>	{	
	void operator () (aiVector3D& out,const aiVectorKey& a,
		const aiVectorKey& b, float d) const	
	{
		Interpolator<aiVector3D> ipl;
		ipl(out,a.mValue,b.mValue,d);
	}
}; 

template <>
struct Interpolator <aiQuatKey>		{
	void operator () (aiQuaternion& out, const aiQuatKey& a,
		const aiQuatKey& b, float d) const
	{
		Interpolator<aiQuaternion> ipl;
		ipl(out,a.mValue,b.mValue,d);
	}
}; 

template <>
struct Interpolator <aiMeshKey>		{
	void operator () (unsigned int& out, const aiMeshKey& a,
		const aiMeshKey& b, float d) const
	{
		Interpolator<unsigned int> ipl;
		ipl(out,a.mValue,b.mValue,d);
	}
}; 


} 



#line 484 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"
#line 485 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\anim.h"
#line 55 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h"















































#line 1 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"









#line 11 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"



__pragma(pack(push, 8)) extern "C" {











    __declspec(dllimport) void __cdecl _wassert(
          wchar_t const* _Message,
          wchar_t const* _File,
            unsigned       _Line
        );

    




#line 38 "c:\\program files (x86)\\windows kits\\10\\include\\10.0.10240.0\\ucrt\\assert.h"



} __pragma(pack(pop))
#line 49 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h"



#line 53 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h"

#line 55 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h"







 
typedef enum aiMetadataType
{
	AI_BOOL = 0, 
	AI_INT = 1, 
	AI_UINT64 = 2, 
	AI_FLOAT = 3, 
	AI_AISTRING = 4,
	AI_AIVECTOR3D = 5,


	FORCE_32BIT = 2147483647
#line 75 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h"
} aiMetadataType;









 
struct aiMetadataEntry
{
	aiMetadataType mType;
	void* mData;
};













 
inline aiMetadataType GetAiType( bool ) { return AI_BOOL; }
inline aiMetadataType GetAiType( int ) { return AI_INT; }
inline aiMetadataType GetAiType( uint64_t ) { return AI_UINT64; }
inline aiMetadataType GetAiType( float ) { return AI_FLOAT; }
inline aiMetadataType GetAiType( aiString ) { return AI_AISTRING; }
inline aiMetadataType GetAiType( aiVector3D ) { return AI_AIVECTOR3D; }



#line 115 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h"









 
struct aiMetadata 
{
	
	unsigned int mNumProperties;

	
	 aiString* mKeys;

	

	 aiMetadataEntry* mValues;



	
	aiMetadata()
		
		: mNumProperties(0)
		, mKeys(0)
		, mValues(0)
	{}


	
	~aiMetadata()
	{
        delete[] mKeys;
        mKeys = 0;
		if (mValues)
		{
			
			for (unsigned i=0; i<mNumProperties; ++i)
			{
				void* data = mValues[i].mData;
				switch (mValues[i].mType) 
				{
				case AI_BOOL:
					delete static_cast<bool*>(data);
					break;
				case AI_INT:
					delete static_cast<int*>(data);
					break;
				case AI_UINT64:
					delete static_cast<uint64_t*>(data);
					break;
				case AI_FLOAT:
					delete static_cast<float*>(data);
					break;
				case AI_AISTRING:
					delete static_cast<aiString*>(data);
					break;
				case AI_AIVECTOR3D:
					delete static_cast<aiVector3D*>(data);
					break;
				default:
					(void)( (!!(false)) || (_wassert(L"false", L"d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h", (unsigned)(180)), 0) );
					break;
				}
			}

			
			delete [] mValues;
            mValues = 0;
		}
	}



	template<typename T>
	inline void Set( unsigned index, const std::string& key, const T& value )
	{
		
		(void)( (!!(index < mNumProperties)) || (_wassert(L"index < mNumProperties", L"d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h", (unsigned)(197)), 0) );

		
		mKeys[index] = key;

		
		mValues[index].mType = GetAiType(value);
		
		mValues[index].mData = new T(value);
	}

	template<typename T>
	inline bool Get( unsigned index, T& value )
	{
		
		(void)( (!!(index < mNumProperties)) || (_wassert(L"index < mNumProperties", L"d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h", (unsigned)(212)), 0) );

		
		
        if ( GetAiType( value ) != mValues[ index ].mType ) {
            return false;
        }

		
		
		value = *static_cast<T*>(mValues[index].mData);
		return true;
	}

	template<typename T>
	inline bool Get( const aiString& key, T& value )
	{
		
		for (unsigned i=0; i<mNumProperties; ++i)
			if (mKeys[i]==key)
				return Get(i, value);
		return false;
	}

	template<typename T>
	inline bool Get( const std::string& key, T& value ) {
        return Get(aiString(key), value); 
    }

#line 242 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h"

};

#line 246 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\metadata.h"


#line 56 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"


extern "C" {
#line 60 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"











struct aiNode
{
	





















	 aiString mName;

	
	 aiMatrix4x4 mTransformation;

	
	 aiNode* mParent;

	
	unsigned int mNumChildren;

	
	 aiNode** mChildren;

	
	unsigned int mNumMeshes;

	
	unsigned int* mMeshes;

	




	 aiMetadata* mMetaData;


	
	aiNode() 
		
		: mName("")
		, mParent(0)
		, mNumChildren(0)
		, mChildren(0)
		, mNumMeshes(0)
		, mMeshes(0)
		, mMetaData(0)
	{
	}
	

	
	aiNode(const std::string& name) 
		
		: mName(name)
		, mParent(0)
		, mNumChildren(0)
		, mChildren(0)
		, mNumMeshes(0)
		, mMeshes(0)
		, mMetaData(0)
	{
	}

	
	~aiNode()
	{
		
		
		if (mChildren && mNumChildren)  
		{
			for( unsigned int a = 0; a < mNumChildren; a++)
				delete mChildren[a];
		}
		delete [] mChildren;
		delete [] mMeshes;
		delete mMetaData;
	}


	






	inline const aiNode* FindNode(const aiString& name) const
	{
		return FindNode(name.data);
	}


	inline aiNode* FindNode(const aiString& name)
	{
		return FindNode(name.data);
	}


	

	inline const aiNode* FindNode(const char* name) const
	{
		if (!::strcmp( mName.data,name))return this;
		for (unsigned int i = 0; i < mNumChildren;++i)
		{
			const aiNode* const p = mChildren[i]->FindNode(name);
			if (p) {
				return p;
			}
		}
		
		return 0;
	}

	inline aiNode* FindNode(const char* name) 
	{
		if (!::strcmp( mName.data,name))return this;
		for (unsigned int i = 0; i < mNumChildren;++i)
		{
			aiNode* const p = mChildren[i]->FindNode(name);
			if (p) {
				return p;
			}
		}
		
		return 0;
	}

#line 216 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"
};




































 























struct aiScene
{

	




	unsigned int mFlags;


	






	 aiNode* mRootNode;



	
	unsigned int mNumMeshes;

	






	 aiMesh** mMeshes;



	
	unsigned int mNumMaterials;

	






	 aiMaterial** mMaterials;



	
	unsigned int mNumAnimations; 

	




	 aiAnimation** mAnimations;



	
	unsigned int mNumTextures;

	





	 aiTexture** mTextures;


	


	unsigned int mNumLights;

	




	 aiLight** mLights;


	


	unsigned int mNumCameras;

	






	 aiCamera** mCameras;



	
	 aiScene();

	
	 ~aiScene();

	
	
	inline bool HasMeshes() const 
		{ return mMeshes != 0 && mNumMeshes > 0; }

	
	
	inline bool HasMaterials() const 
		{ return mMaterials != 0 && mNumMaterials > 0; }

	
	inline bool HasLights() const 
		{ return mLights != 0 && mNumLights > 0; }

	
	inline bool HasTextures() const 
		{ return mTextures != 0 && mNumTextures > 0; }

	
	inline bool HasCameras() const 
		{ return mCameras != 0 && mNumCameras > 0; }

	
	inline bool HasAnimations() const 
		{ return mAnimations != 0 && mNumAnimations > 0; }

#line 413 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"


	

	void* mPrivate;


#line 421 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"

};


} 
#line 427 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"

#line 429 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\scene.h"
#line 7 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shaderbuilder.h"
#line 1 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\postprocess.h"

















































extern "C" {
#line 52 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\postprocess.h"













enum aiPostProcessSteps
{

	
	








	aiProcess_CalcTangentSpace = 0x1,

	
	









	aiProcess_JoinIdenticalVertices = 0x2,

	
	












	aiProcess_MakeLeftHanded = 0x4,

	
	












	aiProcess_Triangulate = 0x8,

	
	






















	aiProcess_RemoveComponent = 0x10,

	
	










	aiProcess_GenNormals = 0x20,

	
	













	aiProcess_GenSmoothNormals = 0x40,

	
	















	aiProcess_SplitLargeMeshes = 0x80,

	
	

















	aiProcess_PreTransformVertices = 0x100,

	
	












	aiProcess_LimitBoneWeights = 0x200,

	
	
























	aiProcess_ValidateDataStructure = 0x400,

	
	











	aiProcess_ImproveCacheLocality = 0x800,

	
	
















 
	aiProcess_RemoveRedundantMaterials = 0x1000,

	
	










	aiProcess_FixInfacingNormals = 0x2000,

	
	










	aiProcess_SortByPType = 0x8000,

	
	


































	aiProcess_FindDegenerates = 0x10000,

	
	











	aiProcess_FindInvalidData = 0x20000,

	
	













	aiProcess_GenUVCoords = 0x40000,

	
	













	aiProcess_TransformUVCoords = 0x80000,

	
	











	aiProcess_FindInstances = 0x100000,

	
	







	aiProcess_OptimizeMeshes  = 0x200000, 


	
	
























	aiProcess_OptimizeGraph  = 0x400000, 

	
	
















	aiProcess_FlipUVs = 0x800000, 

	
	











	aiProcess_FlipWindingOrder  = 0x1000000,

	
	


	aiProcess_SplitByBoneCount  = 0x2000000,

	
	











	aiProcess_Debone  = 0x4000000

	
	
	
};











































 
 





























 
 






















} 
#line 632 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\postprocess.h"

#line 634 "d:\\assimp-3.1.1-win-binaries\\include\\assimp\\postprocess.h"

#line 8 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shaderbuilder.h"
#line 1 "d:\\users\\stasw\\documents\\virheimur\\game - client\\material.h"
#pragma once


using namespace glm;

struct Material {
	vec3 ambient;
	vec3 diffuse;
	vec3 specular;
	vec3 emissive;
	float shininess;
};
#line 9 "d:\\users\\stasw\\documents\\virheimur\\game - client\\shaderbuilder.h"
using namespace glm;

class Materials {
public:
	static Materials& GetInstance();
	Material& operator[](string s);
private:
	Materials();
	static Materials& Instance;
	map<string, Material> MaterialMap;
};
class ShaderBuilder
{
public:

	ShaderBuilder(GLuint);
	~ShaderBuilder();
	ShaderBuilder& Add_texture(string, const GLuint);
	ShaderBuilder& Add_textures(map<string,GLuint>& Textures);
	ShaderBuilder& Add_vec2(string, const vec2&);
	ShaderBuilder& Add_vec3(string, const vec3&);
	ShaderBuilder& Add_float(string, const float&);
	ShaderBuilder& Add_bool(string name, const bool & rhs);
	ShaderBuilder& Add_int(string, const int&);
	ShaderBuilder& Add_mat3(string, const mat3&);
	ShaderBuilder& Add_mat4(string, const mat4&);
	ShaderBuilder& Add_aimat4(string name, const aiMatrix4x4 & rhs);
	ShaderBuilder& Add_Material(string, const Material & rhs);
	static std::unique_ptr<ShaderBuilder> GetCurrentProgram();
	static std::unique_ptr<ShaderBuilder> LoadShader(Shader&);
private:
	GLuint textureCount;
	GLuint shaderID;
};

class ShaderInfo
{
public:
	ShaderInfo(GLuint);
	~ShaderInfo();
	void Add_texture(string, const GLuint);
	void Add_textures(map<string, GLuint>& Textures);
	void Add_vec2(string, const vec2&);
	void Add_vec3(string, const vec3&);
	void Add_float(string, const float&);
	void Add_bool(string name, const bool & rhs);
	void Add_int(string, int&);
	void Add_mat3(string, const mat3&);
	void Add_mat4(string, const mat4&);
	void Add_aimat4(string name, const aiMatrix4x4 & rhs);
	void Add_Material(string, const Material & rhs);
	static std::unique_ptr<ShaderBuilder> GetCurrentProgram();
	static std::unique_ptr<ShaderBuilder> LoadShader(Shader&);
private:
	
	
};

#line 8 "d:\\users\\stasw\\documents\\virheimur\\game - client\\imageloader.h"





using namespace std;
using namespace glm;
class ImageLoader
{
public:
	ImageLoader();
	~ImageLoader();
	virtual void Initialize(string Filename);
	void LoadVAO();
	int LoadTexture(string Filename);
	int LoadTexture(u8vec4* ColorData, int Width, int Height);
	u8vec4* GetImageData(string Filename, int & Width, int & Height);
	void ReloadTexture(u8vec4* ColorData, int Width, int Height);
	void ReloadTexture(string Filename);
	void Draw(vec2 TopLeft, vec2 BotRight);
	void DrawImagePart(vec2 TopLeft, vec2 BotRight, vec2 ImageTrueSize,
		vec2 CropTopLeft, vec2 CropBotRight);
	vec2 GetTrueSize() { return this->TrueSize; }
	GLuint VAO, VBO, MyTexture;
private:
	struct Vertices {
		vec2 vertices;
		vec2 uvs;
	};
	vector<Vertices> vertices;
	unsigned int Vertices_Amount;
	vec2 TrueSize;
};

#line 7 "d:\\users\\stasw\\documents\\virheimur\\game - client\\text.h"
#line 1 "d:\\gl files\\freetype-2.6.2\\include\\ft2build.h"


















  
  
  
  
  
  
  
  
  
  
  
  
  





#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftheader.h"





















  
  
  
  
  
  
  
  
  
  
  




#line 38 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftheader.h"


  
  
  
  
  
  
  
  
  
  
  




#line 56 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftheader.h"


  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  

  











#line 112 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftheader.h"


  











#line 127 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftheader.h"


  











#line 142 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftheader.h"


  












#line 158 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftheader.h"

  

  

  












  














  












  















  















  














  














  












  












  












  












  












  












  












  












  














  












  













  













  













  












  












  












  












  












  












  












  












  



















  




















  















  
















  












  













  













  













  












  











  











  










  



  












  











  











  











  











  











  




  
  
  
  














  









#line 832 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftheader.h"



#line 38 "d:\\gl files\\freetype-2.6.2\\include\\ft2build.h"

#line 40 "d:\\gl files\\freetype-2.6.2\\include\\ft2build.h"



#line 8 "d:\\users\\stasw\\documents\\virheimur\\game - client\\text.h"


#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\freetype.h"
































#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


















  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  





#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftoption.h"

























extern "C" {

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  



  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


#line 363 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftoption.h"


  
  
  
  
  
  
  
  



  
  
  
  
  



  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  


  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  











  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  



  
  
  
  
  



  
  
  
  
  
  
  
  
  
  
  
  
  


#line 711 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftoption.h"


  
  
  
  
  
  
  


  
  
  
  
  
  



  
  
  
  
  



  
  
  
  
  
  
  



  
  
  
  
  
  
  



  
  
  
  
  
  



  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  













  
  
  
  
  
  
  



  
  
  
  
  
  
  


  
  
  
  
  


  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  


  


  






  








#line 868 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftoption.h"


  





#line 897 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftoption.h"

}


#line 902 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftoption.h"




#line 43 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"
#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftstdlib.h"



















  
  
  
  
  
  
  
  
  
  











  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  













  
  
  
  
  



















  
  
  
  
  













  
  
  
  
  







  
  
  
  
  








  
  
  
  
  





  
  
  
  
  





                                
                                





  
  




#line 172 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftstdlib.h"



#line 44 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


extern "C" {


  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  






  


#line 78 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"





#line 84 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

  
  








#line 96 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


  
  


#line 103 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  













#line 137 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"






#line 144 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


  
  
  
  
  
  


  
  
  
  
  
  
  
  
  typedef signed short  FT_Int16;


  
  
  
  
  
  
  
  
  typedef unsigned short  FT_UInt16;

  


  


















































#line 230 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"



  typedef signed int      FT_Int32;
  typedef unsigned int    FT_UInt32;








#line 244 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


  


  typedef int            FT_Fast;
  typedef unsigned int   FT_UFast;






#line 258 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


  
  














#line 277 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"



  































#line 313 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

#line 315 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


  typedef __int64   FT_Int64;
  typedef unsigned __int64  FT_UInt64;
#line 320 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


  
  
  
  
  







  


#line 340 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

#line 342 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"















#line 358 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

#line 360 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"











#line 372 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

#line 374 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"








#line 383 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

#line 385 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"








#line 394 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

#line 396 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"








#line 405 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

#line 407 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"








#line 416 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

#line 418 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"

  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  





#line 448 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"
#line 449 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"








#line 458 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"
#line 459 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"


}


#line 465 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\config\\ftconfig.h"



#line 34 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\freetype.h"
#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fttypes.h"
























#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftsystem.h"

























extern "C" {


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  


  









  typedef struct FT_MemoryRec_*  FT_Memory;


  


















  typedef void*
  (*FT_Alloc_Func)( FT_Memory  memory,
                    long       size );


  















  typedef void
  (*FT_Free_Func)( FT_Memory  memory,
                   void*      block );


  



























  typedef void*
  (*FT_Realloc_Func)( FT_Memory  memory,
                      long       cur_size,
                      long       new_size,
                      void*      block );


  





















  struct  FT_MemoryRec_
  {
    void*            user;
    FT_Alloc_Func    alloc;
    FT_Free_Func     free;
    FT_Realloc_Func  realloc;
  };


  
  
  
  
  


  












  typedef struct FT_StreamRec_*  FT_Stream;


  









  typedef union  FT_StreamDesc_
  {
    long   value;
    void*  pointer;

  } FT_StreamDesc;


  





























  typedef unsigned long
  (*FT_Stream_IoFunc)( FT_Stream       stream,
                       unsigned long   offset,
                       unsigned char*  buffer,
                       unsigned long   count );


  












  typedef void
  (*FT_Stream_CloseFunc)( FT_Stream  stream );


  






















































  typedef struct  FT_StreamRec_
  {
    unsigned char*       base;
    unsigned long        size;
    unsigned long        pos;

    FT_StreamDesc        descriptor;
    FT_StreamDesc        pathname;
    FT_Stream_IoFunc     read;
    FT_Stream_CloseFunc  close;

    FT_Memory            memory;
    unsigned char*       cursor;
    unsigned char*       limit;

  } FT_StreamRec;

  


}

#line 353 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftsystem.h"



#line 26 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fttypes.h"
#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftimage.h"


















  
  
  
  
  
  






  


#line 35 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftimage.h"


extern "C" {


  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  typedef signed long  FT_Pos;


  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Vector_
  {
    FT_Pos  x;
    FT_Pos  y;

  } FT_Vector;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_BBox_
  {
    FT_Pos  xMin, yMin;
    FT_Pos  xMax, yMax;

  } FT_BBox;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef enum  FT_Pixel_Mode_
  {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO,
    FT_PIXEL_MODE_GRAY,
    FT_PIXEL_MODE_GRAY2,
    FT_PIXEL_MODE_GRAY4,
    FT_PIXEL_MODE_LCD,
    FT_PIXEL_MODE_LCD_V,
    FT_PIXEL_MODE_BGRA,

    FT_PIXEL_MODE_MAX      

  } FT_Pixel_Mode;


  
  







  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Bitmap_
  {
    unsigned int    rows;
    unsigned int    width;
    int             pitch;
    unsigned char*  buffer;
    unsigned short  num_grays;
    unsigned char   pixel_mode;
    unsigned char   palette_mode;
    void*           palette;

  } FT_Bitmap;


  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Outline_
  {
    short       n_contours;      
    short       n_points;        

    FT_Vector*  points;          
    char*       tags;            
    short*      contours;        

    int         flags;           

  } FT_Outline;

  

  
  




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  












  
  








  






















  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef int
  (*FT_Outline_MoveToFunc)( const FT_Vector*  to,
                            void*             user );




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef int
  (*FT_Outline_LineToFunc)( const FT_Vector*  to,
                            void*             user );




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef int
  (*FT_Outline_ConicToFunc)( const FT_Vector*  control,
                             const FT_Vector*  to,
                             void*             user );




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef int
  (*FT_Outline_CubicToFunc)( const FT_Vector*  control1,
                             const FT_Vector*  control2,
                             const FT_Vector*  to,
                             void*             user );




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Outline_Funcs_
  {
    FT_Outline_MoveToFunc   move_to;
    FT_Outline_LineToFunc   line_to;
    FT_Outline_ConicToFunc  conic_to;
    FT_Outline_CubicToFunc  cubic_to;

    int                     shift;
    FT_Pos                  delta;

  } FT_Outline_Funcs;


  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  






#line 675 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftimage.h"


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef enum  FT_Glyph_Format_
  {
    FT_GLYPH_FORMAT_NONE = ( ( (unsigned long)0 << 24 ) | ( (unsigned long)0 << 16 ) | ( (unsigned long)0 << 8 ) | (unsigned long)0 ),

    FT_GLYPH_FORMAT_COMPOSITE = ( ( (unsigned long)'c' << 24 ) | ( (unsigned long)'o' << 16 ) | ( (unsigned long)'m' << 8 ) | (unsigned long)'p' ),
    FT_GLYPH_FORMAT_BITMAP = ( ( (unsigned long)'b' << 24 ) | ( (unsigned long)'i' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'s' ),
    FT_GLYPH_FORMAT_OUTLINE = ( ( (unsigned long)'o' << 24 ) | ( (unsigned long)'u' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'l' ),
    FT_GLYPH_FORMAT_PLOTTER = ( ( (unsigned long)'p' << 24 ) | ( (unsigned long)'l' << 16 ) | ( (unsigned long)'o' << 8 ) | (unsigned long)'t' )

  } FT_Glyph_Format;


  
  







  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  typedef struct FT_RasterRec_*  FT_Raster;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Span_
  {
    short           x;
    unsigned short  len;
    unsigned char   coverage;

  } FT_Span;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef void
  (*FT_SpanFunc)( int             y,
                  int             count,
                  const FT_Span*  spans,
                  void*           user );




  
  
  
  
  
  
  
  
  typedef int
  (*FT_Raster_BitTest_Func)( int    y,
                             int    x,
                             void*  user );


  
  
  
  
  
  
  
  
  typedef void
  (*FT_Raster_BitSet_Func)( int    y,
                            int    x,
                            void*  user );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  





  
  






  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Raster_Params_
  {
    const FT_Bitmap*        target;
    const void*             source;
    int                     flags;
    FT_SpanFunc             gray_spans;
    FT_SpanFunc             black_spans;  
    FT_Raster_BitTest_Func  bit_test;     
    FT_Raster_BitSet_Func   bit_set;      
    void*                   user;
    FT_BBox                 clip_box;

  } FT_Raster_Params;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef int
  (*FT_Raster_NewFunc)( void*       memory,
                        FT_Raster*  raster );




  
  
  
  
  
  
  
  
  
  
  
  typedef void
  (*FT_Raster_DoneFunc)( FT_Raster  raster );




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef void
  (*FT_Raster_ResetFunc)( FT_Raster       raster,
                          unsigned char*  pool_base,
                          unsigned long   pool_size );




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef int
  (*FT_Raster_SetModeFunc)( FT_Raster      raster,
                            unsigned long  mode,
                            void*          args );




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef int
  (*FT_Raster_RenderFunc)( FT_Raster                raster,
                           const FT_Raster_Params*  params );




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Raster_Funcs_
  {
    FT_Glyph_Format        glyph_format;
    FT_Raster_NewFunc      raster_new;
    FT_Raster_ResetFunc    raster_reset;
    FT_Raster_SetModeFunc  raster_set_mode;
    FT_Raster_RenderFunc   raster_render;
    FT_Raster_DoneFunc     raster_done;

  } FT_Raster_Funcs;

  


}

#line 1207 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftimage.h"









#line 27 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fttypes.h"




extern "C" {


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  typedef unsigned char  FT_Bool;


  
  
  
  
  
  
  
  
  
  typedef signed short  FT_FWord;   


  
  
  
  
  
  
  
  
  
  typedef unsigned short  FT_UFWord;  


  
  
  
  
  
  
  
  
  typedef signed char  FT_Char;


  
  
  
  
  
  
  
  
  typedef unsigned char  FT_Byte;


  
  
  
  
  
  
  
  
  typedef const FT_Byte*  FT_Bytes;


  
  
  
  
  
  
  
  
  typedef FT_UInt32  FT_Tag;


  
  
  
  
  
  
  
  
  typedef char  FT_String;


  
  
  
  
  
  
  
  
  typedef signed short  FT_Short;


  
  
  
  
  
  
  
  
  typedef unsigned short  FT_UShort;


  
  
  
  
  
  
  
  
  typedef signed int  FT_Int;


  
  
  
  
  
  
  
  
  typedef unsigned int  FT_UInt;


  
  
  
  
  
  
  
  
  typedef signed long  FT_Long;


  
  
  
  
  
  
  
  
  typedef unsigned long  FT_ULong;


  
  
  
  
  
  
  
  
  typedef signed short  FT_F2Dot14;


  
  
  
  
  
  
  
  
  
  typedef signed long  FT_F26Dot6;


  
  
  
  
  
  
  
  
  
  typedef signed long  FT_Fixed;


  
  
  
  
  
  
  
  
  
  typedef int  FT_Error;


  
  
  
  
  
  
  
  
  typedef void*  FT_Pointer;


  
  
  
  
  
  
  
  
  
  
  typedef size_t  FT_Offset;


  
  
  
  
  
  
  
  
  
  
  typedef ptrdiff_t  FT_PtrDist;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_UnitVector_
  {
    FT_F2Dot14  x;
    FT_F2Dot14  y;

  } FT_UnitVector;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Matrix_
  {
    FT_Fixed  xx, xy_func();
    FT_Fixed  yx, yy;

  } FT_Matrix;


  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Data_
  {
    const FT_Byte*  pointer;
    FT_Int          length;

  } FT_Data;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef void  (*FT_Generic_Finalizer)(void*  object);


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Generic_
  {
    void*                 data;
    FT_Generic_Finalizer  finalizer;

  } FT_Generic;


  
  
  
  
  
  
  
  
  
  
  
  
  








  
  
  
  
  
  
  


  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  typedef struct FT_ListNodeRec_*  FT_ListNode;


  
  
  
  
  
  
  
  
  typedef struct FT_ListRec_*  FT_List;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_ListNodeRec_
  {
    FT_ListNode  prev;
    FT_ListNode  next;
    void*        data;

  } FT_ListNodeRec;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_ListRec_
  {
    FT_ListNode  head;
    FT_ListNode  tail;

  } FT_ListRec;

  





  



  












}

#line 600 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fttypes.h"




#line 35 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\freetype.h"
#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"


















  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  





  
#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftmoderr.h"


















  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  






  
  
  
  
  
  
  










#line 116 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftmoderr.h"






  extern "C" {
#line 124 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftmoderr.h"

#line 126 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftmoderr.h"


  
  
  
  
  
  
  



  enum {
#line 140 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftmoderr.h"


  FT_Mod_Err_Base = 0,
  FT_Mod_Err_Autofit = 0,
  FT_Mod_Err_BDF = 0,
  FT_Mod_Err_Bzip2 = 0,
  FT_Mod_Err_Cache = 0,
  FT_Mod_Err_CFF = 0,
  FT_Mod_Err_CID = 0,
  FT_Mod_Err_Gzip = 0,
  FT_Mod_Err_LZW = 0,
  FT_Mod_Err_OTvalid = 0,
  FT_Mod_Err_PCF = 0,
  FT_Mod_Err_PFR = 0,
  FT_Mod_Err_PSaux = 0,
  FT_Mod_Err_PShinter = 0,
  FT_Mod_Err_PSnames = 0,
  FT_Mod_Err_Raster = 0,
  FT_Mod_Err_SFNT = 0,
  FT_Mod_Err_Smooth = 0,
  FT_Mod_Err_TrueType = 0,
  FT_Mod_Err_Type1 = 0,
  FT_Mod_Err_Type42 = 0,
  FT_Mod_Err_Winfonts = 0,
  FT_Mod_Err_GXvalid = 0,



  FT_Mod_Err_Max };
#line 170 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftmoderr.h"


  
  
  
  
  
  
  



  }
#line 184 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftmoderr.h"







#line 192 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\ftmoderr.h"



#line 108 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"


  
  
  
  
  
  
  





  
  
  


#line 128 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"


  
  











#line 144 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"


  
  
  








  extern "C" {
#line 159 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"

#line 161 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"


  



  





  enum {
#line 175 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"


  
#line 1 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"


















  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  

  

  FT_Err_Ok = 0x00,
#line 61 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  FT_Err_Cannot_Open_Resource = 0x01 + 0,
#line 64 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Unknown_File_Format = 0x02 + 0,
#line 66 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_File_Format = 0x03 + 0,
#line 68 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Version = 0x04 + 0,
#line 70 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Lower_Module_Version = 0x05 + 0,
#line 72 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Argument = 0x06 + 0,
#line 74 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Unimplemented_Feature = 0x07 + 0,
#line 76 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Table = 0x08 + 0,
#line 78 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Offset = 0x09 + 0,
#line 80 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Array_Too_Large = 0x0A + 0,
#line 82 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Missing_Module = 0x0B + 0,
#line 84 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Missing_Property = 0x0C + 0,
#line 86 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Invalid_Glyph_Index = 0x10 + 0,
#line 91 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Character_Code = 0x11 + 0,
#line 93 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Glyph_Format = 0x12 + 0,
#line 95 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Cannot_Render_Glyph = 0x13 + 0,
#line 97 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Outline = 0x14 + 0,
#line 99 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Composite = 0x15 + 0,
#line 101 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Too_Many_Hints = 0x16 + 0,
#line 103 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Pixel_Size = 0x17 + 0,
#line 105 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Invalid_Handle = 0x20 + 0,
#line 110 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Library_Handle = 0x21 + 0,
#line 112 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Driver_Handle = 0x22 + 0,
#line 114 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Face_Handle = 0x23 + 0,
#line 116 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Size_Handle = 0x24 + 0,
#line 118 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Slot_Handle = 0x25 + 0,
#line 120 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_CharMap_Handle = 0x26 + 0,
#line 122 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Cache_Handle = 0x27 + 0,
#line 124 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Stream_Handle = 0x28 + 0,
#line 126 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Too_Many_Drivers = 0x30 + 0,
#line 131 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Too_Many_Extensions = 0x31 + 0,
#line 133 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Out_Of_Memory = 0x40 + 0,
#line 138 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Unlisted_Object = 0x41 + 0,
#line 140 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Cannot_Open_Stream = 0x51 + 0,
#line 145 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Stream_Seek = 0x52 + 0,
#line 147 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Stream_Skip = 0x53 + 0,
#line 149 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Stream_Read = 0x54 + 0,
#line 151 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Stream_Operation = 0x55 + 0,
#line 153 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Frame_Operation = 0x56 + 0,
#line 155 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Nested_Frame_Access = 0x57 + 0,
#line 157 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Frame_Read = 0x58 + 0,
#line 159 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Raster_Uninitialized = 0x60 + 0,
#line 164 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Raster_Corrupted = 0x61 + 0,
#line 166 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Raster_Overflow = 0x62 + 0,
#line 168 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Raster_Negative_Height = 0x63 + 0,
#line 170 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Too_Many_Caches = 0x70 + 0,
#line 175 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Invalid_Opcode = 0x80 + 0,
#line 180 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Too_Few_Arguments = 0x81 + 0,
#line 182 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Stack_Overflow = 0x82 + 0,
#line 184 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Code_Overflow = 0x83 + 0,
#line 186 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Bad_Argument = 0x84 + 0,
#line 188 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Divide_By_Zero = 0x85 + 0,
#line 190 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Reference = 0x86 + 0,
#line 192 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Debug_OpCode = 0x87 + 0,
#line 194 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_ENDF_In_Exec_Stream = 0x88 + 0,
#line 196 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Nested_DEFS = 0x89 + 0,
#line 198 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_CodeRange = 0x8A + 0,
#line 200 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Execution_Too_Long = 0x8B + 0,
#line 202 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Too_Many_Function_Defs = 0x8C + 0,
#line 204 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Too_Many_Instruction_Defs = 0x8D + 0,
#line 206 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Table_Missing = 0x8E + 0,
#line 208 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Horiz_Header_Missing = 0x8F + 0,
#line 210 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Locations_Missing = 0x90 + 0,
#line 212 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Name_Table_Missing = 0x91 + 0,
#line 214 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_CMap_Table_Missing = 0x92 + 0,
#line 216 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Hmtx_Table_Missing = 0x93 + 0,
#line 218 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Post_Table_Missing = 0x94 + 0,
#line 220 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Horiz_Metrics = 0x95 + 0,
#line 222 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_CharMap_Format = 0x96 + 0,
#line 224 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_PPem = 0x97 + 0,
#line 226 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Vert_Metrics = 0x98 + 0,
#line 228 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Could_Not_Find_Context = 0x99 + 0,
#line 230 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Post_Table_Format = 0x9A + 0,
#line 232 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Invalid_Post_Table = 0x9B + 0,
#line 234 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Syntax_Error = 0xA0 + 0,
#line 239 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Stack_Underflow = 0xA1 + 0,
#line 241 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Ignore = 0xA2 + 0,
#line 243 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_No_Unicode_Glyph_Name = 0xA3 + 0,
#line 245 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Glyph_Too_Big = 0xA4 + 0,
#line 247 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  

  FT_Err_Missing_Startfont_Field = 0xB0 + 0,
#line 252 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Missing_Font_Field = 0xB1 + 0,
#line 254 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Missing_Size_Field = 0xB2 + 0,
#line 256 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Missing_Fontboundingbox_Field = 0xB3 + 0,
#line 258 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Missing_Chars_Field = 0xB4 + 0,
#line 260 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Missing_Startchar_Field = 0xB5 + 0,
#line 262 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Missing_Encoding_Field = 0xB6 + 0,
#line 264 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Missing_Bbx_Field = 0xB7 + 0,
#line 266 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Bbx_Too_Big = 0xB8 + 0,
#line 268 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Corrupted_Font_Header = 0xB9 + 0,
#line 270 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"
  FT_Err_Corrupted_Font_Glyphs = 0xBA + 0,
#line 272 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrdef.h"

  



#line 179 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"



  FT_Err_Max };
#line 184 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"


  
  
  
  
  
  
  


  }
#line 197 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"











  


#line 212 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"

#line 214 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\fterrors.h"



#line 36 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\freetype.h"


extern "C" {



  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  



  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Glyph_Metrics_
  {
    FT_Pos  width;
    FT_Pos  height;

    FT_Pos  horiBearingX;
    FT_Pos  horiBearingY;
    FT_Pos  horiAdvance;

    FT_Pos  vertBearingX;
    FT_Pos  vertBearingY;
    FT_Pos  vertAdvance;

  } FT_Glyph_Metrics;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Bitmap_Size_
  {
    FT_Short  height;
    FT_Short  width;

    FT_Pos    size;

    FT_Pos    x_ppem;
    FT_Pos    y_ppem;

  } FT_Bitmap_Size;


  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct FT_LibraryRec_  *FT_Library;


  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  typedef struct FT_ModuleRec_*  FT_Module;


  
  
  
  
  
  
  
  
  
  typedef struct FT_DriverRec_*  FT_Driver;


  
  
  
  
  
  
  
  
  
  
  
  typedef struct FT_RendererRec_*  FT_Renderer;


  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct FT_FaceRec_*  FT_Face;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct FT_SizeRec_*  FT_Size;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct FT_GlyphSlotRec_*  FT_GlyphSlot;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct FT_CharMapRec_*  FT_CharMap;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  








#line 611 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\freetype.h"


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef enum  FT_Encoding_
  {
    FT_ENCODING_NONE = ( ( (FT_UInt32)(0) << 24 ) | ( (FT_UInt32)(0) << 16 ) | ( (FT_UInt32)(0) << 8 ) | (FT_UInt32)(0) ),

    FT_ENCODING_MS_SYMBOL = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('y') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('b') ),
    FT_ENCODING_UNICODE = ( ( (FT_UInt32)('u') << 24 ) | ( (FT_UInt32)('n') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('c') ),

    FT_ENCODING_SJIS = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('j') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_GB2312 = ( ( (FT_UInt32)('g') << 24 ) | ( (FT_UInt32)('b') << 16 ) | ( (FT_UInt32)(' ') << 8 ) | (FT_UInt32)(' ') ),
    FT_ENCODING_BIG5 = ( ( (FT_UInt32)('b') << 24 ) | ( (FT_UInt32)('i') << 16 ) | ( (FT_UInt32)('g') << 8 ) | (FT_UInt32)('5') ),
    FT_ENCODING_WANSUNG = ( ( (FT_UInt32)('w') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('n') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_JOHAB = ( ( (FT_UInt32)('j') << 24 ) | ( (FT_UInt32)('o') << 16 ) | ( (FT_UInt32)('h') << 8 ) | (FT_UInt32)('a') ),

    
    FT_ENCODING_MS_SJIS    = FT_ENCODING_SJIS,
    FT_ENCODING_MS_GB2312  = FT_ENCODING_GB2312,
    FT_ENCODING_MS_BIG5    = FT_ENCODING_BIG5,
    FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG,
    FT_ENCODING_MS_JOHAB   = FT_ENCODING_JOHAB,

    FT_ENCODING_ADOBE_STANDARD = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('O') << 8 ) | (FT_UInt32)('B') ),
    FT_ENCODING_ADOBE_EXPERT = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('E') ),
    FT_ENCODING_ADOBE_CUSTOM = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('C') ),
    FT_ENCODING_ADOBE_LATIN_1 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('1') ),

    FT_ENCODING_OLD_LATIN_2 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('2') ),

    FT_ENCODING_APPLE_ROMAN = ( ( (FT_UInt32)('a') << 24 ) | ( (FT_UInt32)('r') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('n') )

  } FT_Encoding;


  
  

















  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_CharMapRec_
  {
    FT_Face      face;
    FT_Encoding  encoding;
    FT_UShort    platform_id;
    FT_UShort    encoding_id;

  } FT_CharMapRec;


  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct FT_Face_InternalRec_*  FT_Face_Internal;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_FaceRec_
  {
    FT_Long           num_faces;
    FT_Long           face_index;

    FT_Long           face_flags;
    FT_Long           style_flags;

    FT_Long           num_glyphs;

    FT_String*        family_name;
    FT_String*        style_name;

    FT_Int            num_fixed_sizes;
    FT_Bitmap_Size*   available_sizes;

    FT_Int            num_charmaps;
    FT_CharMap*       charmaps;

    FT_Generic        generic;

    
    
    
    FT_BBox           bbox;

    FT_UShort         units_per_EM;
    FT_Short          ascender;
    FT_Short          descender;
    FT_Short          height;

    FT_Short          max_advance_width;
    FT_Short          max_advance_height;

    FT_Short          underline_position;
    FT_Short          underline_thickness;

    FT_GlyphSlot      glyph;
    FT_Size           size;
    FT_CharMap        charmap;

    

    FT_Driver         driver;
    FT_Memory         memory;
    FT_Stream         stream;

    FT_ListRec        sizes_list;

    FT_Generic        autohint;   
    void*             extensions; 

    FT_Face_Internal  internal;

    

  } FT_FaceRec;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

















  
















  













  













  














  


















  














  














  











  













  














  

















  













  













  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  




  
  
  
  
  
  
  
  
  
  typedef struct FT_Size_InternalRec_*  FT_Size_Internal;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Size_Metrics_
  {
    FT_UShort  x_ppem;      
    FT_UShort  y_ppem;      

    FT_Fixed   x_scale;     
    FT_Fixed   y_scale;     

    FT_Pos     ascender;    
    FT_Pos     descender;   
    FT_Pos     height;      
    FT_Pos     max_advance; 

  } FT_Size_Metrics;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_SizeRec_
  {
    FT_Face           face;      
    FT_Generic        generic;   
    FT_Size_Metrics   metrics;   
    FT_Size_Internal  internal;

  } FT_SizeRec;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct FT_SubGlyphRec_*  FT_SubGlyph;


  
  
  
  
  
  
  
  
  
  typedef struct FT_Slot_InternalRec_*  FT_Slot_Internal;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_GlyphSlotRec_
  {
    FT_Library        library;
    FT_Face           face;
    FT_GlyphSlot      next;
    FT_UInt           reserved;       
    FT_Generic        generic;

    FT_Glyph_Metrics  metrics;
    FT_Fixed          linearHoriAdvance;
    FT_Fixed          linearVertAdvance;
    FT_Vector         advance;

    FT_Glyph_Format   format;

    FT_Bitmap         bitmap;
    FT_Int            bitmap_left;
    FT_Int            bitmap_top;

    FT_Outline        outline;

    FT_UInt           num_subglyphs;
    FT_SubGlyph       subglyphs;

    void*             control_data;
    long              control_len;

    FT_Pos            lsb_delta;
    FT_Pos            rsb_delta;

    void*             other;

    FT_Slot_Internal  internal;

  } FT_GlyphSlotRec;


  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Init_FreeType( FT_Library  *alibrary );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Done_FreeType( FT_Library  library );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  







  
  







  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Parameter_
  {
    FT_ULong    tag;
    FT_Pointer  data;

  } FT_Parameter;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Open_Args_
  {
    FT_UInt         flags;
    const FT_Byte*  memory_base;
    FT_Long         memory_size;
    FT_String*      pathname;
    FT_Stream       stream;
    FT_Module       driver;
    FT_Int          num_params;
    FT_Parameter*   params;

  } FT_Open_Args;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_New_Face( FT_Library   library,
               const char*  filepathname,
               FT_Long      face_index,
               FT_Face     *aface );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_New_Memory_Face( FT_Library      library,
                      const FT_Byte*  file_base,
                      FT_Long         file_size,
                      FT_Long         face_index,
                      FT_Face        *aface );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Open_Face( FT_Library           library,
                const FT_Open_Args*  args,
                FT_Long              face_index,
                FT_Face             *aface );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Attach_File( FT_Face      face,
                  const char*  filepathname );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Attach_Stream( FT_Face        face,
                    FT_Open_Args*  parameters );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Reference_Face( FT_Face  face );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Done_Face( FT_Face  face );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Select_Size( FT_Face  face,
                  FT_Int   strike_index );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef enum  FT_Size_Request_Type_
  {
    FT_SIZE_REQUEST_TYPE_NOMINAL,
    FT_SIZE_REQUEST_TYPE_REAL_DIM,
    FT_SIZE_REQUEST_TYPE_BBOX,
    FT_SIZE_REQUEST_TYPE_CELL,
    FT_SIZE_REQUEST_TYPE_SCALES,

    FT_SIZE_REQUEST_TYPE_MAX

  } FT_Size_Request_Type;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef struct  FT_Size_RequestRec_
  {
    FT_Size_Request_Type  type;
    FT_Long               width;
    FT_Long               height;
    FT_UInt               horiResolution;
    FT_UInt               vertResolution;

  } FT_Size_RequestRec;


  
  
  
  
  
  
  
  
  typedef struct FT_Size_RequestRec_  *FT_Size_Request;


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Request_Size( FT_Face          face,
                   FT_Size_Request  req );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Set_Char_Size( FT_Face     face,
                    FT_F26Dot6  char_width,
                    FT_F26Dot6  char_height,
                    FT_UInt     horz_resolution,
                    FT_UInt     vert_resolution );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Set_Pixel_Sizes( FT_Face  face,
                      FT_UInt  pixel_width,
                      FT_UInt  pixel_height );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Load_Glyph( FT_Face   face,
                 FT_UInt   glyph_index,
                 FT_Int32  load_flags );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Load_Char( FT_Face   face,
                FT_ULong  char_code,
                FT_Int32  load_flags );


  















































































































































































  



  

  




  









































































  












  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" void
  FT_Set_Transform( FT_Face     face,
                    FT_Matrix*  matrix,
                    FT_Vector*  delta );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef enum  FT_Render_Mode_
  {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT,
    FT_RENDER_MODE_MONO,
    FT_RENDER_MODE_LCD,
    FT_RENDER_MODE_LCD_V,

    FT_RENDER_MODE_MAX

  } FT_Render_Mode;


  
  




  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Render_Glyph( FT_GlyphSlot    slot,
                   FT_Render_Mode  render_mode );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  typedef enum  FT_Kerning_Mode_
  {
    FT_KERNING_DEFAULT  = 0,
    FT_KERNING_UNFITTED,
    FT_KERNING_UNSCALED

  } FT_Kerning_Mode;


  
  





  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Get_Kerning( FT_Face     face,
                  FT_UInt     left_glyph,
                  FT_UInt     right_glyph,
                  FT_UInt     kern_mode,
                  FT_Vector  *akerning );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Get_Track_Kerning( FT_Face    face,
                        FT_Fixed   point_size,
                        FT_Int     degree,
                        FT_Fixed*  akerning );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Get_Glyph_Name( FT_Face     face,
                     FT_UInt     glyph_index,
                     FT_Pointer  buffer,
                     FT_UInt     buffer_max );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" const char*
  FT_Get_Postscript_Name( FT_Face  face );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Select_Charmap( FT_Face      face,
                     FT_Encoding  encoding );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Error
  FT_Set_Charmap( FT_Face     face,
                  FT_CharMap  charmap );


  
















  extern "C" FT_Int
  FT_Get_Charmap_Index( FT_CharMap  charmap );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_UInt
  FT_Get_Char_Index( FT_Face   face,
                     FT_ULong  charcode );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_ULong
  FT_Get_First_Char( FT_Face   face,
                     FT_UInt  *agindex );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_ULong
  FT_Get_Next_Char( FT_Face    face,
                    FT_ULong   char_code,
                    FT_UInt   *agindex );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_UInt
  FT_Get_Name_Index( FT_Face     face,
                     FT_String*  glyph_name );


  



























  










































  extern "C" FT_Error
  FT_Get_SubGlyph_Info( FT_GlyphSlot  glyph,
                        FT_UInt       sub_index,
                        FT_Int       *p_index,
                        FT_UInt      *p_flags,
                        FT_Int       *p_arg1,
                        FT_Int       *p_arg2,
                        FT_Matrix    *p_transform );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  








  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_UShort
  FT_Get_FSType_Flags( FT_Face  face );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_UInt
  FT_Face_GetCharVariantIndex( FT_Face   face,
                               FT_ULong  charcode,
                               FT_ULong  variantSelector );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Int
  FT_Face_GetCharVariantIsDefault( FT_Face   face,
                                   FT_ULong  charcode,
                                   FT_ULong  variantSelector );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_UInt32*
  FT_Face_GetVariantSelectors( FT_Face  face );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_UInt32*
  FT_Face_GetVariantsOfChar( FT_Face   face,
                             FT_ULong  charcode );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_UInt32*
  FT_Face_GetCharsOfVariant( FT_Face   face,
                             FT_ULong  variantSelector );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Long
  FT_MulDiv( FT_Long  a,
             FT_Long  b,
             FT_Long  c );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Long
  FT_MulFix( FT_Long  a,
             FT_Long  b );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Long
  FT_DivFix( FT_Long  a,
             FT_Long  b );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Fixed
  FT_RoundFix( FT_Fixed  a );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Fixed
  FT_CeilFix( FT_Fixed  a );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Fixed
  FT_FloorFix( FT_Fixed  a );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" void
  FT_Vector_Transform( FT_Vector*        vec,
                       const FT_Matrix*  matrix );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  


  
























  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" void
  FT_Library_Version( FT_Library   library,
                      FT_Int      *amajor,
                      FT_Int      *aminor,
                      FT_Int      *apatch );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Bool
  FT_Face_CheckTrueTypePatents( FT_Face  face );


  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  extern "C" FT_Bool
  FT_Face_SetUnpatentedHinting( FT_Face  face,
                                FT_Bool  value );

  


}

#line 4282 "d:\\gl files\\freetype-2.6.2\\include\\freetype\\freetype.h"




#line 11 "d:\\users\\stasw\\documents\\virheimur\\game - client\\text.h"

using namespace std;
using namespace glm;
class Text 
{
public:
	static Text& getInstance()
	{
		static Text Instance;
		return Instance;
	}
	Text(Text const&) = delete;
	void operator=(Text const&) = delete;
	~Text();
	void Initialize();
	
	void RenderText(std::string text,
		GLfloat x, GLfloat y, GLfloat xMax, GLfloat scale, vec3 color = vec3(0));
	void RenderTextReverse(std::string text,
		GLfloat x, GLfloat y, GLfloat xMax, GLfloat scale);
	static void LoadTextShader(vec3 color);
	Text();
private:
	Text(string font);
	static Text Instance;
	void AddFont(string font, float scale);
	void LoadCharacters(float scale);
	void ReserveVBO();
	
	GLuint Texture, VAO, VBO;
	Shader shader;
	ImageLoader* m_Font;
	string m_OurFont;
	struct Vertices {
		vec2 vertices;
		vec2 uvs;
	};

	struct Character {
		GLuint     TextureID;  
		glm::ivec2 Size;       
		glm::ivec2 Bearing;    
		GLuint     Advance;    
	};

	static std::map<GLchar, Character> Characters;
	map<float, map<GLchar, Character>> Fonts;

	static vector<Vertices> vertices;
	static unsigned int Vertices_Amount;
	int Resolution;
	FT_Library library;
	FT_Face face;
};

#line 4 "d:\\users\\stasw\\documents\\virheimur\\game - client\\fps.h"

class FPS
{
public:
	FPS();
	~FPS();
	void CountFrame(Shader&);
private:
	int counter;
	time_t m_time;
	int fps;
};

#line 2 "d:\\users\\stasw\\documents\\virheimur\\game - client\\fps.cpp"



FPS::FPS()
{
	int counter = 0;
	time_t m_time = 0;
	int fps = 0;
}


FPS::~FPS()
{
}

void FPS::CountFrame(Shader& shader)
{
	float time = Time::Instance().Frame();
	int fps = 1000.0f / time;
	Text& text = Text::getInstance();
	text.RenderText("[fps : " + to_string(fps) + "]", 20, 50,0.0f, 20.0f);
}
